module.exports = {

"[project]/node_modules/@zoom/videosdk/dist/index.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ActiveMediaFailedCode": (()=>tu),
    "ApprovedState": (()=>Id),
    "AskHostHelpResponse": (()=>Yp),
    "AudioChangeAction": (()=>cd),
    "CRCProtocol": (()=>Xd),
    "CRCReturnCode": (()=>eu),
    "CameraControlCmd": (()=>xd),
    "ChatFileDownloadStatus": (()=>Xs),
    "ChatFileUploadStatus": (()=>Ys),
    "ChatMsgType": (()=>sV),
    "ChatPrivilege": (()=>nV),
    "ConnectionState": (()=>Zn),
    "DialoutState": (()=>pd),
    "FarEndCameraControlDeclinedReason": (()=>Bd),
    "LeaveAudioSource": (()=>ld),
    "LiveStreamStatus": (()=>FL),
    "LiveTranscriptionLanguage": (()=>_L),
    "LiveTranscriptionLanguageCode": (()=>CL),
    "LiveTranscriptionMessageSource": (()=>yL),
    "MobileVideoFacingMode": (()=>Rd),
    "MutedSource": (()=>dd),
    "PassiveStopShareReason": (()=>Ad),
    "ReconnectReason": (()=>lV),
    "RecordingStatus": (()=>Ka),
    "RemoteControlAppStatus": (()=>pV),
    "RemoteControlSessionStatus": (()=>zd),
    "SharePrivilege": (()=>cV),
    "ShareStatus": (()=>fd),
    "SubsessionAllocationPattern": (()=>aV),
    "SubsessionStatus": (()=>uV),
    "SubsessionUserStatus": (()=>dV),
    "VideoActiveState": (()=>Sd),
    "VideoCapturingState": (()=>Ed),
    "VideoQuality": (()=>yd),
    "default": (()=>iV)
});
var e = function(t1, o) {
    return e = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(e, t1) {
        e.__proto__ = t1;
    } || function(e, t1) {
        for(var o in t1)Object.prototype.hasOwnProperty.call(t1, o) && (e[o] = t1[o]);
    }, e(t1, o);
};
function t1(t1, o) {
    if ("function" != typeof o && null !== o) throw new TypeError("Class extends value " + String(o) + " is not a constructor or null");
    function r() {
        this.constructor = t1;
    }
    e(t1, o), t1.prototype = null === o ? Object.create(o) : (r.prototype = o.prototype, new r);
}
var o = function() {
    return o = Object.assign || function(e) {
        for(var t1, o = 1, r = arguments.length; o < r; o++)for(var i in t1 = arguments[o])Object.prototype.hasOwnProperty.call(t1, i) && (e[i] = t1[i]);
        return e;
    }, o.apply(this, arguments);
};
function r(e, t1) {
    var o, r, i, n, s = {
        label: 0,
        sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    };
    return n = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, "function" == typeof Symbol && (n[Symbol.iterator] = function() {
        return this;
    }), n;
    "TURBOPACK unreachable";
    function a(n) {
        return function(a) {
            return function(n) {
                if (o) throw new TypeError("Generator is already executing.");
                for(; s;)try {
                    if (o = 1, r && (i = 2 & n[0] ? r.return : n[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, n[1])).done) return i;
                    switch(r = 0, i && (n = [
                        2 & n[0],
                        i.value
                    ]), n[0]){
                        case 0:
                        case 1:
                            i = n;
                            break;
                        case 4:
                            return s.label++, {
                                value: n[1],
                                done: !1
                            };
                        case 5:
                            s.label++, r = n[1], n = [
                                0
                            ];
                            continue;
                        case 7:
                            n = s.ops.pop(), s.trys.pop();
                            continue;
                        default:
                            if (!((i = (i = s.trys).length > 0 && i[i.length - 1]) || 6 !== n[0] && 2 !== n[0])) {
                                s = 0;
                                continue;
                            }
                            if (3 === n[0] && (!i || n[1] > i[0] && n[1] < i[3])) {
                                s.label = n[1];
                                break;
                            }
                            if (6 === n[0] && s.label < i[1]) {
                                s.label = i[1], i = n;
                                break;
                            }
                            if (i && s.label < i[2]) {
                                s.label = i[2], s.ops.push(n);
                                break;
                            }
                            i[2] && s.ops.pop(), s.trys.pop();
                            continue;
                    }
                    n = t1.call(e, s);
                } catch (e) {
                    n = [
                        6,
                        e
                    ], r = 0;
                } finally{
                    o = i = 0;
                }
                if (5 & n[0]) throw n[1];
                return {
                    value: n[0] ? n[1] : void 0,
                    done: !0
                };
            }([
                n,
                a
            ]);
        };
    }
}
function i(e) {
    var t1 = "function" == typeof Symbol && Symbol.iterator, o = t1 && e[t1], r = 0;
    if (o) return o.call(e);
    if (e && "number" == typeof e.length) return {
        next: function() {
            return e && r >= e.length && (e = void 0), {
                value: e && e[r++],
                done: !e
            };
        }
    };
    throw new TypeError(t1 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function n(e, t1) {
    var o = "function" == typeof Symbol && e[Symbol.iterator];
    if (!o) return e;
    var r, i, n = o.call(e), s = [];
    try {
        for(; (void 0 === t1 || t1-- > 0) && !(r = n.next()).done;)s.push(r.value);
    } catch (e) {
        i = {
            error: e
        };
    } finally{
        try {
            r && !r.done && (o = n.return) && o.call(n);
        } finally{
            if (i) throw i.error;
        }
    }
    return s;
}
function s(e, t1) {
    for(var o = 0, r = t1.length, i = e.length; o < r; o++, i++)e[i] = t1[o];
    return e;
}
function a(e) {
    return this instanceof a ? (this.v = e, this) : new a(e);
}
function d(e) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var t1, o = e[Symbol.asyncIterator];
    return o ? o.call(e) : (e = i(e), t1 = {}, r("next"), r("throw"), r("return"), t1[Symbol.asyncIterator] = function() {
        return this;
    }, t1);
    "TURBOPACK unreachable";
    function r(o) {
        t1[o] = e[o] && function(t1) {
            return new Promise(function(r, i) {
                !function(e, t1, o, r) {
                    Promise.resolve(r).then(function(t1) {
                        e({
                            value: t1,
                            done: o
                        });
                    }, t1);
                }(r, i, (t1 = e[o](t1)).done, t1.value);
            });
        };
    }
}
function u(e) {
    return "function" == typeof e;
}
function l(e) {
    var t1 = e(function(e) {
        Error.call(e), e.stack = (new Error).stack;
    });
    return t1.prototype = Object.create(Error.prototype), t1.prototype.constructor = t1, t1;
}
var c = l(function(e) {
    return function(t1) {
        e(this), this.message = t1 ? t1.length + " errors occurred during unsubscription:\n" + t1.map(function(e, t1) {
            return t1 + 1 + ") " + e.toString();
        }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = t1;
    };
});
function p(e, t1) {
    if (e) {
        var o = e.indexOf(t1);
        0 <= o && e.splice(o, 1);
    }
}
var h = function() {
    function e(e) {
        this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
    }
    var t1;
    return e.prototype.unsubscribe = function() {
        var e, t1, o, r, a;
        if (!this.closed) {
            this.closed = !0;
            var d = this._parentage;
            if (d) if (this._parentage = null, Array.isArray(d)) try {
                for(var l = i(d), p = l.next(); !p.done; p = l.next())p.value.remove(this);
            } catch (t1) {
                e = {
                    error: t1
                };
            } finally{
                try {
                    p && !p.done && (t1 = l.return) && t1.call(l);
                } finally{
                    if (e) throw e.error;
                }
            }
            else d.remove(this);
            var h = this.initialTeardown;
            if (u(h)) try {
                h();
            } catch (e) {
                a = e instanceof c ? e.errors : [
                    e
                ];
            }
            var m = this._finalizers;
            if (m) {
                this._finalizers = null;
                try {
                    for(var g = i(m), f = g.next(); !f.done; f = g.next()){
                        var y = f.value;
                        try {
                            v(y);
                        } catch (e) {
                            a = null != a ? a : [], e instanceof c ? a = s(s([], n(a)), n(e.errors)) : a.push(e);
                        }
                    }
                } catch (e) {
                    o = {
                        error: e
                    };
                } finally{
                    try {
                        f && !f.done && (r = g.return) && r.call(g);
                    } finally{
                        if (o) throw o.error;
                    }
                }
            }
            if (a) throw new c(a);
        }
    }, e.prototype.add = function(t1) {
        var o;
        if (t1 && t1 !== this) if (this.closed) v(t1);
        else {
            if (t1 instanceof e) {
                if (t1.closed || t1._hasParent(this)) return;
                t1._addParent(this);
            }
            (this._finalizers = null !== (o = this._finalizers) && void 0 !== o ? o : []).push(t1);
        }
    }, e.prototype._hasParent = function(e) {
        var t1 = this._parentage;
        return t1 === e || Array.isArray(t1) && t1.includes(e);
    }, e.prototype._addParent = function(e) {
        var t1 = this._parentage;
        this._parentage = Array.isArray(t1) ? (t1.push(e), t1) : t1 ? [
            t1,
            e
        ] : e;
    }, e.prototype._removeParent = function(e) {
        var t1 = this._parentage;
        t1 === e ? this._parentage = null : Array.isArray(t1) && p(t1, e);
    }, e.prototype.remove = function(t1) {
        var o = this._finalizers;
        o && p(o, t1), t1 instanceof e && t1._removeParent(this);
    }, e.EMPTY = ((t1 = new e).closed = !0, t1), e;
}(), m = h.EMPTY;
function g(e) {
    return e instanceof h || e && "closed" in e && u(e.remove) && u(e.add) && u(e.unsubscribe);
}
function v(e) {
    u(e) ? e() : e.unsubscribe();
}
var f = void 0;
function y(e) {
    !function(e, t1) {
        for(var o = [], r = 2; r < arguments.length; r++)o[r - 2] = arguments[r];
        setTimeout.apply(void 0, s([
            e,
            t1
        ], n(o)));
    }(function() {
        throw e;
    });
}
function S() {}
function b(e) {
    e();
}
var E = function(e) {
    function o(t1) {
        var o = e.call(this) || this;
        return o.isStopped = !1, t1 ? (o.destination = t1, g(t1) && t1.add(o)) : o.destination = _, o;
    }
    return t1(o, e), o.create = function(e, t1, o) {
        return new A(e, t1, o);
    }, o.prototype.next = function(e) {
        this.isStopped || this._next(e);
    }, o.prototype.error = function(e) {
        this.isStopped || (this.isStopped = !0, this._error(e));
    }, o.prototype.complete = function() {
        this.isStopped || (this.isStopped = !0, this._complete());
    }, o.prototype.unsubscribe = function() {
        this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);
    }, o.prototype._next = function(e) {
        this.destination.next(e);
    }, o.prototype._error = function(e) {
        try {
            this.destination.error(e);
        } finally{
            this.unsubscribe();
        }
    }, o.prototype._complete = function() {
        try {
            this.destination.complete();
        } finally{
            this.unsubscribe();
        }
    }, o;
}(h), I = function() {
    function e(e) {
        this.partialObserver = e;
    }
    return e.prototype.next = function(e) {
        var t1 = this.partialObserver;
        if (t1.next) try {
            t1.next(e);
        } catch (e) {
            C(e);
        }
    }, e.prototype.error = function(e) {
        var t1 = this.partialObserver;
        if (t1.error) try {
            t1.error(e);
        } catch (e) {
            C(e);
        }
        else C(e);
    }, e.prototype.complete = function() {
        var e = this.partialObserver;
        if (e.complete) try {
            e.complete();
        } catch (e) {
            C(e);
        }
    }, e;
}(), A = function(e) {
    function o(t1, o, r) {
        var i, n = e.call(this) || this;
        return i = u(t1) || !t1 ? {
            next: null != t1 ? t1 : void 0,
            error: null != o ? o : void 0,
            complete: null != r ? r : void 0
        } : t1, n.destination = new I(i), n;
    }
    return t1(o, e), o;
}(E);
function C(e) {
    y(e);
}
var _ = {
    closed: !0,
    next: S,
    error: function(e) {
        throw e;
    },
    complete: S
}, R = "function" == typeof Symbol && Symbol.observable || "@@observable";
function w(e) {
    return e;
}
function T() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    return O(e);
}
function O(e) {
    return 0 === e.length ? w : 1 === e.length ? e[0] : function(t1) {
        return e.reduce(function(e, t1) {
            return t1(e);
        }, t1);
    };
}
var D = function() {
    function e(e) {
        e && (this._subscribe = e);
    }
    return e.prototype.lift = function(t1) {
        var o = new e;
        return o.source = this, o.operator = t1, o;
    }, e.prototype.subscribe = function(e, t1, o) {
        var r, i = this, n = (r = e) && r instanceof E || function(e) {
            return e && u(e.next) && u(e.error) && u(e.complete);
        }(r) && g(r) ? e : new A(e, t1, o);
        return b(function() {
            var e = i, t1 = e.operator, o = e.source;
            n.add(t1 ? t1.call(n, o) : o ? i._subscribe(n) : i._trySubscribe(n));
        }), n;
    }, e.prototype._trySubscribe = function(e) {
        try {
            return this._subscribe(e);
        } catch (t1) {
            e.error(t1);
        }
    }, e.prototype.forEach = function(e, t1) {
        var o = this;
        return new (t1 = P(t1))(function(t1, r) {
            var i = new A({
                next: function(t1) {
                    try {
                        e(t1);
                    } catch (e) {
                        r(e), i.unsubscribe();
                    }
                },
                error: r,
                complete: t1
            });
            o.subscribe(i);
        });
    }, e.prototype._subscribe = function(e) {
        var t1;
        return null === (t1 = this.source) || void 0 === t1 ? void 0 : t1.subscribe(e);
    }, e.prototype[R] = function() {
        return this;
    }, e.prototype.pipe = function() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        return O(e)(this);
    }, e.prototype.toPromise = function(e) {
        var t1 = this;
        return new (e = P(e))(function(e, o) {
            var r;
            t1.subscribe(function(e) {
                return r = e;
            }, function(e) {
                return o(e);
            }, function() {
                return e(r);
            });
        });
    }, e.create = function(t1) {
        return new e(t1);
    }, e;
}();
function P(e) {
    var t1;
    return null !== (t1 = null != e ? e : f) && void 0 !== t1 ? t1 : Promise;
}
function M(e) {
    return function(t1) {
        if (function(e) {
            return u(null == e ? void 0 : e.lift);
        }(t1)) return t1.lift(function(t1) {
            try {
                return e(t1, this);
            } catch (e) {
                this.error(e);
            }
        });
        throw new TypeError("Unable to lift unknown Observable type");
    };
}
function k(e, t1, o, r, i) {
    return new N(e, t1, o, r, i);
}
var L, N = function(e) {
    function o(t1, o, r, i, n, s) {
        var a = e.call(this, t1) || this;
        return a.onFinalize = n, a.shouldUnsubscribe = s, a._next = o ? function(e) {
            try {
                o(e);
            } catch (e) {
                t1.error(e);
            }
        } : e.prototype._next, a._error = i ? function(e) {
            try {
                i(e);
            } catch (e) {
                t1.error(e);
            } finally{
                this.unsubscribe();
            }
        } : e.prototype._error, a._complete = r ? function() {
            try {
                r();
            } catch (e) {
                t1.error(e);
            } finally{
                this.unsubscribe();
            }
        } : e.prototype._complete, a;
    }
    return t1(o, e), o.prototype.unsubscribe = function() {
        var t1;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var o = this.closed;
            e.prototype.unsubscribe.call(this), !o && (null === (t1 = this.onFinalize) || void 0 === t1 || t1.call(this));
        }
    }, o;
}(E), V = l(function(e) {
    return function() {
        e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
    };
}), U = function(e) {
    function o() {
        var t1 = e.call(this) || this;
        return t1.closed = !1, t1.currentObservers = null, t1.observers = [], t1.isStopped = !1, t1.hasError = !1, t1.thrownError = null, t1;
    }
    return t1(o, e), o.prototype.lift = function(e) {
        var t1 = new j(this, this);
        return t1.operator = e, t1;
    }, o.prototype._throwIfClosed = function() {
        if (this.closed) throw new V;
    }, o.prototype.next = function(e) {
        var t1 = this;
        b(function() {
            var o, r;
            if (t1._throwIfClosed(), !t1.isStopped) {
                t1.currentObservers || (t1.currentObservers = Array.from(t1.observers));
                try {
                    for(var n = i(t1.currentObservers), s = n.next(); !s.done; s = n.next())s.value.next(e);
                } catch (e) {
                    o = {
                        error: e
                    };
                } finally{
                    try {
                        s && !s.done && (r = n.return) && r.call(n);
                    } finally{
                        if (o) throw o.error;
                    }
                }
            }
        });
    }, o.prototype.error = function(e) {
        var t1 = this;
        b(function() {
            if (t1._throwIfClosed(), !t1.isStopped) {
                t1.hasError = t1.isStopped = !0, t1.thrownError = e;
                for(var o = t1.observers; o.length;)o.shift().error(e);
            }
        });
    }, o.prototype.complete = function() {
        var e = this;
        b(function() {
            if (e._throwIfClosed(), !e.isStopped) {
                e.isStopped = !0;
                for(var t1 = e.observers; t1.length;)t1.shift().complete();
            }
        });
    }, o.prototype.unsubscribe = function() {
        this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
    }, Object.defineProperty(o.prototype, "observed", {
        get: function() {
            var e;
            return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0;
        },
        enumerable: !1,
        configurable: !0
    }), o.prototype._trySubscribe = function(t1) {
        return this._throwIfClosed(), e.prototype._trySubscribe.call(this, t1);
    }, o.prototype._subscribe = function(e) {
        return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e);
    }, o.prototype._innerSubscribe = function(e) {
        var t1 = this, o = this, r = o.hasError, i = o.isStopped, n = o.observers;
        return r || i ? m : (this.currentObservers = null, n.push(e), new h(function() {
            t1.currentObservers = null, p(n, e);
        }));
    }, o.prototype._checkFinalizedStatuses = function(e) {
        var t1 = this, o = t1.hasError, r = t1.thrownError, i = t1.isStopped;
        o ? e.error(r) : i && e.complete();
    }, o.prototype.asObservable = function() {
        var e = new D;
        return e.source = this, e;
    }, o.create = function(e, t1) {
        return new j(e, t1);
    }, o;
}(D), j = function(e) {
    function o(t1, o) {
        var r = e.call(this) || this;
        return r.destination = t1, r.source = o, r;
    }
    return t1(o, e), o.prototype.next = function(e) {
        var t1, o;
        null === (o = null === (t1 = this.destination) || void 0 === t1 ? void 0 : t1.next) || void 0 === o || o.call(t1, e);
    }, o.prototype.error = function(e) {
        var t1, o;
        null === (o = null === (t1 = this.destination) || void 0 === t1 ? void 0 : t1.error) || void 0 === o || o.call(t1, e);
    }, o.prototype.complete = function() {
        var e, t1;
        null === (t1 = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === t1 || t1.call(e);
    }, o.prototype._subscribe = function(e) {
        var t1, o;
        return null !== (o = null === (t1 = this.source) || void 0 === t1 ? void 0 : t1.subscribe(e)) && void 0 !== o ? o : m;
    }, o;
}(U), x = function(e) {
    function o(t1) {
        var o = e.call(this) || this;
        return o._value = t1, o;
    }
    return t1(o, e), Object.defineProperty(o.prototype, "value", {
        get: function() {
            return this.getValue();
        },
        enumerable: !1,
        configurable: !0
    }), o.prototype._subscribe = function(t1) {
        var o = e.prototype._subscribe.call(this, t1);
        return !o.closed && t1.next(this._value), o;
    }, o.prototype.getValue = function() {
        var e = this, t1 = e.hasError, o = e.thrownError, r = e._value;
        if (t1) throw o;
        return this._throwIfClosed(), r;
    }, o.prototype.next = function(t1) {
        e.prototype.next.call(this, this._value = t1);
    }, o;
}(U), B = {
    now: function() {
        return (B.delegate || Date).now();
    },
    delegate: void 0
}, F = function(e) {
    function o(t1, o, r) {
        void 0 === t1 && (t1 = 1 / 0), void 0 === o && (o = 1 / 0), void 0 === r && (r = B);
        var i = e.call(this) || this;
        return i._bufferSize = t1, i._windowTime = o, i._timestampProvider = r, i._buffer = [], i._infiniteTimeWindow = !0, i._infiniteTimeWindow = o === 1 / 0, i._bufferSize = Math.max(1, t1), i._windowTime = Math.max(1, o), i;
    }
    return t1(o, e), o.prototype.next = function(t1) {
        var o = this, r = o.isStopped, i = o._buffer, n = o._infiniteTimeWindow, s = o._timestampProvider, a = o._windowTime;
        r || (i.push(t1), !n && i.push(s.now() + a)), this._trimBuffer(), e.prototype.next.call(this, t1);
    }, o.prototype._subscribe = function(e) {
        this._throwIfClosed(), this._trimBuffer();
        for(var t1 = this._innerSubscribe(e), o = this._infiniteTimeWindow, r = this._buffer.slice(), i = 0; i < r.length && !e.closed; i += o ? 1 : 2)e.next(r[i]);
        return this._checkFinalizedStatuses(e), t1;
    }, o.prototype._trimBuffer = function() {
        var e = this, t1 = e._bufferSize, o = e._timestampProvider, r = e._buffer, i = e._infiniteTimeWindow, n = (i ? 1 : 2) * t1;
        if (t1 < 1 / 0 && n < r.length && r.splice(0, r.length - n), !i) {
            for(var s = o.now(), a = 0, d = 1; d < r.length && r[d] <= s; d += 2)a = d;
            a && r.splice(0, a + 1);
        }
    }, o;
}(U), H = function(e) {
    function o(t1, o) {
        return e.call(this) || this;
    }
    return t1(o, e), o.prototype.schedule = function(e, t1) {
        return this;
    }, o;
}(h), $ = function(e) {
    function o(t1, o) {
        var r = e.call(this, t1, o) || this;
        return r.scheduler = t1, r.work = o, r.pending = !1, r;
    }
    return t1(o, e), o.prototype.schedule = function(e, t1) {
        var o;
        if (void 0 === t1 && (t1 = 0), this.closed) return this;
        this.state = e;
        var r = this.id, i = this.scheduler;
        return null != r && (this.id = this.recycleAsyncId(i, r, t1)), this.pending = !0, this.delay = t1, this.id = null !== (o = this.id) && void 0 !== o ? o : this.requestAsyncId(i, this.id, t1), this;
    }, o.prototype.requestAsyncId = function(e, t1, o) {
        return void 0 === o && (o = 0), function(e, t1) {
            for(var o = [], r = 2; r < arguments.length; r++)o[r - 2] = arguments[r];
            return setInterval.apply(void 0, s([
                e,
                t1
            ], n(o)));
        }(e.flush.bind(e, this), o);
    }, o.prototype.recycleAsyncId = function(e, t1, o) {
        if (void 0 === o && (o = 0), null != o && this.delay === o && !1 === this.pending) return t1;
        null != t1 && function(e) {
            clearInterval(e);
        }(t1);
    }, o.prototype.execute = function(e, t1) {
        if (this.closed) return new Error("executing a cancelled action");
        this.pending = !1;
        var o = this._execute(e, t1);
        if (o) return o;
        !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
    }, o.prototype._execute = function(e, t1) {
        var o, r = !1;
        try {
            this.work(e);
        } catch (e) {
            r = !0, o = e || new Error("Scheduled action threw falsy error");
        }
        if (r) return this.unsubscribe(), o;
    }, o.prototype.unsubscribe = function() {
        if (!this.closed) {
            var t1 = this.id, o = this.scheduler, r = o.actions;
            this.work = this.state = this.scheduler = null, this.pending = !1, p(r, this), null != t1 && (this.id = this.recycleAsyncId(o, t1, null)), this.delay = null, e.prototype.unsubscribe.call(this);
        }
    }, o;
}(H), W = 1, G = {};
function K(e) {
    return e in G && (delete G[e], !0);
}
var z = function(e) {
    var t1 = W++;
    return G[t1] = !0, L || (L = Promise.resolve()), L.then(function() {
        return K(t1) && e();
    }), t1;
}, q = function() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    return z.apply(void 0, s([], n(e)));
}, J = function(e) {
    return function(e) {
        K(e);
    }(e);
}, Q = function(e) {
    function o(t1, o) {
        var r = e.call(this, t1, o) || this;
        return r.scheduler = t1, r.work = o, r;
    }
    return t1(o, e), o.prototype.requestAsyncId = function(t1, o, r) {
        return void 0 === r && (r = 0), null !== r && r > 0 ? e.prototype.requestAsyncId.call(this, t1, o, r) : (t1.actions.push(this), t1._scheduled || (t1._scheduled = q(t1.flush.bind(t1, void 0))));
    }, o.prototype.recycleAsyncId = function(t1, o, r) {
        var i;
        if (void 0 === r && (r = 0), null != r ? r > 0 : this.delay > 0) return e.prototype.recycleAsyncId.call(this, t1, o, r);
        var n = t1.actions;
        null != o && (null === (i = n[n.length - 1]) || void 0 === i ? void 0 : i.id) !== o && (J(o), t1._scheduled === o && (t1._scheduled = void 0));
    }, o;
}($), Z = function() {
    function e(t1, o) {
        void 0 === o && (o = e.now), this.schedulerActionCtor = t1, this.now = o;
    }
    return e.prototype.schedule = function(e, t1, o) {
        return void 0 === t1 && (t1 = 0), new this.schedulerActionCtor(this, e).schedule(o, t1);
    }, e.now = B.now, e;
}(), Y = function(e) {
    function o(t1, o) {
        void 0 === o && (o = Z.now);
        var r = e.call(this, t1, o) || this;
        return r.actions = [], r._active = !1, r;
    }
    return t1(o, e), o.prototype.flush = function(e) {
        var t1 = this.actions;
        if (this._active) t1.push(e);
        else {
            var o;
            this._active = !0;
            do {
                if (o = e.execute(e.state, e.delay)) break;
            }while (e = t1.shift())
            if (this._active = !1, o) {
                for(; e = t1.shift();)e.unsubscribe();
                throw o;
            }
        }
    }, o;
}(Z), X = new (function(e) {
    function o() {
        return null !== e && e.apply(this, arguments) || this;
    }
    return t1(o, e), o.prototype.flush = function(e) {
        this._active = !0;
        var t1 = this._scheduled;
        this._scheduled = void 0;
        var o, r = this.actions;
        e = e || r.shift();
        do {
            if (o = e.execute(e.state, e.delay)) break;
        }while ((e = r[0]) && e.id === t1 && r.shift())
        if (this._active = !1, o) {
            for(; (e = r[0]) && e.id === t1 && r.shift();)e.unsubscribe();
            throw o;
        }
    }, o;
}(Y))(Q), ee = new Y($), te = ee, oe = function(e) {
    function o(t1, o) {
        var r = e.call(this, t1, o) || this;
        return r.scheduler = t1, r.work = o, r;
    }
    return t1(o, e), o.prototype.schedule = function(t1, o) {
        return void 0 === o && (o = 0), o > 0 ? e.prototype.schedule.call(this, t1, o) : (this.delay = o, this.state = t1, this.scheduler.flush(this), this);
    }, o.prototype.execute = function(t1, o) {
        return o > 0 || this.closed ? e.prototype.execute.call(this, t1, o) : this._execute(t1, o);
    }, o.prototype.requestAsyncId = function(t1, o, r) {
        return void 0 === r && (r = 0), null != r && r > 0 || null == r && this.delay > 0 ? e.prototype.requestAsyncId.call(this, t1, o, r) : (t1.flush(this), 0);
    }, o;
}($), re = new (function(e) {
    function o() {
        return null !== e && e.apply(this, arguments) || this;
    }
    return t1(o, e), o;
}(Y))(oe), ie = new D(function(e) {
    return e.complete();
});
function ne(e) {
    return e && u(e.schedule);
}
function se(e) {
    return e[e.length - 1];
}
function ae(e) {
    return u(se(e)) ? e.pop() : void 0;
}
function de(e) {
    return ne(se(e)) ? e.pop() : void 0;
}
var ue = function(e) {
    return e && "number" == typeof e.length && "function" != typeof e;
};
function le(e) {
    return u(null == e ? void 0 : e.then);
}
function ce(e) {
    return u(e[R]);
}
function pe(e) {
    return Symbol.asyncIterator && u(null == e ? void 0 : e[Symbol.asyncIterator]);
}
function he(e) {
    return new TypeError("You provided " + (null !== e && "object" == typeof e ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
var me = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
function ge(e) {
    return u(null == e ? void 0 : e[me]);
}
function ve(e) {
    return function(e, t1, o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var r, i = o.apply(e, t1 || []), n = [];
        return r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function() {
            return this;
        }, r;
        "TURBOPACK unreachable";
        function s(e) {
            i[e] && (r[e] = function(t1) {
                return new Promise(function(o, r) {
                    n.push([
                        e,
                        t1,
                        o,
                        r
                    ]) > 1 || d(e, t1);
                });
            });
        }
        function d(e, t1) {
            try {
                !function(e) {
                    e.value instanceof a ? Promise.resolve(e.value.v).then(u, l) : c(n[0][2], e);
                }(i[e](t1));
            } catch (e) {
                c(n[0][3], e);
            }
        }
        function u(e) {
            d("next", e);
        }
        function l(e) {
            d("throw", e);
        }
        function c(e, t1) {
            e(t1), n.shift(), n.length && d(n[0][0], n[0][1]);
        }
    }(this, arguments, function() {
        var t1, o, i;
        return r(this, function(r) {
            switch(r.label){
                case 0:
                    t1 = e.getReader(), r.label = 1;
                case 1:
                    r.trys.push([
                        1,
                        ,
                        9,
                        10
                    ]), r.label = 2;
                case 2:
                    return [
                        4,
                        a(t1.read())
                    ];
                case 3:
                    return o = r.sent(), i = o.value, o.done ? [
                        4,
                        a(void 0)
                    ] : [
                        3,
                        5
                    ];
                case 4:
                    return [
                        2,
                        r.sent()
                    ];
                case 5:
                    return [
                        4,
                        a(i)
                    ];
                case 6:
                    return [
                        4,
                        r.sent()
                    ];
                case 7:
                    return r.sent(), [
                        3,
                        2
                    ];
                case 8:
                    return [
                        3,
                        10
                    ];
                case 9:
                    return t1.releaseLock(), [
                        7
                    ];
                case 10:
                    return [
                        2
                    ];
            }
        });
    });
}
function fe(e) {
    return u(null == e ? void 0 : e.getReader);
}
function ye(e) {
    if (e instanceof D) return e;
    if (null != e) {
        if (ce(e)) return n = e, new D(function(e) {
            var t1 = n[R]();
            if (u(t1.subscribe)) return t1.subscribe(e);
            throw new TypeError("Provided object does not correctly implement Symbol.observable");
        });
        if (ue(e)) return r = e, new D(function(e) {
            for(var t1 = 0; t1 < r.length && !e.closed; t1++)e.next(r[t1]);
            e.complete();
        });
        if (le(e)) return o = e, new D(function(e) {
            o.then(function(t1) {
                e.closed || (e.next(t1), e.complete());
            }, function(t1) {
                return e.error(t1);
            }).then(null, y);
        });
        if (pe(e)) return Se(e);
        if (ge(e)) return t1 = e, new D(function(e) {
            var o, r;
            try {
                for(var n = i(t1), s = n.next(); !s.done; s = n.next()){
                    var a = s.value;
                    if (e.next(a), e.closed) return;
                }
            } catch (e) {
                o = {
                    error: e
                };
            } finally{
                try {
                    s && !s.done && (r = n.return) && r.call(n);
                } finally{
                    if (o) throw o.error;
                }
            }
            e.complete();
        });
        if (fe(e)) return Se(ve(e));
    }
    var t1, o, r, n;
    throw he(e);
}
function Se(e) {
    return new D(function(t1) {
        (function(e, t1) {
            var o, i, n, s;
            return function(e, t1, o, r) {
                return new (o || (o = Promise))(function(t1, i) {
                    function n(e) {
                        try {
                            a(r.next(e));
                        } catch (e) {
                            i(e);
                        }
                    }
                    function s(e) {
                        try {
                            a(r.throw(e));
                        } catch (e) {
                            i(e);
                        }
                    }
                    function a(e) {
                        var r;
                        e.done ? t1(e.value) : (r = e.value, r instanceof o ? r : new o(function(e) {
                            e(r);
                        })).then(n, s);
                    }
                    a((r = r.apply(e, [])).next());
                });
            }(this, 0, void 0, function() {
                var a, u;
                return r(this, function(r) {
                    switch(r.label){
                        case 0:
                            r.trys.push([
                                0,
                                5,
                                6,
                                11
                            ]), o = d(e), r.label = 1;
                        case 1:
                            return [
                                4,
                                o.next()
                            ];
                        case 2:
                            if ((i = r.sent()).done) return [
                                3,
                                4
                            ];
                            if (a = i.value, t1.next(a), t1.closed) return [
                                2
                            ];
                            r.label = 3;
                        case 3:
                            return [
                                3,
                                1
                            ];
                        case 4:
                            return [
                                3,
                                11
                            ];
                        case 5:
                            return u = r.sent(), n = {
                                error: u
                            }, [
                                3,
                                11
                            ];
                        case 6:
                            return r.trys.push([
                                6,
                                ,
                                9,
                                10
                            ]), i && !i.done && (s = o.return) ? [
                                4,
                                s.call(o)
                            ] : [
                                3,
                                8
                            ];
                        case 7:
                            r.sent(), r.label = 8;
                        case 8:
                            return [
                                3,
                                10
                            ];
                        case 9:
                            if (n) throw n.error;
                            return [
                                7
                            ];
                        case 10:
                            return [
                                7
                            ];
                        case 11:
                            return t1.complete(), [
                                2
                            ];
                    }
                });
            });
        })(e, t1).catch(function(e) {
            return t1.error(e);
        });
    });
}
function be(e, t1, o, r, i) {
    void 0 === r && (r = 0), void 0 === i && (i = !1);
    var n = t1.schedule(function() {
        o(), i ? e.add(this.schedule(null, r)) : this.unsubscribe();
    }, r);
    if (e.add(n), !i) return n;
}
function Ee(e, t1) {
    return void 0 === t1 && (t1 = 0), M(function(o, r) {
        o.subscribe(k(r, function(o) {
            return be(r, e, function() {
                return r.next(o);
            }, t1);
        }, function() {
            return be(r, e, function() {
                return r.complete();
            }, t1);
        }, function(o) {
            return be(r, e, function() {
                return r.error(o);
            }, t1);
        }));
    });
}
function Ie(e, t1) {
    return void 0 === t1 && (t1 = 0), M(function(o, r) {
        r.add(e.schedule(function() {
            return o.subscribe(r);
        }, t1));
    });
}
function Ae(e, t1) {
    if (!e) throw new Error("Iterable cannot be null");
    return new D(function(o) {
        be(o, t1, function() {
            var r = e[Symbol.asyncIterator]();
            be(o, t1, function() {
                r.next().then(function(e) {
                    e.done ? o.complete() : o.next(e.value);
                });
            }, 0, !0);
        });
    });
}
function Ce(e, t1) {
    return t1 ? function(e, t1) {
        if (null != e) {
            if (ce(e)) return function(e, t1) {
                return ye(e).pipe(Ie(t1), Ee(t1));
            }(e, t1);
            if (ue(e)) return function(e, t1) {
                return new D(function(o) {
                    var r = 0;
                    return t1.schedule(function() {
                        r === e.length ? o.complete() : (o.next(e[r++]), o.closed || this.schedule());
                    });
                });
            }(e, t1);
            if (le(e)) return function(e, t1) {
                return ye(e).pipe(Ie(t1), Ee(t1));
            }(e, t1);
            if (pe(e)) return Ae(e, t1);
            if (ge(e)) return function(e, t1) {
                return new D(function(o) {
                    var r;
                    return be(o, t1, function() {
                        r = e[me](), be(o, t1, function() {
                            var e, t1, i;
                            try {
                                t1 = (e = r.next()).value, i = e.done;
                            } catch (e) {
                                return void o.error(e);
                            }
                            i ? o.complete() : o.next(t1);
                        }, 0, !0);
                    }), function() {
                        return u(null == r ? void 0 : r.return) && r.return();
                    };
                });
            }(e, t1);
            if (fe(e)) return function(e, t1) {
                return Ae(ve(e), t1);
            }(e, t1);
        }
        throw he(e);
    }(e, t1) : ye(e);
}
function _e() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    return Ce(e, de(e));
}
function Re(e, t1) {
    var o = u(e) ? e : function() {
        return e;
    };
    return new D(function(e) {
        return e.error(o());
    });
}
var we = l(function(e) {
    return function() {
        e(this), this.name = "EmptyError", this.message = "no elements in sequence";
    };
});
function Te(e, t1) {
    return new Promise(function(t1, o) {
        var r = new A({
            next: function(e) {
                t1(e), r.unsubscribe();
            },
            error: o,
            complete: function() {
                o(new we);
            }
        });
        e.subscribe(r);
    });
}
function Oe(e) {
    return e instanceof Date && !isNaN(e);
}
var De = l(function(e) {
    return function(t1) {
        void 0 === t1 && (t1 = null), e(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = t1;
    };
});
function Pe(e, t1) {
    var o = Oe(e) ? {
        first: e
    } : "number" == typeof e ? {
        each: e
    } : e, r = o.first, i = o.each, n = o.with, s = void 0 === n ? Me : n, a = o.scheduler, d = void 0 === a ? ee : a, u = o.meta, l = void 0 === u ? null : u;
    if (null == r && null == i) throw new TypeError("No timeout provided.");
    return M(function(e, t1) {
        var o, n, a = null, u = 0, c = function(e) {
            n = be(t1, d, function() {
                try {
                    o.unsubscribe(), ye(s({
                        meta: l,
                        lastValue: a,
                        seen: u
                    })).subscribe(t1);
                } catch (e) {
                    t1.error(e);
                }
            }, e);
        };
        o = e.subscribe(k(t1, function(e) {
            null == n || n.unsubscribe(), u++, t1.next(a = e), i > 0 && c(i);
        }, void 0, void 0, function() {
            (null == n ? void 0 : n.closed) || null == n || n.unsubscribe(), a = null;
        })), !u && c(null != r ? "number" == typeof r ? r : +r - d.now() : i);
    });
}
function Me(e) {
    throw new De(e);
}
function ke(e, t1) {
    return M(function(o, r) {
        var i = 0;
        o.subscribe(k(r, function(o) {
            r.next(e.call(t1, o, i++));
        }));
    });
}
var Le = Array.isArray;
function Ne(e) {
    return ke(function(t1) {
        return function(e, t1) {
            return Le(t1) ? e.apply(void 0, s([], n(t1))) : e(t1);
        }(e, t1);
    });
}
var Ve = Array.isArray, Ue = Object.getPrototypeOf, je = Object.prototype, xe = Object.keys;
function Be(e, t1, o) {
    return void 0 === o && (o = 1 / 0), u(t1) ? Be(function(o, r) {
        return ke(function(e, i) {
            return t1(o, e, r, i);
        })(ye(e(o, r)));
    }, o) : ("number" == typeof t1 && (o = t1), M(function(t1, r) {
        return function(e, t1, o, r) {
            var i = [], n = 0, s = 0, a = !1, d = function() {
                !a || i.length || n || t1.complete();
            }, u = function(e) {
                n++;
                var a = !1;
                ye(o(e, s++)).subscribe(k(t1, function(e) {
                    t1.next(e);
                }, function() {
                    a = !0;
                }, void 0, function() {
                    if (a) try {
                        for(n--; i.length && n < r;)e = i.shift(), u(e);
                        d();
                    } catch (e) {
                        t1.error(e);
                    }
                    var e;
                }));
            };
            return e.subscribe(k(t1, function(e) {
                return n < r ? u(e) : i.push(e);
            }, function() {
                a = !0, d();
            })), function() {};
        }(t1, r, e, o);
    }));
}
function Fe(e) {
    return void 0 === e && (e = 1 / 0), Be(w, e);
}
function He() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    return Fe(1)(Ce(e, de(e)));
}
function $e() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    var o = ae(e), r = function(e) {
        if (1 === e.length) {
            var t1 = e[0];
            if (Ve(t1)) return {
                args: t1,
                keys: null
            };
            if ((r = t1) && "object" == typeof r && Ue(r) === je) {
                var o = xe(t1);
                return {
                    args: o.map(function(e) {
                        return t1[e];
                    }),
                    keys: o
                };
            }
        }
        var r;
        return {
            args: e,
            keys: null
        };
    }(e), i = r.args, n = r.keys, s = new D(function(e) {
        var t1 = i.length;
        if (t1) for(var o = new Array(t1), r = t1, s = t1, a = function(t1) {
            var a = !1;
            ye(i[t1]).subscribe(k(e, function(e) {
                a || (a = !0, s--), o[t1] = e;
            }, function() {
                return r--;
            }, void 0, function() {
                r && a || (s || e.next(n ? function(e, t1) {
                    return e.reduce(function(e, o, r) {
                        return e[o] = t1[r], e;
                    }, {});
                }(n, o) : o), e.complete());
            }));
        }, d = 0; d < t1; d++)a(d);
        else e.complete();
    });
    return o ? s.pipe(Ne(o)) : s;
}
var We = [
    "addListener",
    "removeListener"
], Ge = [
    "addEventListener",
    "removeEventListener"
], Ke = [
    "on",
    "off"
];
function ze(e, t1, o, r) {
    if (u(o) && (r = o, o = void 0), r) return ze(e, t1, o).pipe(Ne(r));
    var i = n(function(e) {
        return u(e.addEventListener) && u(e.removeEventListener);
    }(e) ? Ge.map(function(r) {
        return function(i) {
            return e[r](t1, i, o);
        };
    }) : function(e) {
        return u(e.addListener) && u(e.removeListener);
    }(e) ? We.map(qe(e, t1)) : function(e) {
        return u(e.on) && u(e.off);
    }(e) ? Ke.map(qe(e, t1)) : [], 2), s = i[0], a = i[1];
    if (!s && ue(e)) return Be(function(e) {
        return ze(e, t1, o);
    })(ye(e));
    if (!s) throw new TypeError("Invalid event target");
    return new D(function(e) {
        var t1 = function() {
            for(var t1 = [], o = 0; o < arguments.length; o++)t1[o] = arguments[o];
            return e.next(1 < t1.length ? t1 : t1[0]);
        };
        return s(t1), function() {
            return a(t1);
        };
    });
}
function qe(e, t1) {
    return function(o) {
        return function(r) {
            return e[o](t1, r);
        };
    };
}
function Je(e, t1, o) {
    return o ? Je(e, t1).pipe(Ne(o)) : new D(function(o) {
        var r = function() {
            for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
            return o.next(1 === e.length ? e[0] : e);
        }, i = e(r);
        return u(t1) ? function() {
            return t1(r, i);
        } : void 0;
    });
}
function Qe(e, t1, o) {
    void 0 === e && (e = 0), void 0 === o && (o = te);
    var r = -1;
    return null != t1 && (ne(t1) ? o = t1 : r = t1), new D(function(t1) {
        var i = Oe(e) ? +e - o.now() : e;
        i < 0 && (i = 0);
        var n = 0;
        return o.schedule(function() {
            t1.closed || (t1.next(n++), 0 <= r ? this.schedule(void 0, r) : t1.complete());
        }, i);
    });
}
function Ze(e, t1) {
    return void 0 === e && (e = 0), void 0 === t1 && (t1 = ee), e < 0 && (e = 0), Qe(e, e, t1);
}
function Ye() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    var o = de(e), r = function(e) {
        return "number" == typeof se(e) ? e.pop() : 1 / 0;
    }(e), i = e;
    return i.length ? 1 === i.length ? ye(i[0]) : Fe(r)(Ce(i, o)) : ie;
}
var Xe = Array.isArray;
function et(e, t1) {
    return function(o, r) {
        return !e.call(t1, o, r);
    };
}
function tt(e, t1) {
    return M(function(o, r) {
        var i = 0;
        o.subscribe(k(r, function(o) {
            return e.call(t1, o, i++) && r.next(o);
        }));
    });
}
function ot() {
    for(var e, t1 = [], o = 0; o < arguments.length; o++)t1[o] = arguments[o];
    return 1 === (t1 = 1 === (e = t1).length && Xe(e[0]) ? e[0] : e).length ? ye(t1[0]) : new D(function(e) {
        return function(t1) {
            for(var o = [], r = function(r) {
                o.push(ye(e[r]).subscribe(k(t1, function(e) {
                    if (o) {
                        for(var i = 0; i < o.length; i++)i !== r && o[i].unsubscribe();
                        o = null;
                    }
                    t1.next(e);
                })));
            }, i = 0; o && !t1.closed && i < e.length; i++)r(i);
        };
    }(t1));
}
function rt(e) {
    return M(function(t1, o) {
        var r, i = null, n = !1;
        i = t1.subscribe(k(o, void 0, void 0, function(s) {
            r = ye(e(s, rt(e)(t1))), i ? (i.unsubscribe(), i = null, r.subscribe(o)) : n = !0;
        })), n && (i.unsubscribe(), i = null, r.subscribe(o));
    });
}
function it(e) {
    return e <= 0 ? function() {
        return ie;
    } : M(function(t1, o) {
        var r = 0;
        t1.subscribe(k(o, function(t1) {
            ++r <= e && (o.next(t1), e <= r && o.complete());
        }));
    });
}
function nt() {
    return M(function(e, t1) {
        e.subscribe(k(t1, S));
    });
}
function st(e) {
    return ke(function() {
        return e;
    });
}
function at(e, t1) {
    void 0 === t1 && (t1 = ee);
    var o, r = Qe(e, t1);
    return o = function() {
        return r;
    }, Be(function(e, t1) {
        return ye(o()).pipe(it(1), st(e));
    });
}
function dt(e, t1, o) {
    return void 0 === o && (o = 1 / 0), u(t1) ? Be(function() {
        return e;
    }, t1, o) : Be(function() {
        return e;
    }, o);
}
function ut(e, t1) {
    return M(function(e, t1, o) {
        return function(r, i) {
            var n = o, s = t1, a = 0;
            r.subscribe(k(i, function(t1) {
                var o = a++;
                s = n ? e(s, t1, o) : (n = !0, t1), i.next(s);
            }, undefined));
        };
    }(e, t1, arguments.length >= 2));
}
function lt(e) {
    return M(function(t1, o) {
        var r = !1, i = 0;
        t1.subscribe(k(o, function(t1) {
            return (r || (r = !e(t1, i++))) && o.next(t1);
        }));
    });
}
function ct() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    var o = de(e);
    return M(function(t1, r) {
        (o ? He(e, t1, o) : He(e, t1)).subscribe(r);
    });
}
function pt(e, t1) {
    return M(function(o, r) {
        var i = null, n = 0, s = !1, a = function() {
            return s && !i && r.complete();
        };
        o.subscribe(k(r, function(o) {
            null == i || i.unsubscribe();
            var s = 0, d = n++;
            ye(e(o, d)).subscribe(i = k(r, function(e) {
                return r.next(t1 ? t1(o, e, d, s++) : e);
            }, function() {
                i = null, a();
            }));
        }, function() {
            s = !0, a();
        }));
    });
}
function ht(e) {
    return M(function(t1, o) {
        ye(e).subscribe(k(o, function() {
            return o.complete();
        }, S)), !o.closed && t1.subscribe(o);
    });
}
function mt(e, t1) {
    return void 0 === t1 && (t1 = !1), M(function(o, r) {
        var i = 0;
        o.subscribe(k(r, function(o) {
            var n = e(o, i++);
            (n || t1) && r.next(o), !n && r.complete();
        }));
    });
}
function gt(e, t1, o) {
    var r = u(e) || t1 || o ? {
        next: e,
        error: t1,
        complete: o
    } : e;
    return r ? M(function(e, t1) {
        var o;
        null === (o = r.subscribe) || void 0 === o || o.call(r);
        var i = !0;
        e.subscribe(k(t1, function(e) {
            var o;
            null === (o = r.next) || void 0 === o || o.call(r, e), t1.next(e);
        }, function() {
            var e;
            i = !1, null === (e = r.complete) || void 0 === e || e.call(r), t1.complete();
        }, function(e) {
            var o;
            i = !1, null === (o = r.error) || void 0 === o || o.call(r, e), t1.error(e);
        }, function() {
            var e, t1;
            i && (null === (e = r.unsubscribe) || void 0 === e || e.call(r)), null === (t1 = r.finalize) || void 0 === t1 || t1.call(r);
        }));
    }) : w;
}
function vt() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    var o = ae(e);
    return M(function(t1, r) {
        for(var i = e.length, a = new Array(i), d = e.map(function() {
            return !1;
        }), u = !1, l = function(t1) {
            ye(e[t1]).subscribe(k(r, function(e) {
                a[t1] = e, u || d[t1] || (d[t1] = !0, (u = d.every(w)) && (d = null));
            }, S));
        }, c = 0; c < i; c++)l(c);
        t1.subscribe(k(r, function(e) {
            if (u) {
                var t1 = s([
                    e
                ], n(a));
                r.next(o ? o.apply(void 0, s([], n(t1))) : t1);
            }
        }));
    });
}
function ft(e) {
    return ft = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e;
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, ft(e);
}
function yt(e, t1, o) {
    return (t1 = function(e) {
        var t1 = function(e, t1) {
            if ("object" != ft(e) || !e) return e;
            var o = e[Symbol.toPrimitive];
            if (void 0 !== o) {
                var r = o.call(e, t1);
                if ("object" != ft(r)) return r;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e);
        }(e, "string");
        return "symbol" == ft(t1) ? t1 : t1 + "";
    }(t1)) in e ? Object.defineProperty(e, t1, {
        value: o,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t1] = o, e;
}
function St(e, t1) {
    var o = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t1 && (r = r.filter(function(t1) {
            return Object.getOwnPropertyDescriptor(e, t1).enumerable;
        })), o.push.apply(o, r);
    }
    return o;
}
function bt(e) {
    for(var t1 = 1; t1 < arguments.length; t1++){
        var o = null != arguments[t1] ? arguments[t1] : {};
        t1 % 2 ? St(Object(o), !0).forEach(function(t1) {
            yt(e, t1, o[t1]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(o)) : St(Object(o)).forEach(function(t1) {
            Object.defineProperty(e, t1, Object.getOwnPropertyDescriptor(o, t1));
        });
    }
    return e;
}
function Et(e) {
    return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. ";
}
var It = "function" == typeof Symbol && Symbol.observable || "@@observable", At = function() {
    return Math.random().toString(36).substring(7).split("").join(".");
}, Ct = {
    INIT: "@@redux/INIT" + At(),
    REPLACE: "@@redux/REPLACE" + At(),
    PROBE_UNKNOWN_ACTION: function() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + At();
    }
};
function _t(e, t1, o) {
    var r;
    if ("function" == typeof t1 && "function" == typeof o || "function" == typeof o && "function" == typeof arguments[3]) throw new Error(Et(0));
    if ("function" == typeof t1 && void 0 === o && (o = t1, t1 = void 0), void 0 !== o) {
        if ("function" != typeof o) throw new Error(Et(1));
        return o(_t)(e, t1);
    }
    if ("function" != typeof e) throw new Error(Et(2));
    var i = e, n = t1, s = [], a = s, d = !1;
    function u() {
        a === s && (a = s.slice());
    }
    function l() {
        if (d) throw new Error(Et(3));
        return n;
    }
    function c(e) {
        if ("function" != typeof e) throw new Error(Et(4));
        if (d) throw new Error(Et(5));
        var t1 = !0;
        return u(), a.push(e), function() {
            if (t1) {
                if (d) throw new Error(Et(6));
                t1 = !1, u();
                var o = a.indexOf(e);
                a.splice(o, 1), s = null;
            }
        };
    }
    function p(e) {
        if (!function(e) {
            if ("object" != typeof e || null === e) return !1;
            for(var t1 = e; null !== Object.getPrototypeOf(t1);)t1 = Object.getPrototypeOf(t1);
            return Object.getPrototypeOf(e) === t1;
        }(e)) throw new Error(Et(7));
        if (void 0 === e.type) throw new Error(Et(8));
        if (d) throw new Error(Et(9));
        try {
            d = !0, n = i(n, e);
        } finally{
            d = !1;
        }
        for(var t1 = s = a, o = 0; o < t1.length; o++)(0, t1[o])();
        return e;
    }
    return p({
        type: Ct.INIT
    }), (r = {
        dispatch: p,
        subscribe: c,
        getState: l,
        replaceReducer: function(e) {
            if ("function" != typeof e) throw new Error(Et(10));
            i = e, p({
                type: Ct.REPLACE
            });
        }
    })[It] = function() {
        var e, t1 = c;
        return (e = {
            subscribe: function(e) {
                if ("object" != typeof e || null === e) throw new Error(Et(11));
                function o() {
                    e.next && e.next(l());
                }
                return o(), {
                    unsubscribe: t1(o)
                };
            }
        })[It] = function() {
            return this;
        }, e;
    }, r;
}
function Rt() {
    for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
    return 0 === t1.length ? function(e) {
        return e;
    } : 1 === t1.length ? t1[0] : t1.reduce(function(e, t1) {
        return function() {
            return e(t1.apply(void 0, arguments));
        };
    });
}
var wt = function(e) {
    function o(t1, o) {
        var r = e.call(this, function(e) {
            var t1 = r.__notifier.subscribe(e);
            return t1 && !t1.closed && e.next(r.value), t1;
        }) || this;
        return r.__notifier = new U, r.value = o, t1.subscribe(function(e) {
            e !== r.value && (r.value = e, r.__notifier.next(e));
        }), r;
    }
    return t1(o, e), o;
}(D), Tt = function(e, t1) {
    return e === t1 || "function" == typeof t1 && e === t1.toString();
};
function Ot() {
    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
    var o = e.length;
    return tt(1 === o ? function(t1) {
        return Tt(t1.type, e[0]);
    } : function(t1) {
        for(var r = 0; r < o; r++)if (Tt(t1.type, e[r])) return !0;
        return !1;
    });
}
var Dt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
    return typeof e;
} : function(e) {
    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
};
function Pt(e, t1) {
    e.super_ = t1, e.prototype = Object.create(t1.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    });
}
function Mt(e, t1) {
    Object.defineProperty(this, "kind", {
        value: e,
        enumerable: !0
    }), t1 && t1.length && Object.defineProperty(this, "path", {
        value: t1,
        enumerable: !0
    });
}
("object" === ("undefined" == typeof global ? "undefined" : Dt(global)) && global ? global : "undefined" != typeof window ? window : {}).DeepDiff, Pt(function e(t1, o, r) {
    e.super_.call(this, "E", t1), Object.defineProperty(this, "lhs", {
        value: o,
        enumerable: !0
    }), Object.defineProperty(this, "rhs", {
        value: r,
        enumerable: !0
    });
}, Mt), Pt(function e(t1, o) {
    e.super_.call(this, "N", t1), Object.defineProperty(this, "rhs", {
        value: o,
        enumerable: !0
    });
}, Mt), Pt(function e(t1, o) {
    e.super_.call(this, "D", t1), Object.defineProperty(this, "lhs", {
        value: o,
        enumerable: !0
    });
}, Mt), Pt(function e(t1, o, r) {
    e.super_.call(this, "A", t1), Object.defineProperty(this, "index", {
        value: o,
        enumerable: !0
    }), Object.defineProperty(this, "item", {
        value: r,
        enumerable: !0
    });
}, Mt);
const kt = !1;
var Lt, Nt, Vt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function Ut(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function jt(e) {
    if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
    var t1 = e.default;
    if ("function" == typeof t1) {
        var o = function e() {
            return this instanceof e ? Reflect.construct(t1, arguments, this.constructor) : t1.apply(this, arguments);
        };
        o.prototype = t1.prototype;
    } else o = {};
    return Object.defineProperty(o, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(t1) {
        var r = Object.getOwnPropertyDescriptor(e, t1);
        Object.defineProperty(o, t1, r.get ? r : {
            enumerable: !0,
            get: function() {
                return e[t1];
            }
        });
    }), o;
}
var xt = (Nt || (Nt = 1, Lt = function(e, t1, o, r, i, n, s, a) {
    if (!e) {
        var d;
        if (void 0 === t1) d = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
            var u = [
                o,
                r,
                i,
                n,
                s,
                a
            ], l = 0;
            (d = new Error(t1.replace(/%s/g, function() {
                return u[l++];
            }))).name = "Invariant Violation";
        }
        throw d.framesToPop = 1, d;
    }
}), Lt), Bt = Ut(xt), Ft = function(e) {
    return "function" == typeof e;
}, Ht = function(e) {
    return e.toString();
}, $t = function(e) {
    return "string" == typeof e;
}, Wt = "||", Gt = function(e) {
    return e;
}, Kt = function(e) {
    return null === e;
};
function zt(e, t1, o) {
    void 0 === t1 && (t1 = Gt), Bt(Ft(t1) || Kt(t1), "Expected payloadCreator to be a function, undefined or null");
    var r = Kt(t1) || t1 === Gt ? Gt : function(e) {
        for(var o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)r[i - 1] = arguments[i];
        return e instanceof Error ? e : t1.apply(void 0, [
            e
        ].concat(r));
    }, i = Ft(o), n = e.toString(), s = function() {
        var t1 = r.apply(void 0, arguments), n = {
            type: e
        };
        return t1 instanceof Error && (n.error = !0), void 0 !== t1 && (n.payload = t1), i && (n.meta = o.apply(void 0, arguments)), n;
    };
    return s.toString = function() {
        return n;
    }, s;
}
var qt, Jt, Qt, Zt, Yt, Xt, eo = function(e) {
    if ("object" != typeof e || null === e) return !1;
    for(var t1 = e; null !== Object.getPrototypeOf(t1);)t1 = Object.getPrototypeOf(t1);
    return Object.getPrototypeOf(e) === t1;
}, to = function(e) {
    return Array.isArray(e);
}, oo = function(e) {
    return null == e;
};
var ro = Ut(function() {
    if (Xt) return Yt;
    Xt = 1;
    var e = function() {
        if (Zt) return Qt;
        Zt = 1;
        var e = function() {
            if (Jt) return qt;
            Jt = 1, qt = function(n) {
                return e.test(n) ? n.toLowerCase() : t1.test(n) ? ((function(e) {
                    return e.replace(r, function(e, t1) {
                        return t1 ? " " + t1 : "";
                    });
                })(n) || n).toLowerCase() : o.test(n) ? (function(e) {
                    return e.replace(i, function(e, t1, o) {
                        return t1 + " " + o.toLowerCase().split("").join(" ");
                    });
                })(n).toLowerCase() : n.toLowerCase();
            };
            var e = /\s/, t1 = /(_|-|\.|:)/, o = /([a-z][A-Z]|[A-Z][a-z])/, r = /[\W_]+(.|$)/g, i = /(.)([A-Z]+)/g;
            return qt;
        }();
        return Qt = function(t1) {
            return e(t1).replace(/[\W_]+(.|$)/g, function(e, t1) {
                return t1 ? " " + t1 : "";
            }).trim();
        };
    }();
    return Yt = function(t1) {
        return e(t1).replace(/\s(\w)/g, function(e, t1) {
            return t1.toUpperCase();
        });
    };
}()), io = function(e) {
    return -1 === e.indexOf("/") ? ro(e) : e.split("/").map(ro).join("/");
}, no = function(e, t1) {
    return e.reduce(function(e, o) {
        return t1(e, o);
    }, {});
}, so = function(e) {
    return "undefined" != typeof Map && e instanceof Map;
};
function ao(e) {
    if (so(e)) return Array.from(e.keys());
    if ("undefined" != typeof Reflect && "function" == typeof Reflect.ownKeys) return Reflect.ownKeys(e);
    var t1 = Object.getOwnPropertyNames(e);
    return "function" == typeof Object.getOwnPropertySymbols && (t1 = t1.concat(Object.getOwnPropertySymbols(e))), t1;
}
function uo(e, t1) {
    return so(t1) ? t1.get(e) : t1[e];
}
var lo = function(e) {
    return function t1(o, r, i, n) {
        var s = void 0 === r ? {} : r, a = s.namespace, d = void 0 === a ? "/" : a, u = s.prefix;
        return void 0 === i && (i = {}), void 0 === n && (n = ""), ao(o).forEach(function(r) {
            var s = function(e) {
                return n || !u || u && new RegExp("^" + u + d).test(e) ? e : "" + u + d + e;
            }(function(e) {
                var t1;
                if (!n) return e;
                var o = e.toString().split(Wt), r = n.split(Wt);
                return (t1 = []).concat.apply(t1, r.map(function(e) {
                    return o.map(function(t1) {
                        return "" + e + d + t1;
                    });
                })).join(Wt);
            }(r)), a = uo(r, o);
            e(a) ? t1(a, {
                namespace: d,
                prefix: u
            }, i, s) : i[s] = a;
        }), i;
    };
}, co = lo(eo);
function po(e) {
    for(var t1 = 1; t1 < arguments.length; t1++){
        var o = null != arguments[t1] ? arguments[t1] : {}, r = Object.keys(o);
        "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(o).filter(function(e) {
            return Object.getOwnPropertyDescriptor(o, e).enumerable;
        }))), r.forEach(function(t1) {
            ho(e, t1, o[t1]);
        });
    }
    return e;
}
function ho(e, t1, o) {
    return t1 in e ? Object.defineProperty(e, t1, {
        value: o,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t1] = o, e;
}
function mo(e) {
    for(var t1 = arguments.length, o = new Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
    var i, n = eo((i = o)[i.length - 1]) ? o.pop() : {};
    return Bt(o.every($t) && ($t(e) || eo(e)), "Expected optional object followed by string action types"), $t(e) ? vo([
        e
    ].concat(o), n) : po({}, function(e, t1) {
        return function(e, t1) {
            var o = void 0 === t1 ? {} : t1, r = o.namespace, i = void 0 === r ? "/" : r, n = o.prefix;
            function s(t1, o, r) {
                var i = io(r.shift());
                0 === r.length ? o[i] = e[t1] : (o[i] || (o[i] = {}), s(t1, o[i], r));
            }
            var a = {};
            return Object.getOwnPropertyNames(e).forEach(function(e) {
                var t1 = n ? e.replace("" + n + i, "") : e;
                return s(e, a, t1.split(i));
            }), a;
        }(go(co(e, t1)), t1);
    }(e, n), vo(o, n));
}
function go(e, t1) {
    var o = void 0 === t1 ? {} : t1, r = o.prefix, i = o.namespace, n = void 0 === i ? "/" : i;
    return no(Object.keys(e), function(t1, o) {
        var i, s = e[o];
        Bt(function(e) {
            if (Ft(e) || oo(e)) return !0;
            if (to(e)) {
                var t1 = e[0], o = void 0 === t1 ? Gt : t1, r = e[1];
                return Ft(o) && Ft(r);
            }
            return !1;
        }(s), "Expected function, undefined, null, or array with payload and meta functions for " + o);
        var a = r ? "" + r + n + o : o, d = to(s) ? zt.apply(void 0, [
            a
        ].concat(s)) : zt(a, s);
        return po({}, t1, ((i = {})[o] = d, i));
    });
}
function vo(e, t1) {
    var o = go(no(e, function(e, t1) {
        var o;
        return po({}, e, ((o = {})[t1] = Gt, o));
    }), t1);
    return no(Object.keys(o), function(e, t1) {
        var r;
        return po({}, e, ((r = {})[io(t1)] = o[t1], r));
    });
}
var fo = function() {
    for(var e = arguments.length, t1 = Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
    var r = "function" != typeof t1[t1.length - 1] && t1.pop(), i = t1;
    if (void 0 === r) throw new TypeError("The initial state may not be undefined. If you do not want to set a value for this reducer, you can use null instead of undefined.");
    return function(e, t1) {
        for(var o = arguments.length, n = Array(o > 2 ? o - 2 : 0), s = 2; s < o; s++)n[s - 2] = arguments[s];
        var a = void 0 === e, d = void 0 === t1;
        return a && d && r ? r : i.reduce(function(e, o) {
            return o.apply(void 0, [
                e,
                t1
            ].concat(n));
        }, a && !d && r ? r : e);
    };
}, yo = lo(function(e) {
    return (eo(e) || so(e)) && !function(e) {
        var t1 = ao(e), o = t1.every(function(e) {
            return "next" === e || "throw" === e;
        });
        return t1.length && t1.length <= 2 && o;
    }(e);
});
function So(e, t1, o) {
    void 0 === o && (o = {}), Bt(eo(e) || so(e), "Expected handlers to be a plain object.");
    var r = yo(e, o), i = ao(r).map(function(e) {
        return function(e, t1, o) {
            void 0 === t1 && (t1 = Gt);
            var r = Ht(e).split(Wt);
            Bt(!(void 0 === o), "defaultState for reducer handling " + r.join(", ") + " should be defined"), Bt(Ft(t1) || eo(t1), "Expected reducer to be a function or object with next and throw reducers");
            var i = Ft(t1) ? [
                t1,
                t1
            ] : [
                t1.next,
                t1.throw
            ].map(function(e) {
                return oo(e) ? Gt : e;
            }), n = i[0], s = i[1];
            return function(e, t1) {
                void 0 === e && (e = o);
                var i = t1.type;
                return i && -1 !== r.indexOf(Ht(i)) ? (!0 === t1.error ? s : n)(e, t1) : e;
            };
        }(e, uo(e, r), t1);
    }), n = fo.apply(void 0, i.concat([
        t1
    ]));
    return function(e, o) {
        return void 0 === e && (e = t1), n(e, o);
    };
}
const bo = zt("CONNECT_ZOOM_SOCKET"), Eo = zt("CONNECT_XMPP_SOCKET"), Io = zt("CLOSE_ZOOM_SOCKET"), Ao = zt("CLOSE_XMPP_SOCKET"), Co = zt("RECEIVE_MESSAGE_FROM_ZOOM_SOCKET"), _o = zt("RECEIVE_SHARING_PAYLOAD_FROM_ZOOM_SOCKET"), Ro = zt("RECEIVE_MESSAGE_FROM_XMPP_SOCKET"), wo = zt("CONNECT_MAIN_SESSION_SOCKET"), To = zt("CLOSE_MAIN_SESSION_SOCKET"), Oo = zt("RECEIVE_MESSAGE_FROM_MAIN_SESSION_SOCKET"), { setZoomSocketStatus: Do, setRwgServersList: Po, setRwgRetryCount: Mo, setXmppSocketStatus: ko, setMainSessionSocketStatus: Lo, resetSocket: No } = mo("SET_ZOOM_SOCKET_STATUS", "SET_RWG_SERVERS_LIST", "SET_RWG_RETRY_COUNT", "SET_XMPP_SOCKET_STATUS", "SET_MAIN_SESSION_SOCKET_STATUS", "RESET_SOCKET"), Vo = zt("CONNECT_TO_MEDIA_STREAM"), Uo = zt("RECEIVE_PAYLOAD_FROM_MEDIA_SDK"), { setAudioEncodeStatus: jo, setAudioDecodeStatus: xo, setVideoEncodeStatus: Bo, setVideoDecodeStatus: Fo, setSharingEncodeStatus: Ho, setSharingDecodeStatus: $o, setMediaConstraints: Wo, setMediaEncryptKey: Go, setIsEnableDecoderInWorklet: Ko, setPatchedMediaSdkStatus: zo, setMediaAssetsPath: qo, setIsEnableVideoAudioQos: Jo, setIsAudioBridgeReceiveReady: Qo, setIsAudioBridgeSendReady: Zo, setIsMediaAgentInitialized: Yo, setAdaptedAbOptionForMediaSdk: Xo, resetMedia: er } = mo("SET_AUDIO_ENCODE_STATUS", "SET_AUDIO_DECODE_STATUS", "SET_VIDEO_ENCODE_STATUS", "SET_VIDEO_DECODE_STATUS", "SET_SHARING_ENCODE_STATUS", "SET_SHARING_DECODE_STATUS", "SET_MEDIA_CONSTRAINTS", "SET_MEDIA_ENCRYPT_KEY", "SET_IS_ENABLE_DECODER_IN_WORKLET", "SET_PATCHED_MEDIA_SDK_STATUS", "SET_MEDIA_ASSETS_PATH", "SET_IS_ENABLE_VIDEO_AUDIO_QOS", "SET_IS_AUDIO_BRIDGE_RECEIVE_READY", "SET_IS_AUDIO_BRIDGE_SEND_READY", "SET_IS_MEDIA_AGENT_INITIALIZED", "SET_ADAPTED_AB_OPTION_FOR_MEDIA_SDK", "RESET_MEDIA");
function tr(e, t1) {
    for(var o = arguments.length, r = new Array(o > 2 ? o - 2 : 0), i = 2; i < o; i++)r[i - 2] = arguments[i];
    return e(_e(...r || []), t1, null);
}
function or() {
    for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
    const r = function() {
        for(var e = arguments.length, o = new Array(e), r = 0; r < e; r++)o[r] = arguments[r];
        return Ye(...t1.map((e)=>{
            const t1 = e(...o);
            if (!t1) throw new TypeError(`combineEpics: one of the provided Epics "${e.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`);
            return t1.pipe(rt((e, t1)=>(setTimeout(()=>{
                    throw e;
                }, 0), t1)));
        }));
    };
    try {
        Object.defineProperty(r, "name", {
            value: `combineEpics(${t1.map((e)=>e.name || "<anonymous>").join(", ")})`
        });
    } catch (e) {}
    return r;
}
function rr() {
    for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
    return or(...t1.flatMap((e)=>Object.values(e)));
}
function ir(e, t1) {
    return e.pipe(Ot(`${Co}`), tt((e)=>e.payload.evt === t1));
}
function nr(e, t1) {
    return e.pipe(Ot(`${Oo}`), tt((e)=>e.payload.evt === t1));
}
function sr(e, t1) {
    return e.pipe(Ot(`${Ro}`), tt((e)=>e.payload.evt === t1));
}
function ar(e, t1) {
    return e.pipe(Ot(`${Co}`, `${Oo}`), tt((e)=>e.payload.evt === t1));
}
function dr(e, t1) {
    return e.pipe(Ot(`${Uo}`), tt((e)=>Array.isArray(t1) ? t1.indexOf(e.payload.type) > -1 : e.payload.type === t1));
}
function ur(e, t1) {
    return e.pipe(Ot(`${Vo}`), tt(()=>{
        const { media: { assetsPath: e, mediaConstraints: o } } = t1.value;
        return void 0 !== e && void 0 !== o;
    }), pt(()=>{
        const { media: { isMediaAgentInitialized: o } } = t1.value;
        return o ? Ce([
            0
        ]) : e.pipe(Ot(`${Yo}`), tt((e)=>!!e.payload), it(1));
    }));
}
function lr(e, t1, o) {
    const r = document.createElement("script");
    r.type = "text/javascript", r.readyState ? r.onreadystatechange = ()=>{
        "loaded" !== r.readyState && "complete" !== r.readyState || (r.onreadystatechange = null, t1());
    } : (r.onload = ()=>{
        t1();
    }, r.onerror = ()=>{
        o();
    }), r.src = e, window.crossOriginIsolated && (r.crossOrigin = "anonymous"), "function" == typeof document.body.append ? document.getElementsByTagName("head")[0].append(r) : document.getElementsByTagName("head")[0].appendChild(r);
}
function cr(e, t1) {
    let o = e;
    /^https?:\/\//.test(o) || (o = `https://${e}`);
    try {
        const e = new URL(o);
        if (!t1) return e.href;
        if (t1.hostname) return e.hostname;
        if (t1.path) return e.pathname;
    } catch (e) {
        return "";
    }
    return "";
}
function pr(e) {
    if (e) {
        var t1;
        const o = document.getElementById(e);
        null == o || null === (t1 = o.parentNode) || void 0 === t1 || t1.removeChild(o);
    }
}
let hr = "zoom.us";
const mr = "3.11.0", gr = `https://dmogdx0jrul3u.cloudfront.net/${mr}/lib/av`, vr = `https://source.zoom.us/${mr}/lib/av`, fr = `https://jssdk.zoomus.cn/${mr}/lib/av`, yr = ()=>hr, Sr = "function" == typeof Buffer, br = "function" == typeof TextDecoder ? new TextDecoder : void 0, Er = "function" == typeof TextEncoder ? new TextEncoder : void 0, Ir = Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="), Ar = (()=>{
    let e = {};
    return Ir.forEach((t1, o)=>e[t1] = o), e;
})(), Cr = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, _r = String.fromCharCode.bind(String), Rr = "function" == typeof Uint8Array.from ? Uint8Array.from.bind(Uint8Array) : (e)=>new Uint8Array(Array.prototype.slice.call(e, 0)), wr = (e)=>e.replace(/=/g, "").replace(/[+\/]/g, (e)=>"+" == e ? "-" : "_"), Tr = (e)=>e.replace(/[^A-Za-z0-9\+\/]/g, ""), Or = "function" == typeof btoa ? (e)=>btoa(e) : Sr ? (e)=>Buffer.from(e, "binary").toString("base64") : (e)=>{
    let t1, o, r, i, n = "";
    const s = e.length % 3;
    for(let s = 0; s < e.length;){
        if ((o = e.charCodeAt(s++)) > 255 || (r = e.charCodeAt(s++)) > 255 || (i = e.charCodeAt(s++)) > 255) throw new TypeError("invalid character found");
        t1 = o << 16 | r << 8 | i, n += Ir[t1 >> 18 & 63] + Ir[t1 >> 12 & 63] + Ir[t1 >> 6 & 63] + Ir[63 & t1];
    }
    return s ? n.slice(0, s - 3) + "===".substring(s) : n;
}, Dr = Sr ? (e)=>Buffer.from(e).toString("base64") : (e)=>{
    let t1 = [];
    for(let o = 0, r = e.length; o < r; o += 4096)t1.push(_r.apply(null, e.subarray(o, o + 4096)));
    return Or(t1.join(""));
}, Pr = (e)=>{
    if (e.length < 2) return (t1 = e.charCodeAt(0)) < 128 ? e : t1 < 2048 ? _r(192 | t1 >>> 6) + _r(128 | 63 & t1) : _r(224 | t1 >>> 12 & 15) + _r(128 | t1 >>> 6 & 63) + _r(128 | 63 & t1);
    var t1 = 65536 + 1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320);
    return _r(240 | t1 >>> 18 & 7) + _r(128 | t1 >>> 12 & 63) + _r(128 | t1 >>> 6 & 63) + _r(128 | 63 & t1);
}, Mr = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, kr = Sr ? (e)=>Buffer.from(e, "utf8").toString("base64") : Er ? (e)=>Dr(Er.encode(e)) : (e)=>Or(((e)=>e.replace(Mr, Pr))(e)), Lr = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, Nr = (e)=>{
    switch(e.length){
        case 4:
            var t1 = ((7 & e.charCodeAt(0)) << 18 | (63 & e.charCodeAt(1)) << 12 | (63 & e.charCodeAt(2)) << 6 | 63 & e.charCodeAt(3)) - 65536;
            return _r(55296 + (t1 >>> 10)) + _r(56320 + (1023 & t1));
        case 3:
            return _r((15 & e.charCodeAt(0)) << 12 | (63 & e.charCodeAt(1)) << 6 | 63 & e.charCodeAt(2));
        default:
            return _r((31 & e.charCodeAt(0)) << 6 | 63 & e.charCodeAt(1));
    }
}, Vr = "function" == typeof atob ? (e)=>atob(Tr(e)) : Sr ? (e)=>Buffer.from(e, "base64").toString("binary") : (e)=>{
    if (e = e.replace(/\s+/g, ""), !Cr.test(e)) throw new TypeError("malformed base64.");
    e += "==".slice(2 - (3 & e.length));
    let t1, o, r, i = "";
    for(let n = 0; n < e.length;)t1 = Ar[e.charAt(n++)] << 18 | Ar[e.charAt(n++)] << 12 | (o = Ar[e.charAt(n++)]) << 6 | (r = Ar[e.charAt(n++)]), i += 64 === o ? _r(t1 >> 16 & 255) : 64 === r ? _r(t1 >> 16 & 255, t1 >> 8 & 255) : _r(t1 >> 16 & 255, t1 >> 8 & 255, 255 & t1);
    return i;
}, Ur = Sr ? (e)=>Rr(Buffer.from(e, "base64")) : (e)=>Rr(Vr(e).split("").map((e)=>e.charCodeAt(0))), jr = Sr ? (e)=>Buffer.from(e, "base64").toString("utf8") : br ? (e)=>br.decode(Ur(e)) : (e)=>((e)=>e.replace(Lr, Nr))(Vr(e)), xr = (e, t1 = !1)=>t1 ? wr(kr(e)) : kr(e), Br = (e)=>jr(((e)=>Tr(e.replace(/[-_]/g, (e)=>"-" == e ? "+" : "/")))(e)), Fr = (e, t1 = !1)=>t1 ? wr(Dr(e)) : Dr(e);
function Hr(e) {
    return xr(e, !0);
}
function $r(e) {
    return Br(e);
}
function Wr(e) {
    return xr(e, !1);
}
const Gr = {
    "-": "+",
    _: "/",
    ".": "="
};
function Kr(e) {
    const t1 = e.replace(/[-_.]/g, (e)=>Gr[e]);
    return Uint8Array.from(window.atob(t1), (e)=>e.charCodeAt(0));
}
const zr = (e)=>{
    const t1 = e.charCodeAt(0);
    return t1 <= parseInt("0x7F", 16) ? 1 : t1 <= parseInt("0x7FF", 16) ? 2 : t1 <= parseInt("0xFFFF", 16) ? 3 : t1 <= parseInt("0x1FFFFF", 16) ? 4 : t1 <= parseInt("0x3FFFFFF", 16) ? 5 : 6;
}, qr = (e, t1)=>{
    const o = e.split(".").map((e)=>Number(e)).slice(0, 3), r = t1.split(".").map((e)=>Number(e)).slice(0, 3);
    let i = 0;
    for(let e = 0; e < 3; e++){
        const t1 = e < o.length ? o[e] : 0, n = e < r.length ? r[e] : 0;
        if (t1 < n) {
            i = -1;
            break;
        }
        if (t1 > n) {
            i = 1;
            break;
        }
    }
    return i;
}, Jr = (e)=>{
    var t1;
    let o = (new Date).getTime(), r = 1e3 * (null === (t1 = performance) || void 0 === t1 ? void 0 : t1.now()) || 0;
    const i = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e)=>{
        let t1 = 16 * Math.random();
        return o > 0 ? (t1 = (o + t1) % 16 | 0, o = Math.floor(o / 16)) : (t1 = (r + t1) % 16 | 0, r = Math.floor(r / 16)), ("x" === e ? t1 : 3 & t1 | 8).toString(16);
    });
    return i + "";
};
function Qr(e, t1) {
    if (e === t1) return !0;
    if (!e || !t1) return !1;
    const o = Object.keys(e), r = Object.keys(t1), i = o.length;
    if (r.length !== i) return !1;
    for(let r = 0; r < i; r++){
        const i = o[r];
        if (e[i] !== t1[i] || !Object.prototype.hasOwnProperty.call(t1, i)) return !1;
    }
    return !0;
}
const Zr = (e, t1)=>e >> 10 == t1 >> 10, Yr = (e, t1)=>new Promise((o)=>{
        setTimeout(()=>{
            o(e());
        }, t1);
    }), Xr = (e)=>{
    const t1 = `${Math.floor(1e4 * Math.random())}`;
    return e.indexOf("@") > -1 ? e.replace("@", t1) : `${e}${t1}`;
}, ei = (e)=>{
    try {
        const t1 = new URL(e);
        return !("data:" === t1.protocol && "null" === t1.origin) && t1.origin !== location.origin;
    } catch (e) {
        return !0;
    }
}, ti = (e)=>{
    const t1 = e.split(".")[1];
    if ("string" == typeof t1) {
        let o = t1.replace(/-/g, "+").replace(/_/g, "/");
        switch(o.length % 4){
            case 0:
                break;
            case 2:
                o += "==";
                break;
            case 3:
                o += "=";
                break;
            default:
                throw new Error("base64 string is not of the correct length");
        }
        try {
            const e = decodeURIComponent(window.atob(o).replace(/(.)/g, function(e, t1) {
                let o = t1.charCodeAt(0).toString(16).toUpperCase();
                return o.length < 2 && (o = "0" + o), "%" + o;
            }));
            return JSON.parse(e);
        } catch (e) {
            console.error("Invalid token specified: invalid base64");
        }
    }
};
function oi(e) {
    return e && e.endsWith("/") ? e.slice(0, e.length - 1) : e;
}
function ri(e) {
    return [
        ...new Uint8Array(e)
    ].map((e)=>e.toString(16).padStart(2, "0")).join("");
}
function ii(e) {
    return `${e.tagName}${e.id ? `#${e.id}` : ""}${e.className ? `${e.className.split(" ").map((e)=>`.${e}`).join("")}` : ""}`;
}
function ni(e) {
    const t1 = function(e) {
        const t1 = e && e.getRootNode();
        if (t1 && "#document" !== t1.nodeName && t1.host) return ii(t1.host);
    }(e);
    return `${t1 ? `${t1}>` : ""}${ii(e)}`;
}
function si(e) {
    return "object" == typeof e && null !== e ? e instanceof HTMLElement ? ni(e) : ArrayBuffer.isView(e) ? ri(e.buffer) : Array.isArray(e) ? e.map((e)=>si(e)) : Object.keys(e).reduce((t1, o)=>({
            ...t1,
            [`${o}`]: si(e[o])
        }), {}) : e;
}
const ai = [
    gr,
    fr,
    vr
].map((e)=>cr(e, {
        hostname: !0
    }));
function di(e) {
    return ai.some((t1)=>new RegExp(`^https://${t1}`).test(null != e ? e : ""));
}
let ui = function(e) {
    return e[e.Success = 0] = "Success", e[e.MeetingIsOver = 6] = "MeetingIsOver", e[e.UserFull = 9] = "UserFull", e[e.MeetingLocked = 12] = "MeetingLocked", e[e.WebinarBlockedEmail = 3033] = "WebinarBlockedEmail", e[e.MeetingNotStarted = 3008] = "MeetingNotStarted", e[e.MeetingHasClosed = 103003] = "MeetingHasClosed", e[e.UserHasBeenRemoved = 103039] = "UserHasBeenRemoved", e[e.MMRIBReject = 103043] = "MMRIBReject", e[e.MMRConfParticipantExists = 103044] = "MMRConfParticipantExists", e;
}({}), li = function(e) {
    return e[e.Unknown = 0] = "Unknown", e[e.Normal = 1] = "Normal", e[e.Userrequest = 2] = "Userrequest", e[e.SdkConnection = 3] = "SdkConnection", e[e.Reconnect = 5] = "Reconnect", e[e.PtRequest = 6] = "PtRequest", e[e.KickedByHost = 7] = "KickedByHost", e[e.EndByHost = 8] = "EndByHost", e[e.EndByHostStartAnotherMeeting = 9] = "EndByHostStartAnotherMeeting", e[e.FreeMeetingTimeout = 10] = "FreeMeetingTimeout", e[e.JBHTimeout = 11] = "JBHTimeout", e[e.EndBySingleStatus = 12] = "EndBySingleStatus", e[e.WebinarNeedRegister = 13] = "WebinarNeedRegister", e[e.ArchiveFail = 14] = "ArchiveFail", e[e.EndByNone = 15] = "EndByNone", e[e.EndByAdmin = 16] = "EndByAdmin", e[e.DuplicateSession = 17] = "DuplicateSession", e[e.MeetingTransfer = 18] = "MeetingTransfer", e;
}({}), ci = function(e) {
    return e[e.WaitingRoomFailover = 1] = "WaitingRoomFailover", e[e.WebEndAndRejoin = 2] = "WebEndAndRejoin", e;
}({}), pi = function(e) {
    return e[e.Success = 0] = "Success", e[e.CommonError = 200] = "CommonError", e[e.WrongPasscode = 3004] = "WrongPasscode", e[e.RoleTypeMissing = 3010] = "RoleTypeMissing", e[e.InvalidParameter = 4003] = "InvalidParameter", e;
}({}), hi = function(e) {
    return e[e.Success = 0] = "Success", e[e.AnotherMeetingInProgress = 3e3] = "AnotherMeetingInProgress", e[e.MeetingNotExist = 3001] = "MeetingNotExist", e[e.NotHost = 3003] = "NotHost", e[e.WrongPasscode = 3004] = "WrongPasscode", e[e.MissingEmail = 3005] = "MissingEmail", e[e.MeetingNotStarted = 3008] = "MeetingNotStarted", e[e.UserHasBeenRemoved = 3009] = "UserHasBeenRemoved", e[e.RoleTypeMissing = 3010] = "RoleTypeMissing", e[e.WebinarEnforceLogin = 3034] = "WebinarEnforceLogin", e[e.RealNameMissing = 3082] = "RealNameMissing", e[e.RegisterRequired = 3099] = "RegisterRequired", e[e.SsoLoginWindow = 6024] = "SsoLoginWindow", e[e.ZoomLoginWindow = 3051] = "ZoomLoginWindow", e[e.ZoomSpecificLoginWindow = 3052] = "ZoomSpecificLoginWindow", e[e.LoginRequired = 3100] = "LoginRequired", e[e.Reconnecting = 4e3] = "Reconnecting", e[e.Disconnect = 4001] = "Disconnect", e[e.InvalidParameter = 4003] = "InvalidParameter", e[e.DeniedRegisterWithPanelist = 3032] = "DeniedRegisterWithPanelist", e[e.ServiceOffline = 403] = "ServiceOffline", e[e.RwcEmpty = 3621] = "RwcEmpty", e[e.RwcError = 3622] = "RwcError", e[e.FrequentCall = 3633] = "FrequentCall", e[e.FrequentJoin = 3634] = "FrequentJoin", e[e.WasmFail = 3635] = "WasmFail", e[e.CommonError = 200] = "CommonError", e[e.Upgrade = 1e4] = "Upgrade", e;
}({});
hi.Success, hi.RegisterRequired, hi.LoginRequired, hi.SsoLoginWindow, hi.ZoomLoginWindow, hi.ZoomSpecificLoginWindow, hi.MissingEmail, hi.MeetingNotExist, hi.NotHost, hi.WrongPasscode, hi.RoleTypeMissing, hi.AnotherMeetingInProgress, hi.MeetingNotStarted, hi.InvalidParameter, hi.Reconnecting, hi.UserHasBeenRemoved, hi.WebinarEnforceLogin, hi.Disconnect, hi.DeniedRegisterWithPanelist, hi.RwcEmpty, hi.RwcError, hi.FrequentCall, hi.FrequentJoin, hi.WasmFail, hi.Upgrade;
const mi = {
    3004: {
        "apac.errorcodes_pac_mn_wrong": 3714
    },
    3005: {
        "apac.errorcodes_web_has_in_progress": 3e3
    },
    3008: {
        "apac.errorcodes_not_start": 3008
    },
    3027: {
        "apac.errorcodes_host_email_as_attendee": 3627
    },
    3033: {
        "apac.errorcodes_denied_email": 3620
    },
    1005: {
        "apac.errorcodes_no_response_from_web": 3621
    },
    131005: {
        "apac.errorcodes_no_response_from_web": 3621
    },
    1001: {
        "apac.errorcodes_host_inactive": 3625
    },
    131001: {
        "apac.errorcodes_host_inactive": 3625
    },
    131013: {
        "meeting ended": 4004
    },
    103039: {
        "apac.errorcodes_be_removed": 3009
    },
    6: {
        "meeting ended": 4004
    },
    9: {
        "meeting is at capacity": 4005
    },
    12: {
        "meeting locked": 4006
    },
    103043: {
        "reject for information barriers": 4007
    },
    103044: {
        "participant exist": 4008
    }
};
function gi(e, t1) {
    let o = {
        code: 200
    };
    if (void 0 !== mi[e]) {
        const t1 = mi[e], r = Object.keys(t1)[0];
        return o = {
            code: t1[r],
            i18nKey: r
        }, {
            reason: r.startsWith("apac") ? "" : r,
            errorCode: o.code
        };
    }
    return {
        code: 200,
        reason: "connection error"
    };
}
const vi = "SET_MEETING_INFO", fi = "SET_MEETING_JOIN_INFO", yi = "SET_WINDOWN_OPEN", Si = "SET_APPID_SIGNATURE", bi = "SET_ZTK", Ei = "SET_ZSK", Ii = "SET_TK_MTKGUID", Ai = "SET_PING_RWC_TIMESTAMP", Ci = "SET_IN_MEETING_INFO", _i = "SET_MEETING_ATTRIBUTE", Ri = "RESET_MEETING", wi = "SET_IS_HOST", Ti = "SET_IS_COHOST", Oi = "SET_MEETING_IS_ON_HOLD", Di = "SET_IS_MEETING_RESET", Pi = "SET_AUDIO_VIDEO_BEFORE_ON_HOLD", Mi = "SET_CURRENT_USER_AUDIO_BEFORE_RESET", ki = "SET_IS_CURRENT_USER_MUTED_BEFORE_RESET", Li = "SET_IS_CURRENT_USER_START_VIDEO_BEFORE_RESET", Ni = "SET_MEETING_STATUS", Vi = "SET_MEETING_REGION", Ui = "SET_JOIN_MEETING_TIME_STAMP", ji = "SET_ACTIVE_APP_INFO", xi = "SET_MEETING_IDLE_START_TIME", Bi = "SET_SESSION_IDLE_TIMEOUT_MINUTES", Fi = "SET_IS_AUDIO_BRIDGE_ENABLED", Hi = "ADD_DISCARDED_RWC_HOST", $i = "SET_SHARE_PRONOUN_TYPE", Wi = "SET_IS_STAY_AWAKE_DURING_THE_SESSION", Gi = "SET_MEETING_JOIN_SUCCESS_TIMESTAMP", Ki = "RESET_FAILOVER_RECORD", zi = "SET_FAILOVER_REASON", qi = "SET_IS_QUICKLY_LEAVE_MEETING_AFTER_REFRESH", Ji = "SET_MEETING_INFO_TIMESTAMP", Qi = "SET_IS_ENABLE_ZMK_FROM_RWG", Zi = "SET_IS_RLB_TP", Yi = "SET_IS_RLB_TP_READY", Xi = [
    "bLock",
    "bHoldUponEntry",
    "viewOnly",
    "listenOnlyPhone",
    "bAllowRaiseHand",
    "bAllowAttendeeRename",
    "bBroadcast",
    "bAllowPlayChimeForEnterOrExit",
    "bIbDisableShare",
    "bIbDisableChat",
    "encryptKey",
    "bNoHostTimeOut",
    "bAllowShowCount",
    "bHasAST",
    "bHasRMC",
    "gatewayKey",
    "encryptKey"
], en = {
    bChime: "bAllowPlayChimeForEnterOrExit",
    bHasAST: "hasAst",
    bHasRMC: "hasRmc",
    topic: (e)=>({
            meetingTopic: $r(e)
        }),
    gatewayKey: (e)=>{
        const [, t1, o] = e.split(".");
        return t1 && o ? {
            gatewayUser: {
                userId: Number(t1),
                sn: o
            }
        } : {};
    },
    encryptKey: (e)=>({
            gcmSessinKey: Kr(e)
        })
}, tn = zt("GET_MEETING_INFO"), on = zt("GET_INSTANT_MEETING_INFO");
zt("LOGON_ZOOM_DOMAIN"), zt("VERIFY_ZOOM_RECAPTCHA"), zt("LOGON_THIRD_PARTY_DOMAIN");
const rn = zt("PING_RWC_SERVER"), nn = zt("MEETING_FAILOVER"), sn = zt("LEAVE_MEETING"), an = zt("LEAVE_WAITING_ROOM"), dn = zt("END_MEETING");
zt("REGISTER_WEBINAR");
const un = zt("TRIGGER_IDLE_CHECK"), ln = zt("END_OF_ZE_WORLD"), { setMeetingInfo: cn, setMeetingJoinInfo: pn, setWindownOpen: hn, setAppidSignature: mn, setZtk: gn, setZsk: vn, setTkMtkguid: fn, setPingRwcTimestamp: yn, setInMeetingInfo: Sn, setMeetingAttribute: bn, resetMeeting: En, setIsHost: In, setIsCohost: An, setMeetingIsOnHold: Cn, setIsMeetingReset: _n, setAudioVideoBeforeOnHold: Rn, setCurrentUserAudioBeforeReset: wn, setIsCurrentUserMutedBeforeReset: Tn, setMeetingStatus: On, setMeetingRegion: Dn, setIsCurrentUserStartVideoBeforeReset: Pn, setJoinMeetingTimeStamp: Mn, setActiveAppInfo: kn, setMeetingIdleStartTime: Ln, setSessionIdleTimeoutMinutes: Nn, setIsAudioBridgeEnabled: Vn, addDiscardedRwcHost: Un, setSharePronounType: jn, setIsStayAwakeDuringTheSession: xn, setMeetingJoinSuccessTimestamp: Bn, resetFailoverRecord: Fn, setFailoverReason: Hn, setIsQuicklyLeaveMeetingAfterRefresh: $n, setMeetingInfoTimestamp: Wn, setIsEnableZmkFromRwg: Gn, setIsRlbTp: Kn, setIsRlbTpReady: zn } = mo({
    [vi]: (e)=>e,
    [fi]: (e)=>e,
    [yi]: (e)=>e,
    [Si]: (e)=>e,
    [bi]: (e)=>e,
    [Ei]: (e)=>e,
    [Ii]: (e)=>e,
    [Ai]: (e)=>e,
    [Ci]: (e)=>e,
    [_i]: (e)=>{
        if (Xi.some((t1)=>e && void 0 !== e[t1])) {
            let t1 = e;
            return Object.keys(en).some((t1)=>void 0 !== e[t1]) && (t1 = Object.keys(e).reduce((t1, o)=>{
                const r = en[o];
                return "function" == typeof r ? Object.assign(t1, r(e[o])) : "string" == typeof r ? t1[r] = e[o] : (t1[o], e[o]), t1;
            }, {})), t1;
        }
        return {};
    },
    [wi]: (e)=>e && e.bHost,
    [Ti]: (e)=>e && e.bCoHost,
    [Ri]: (e)=>e,
    [Oi]: (e)=>e,
    [Di]: (e)=>e,
    [Pi]: (e)=>e,
    [Mi]: (e)=>e,
    [ki]: (e)=>e,
    [Ni]: (e)=>e,
    [Vi]: (e)=>e,
    [Li]: (e)=>e,
    [Ui]: (e)=>e,
    [ji]: (e)=>e,
    [xi]: (e)=>e,
    [Bi]: (e)=>e,
    [Fi]: (e)=>e,
    [Hi]: (e)=>e,
    [$i]: (e)=>e,
    [Wi]: (e)=>e,
    [Gi]: (e)=>e,
    [Ki]: (e)=>e,
    [zi]: (e)=>e,
    [qi]: (e)=>e,
    [Ji]: (e)=>e,
    [Qi]: (e)=>e,
    [Zi]: (e)=>e,
    [Yi]: (e)=>e
});
let qn = function(e) {
    return e.Failover = "failover", e.OnHold = "on hold", e.Promote = "promote", e.Depromote = "depromote", e.JoinBreakoutRoom = "join breakout room", e.MoveToBreakoutRoom = "move to breakout room", e.BackToMainSession = "back to main session", e;
}({});
const Jn = "js_media.min.js";
let Qn = function(e) {
    return e.CDN = "CDN", e.Global = "Global", e.CN = "CN", e;
}({}), Zn = function(e) {
    return e.Connected = "Connected", e.Reconnecting = "Reconnecting", e.Closed = "Closed", e.Fail = "Fail", e;
}({}), Yn = function(e) {
    return e.Initial = "initial", e.Joined = "joined", e.Closed = "closed", e;
}({}), Xn = function(e) {
    return e.AudioBridgeEnable = "M:1,2;V:1,2", e.AudioDecodeInWorklet = "M:6;V:3", e.VideoFullHD = "M:8;V:4", e.VideoShareFullHD = "M:9;V:5", e.WebGL2Render = "M:20;V:8", e.WebGPURender = "M:21;V:9", e.ZMKFromRWG = "M:19;V:10", e;
}({}), es = function(e) {
    return e[e.NormalCase = -1] = "NormalCase", e[e.NoHeartbeat = 0] = "NoHeartbeat", e[e.NoHeartbeatMChannel = 1] = "NoHeartbeatMChannel", e[e.NetworkChange = 2] = "NetworkChange", e[e.NotifyUiFailover = 3] = "NotifyUiFailover", e[e.InvalidParameters = 4] = "InvalidParameters", e[e.OnError = 5] = "OnError", e[e.OnErrorMChannel = 6] = "OnErrorMChannel", e[e.Disconnect = 7] = "Disconnect", e[e.DisconnectMChannel = 8] = "DisconnectMChannel", e[e.DisconnectXmpp = 9] = "DisconnectXmpp", e[e.RefreshPage = 10] = "RefreshPage", e[e.OnErrorXmppChannel = 15] = "OnErrorXmppChannel", e;
}({});
const ts = [
    "8-29",
    "9-21",
    "12-44"
];
let os = function(e) {
    return e.LocalStorage = "LocalStorage", e.SessionStorage = "SessionStorage", e.Memory = "Memory", e;
}({});
const rs = Hr("{}");
class is {
    constructor(e){
        this.sessionStorageKey = void 0, this.localStorageKey = void 0, this.sessionCache = void 0, this.localCache = void 0, this.memoryCache = void 0, this.sessionStorageKey = Hr(`zoom-storage-${e}`), this.localStorageKey = Hr("zoom-local-storage"), this.memoryCache = {};
        try {
            this.sessionCache = JSON.parse($r(sessionStorage.getItem(this.sessionStorageKey) || rs)), this.localCache = JSON.parse($r(localStorage.getItem(this.localStorageKey) || rs));
        } catch (e) {
            console.error(e), this.sessionCache = {}, this.localCache = {};
        }
    }
    static init(e) {
        this.instance = new is(e);
    }
    static get(e) {
        if (void 0 === this.instance) throw new Error("read before initial");
        return this.instance.getValue(e).value;
    }
    static set(e, t1, o) {
        if (void 0 === this.instance) throw new Error("set before initial");
        return this.instance.setValue(e, t1, o);
    }
    static remove(e) {
        if (void 0 === this.instance) throw new Error("remove before initial");
        return this.instance.removeValue(e);
    }
    static clearSession() {
        if (void 0 === this.instance) throw new Error("clear before initial");
        return this.instance.memoryCache = {}, this.instance.sessionCache = {}, this.instance.localCache = {}, sessionStorage.removeItem(this.instance.sessionStorageKey);
    }
    getValue(e) {
        return this.sessionCache.hasOwnProperty(e) ? {
            value: this.sessionCache[e],
            type: os.SessionStorage
        } : this.localCache.hasOwnProperty(e) ? {
            value: this.localCache[e],
            type: os.LocalStorage
        } : {
            value: this.memoryCache[e],
            type: os.Memory
        };
    }
    setValue(e, t1, o) {
        if (!e) throw new Error("key is null");
        switch(o){
            case os.SessionStorage:
                {
                    const o = this.sessionCache[e];
                    let r = t1;
                    return "function" == typeof t1 && (r = t1(o)), o !== r && (this.sessionCache[e] = r, this.flushValue(os.SessionStorage)), r;
                }
            case os.LocalStorage:
                {
                    const o = this.localCache[e];
                    let r = t1;
                    return "function" == typeof t1 && (r = t1(o)), o !== r && (this.localCache[e] = r, this.flushValue(os.LocalStorage)), r;
                }
            case os.Memory:
                {
                    const o = this.memoryCache[e];
                    let r = t1;
                    return "function" == typeof t1 && (r = t1(o)), this.memoryCache[e] = r, r;
                }
            default:
                return null;
        }
    }
    removeValue(e) {
        const { type: t1 } = this.getValue(e);
        switch(t1){
            case os.SessionStorage:
                delete this.sessionCache[e], this.flushValue(os.SessionStorage);
                break;
            case os.LocalStorage:
                delete this.localCache[e], this.flushValue(os.LocalStorage);
                break;
            case os.Memory:
                delete this.memoryCache[e];
        }
    }
    flushValue(e) {
        e === os.SessionStorage ? sessionStorage.setItem(this.sessionStorageKey, Hr(JSON.stringify(this.sessionCache))) : e === os.LocalStorage && localStorage.setItem(this.localStorageKey, Hr(JSON.stringify(this.localCache)));
    }
}
is.instance = void 0;
let ns = function(e) {
    return e.WebclientOpt = "WEB_CLIENT_OPT", e.WebclientWebinarToken = "WEB_CLIENT_WEBINAR_TOKEN", e.WebclientMeetingToken = "WEB_CLIENT_MEETING_TOKEN", e.WebclientZtk = "WEB_CLIENT_ZTK", e.WebclientZsk = "WEB_CLIENT_ZSK", e.WebclientTk = "WEB_CLIENT_TK", e.WebclientIVState = "WEB_CLIENT_IV_STATE", e.WebclientIsOnHold = "WEB_CLIENT_IS_ON_HOLD", e.WebclientParticipantId = "WEB_CLIENT_PARTICIPANT_ID", e.WebclientZoomId = "WEB_CLIENT_ZOOM_ID", e.WebclientUserName = "WEB_CLIENT_USER_NAME", e.WebclientUserEmail = "WEB_CLIENT_USER_EMAIL", e.WebclientBreakoutRoomAttendeeStatus = "WEB_CLIENT_BO_ATTENDEE_STATUS", e.WebclientBreakoutRoomCommand = "WEB_CLIENT_BO_COMMAND", e.WebclientAudioEncryptKey = "WEB_CLIENT_AUDIO_ENCRYPT_KEY", e.WebclientVideoEncryptKey = "WEB_CLIENT_VIDEO_ENCRYPT_KEY", e.WebclientSharingEncryptKey = "WEB_CLIENT_SHARING_ENCRYPT_KEY", e.WebclientFailoverCount = "WEB_CLIENT_FAILOVER_COUNT", e.WebclientRecordingToken = "WEB_CLIENT_RECORDING_TOKEN", e;
}({}), ss = function(e) {
    return e.WebclientDeviceId = "WEBCLIENT_DEVICE_ID", e.VSDKLogTrackingId = "ZM_VSDK_LOG_TRACKING_IDS", e;
}({}), as = function(e) {
    return e.EnforceWebRTCAudio = "ENFORCE_WEB_RTC_AUDIO", e.DisableAutoReportLogs = "DISABLE_AUTO_REPORT_LOGS", e;
}({});
function ds(e, t1) {
    const o = t1.match(e);
    return o && o.length > 0 && o[1] || "";
}
function us(e, t1) {
    const o = t1.match(e);
    return o && o.length > 1 && o[2] || "";
}
const ls = /version\/(\d+(\.?_?\d+)+)/i, cs = [
    {
        test: [
            /opera/i
        ],
        describe: (e)=>[
                "Opera(Legacy)",
                ds(ls, e) || ds(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: [
            /opr\/|opios/i
        ],
        describe: (e)=>[
                "Opera",
                ds(/(?:opr|opios)[\s/](\S+)/i, e) || ds(ls, e)
            ]
    },
    {
        test: [
            /SamsungBrowser/i
        ],
        describe: (e)=>[
                "Samsung Internet for Android",
                ds(ls, e) || ds(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: [
            /micromessenger/i
        ],
        describe: (e)=>[
                "WeChat",
                ds(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || ds(ls, e)
            ]
    },
    {
        test: [
            /qqbrowser/i
        ],
        describe: (e)=>[
                /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser",
                ds(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || ds(ls, e)
            ]
    },
    {
        test: [
            /msie|trident/i
        ],
        describe: (e)=>[
                "Internet Explorer",
                ds(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: [
            /\sedg\//i
        ],
        describe: (e)=>[
                "Microsoft Edge",
                ds(/\sedg\/(\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: [
            /edg([ea]|ios)/i
        ],
        describe: (e)=>[
                "Microsoft Edge(Legacy)",
                us(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: [
            /firefox|iceweasel|fxios/i
        ],
        describe: (e)=>[
                "Firefox",
                ds(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: [
            /electron/i
        ],
        describe: (e)=>[
                "Electron",
                ds(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: [
            /chromium/i
        ],
        describe: (e)=>[
                "Chromium",
                ds(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || ds(ls, e)
            ]
    },
    {
        test: [
            /chrome|crios|crmo/i
        ],
        describe: (e)=>[
                "Chrome",
                ds(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e)
            ]
    },
    {
        test: (e)=>!/like android/i.test(e) && /android/i.test(e),
        describe: (e)=>[
                "Android Browser",
                ds(ls, e)
            ]
    },
    {
        test: [
            /safari|applewebkit/i
        ],
        describe: (e)=>[
                "Safari",
                ds(ls, e)
            ]
    }
], ps = [
    {
        test: [
            /windows /i
        ],
        describe: (e)=>[
                "Windows",
                ds(/Windows ((NT|XP)( \d\d?.\d)?)/i, e)
            ]
    },
    {
        test: [
            /Macintosh(.*?) FxiOS(.*?)\//
        ],
        describe: (e)=>[
                "iOS",
                us(/(Version\/)(\d[\d.]+)/, e)
            ]
    },
    {
        test: [
            /macintosh/i
        ],
        describe: (e)=>[
                "macOS",
                ds(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, ".")
            ]
    },
    {
        test: [
            /(ipod|iphone|ipad)/i
        ],
        describe: (e)=>[
                "iOS",
                ds(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".")
            ]
    },
    {
        test: (e)=>!/like android/i.test(e) && /android/i.test(e),
        describe: (e)=>[
                "Android",
                ds(/android[\s/-](\d+(\.\d+)*)/i, e)
            ]
    },
    {
        test: [
            /linux/i
        ],
        describe: ()=>[
                "Linux"
            ]
    },
    {
        test: [
            /CrOS/
        ],
        describe: ()=>[
                "Chrome OS"
            ]
    }
];
class hs {
    constructor(){
        this.value = void 0, this.gpu = void 0;
    }
    get isSupported() {
        if (void 0 === this.value) if ("function" == typeof window.OffscreenCanvas) {
            const e = new OffscreenCanvas(1, 1);
            e.addEventListener("webglcontextlost", (e)=>{
                e.preventDefault();
            });
            const t1 = e.getContext("webgl");
            if (this.value = !!t1, t1) {
                const e = t1.getExtension("WEBGL_debug_renderer_info");
                e && (this.gpu = t1.getParameter(e.UNMASKED_RENDERER_WEBGL));
            }
        } else this.value = !1;
        return this.value;
    }
}
const ms = new class {
    constructor(){
        this._browser = void 0, this._os = void 0, this._browserVersion = void 0, this._osVersion = void 0, this._offscreenCanvasCapality = void 0, this._clientHintsData = void 0, this._offscreenCanvasCapality = new hs, "userAgentData" in navigator && navigator.userAgentData.getHighEntropyValues([
            "architecture",
            "bitness",
            "formFactor",
            "model",
            "platformVersion",
            "wow64"
        ]).then((e)=>{
            this._clientHintsData = e, this._os && this._osVersion && this._clientHintsData.platform && this._clientHintsData.platformVersion && (this._os = this._clientHintsData.platform, this._osVersion = this._clientHintsData.platformVersion);
        }).catch((e)=>{
            console.warn(e);
        });
    }
    _getBrowserVersion() {
        var e;
        if (null !== (e = this._clientHintsData) && void 0 !== e && null !== (e = e.brands) && void 0 !== e && e.length) {
            const e = this._clientHintsData.brands.filter((e)=>!/(Chromium|Not.*Brand)/i.test(e.brand))[0];
            e && (this._browser = e.brand);
            const t1 = this._clientHintsData.brands.find((e)=>{
                var t1;
                return "chromium" === (null === (t1 = e.brand) || void 0 === t1 ? void 0 : t1.toLowerCase());
            });
            t1 ? (this._browserVersion = t1.version, this._browser || (this._browser = t1.brand)) : this._browserVersion = e.version;
        } else {
            const e = navigator.userAgent, t1 = cs.find((t1)=>"function" == typeof t1.test ? t1.test(e) : t1.test.some((t1)=>t1.test(e)));
            if (t1) {
                const o = t1.describe(e);
                this._browser = o[0], this._browserVersion = o[1], this.isIOSMobile && (this._browser = "ios-safari");
            } else this._browser = "unknown", this._browserVersion = "0";
        }
    }
    _getOSVersion() {
        var e, t1;
        if (null !== (e = this._clientHintsData) && void 0 !== e && e.platform && null !== (t1 = this._clientHintsData) && void 0 !== t1 && t1.platformVersion) this._os = this._clientHintsData.platform, this._osVersion = this._clientHintsData.platformVersion;
        else {
            const e = navigator.userAgent, t1 = ps.find((t1)=>"function" == typeof t1.test ? t1.test(e) : t1.test.some((t1)=>t1.test(e)));
            if (t1) {
                const o = t1.describe(e);
                this._os = o[0], this._osVersion = o[1];
            } else this._os = "unknown", this._osVersion = "0";
        }
    }
    get browser() {
        return this._browser || this._getBrowserVersion(), this._browser;
    }
    get browserVersion() {
        return this._browserVersion || this._getBrowserVersion(), this._browserVersion;
    }
    get os() {
        return this._os || this._getOSVersion(), this._os;
    }
    get osVersion() {
        return this._osVersion || this._getOSVersion(), this._osVersion;
    }
    get isIE() {
        return "Internet Explorer" === this.browser;
    }
    get isLegacyEdge() {
        return "Microsoft Edge(Legacy)" === this.browser;
    }
    get isLegacyOpera() {
        return "Opera(Legacy)" === this.browser;
    }
    get isFirefox() {
        return "Firefox" === this.browser;
    }
    get isSafari() {
        return "Safari" === this.browser;
    }
    get isChrome() {
        var e, t1;
        if (null !== (e = this._clientHintsData) && void 0 !== e && null !== (e = e.brands) && void 0 !== e && e.length) return null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.brands.some((e)=>{
            var t1;
            return "chromium" === (null === (t1 = e.brand) || void 0 === t1 ? void 0 : t1.toLocaleLowerCase());
        });
        const { userAgent: o } = navigator;
        return !this.isLegacyOpera && !this.isLegacyEdge && /chrome/i.test(o) && /webkit/i.test(o);
    }
    get isLegacyChrome() {
        var e;
        return this.isChrome && "function" != typeof (null === (e = navigator.mediaDevices) || void 0 === e ? void 0 : e.getDisplayMedia);
    }
    get isMacOS() {
        return "macOS" === this.os;
    }
    get isIPad() {
        var e;
        return /iPad/i.test(navigator.userAgent) || this.isMacOS && (null === (e = navigator) || void 0 === e ? void 0 : e.maxTouchPoints) > 2;
    }
    get isIOSMobile() {
        return "iOS" === this.os || this.isIPad;
    }
    get architecture() {
        var e, t1;
        return null !== (e = null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.architecture) && void 0 !== e ? e : "";
    }
    get isArm() {
        return this.architecture ? "arm" === this.architecture : /arm/i.test(navigator.userAgent);
    }
    get isChromeOS() {
        return "Chrome OS" === this.os;
    }
    get isAndroidBrowser() {
        var e;
        return "android" === (null === (e = this.os) || void 0 === e ? void 0 : e.toLowerCase());
    }
    get isArmChromeOS() {
        return this.isArm && this.isChromeOS;
    }
    get isAndroidOrIOSBrowser() {
        return this.isAndroidBrowser || this.isIOSMobile;
    }
    get isSupportEssentialAudioAndVideoAbility() {
        return "object" == typeof WebAssembly && "function" == typeof Worker;
    }
    get isSupportAudioWorklet() {
        return "function" == typeof AudioWorklet;
    }
    get isSupportImageCapture() {
        return "ImageCapture" in window;
    }
    get isSupportMediaStreamTrackProcessor() {
        return "MediaStreamTrackProcessor" in window;
    }
    get isSupportOffscreenCanvas() {
        return this._offscreenCanvasCapality.isSupported;
    }
    get gpu() {
        return this._offscreenCanvasCapality.isSupported ? this._offscreenCanvasCapality.gpu : "";
    }
    get bitness() {
        var e, t1;
        return null !== (e = null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.bitness) && void 0 !== e ? e : "";
    }
    get model() {
        var e, t1;
        return null !== (e = null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.model) && void 0 !== e ? e : "";
    }
    get wow64() {
        var e;
        if ("windows" === this.os.toLowerCase()) return null === (e = this._clientHintsData) || void 0 === e ? void 0 : e.wow64;
    }
    get isSupportSendScreenSharing() {
        return "getDisplayMedia" in navigator.mediaDevices && "function" == typeof navigator.mediaDevices.getDisplayMedia;
    }
    get isSupportSharedArrayBuffer() {
        return "function" == typeof SharedArrayBuffer;
    }
};
function gs() {
    return ms.isAndroidOrIOSBrowser || !!is.get(as.EnforceWebRTCAudio);
}
const vs = ()=>ms.isIE, fs = ()=>{
    var e;
    return ms.isSupportOffscreenCanvas && (null === (e = navigator) || void 0 === e ? void 0 : e.hardwareConcurrency) >= 2 && "function" == typeof requestAnimationFrame && ms.isSupportSharedArrayBuffer;
}, ys = (e, t1)=>{
    var o;
    const { isSafari: r, isIOSMobile: i, isSupportMediaStreamTrackProcessor: n, isAndroidOrIOSBrowser: s, isArmChromeOS: a, isChromeOS: d, isArm: u, isSupportOffscreenCanvas: l, isIPad: c } = ms;
    if (!fs()) {
        const o = r || i, s = "function" != typeof window.SharedArrayBuffer && (!!o || n && l);
        return e && s ? t1 ? 25 : navigator.hardwareConcurrency < 4 ? 2 : 4 : 1;
    }
    return s ? t1 ? 25 : c ? 9 : 4 : a || d && !u ? navigator.hardwareConcurrency >= 4 ? 9 : 2 : (null === (o = navigator) || void 0 === o ? void 0 : o.hardwareConcurrency) < 4 ? 2 : 25;
};
function Ss() {
    var e;
    return "webkit" in window && !("chrome" in window) && !(null === (e = window.webkit.messageHandlers) || void 0 === e || !e.jsOCHelper);
}
function bs() {
    var e;
    const { isAndroidBrowser: t1, isIOSMobile: o, osVersion: r, browserVersion: i, isChrome: n, isFirefox: s, isSafari: a } = ms;
    var d, u;
    if (o) return Number(null === (d = r.match(/^\d+/)) || void 0 === d ? void 0 : d[0]) >= 15;
    if (t1) return Number(null === (u = r.match(/^\d+/)) || void 0 === u ? void 0 : u[0]) >= 10;
    const l = Number(null === (e = i.match(/^\d+/)) || void 0 === e ? void 0 : e[0]);
    return !!(n && l >= 69) || !!(a && l > 14) || !!(s && l >= 76);
}
let Es = function(e) {
    return e.VIDEO_ENCODE = "0", e.VIDEO_DECODE = "1", e.AUDIO_ENCODE = "2", e.AUDIO_DECODE = "3", e.SHARING_ENCODE = "4", e.SHARING_DECODE = "5", e;
}({}), Is = function(e) {
    return e[e.NONE = 0] = "NONE", e[e.AES_256 = 1] = "AES_256", e[e.AES_GCM = 2] = "AES_GCM", e;
}({});
const As = Object.freeze({
    RWG_CHAT: {
        gcmType: 1,
        sessionType: "RWG_CHAT"
    },
    XMPP_CHAT: {
        gcmType: 1,
        sessionType: "XMPP_CHAT"
    },
    CC_MESSAGE: {
        gcmType: 3,
        sessionType: "CC_MESSAGE"
    },
    BO_BROADCAST: {
        gcmType: 1,
        sessionType: "BO_BROADCAST"
    },
    CHAT_FILE: {
        gcmType: 2,
        sessionType: "CHAT_FILE"
    },
    CHAT_FILE_INFO: {
        gcmType: 1,
        sessionType: "CHAT_FILE_INFO"
    }
}), Cs = (window.crypto || window.msCrypto).subtle, _s = ns.WebclientIVState, Rs = Object.keys(As).map((e)=>As[e].sessionType);
class ws {
    constructor(e, t1, o){
        this.isGCMEnabled = void 0, this.gcmSessionKey = void 0, this.gcmMainSessionKey = void 0, this.zoomId = void 0, this.resetParameters(e, t1, o), is.set(_s, {}, os.SessionStorage);
    }
    static init(e, t1, o) {
        this.instance ? this.instance.resetParameters(e, t1, o) : this.instance = new ws(e, t1, o);
    }
    static destroy() {
        this.instance && (this.instance = void 0);
    }
    resetParameters(e, t1, o) {
        this.isGCMEnabled = !(ms.isIE || !ms.isSupportEssentialAudioAndVideoAbility) && o === Is.AES_GCM, this.gcmSessionKey = Kr(t1), this.gcmMainSessionKey || (this.gcmMainSessionKey = this.gcmSessionKey), this.zoomId = String(e);
    }
    beginCrypto(e, t1, o) {
        const r = new Uint32Array(1);
        r[0] = 9, r[0] += Number(o);
        const i = new Uint8Array(r.buffer);
        let n = new Uint8Array(132);
        const s = Kr(t1);
        return n.set(s, 0), n.set(i, s.length), n = n.subarray(0, s.length + 4), Cs.importKey("raw", e, {
            name: "HMAC",
            hash: "SHA-256"
        }, !0, [
            "sign"
        ]).then((e)=>Cs.sign({
                name: "HMAC"
            }, e, n)).then((e)=>Cs.importKey("raw", e, {
                name: "AES-GCM",
                length: 256
            }, !0, [
                "encrypt",
                "decrypt"
            ]));
    }
    getNextIV(e) {
        const t1 = is.get(_s);
        return void 0 === t1[e] ? (t1[e] = 0, is.set(_s, t1, os.SessionStorage)) : is.set(_s, (t1)=>({
                ...t1,
                [e]: t1[e] + 1
            }), os.SessionStorage);
    }
    resetIVState() {
        const e = is.get(_s);
        if (void 0 === e) ;
        else {
            const t1 = Object.keys(e).filter((e)=>Rs.indexOf(e) > -1);
            t1.length > 0 && (t1.forEach((t1)=>{
                e[t1] += 1e6;
            }), is.set(_s, e, os.SessionStorage));
        }
    }
    static resetIV() {
        if (void 0 === this.instance) throw new Error("reset before intialize");
        this.instance.resetIVState();
    }
    static beginEncrypt(e) {
        let { text: t1, type: o } = e;
        const r = new Uint8Array(0);
        if (this.instance && this.instance.isGCMEnabled) {
            const e = 16, i = 12, n = this.instance.getNextIV(o.sessionType), s = new ArrayBuffer(i), a = new Uint8Array(s);
            new DataView(s).setUint32(0, n, !0);
            let d = null;
            return d = "BO_BROADCAST" === o.sessionType || "XMPP_CHAT" === o.sessionType ? this.instance.gcmMainSessionKey : this.instance.gcmSessionKey, this.instance.beginCrypto(d, this.instance.zoomId, o.gcmType).then((o)=>{
                const i = ArrayBuffer.isView(t1) ? t1 : (new TextEncoder).encode(t1);
                return Cs.encrypt({
                    name: "AES-GCM",
                    iv: a,
                    additionalData: r,
                    tagLength: 8 * e
                }, o, i);
            }).then((t1)=>{
                const i = 1 + a.byteLength + 2 + r.byteLength + 4 + t1.byteLength, n = new ArrayBuffer(i);
                if (new Uint8Array(n)[0] = a.length, new Uint8Array(n, 1, a.byteLength).set(a), new DataView(n).setUint16(1 + a.byteLength, r.length, !0), new Uint8Array(n, 3 + a.byteLength).set(r), new DataView(n).setUint32(1 + a.byteLength + 2 + r.byteLength, t1.byteLength - e, !0), new Uint8Array(n, 1 + a.byteLength + 2 + r.byteLength + 4).set(new Uint8Array(t1)), o.sessionType === As.CHAT_FILE.sessionType) return n;
                const s = new Uint8Array(n).reduce((e, t1)=>e + String.fromCharCode(t1), "");
                return window.btoa(s).replace(/_/g, "/").replace(/-/g, "+").replace(/\=/g, "");
            });
        }
        return Promise.resolve(ArrayBuffer.isView(t1) ? t1 : Hr(t1));
    }
    static beginDecrypt(e) {
        let { decryptedText: t1, type: o, zoomId: r } = e;
        if (this.instance && this.instance.isGCMEnabled) {
            const e = ArrayBuffer.isView(t1) || t1 instanceof ArrayBuffer ? new Uint8Array(t1) : function(e) {
                let t1;
                const o = e.length, r = new Array(o);
                for(t1 = 0; t1 < o; ++t1)r[t1] = 255 & e.charCodeAt(t1);
                return new Uint8Array(r);
            }(atob(t1.replace(/_/g, "/").replace(/-/g, "+"))), i = e[0], n = e.slice(1, i + 1), s = e.slice(1 + i, 3 + i), a = new DataView(s.buffer).getUint16(0, !0), d = e.slice(1 + i + 2, 1 + i + 2 + a), u = e.slice(1 + i + 2 + a, 1 + i + 2 + a + 4), l = new DataView(u.buffer).getUint32(0, !0), c = e.slice(1 + i + 2 + a + 4, 1 + i + 2 + a + 4 + l), p = e.slice(1 + i + 2 + a + 4 + l);
            let h = null;
            return h = "BO_BROADCAST" === o.sessionType || "XMPP_CHAT" === o.sessionType ? this.instance.gcmMainSessionKey : this.instance.gcmSessionKey, this.instance.beginCrypto(h, r, o.gcmType).then((e)=>{
                const t1 = function(e, t1) {
                    e = new Uint8Array(e), t1 = new Uint8Array(t1);
                    const o = new Uint8Array(e.length + t1.length);
                    return o.set(e), o.set(t1, e.length), o;
                }(c, p);
                return Cs.decrypt({
                    name: "AES-GCM",
                    iv: n,
                    additionalData: d,
                    tagLength: 8 * p.length
                }, e, t1.buffer);
            }).then((e)=>({
                    message: o.sessionType === As.CHAT_FILE.sessionType ? e : (new TextDecoder).decode(e),
                    iv: n,
                    aad: d
                })).catch((e)=>({
                    message: "[This is an encrypted message]",
                    iv: n,
                    aad: d
                }));
        }
        {
            const e = new TextDecoder("utf-8");
            return Promise.resolve({
                message: ArrayBuffer.isView(t1) || t1 instanceof ArrayBuffer ? t1 : e.decode(Kr(t1))
            });
        }
    }
}
ws.instance = void 0;
const Ts = 20225, Os = 20234, Ds = 7937, Ps = 7938, Ms = 12039, ks = 16138, Ls = 4098, Ns = 4305, Vs = 4343, Us = 16428;
let js = function(e) {
    return e[e.NoAttendee = 0] = "NoAttendee", e[e.All = 1] = "All", e[e.AllPanelist = 2] = "AllPanelist", e[e.Host = 3] = "Host", e[e.NoOne = 4] = "NoOne", e[e.EveryonePublicly = 5] = "EveryonePublicly", e;
}({}), xs = function(e) {
    return e[e.AllPanelist = 1] = "AllPanelist", e[e.Everyone = 2] = "Everyone", e[e.Invalid = 0] = "Invalid", e;
}({}), Bs = function(e) {
    return e[e.All = 0] = "All", e[e.Panelist = 1] = "Panelist", e[e.IndividualCcPanelist = 2] = "IndividualCcPanelist", e[e.Individual = 3] = "Individual", e[e.SilentModeUsers = 4] = "SilentModeUsers", e;
}({}), Fs = function(e) {
    return e[e.None = 0] = "None", e[e.Delete = 1] = "Delete", e[e.Modify = 2] = "Modify", e;
}({}), Hs = function(e) {
    return e[e.Success = 0] = "Success", e[e.Delete = 1] = "Delete", e[e.Block = 3] = "Block", e;
}({});
const $s = [
    js.All,
    js.Host,
    js.NoOne,
    js.EveryonePublicly
], Ws = [
    js.NoOne,
    js.All,
    js.AllPanelist
], Gs = {
    AllPanelist: 11,
    Everyone: 12
}, Ks = {
    [Gs.AllPanelist]: xs.AllPanelist,
    [Gs.Everyone]: xs.Everyone
}, zs = {
    userId: Bs.All,
    displayName: "Everyone",
    isHost: !1,
    isCoHost: !1
}, qs = {
    userId: Bs.Panelist,
    displayName: "All panelists"
}, Js = {
    userId: Bs.SilentModeUsers,
    displayName: "Everyone (in Waiting Room)",
    isHost: !1,
    isCoHost: !1
};
let Qs = function(e) {
    return e[e.Local = 0] = "Local", e[e.ThirdParty = 1] = "ThirdParty", e;
}({}), Zs = function(e) {
    return e[e.ChunkSize = 20971520] = "ChunkSize", e[e.EncodeBlockSize = 32768] = "EncodeBlockSize", e[e.DecodeBlockSize = 32803] = "DecodeBlockSize", e[e.MaxSize = 2147483648] = "MaxSize", e[e.ReaderChunkSize = 1073741824] = "ReaderChunkSize", e;
}({}), Ys = function(e) {
    return e[e.Init = 0] = "Init", e[e.InProgress = 1] = "InProgress", e[e.Success = 2] = "Success", e[e.Fail = 3] = "Fail", e[e.Cancel = 4] = "Cancel", e[e.Complete = 5] = "Complete", e;
}({}), Xs = function(e) {
    return e[e.InProgress = 1] = "InProgress", e[e.Success = 2] = "Success", e[e.Fail = 3] = "Fail", e[e.Cancel = 4] = "Cancel", e;
}({});
const ea = {
    "7z": "application/x-7z-compressed",
    avi: "video/x-msvideo",
    bin: "application/octet-stream",
    bmp: "image/bmp",
    css: "text/css",
    csv: "text/csv",
    doc: "application/msword",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    gif: "image/gif",
    gz: "application/gzip",
    html: "text/html",
    ics: "text/calendar",
    jar: "application/java-archive",
    jpeg: "image/jpeg",
    jpg: "image/jpeg",
    js: "text/javascript",
    json: "application/json",
    mid: "audio/midi",
    mov: "video/*",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    mpeg: "video/*",
    mpg: "video/*",
    pdf: "application/pdf",
    png: "image/png",
    ppt: "application/vnd.ms-powerpoint",
    pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    rar: "application/vnd.rar",
    rtf: "application/rtf",
    tar: "application/x-tar",
    tif: "image/tiff",
    tiff: "image/tiff",
    txt: "text/plain",
    wav: "audio/wav",
    webp: "image/webp",
    wma: "audio/*",
    wmv: "video/*",
    xls: "application/vnd.ms-excel",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    xml: "application/xml",
    zip: "application/zip"
};
let ta = function(e) {
    return e.Open = "open", e.Message = "message", e.Error = "error", e.Close = "close", e.Inactive = "inactive", e;
}({});
class oa {
    constructor(){
        this.eventHandlers = void 0, this.websocket = void 0, this.seq = void 0, this.intervalsToBeCleardWhenSocketClose = [], this.isAlive = !1, this.isRlbTP = void 0, this.eventHandlers = new Map, this.websocket = null, this.seq = 1, this.isRlbTP = !1;
    }
    on(e, t1) {
        let o = this.eventHandlers.get(e);
        o || (o = []), o.push(t1), this.eventHandlers.set(e, o);
    }
    off(e, t1) {
        const o = this.eventHandlers.get(e);
        if (o) {
            const r = o.filter((e)=>e !== t1);
            this.eventHandlers.set(e, r);
        }
    }
    emit(e, t1) {
        const o = this.eventHandlers.get(e);
        o && o instanceof Array && o.slice(0).forEach((e)=>{
            try {
                e(t1);
            } catch (e) {
                console.error(e);
            }
        });
    }
    sendMessageToRwg(e) {
        this.seq += 1;
        const t1 = this.seq;
        return this.websocket && this.websocket.readyState === WebSocket.OPEN && this.websocket.send(JSON.stringify(Object.assign(e, {
            seq: t1
        }))), t1;
    }
    connect(e, t1) {
        this.websocket = t1 ? new window.ZoomTPModule.ZoomTPWebSocket(e) : new WebSocket(e), this.websocket.binaryType = "arraybuffer", this.isRlbTP = t1, this.addWebSocketEventListeners();
    }
    close() {
        var e;
        null === (e = this.websocket) || void 0 === e || e.close();
    }
    addHeartBeat() {
        const e = ms.isAndroidOrIOSBrowser ? 15e3 : 2e4, t1 = setInterval(()=>{
            this.isAlive || this.emit(ta.Inactive, {}), this.sendMessageToRwg({
                evt: 0
            }), this.isAlive = !1;
        }, e);
        this.intervalsToBeCleardWhenSocketClose.push(t1);
    }
    clearIntervals() {
        this.intervalsToBeCleardWhenSocketClose.forEach((e)=>clearInterval(e)), this.isAlive = !1;
    }
    addWebSocketEventListeners() {
        this.websocket && (this.websocket.addEventListener("open", (e)=>{
            this.isRlbTP || this.addHeartBeat(), this.emit(ta.Open, e);
        }), this.websocket.addEventListener("message", (e)=>{
            this.isAlive = !0, this.emit(ta.Message, e);
        }), this.websocket.addEventListener("close", (e)=>{
            this.clearIntervals(), this.emit(ta.Close, e);
        }), this.websocket.addEventListener("error", (e)=>{
            this.clearIntervals(), this.emit(ta.Error, e);
        }));
    }
    sendLaunchParams(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4301,
                body: e
            })
        };
    }
    joinMeeting(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4097,
                body: {
                    meetingtoken: e
                }
            })
        };
    }
    lockMeeting(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4099,
                body: {
                    bLock: e
                }
            })
        };
    }
    endMeeting() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4101,
                body: {}
            })
        };
    }
    leaveMeeting() {
        const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? 4364 : 4103;
        return {
            seq: this.sendMessageToRwg({
                evt: e,
                body: {}
            })
        };
    }
    recordMeeting(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4105,
                body: {
                    bRecord: e,
                    bPause: t1
                }
            })
        };
    }
    localRecordingGrantPermission(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: Vs,
                body: {
                    cmdType: "permission_request_answer",
                    userId: e,
                    agreed: t1,
                    saveAgreed: o
                }
            })
        };
    }
    hostGrantPermission(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: Vs,
                body: {
                    cmdType: "grant_permission",
                    userId: e,
                    grant: t1
                }
            })
        };
    }
    localRecordingRequestPermission() {
        return {
            seq: this.sendMessageToRwg({
                evt: Vs,
                body: {
                    cmdType: "request_permission"
                }
            })
        };
    }
    localRecordingMeeting(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: Vs,
                body: {
                    cmdType: "change_recording_status",
                    status: e
                }
            })
        };
    }
    summaryMeeting(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8009,
                body: {
                    type: e ? "start" : "stop"
                }
            })
        };
    }
    startMeetingQuery(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8017,
                body: {
                    type: e ? "start" : "stop"
                }
            })
        };
    }
    allowSelfRecord(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4325,
                body: {
                    bAllowISORecord: e
                }
            })
        };
    }
    enableZoomIQRecord(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4318,
                body: {
                    check: e
                }
            })
        };
    }
    expel(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4107,
                body: {
                    id: e
                }
            })
        };
    }
    expelAttendee(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4205,
                body: {
                    jid: e
                }
            })
        };
    }
    rename(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4109,
                body: {
                    id: e,
                    dn2: t1,
                    olddn2: o
                }
            })
        };
    }
    assignHost(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4111,
                body: {
                    id: e,
                    bCoHost: t1
                }
            })
        };
    }
    reclaimHost(e) {
        let t1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return {
            seq: this.sendMessageToRwg({
                evt: 4133,
                body: {
                    id: e,
                    bCoHost: t1
                }
            })
        };
    }
    revokeCoHost(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4195,
                body: {
                    id: e
                }
            })
        };
    }
    putOnHold(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4113,
                body: {
                    id: e,
                    bHold: t1
                }
            })
        };
    }
    setMuteOnEntry(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4115,
                body: {
                    bOn: e
                }
            })
        };
    }
    setHoldOnEntry(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4117,
                body: {
                    bOn: e
                }
            })
        };
    }
    inviteCRCDevice(e, t1) {
        let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
        return {
            seq: this.sendMessageToRwg({
                evt: 4119,
                body: {
                    ip: e,
                    type: t1,
                    encrypt: o
                }
            })
        };
    }
    cancelInviteCRCDevice(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4121,
                body: {
                    transID: e
                }
            })
        };
    }
    sendCloseCaption(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4125,
                body: {
                    ...e
                }
            })
        };
    }
    allowViewParticipantNumber(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4127,
                body: {
                    bOn: e
                }
            })
        };
    }
    lowerAllHands() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4129,
                body: {}
            })
        };
    }
    raiseLowerHand(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4131,
                body: {
                    id: e,
                    bOn: t1
                }
            })
        };
    }
    chat(e, t1, o, r) {
        const i = {
            text: e,
            destNodeID: t1
        };
        return o && Object.assign(i, {
            sn: o
        }), r && Object.assign(i, {
            attendeeNodeID: r
        }), {
            seq: this.sendMessageToRwg({
                evt: 4135,
                body: i
            })
        };
    }
    assignCC(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4137,
                body: {
                    id: e,
                    bCCEditor: t1
                }
            })
        };
    }
    enableLT(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4227,
                body: {
                    op: e ? 2 : 4
                }
            })
        };
    }
    enableNewLLT() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4285
            })
        };
    }
    disableCaptions(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: Ns,
                body: {
                    type: 4,
                    disableNewLtt: e
                }
            })
        };
    }
    enableManualCaption(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4291,
                body: {
                    op: e ? 1 : 0
                }
            })
        };
    }
    setTranslationLanguage(e) {
        return void 0 !== e ? {
            seq: this.sendMessageToRwg({
                evt: Ns,
                body: {
                    type: 1,
                    lang: e
                }
            })
        } : {
            seq: this.sendMessageToRwg({
                evt: Ns,
                body: {
                    type: 3
                }
            })
        };
    }
    setSpokenLanguage(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4287,
                body: {
                    lang: e
                }
            })
        };
    }
    allowAskLT(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4263,
                body: {
                    bAnonymous: e
                }
            })
        };
    }
    approveLT() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4262,
                body: {
                    bApproved: !0
                }
            })
        };
    }
    askLT(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4261,
                body: {
                    bAnonymous: e
                }
            })
        };
    }
    setChatPriviledge(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4141,
                body: {
                    chatPriviledge: e
                }
            })
        };
    }
    setPanelistChatPrivilege(e) {
        if (!Object.values(Gs).includes(e)) throw Error("Invalid panelist chat privilege req value");
        return {
            seq: this.sendMessageToRwg({
                evt: 4141,
                body: {
                    chatPriviledge: e
                }
            })
        };
    }
    sendFeedback(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4143,
                body: {
                    feedback: e
                }
            })
        };
    }
    clearFeedback() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4145,
                body: {}
            })
        };
    }
    allowUnmuteVideo(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4147,
                body: {
                    bOn: e
                }
            })
        };
    }
    allowUnmuteAudio(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4149,
                body: {
                    bOn: e
                }
            })
        };
    }
    allowRaiseHand(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4151,
                body: {
                    bOn: e
                }
            })
        };
    }
    boToken(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4173,
                body: {
                    topic: e
                }
            })
        };
    }
    startBO(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4175,
                body: {
                    proto: e
                }
            })
        };
    }
    stopBO(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4177,
                body: {
                    status: e
                }
            })
        };
    }
    assignToBO(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4179,
                body: {
                    targetID: e,
                    targetBID: t1
                }
            })
        };
    }
    switchBO(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4181,
                body: {
                    targetID: e,
                    targetBID: t1
                }
            })
        };
    }
    wantJoinBO(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4183,
                body: {
                    targetID: e,
                    targetBID: t1
                }
            })
        };
    }
    joinBO(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4193,
                body: {
                    targetBID: e
                }
            })
        };
    }
    leaveBO() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        return {
            seq: this.sendMessageToRwg({
                evt: 4185,
                body: {
                    reason: e
                }
            })
        };
    }
    broadcastBO(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4187,
                body: {
                    textContent: e
                }
            })
        };
    }
    askForHelpBO(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4189,
                body: {
                    targetID: e
                }
            })
        };
    }
    askForHelpResultBO(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4191,
                body: {
                    targetID: e,
                    helpResult: t1
                }
            })
        };
    }
    coHostStartBO(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4241,
                body: {
                    proto: e,
                    targetID: t1
                }
            })
        };
    }
    coHostStopBO(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4243,
                body: {
                    status: e,
                    targetID: t1
                }
            })
        };
    }
    coHostAssignToBO(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4245,
                body: {
                    userGUID: e,
                    targetID: o,
                    targetBID: t1
                }
            })
        };
    }
    moveToMainSession(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4247,
                body: {
                    userGUID: e
                }
            })
        };
    }
    coHostMoveToMainSession(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4249,
                body: {
                    userGUID: e,
                    targetID: t1
                }
            })
        };
    }
    allowParticipantRename(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4163,
                body: {
                    bOn: e
                }
            })
        };
    }
    allowMessageFeedbackNotify(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4171,
                body: {
                    bOn: e,
                    id: t1
                }
            })
        };
    }
    setPlayChime(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4197,
                body: {
                    bOn: e,
                    id: t1
                }
            })
        };
    }
    admitAllSilentUsers() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4199,
                body: {}
            })
        };
    }
    bindTeleUser(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4201,
                body: {
                    teleUserID: e,
                    targetUserID: t1,
                    bBind: o
                }
            })
        };
    }
    practiceSession() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4207,
                body: null
            })
        };
    }
    roleChangeWebinar(e, t1, o, r) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4209,
                body: {
                    jid: t1,
                    userID: o,
                    clientCap: r,
                    bPromote: e
                }
            })
        };
    }
    sendPromoteConsent(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4254,
                body: {
                    agreed: e,
                    req_id: t1
                }
            })
        };
    }
    batchCreateBOToken(e) {
        const t1 = e.map((e, t1)=>({
                topic: e,
                index: t1
            }));
        return {
            seq: this.sendMessageToRwg({
                evt: 4211,
                body: t1
            })
        };
    }
    mute(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8193,
                body: {
                    bMute: t1,
                    id: e
                }
            })
        };
    }
    audioDrop(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8195,
                body: {
                    id: e
                }
            })
        };
    }
    audioDialout(e, t1, o, r, i) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8197,
                body: {
                    pn: e,
                    dn2: Hr(t1),
                    bCallme: o,
                    bPressOne: r,
                    bGreeting: i
                }
            })
        };
    }
    audioCancelDialout(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8199,
                body: {
                    pn: e,
                    bCallme: t1
                }
            })
        };
    }
    audioMuteAll(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8201,
                body: {
                    bMute: e
                }
            })
        };
    }
    allowToTalk(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8204,
                body: {
                    id: e,
                    bAllowTalk: t1
                }
            })
        };
    }
    subscribeVideo() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t1 = arguments.length > 1 ? arguments[1] : void 0, o = arguments.length > 2 ? arguments[2] : void 0;
        return {
            seq: this.sendMessageToRwg({
                evt: 12289,
                body: {
                    id: e,
                    size: t1,
                    bOn: o
                }
            })
        };
    }
    unsubscribeVideo() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        return {
            seq: this.sendMessageToRwg({
                evt: 12291,
                body: {
                    id: e
                }
            })
        };
    }
    muteAttendeeVideo(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 12297,
                body: {
                    id: e,
                    bOn: t1
                }
            })
        };
    }
    notifyRwgIsMuteVideo(e, t1) {
        return this.muteAttendeeVideo(e, t1);
    }
    pauseSharing() {
        return {
            seq: this.sendMessageToRwg({
                evt: 16385,
                body: {}
            })
        };
    }
    resumeSharing() {
        return {
            seq: this.sendMessageToRwg({
                evt: 16387,
                body: {}
            })
        };
    }
    allowAnonymousQuestion(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4155,
                body: {
                    userId: e,
                    bOn: t1
                }
            })
        };
    }
    allowViewAll(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4157,
                body: {
                    userId: e,
                    bOn: t1
                }
            })
        };
    }
    allowVote(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4159,
                body: {
                    userId: e,
                    bOn: t1
                }
            })
        };
    }
    allowComment(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4161,
                body: {
                    userId: e,
                    bOn: t1
                }
            })
        };
    }
    sharingRequestRemoteControl(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16389,
                body: {
                    id: e,
                    bOn: t1
                }
            })
        };
    }
    subscribeGrabRemoteControl(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16393,
                body: {
                    id: e,
                    bOn: t1
                }
            })
        };
    }
    subscribeSharing(e, t1, o, r) {
        const i = {
            id: e,
            size: t1
        };
        return o && Object.assign(i, {
            bShareToBO: !0
        }), void 0 !== r && Object.assign(i, {
            bVideoShare: r
        }), {
            seq: this.sendMessageToRwg({
                evt: 16415,
                body: i
            })
        };
    }
    unsubscribeSharing(e, t1) {
        const o = {
            id: e
        };
        return t1 && Object.assign(o, {
            bShareToBO: !0
        }), {
            seq: this.sendMessageToRwg({
                evt: 16417,
                body: o
            })
        };
    }
    sendRWGConnectionPerformance(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4167,
                body: {
                    data: e
                }
            })
        };
    }
    sendSdkKeyToMonitor(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4167,
                body: {
                    data: `ZoomConferenceClient,videoapp_HTML5_sdk_web_join,${o},2,${t1},${e}`
                }
            })
        };
    }
    sendDatachannelOffer(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 24321,
                offer: e
            })
        };
    }
    joinOrLeaveVoip(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8203,
                body: {
                    bOn: e
                }
            })
        };
    }
    startSharing(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16409,
                body: {
                    id: e,
                    boOn: !1,
                    ...null != t1 ? t1 : {}
                }
            })
        };
    }
    stopSharing(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16409,
                body: {
                    id: e,
                    bOn: !0
                }
            })
        };
    }
    lockSharing(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4169,
                body: {
                    lockShare: e
                }
            })
        };
    }
    startShareToBreakoutRoom(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16425,
                body: {
                    id: e,
                    bShareToBO: !0
                }
            })
        };
    }
    stopShareToBreakoutRoom(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16425,
                body: {
                    id: e,
                    bShareToBO: !1
                }
            })
        };
    }
    preAssignBreakoutRoom() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4213,
                body: {}
            })
        };
    }
    claimHost(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4215,
                body: {
                    hostKey: e
                }
            })
        };
    }
    allowMultiplePin(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4217,
                body: {
                    userID: e,
                    bOn: t1
                }
            })
        };
    }
    spotlightVideo(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4219,
                body: {
                    id: e,
                    ...t1
                }
            })
        };
    }
    connectCamera(e, t1) {
        const o = {
            evt: 12307,
            body: {
                id: e,
                bOn: t1
            }
        };
        return {
            seq: this.sendMessageToRwg(o)
        };
    }
    followHostLayout(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4223,
                body: {
                    bFollowHostVideo: e
                }
            })
        };
    }
    setVideoDragLayout(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4218,
                body: {
                    drag_list: e
                }
            })
        };
    }
    chatCmdReq(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4237,
                body: {
                    msgID: e,
                    cmd: t1
                }
            })
        };
    }
    activeAppLinkReq(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4257,
                body: {
                    appId: e
                }
            })
        };
    }
    activeAppInfoReq() {
        return {
            seq: this.sendMessageToRwg({
                evt: 4255,
                body: {}
            })
        };
    }
    muteShareAudio(e, t1) {
        const o = {
            bOn: !0,
            bShareAudio: !e
        };
        return t1 && Object.assign(o, {
            bShareAudioOnly: !0
        }), {
            seq: this.sendMessageToRwg({
                evt: 16423,
                body: o
            })
        };
    }
    localMuteAudio(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 8209,
                body: {
                    id: e,
                    bMute: t1
                }
            })
        };
    }
    changeSharePronoun(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4264,
                body: {
                    bPronoun: e,
                    strPronoun: t1
                }
            })
        };
    }
    sendReceivingSharingReady(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16421,
                body: {
                    ssrc: e
                }
            })
        };
    }
    sendManualCaption(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4289,
                body: {
                    ...e
                }
            })
        };
    }
    sendPollingAction(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4224,
                body: {
                    action: e,
                    PollingId: t1,
                    ...o
                }
            })
        };
    }
    broadcastUserNetworkQuality(e) {
        const t1 = {
            type: e.isUplink,
            level: e.level,
            bwLevel: e.bwLevel
        };
        return {
            seq: this.sendMessageToRwg({
                evt: 4331,
                body: t1
            })
        };
    }
    sendFarEndCameraControl(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4329,
                body: {
                    cmd: e,
                    userID: t1,
                    buttonID: o
                }
            })
        };
    }
    sendCameraAblity(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4330,
                body: {
                    ...e,
                    focus: !1
                }
            })
        };
    }
    sendReaction(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4259,
                body: {
                    ...e
                }
            })
        };
    }
    remoteControlConsent(e, t1, o, r) {
        let i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = arguments.length > 5 ? arguments[5] : void 0;
        const { deviceId: s, ...a } = r, d = void 0 !== n ? {
            runAsAdmin: n
        } : {};
        return {
            seq: this.sendMessageToRwg({
                evt: 16427,
                body: {
                    DeviceID: s,
                    op: e,
                    SendUserID: o,
                    AssignUserID: t1,
                    ...a,
                    bAutoDelete: i,
                    ...d
                }
            })
        };
    }
    takeBackRemoteControlPermission(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16431,
                body: {
                    SendUserID: e,
                    ReceiverUserID: t1
                }
            })
        };
    }
    syncSharedContentMetaWithRcApp(e) {
        const { deviceId: t1, ...o } = e;
        return {
            seq: this.sendMessageToRwg({
                evt: 16429,
                body: {
                    DeviceID: t1,
                    ...o
                }
            })
        };
    }
    startLiveStream(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 7977,
                body: {
                    action: 1,
                    streamingURL: e,
                    streamingKey: t1,
                    broadcastURL: o
                }
            })
        };
    }
    stopLiveStream() {
        return {
            seq: this.sendMessageToRwg({
                evt: 7977,
                body: {
                    action: 0
                }
            })
        };
    }
    sendRemoteControlAuth(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 16433,
                body: {
                    auth: e
                }
            })
        };
    }
    chatFileTransfer(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4307,
                body: {
                    ...e,
                    fileType: 0,
                    receiverType: 0
                }
            })
        };
    }
    broadcastVoiceReq(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 4314,
                body: {
                    broadcastVoice: e
                }
            })
        };
    }
}
class ra extends oa {
    static createAgent() {
        return this.rwgInstance || (this.rwgInstance = new ra), this.rwgInstance;
    }
}
ra.rwgInstance = null;
class ia extends oa {
    static getInstance() {
        return this.instance || (this.instance = new ia), this.instance;
    }
}
ia.instance = null;
const na = [
    {
        name: "audio_simd.min.js",
        category: "audio",
        type: "worker",
        tag: "simd",
        alias: "audioSIMDWorkletPath"
    },
    {
        name: "audio.simd.wasm",
        category: "audio",
        type: "wasm",
        tag: "simd",
        alias: "audioSIMDWasm"
    },
    {
        name: "js_audio_process.min.js",
        category: "audio",
        type: "worker",
        tag: "",
        alias: "audioWorkerPath"
    },
    {
        name: "audio.encode.wasm",
        category: "audio",
        type: "wasm",
        tag: "",
        alias: "audioWasm"
    },
    {
        name: "js_audio_worklet.min.js",
        category: "audio",
        type: "worklet",
        tag: "",
        alias: "audioWorkletPath"
    },
    {
        name: "js_audio_worklet_simd.min.js",
        category: "audio",
        type: "worklet",
        tag: "simd",
        alias: "audioWorkletSIMDPath"
    },
    {
        name: "js_audio_worklet_process.min.js",
        category: "audio",
        type: "worklet",
        tag: "",
        alias: "audioWorkletProcessPath"
    },
    {
        name: "js_sharing_audio_worklet.min.js",
        category: "audio",
        type: "worklet",
        tag: "",
        alias: "sharingAudioWorkletPath"
    },
    {
        name: "js_audio_level_worklet_process.min.js",
        category: "audio",
        type: "worklet",
        tag: "",
        alias: "audioLevelWorkletPath"
    },
    {
        name: "video_mtsimd.min.js",
        category: "video",
        type: "worker",
        tag: "simd,thread",
        alias: "videoMSIMDWorkerPath"
    },
    {
        name: "video.mtsimd.wasm",
        category: "video",
        type: "wasm",
        tag: "simd,thread,videoShare",
        alias: "videoMSIMDWasm"
    },
    {
        name: "video_m.min.js",
        category: "video",
        type: "worker",
        tag: "thread",
        alias: "videoMtWorkerPath"
    },
    {
        name: "video.mt.wasm",
        category: "video",
        type: "wasm",
        tag: "thread",
        alias: "videoMtWasm"
    },
    {
        name: "video_simd.min.js",
        category: "video",
        type: "worker",
        tag: "simd",
        alias: "videoSIMDWorkerPath"
    },
    {
        name: "video.simd.wasm",
        category: "video",
        type: "wasm",
        tag: "simd",
        alias: "videoSIMDWasm"
    },
    {
        name: "video_s.min.js",
        category: "video",
        type: "worker",
        tag: "",
        alias: "videoWorkerPath"
    },
    {
        name: "video.decode.wasm",
        category: "video",
        type: "wasm",
        tag: "",
        alias: "videoWasm"
    },
    {
        name: "video_share_mtsimd.min.js",
        category: "video",
        type: "worker",
        tag: "videoShare",
        alias: "vsmiworkerpath"
    },
    {
        name: "sharing_mtsimd.min.js",
        category: "sharing",
        type: "worker",
        tag: "simd,thread",
        alias: "sharingMSIMDWorkerPath"
    },
    {
        name: "sharing_m.min.js",
        category: "sharing",
        type: "worker",
        tag: "thread",
        alias: "sharingMtWorkerPath"
    },
    {
        name: "sharing_simd.min.js",
        category: "sharing",
        type: "worker",
        tag: "simd",
        alias: "sharingSIMDWorkerPath"
    },
    {
        name: "sharing_s.min.js",
        category: "sharing",
        type: "worker",
        tag: "",
        alias: "sharingWorkerPath"
    }
], sa = "1501", aa = (e, t1)=>na.reduce((o, r)=>{
        const { name: i, alias: n } = r;
        return Object.assign(o, {
            [`${n}`]: `${e}/${t1 && sa ? `${sa}_` : ""}${i}`
        }), o;
    }, {});
let da = function(e) {
    return e.VideoEncode = "0", e.VideoDecode = "1", e.AudioEncode = "2", e.AudioDecode = "3", e.SharingEncode = "4", e.SharingDecode = "5", e;
}({});
const ua = ns.WebclientIVState;
class la {
    static getInstance() {
        return void 0 === this.agentInstance && (this.agentInstance = new la), this.agentInstance;
    }
    constructor(){
        this.assetsPath = void 0, this.instance = void 0, this.callbackList = void 0, this.mediaWorkersPath = void 0, this.constraints = void 0, this.svcUrl = void 0, this.meetingNumber = void 0, this.confId = void 0, this.mediaSocketAddress = void 0, this.currentUserId = void 0, this.receivedSharingCanvas = void 0, this.sharingCanvas = void 0, this.mediaOptions = void 0, this.inProgress = void 0, this.callbackList = [];
    }
    init(e) {
        if (!this.instance && window.JsMediaSDK_Instance) {
            const t1 = {
                ivObj: {
                    [Es.AUDIO_ENCODE]: is.get(ua) && is.get(ua)[Es.AUDIO_ENCODE],
                    [Es.VIDEO_ENCODE]: is.get(ua) && is.get(ua)[Es.VIDEO_ENCODE],
                    [Es.SHARING_ENCODE]: is.get(ua) && is.get(ua)[Es.SHARING_ENCODE]
                },
                globalTracingLogger: e
            };
            this.instance = new window.JsMediaSDK_Instance(t1), this.instance.setRWGAgent(ra.createAgent());
        }
    }
    setAssetsAndConstraint(e, t1, o, r) {
        var i;
        this.assetsPath = e, this.constraints = t1, this.mediaWorkersPath = aa(this.assetsPath, !!o), this.onMediaSDKCallback = this.onMediaSDKCallback.bind(this), this.mediaOptions = r, null === (i = this.instance) || void 0 === i || i.JsMediaSDK_PreLoad(this.mediaWorkersPath, this.onMediaSDKCallback, r);
    }
    onMediaSDKCallback(e, t1) {
        this.callbackList.length > 0 && this.callbackList.forEach((o)=>o(e, t1));
    }
    registerCallback(e) {
        this.callbackList.push(e);
    }
    unregisterCallback(e) {
        this.callbackList = this.callbackList.filter((t1)=>t1 !== e);
    }
    static isSupportVideoEncodeHardwareAcceleration() {
        return window.JsMediaSDK_Instance.util.IsSupportVideoEncodeHardwareAcceleration();
    }
    static isSupportVideoDecodeHardwareAcceleration() {
        return window.JsMediaSDK_Instance.util.IsSupportVideoDecodeHardwareAcceleration();
    }
    static isCompatibleHardwareForEncode() {
        var e;
        return ms.isSupportOffscreenCanvas && 0 == (null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.AdapterWhiteListCheckForEncoder());
    }
    static getPTZCapability() {
        var e, t1, o, r, i, n;
        return {
            pan: !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || null === (t1 = e.isSupportCameraPan) || void 0 === t1 || !t1.call(e)),
            tilt: !(null === (o = window.JsMediaSDK_Instance) || void 0 === o || null === (o = o.util) || void 0 === o || null === (r = o.isSupportCameraTilt) || void 0 === r || !r.call(o)),
            zoom: !(null === (i = window.JsMediaSDK_Instance) || void 0 === i || null === (i = i.util) || void 0 === i || null === (n = i.isSupportCameraZoom) || void 0 === n || !n.call(i))
        };
    }
    static isSupportVideoShare() {
        var e, t1;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || null === (t1 = e.isSupportVideoShareReceive) || void 0 === t1 || !t1.call(e));
    }
    static isSupportVideoShareSend() {
        var e, t1;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || null === (t1 = e.isSupportVideoShareSend) || void 0 === t1 || !t1.call(e));
    }
    static isSupportSending720P() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || !e.get720pcapacity());
    }
    static isSupportSubscribing1080P() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || !e.getsub1080pcapacity());
    }
    static isSupportOpenMicWhenShareAudio() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportOpenMicWhenShareAudio());
    }
    static isSupportMediaPlaybackAsVideoInput() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util.videoToMediaStreamManager) || void 0 === e || !e.isSupported());
    }
    static isSupportMediaPlaybackAsAudioInput() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util.audioToMediaStreamMananger) || void 0 === e || !e.isSupported());
    }
    static isSupportAudioDenoise(e) {
        var t1;
        return !(null === (t1 = window.JsMediaSDK_Instance) || void 0 === t1 || !t1.util.isSupportAudioDenoise(e));
    }
    static isSupportAudioBridgeAVSync() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportAudioBridgeAvsync());
    }
    static getAudioFeatureFlag() {
        var e;
        return null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.getAudioFeatureFlags();
    }
    static isSupportShareMultiStream() {
        var e;
        return null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.isSupportShareMultiStream();
    }
    static isSupportVideoLTR() {
        var e;
        return null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.isSupportVideoLTR();
    }
    static isSupportStereoAudio() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isBrowserSupportStereo());
    }
    static isSupportFullHDVideo() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportSendVideoFullHD());
    }
    static isSupportFullHDVideoShare() {
        var e;
        return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportSendVideoShareFullHD());
    }
    static isSupportShare2ndAudioDevice(e) {
        var t1;
        return !(null === (t1 = window.JsMediaSDK_Instance) || void 0 === t1 || !t1.util.isSupportShare2ndAudioDevice(e));
    }
    connect(e) {
        var t1, o, r, i, n, s;
        let { svcUrl: a, meetingNumber: d, conId: u, e2eEncrypt: l, isViewOnly: c, currentUserId: p, isWebinar: h, enableAudioQos: m, enableVideoQos: g = !1, enableWebtransport: v = !1, webtransportPort: f, rendererType: y, adaptedABOptionForMediaSDK: S, mediasdkConfig: b } = e;
        const { isSupportEssentialAudioAndVideoAbility: E, isSupportAudioWorklet: I, isSupportSendScreenSharing: A } = ms;
        this.svcUrl = a, this.meetingNumber = d, this.confId = u;
        const C = ((e, t1, o)=>({
                videoSocketAddress: `wss://${e}/wc/media/${t1}?type=v&cid=${o}`,
                audioSocketAddress: `wss://${e}/wc/media/${t1}?type=a&cid=${o}`,
                sharingSocketAddress: `wss://${e}/wc/media/${t1}?type=${vs() ? "j" : "s"}&cid=${o}`
            }))(a, d, u);
        this.mediaSocketAddress = C, this.currentUserId = p;
        const _ = ys(null === (t1 = this.mediaOptions) || void 0 === t1 ? void 0 : t1.enableMultiDecodeVideoWithoutSAB);
        var R, w, T, O, D, P, M, k, L;
        (null === (o = this.instance) || void 0 === o || o.setPropsBeforeInit({
            callback: this.onMediaSDKCallback,
            audioWorkerPath: E ? null === (r = this.mediaWorkersPath) || void 0 === r ? void 0 : r.audioWorkletPath : void 0,
            e2eEncrypt: l,
            isEnableListenInitEvent: !0,
            enableWebtransport: v,
            webtransportPort: f,
            featureOptions: S,
            rendererType: y,
            mediasdkConfig: b
        }), !0 === (null === (i = this.constraints) || void 0 === i ? void 0 : i.audio) && E && !gs()) && ((h || I) && (null === (R = this.instance) || void 0 === R || R.initAudioDecode(this.mediaWorkersPath, C.audioSocketAddress, p, kt, u, d, _, m)), !I || h && c || null === (w = this.instance) || void 0 === w || w.initAudioEncode(this.mediaWorkersPath, C.audioSocketAddress, p, kt, u, d, _, m));
        !0 === (null === (n = this.constraints) || void 0 === n ? void 0 : n.video) && E && (null === (T = this.instance) || void 0 === T || T.initVideoDecode(this.mediaWorkersPath, C.videoSocketAddress, p, kt, u, d, _, null === (O = null === (D = window.JsMediaSDK_Instance) || void 0 === D || null === (D = D.util) || void 0 === D ? void 0 : D.isGraphicShouldUseHardwareAccelerationDecode()) || void 0 === O || O, g), h && c || null === (P = this.instance) || void 0 === P || P.initVideoEncode(this.mediaWorkersPath, C.videoSocketAddress, p, kt, u, d, _, !1, g, !0, !0)), !0 === (null === (s = this.constraints) || void 0 === s ? void 0 : s.screen) && (E ? (null === (M = this.instance) || void 0 === M || M.initSharingDecode(this.mediaWorkersPath, C.sharingSocketAddress, p, kt, u, d, _), !A || h && c || null === (k = this.instance) || void 0 === k || k.initSharingEncode(this.mediaWorkersPath, C.sharingSocketAddress, p, kt, u, d, _)) : null === (L = this.instance) || void 0 === L || L.initSharingDecode(C.sharingSocketAddress)), this.inProgress = !0;
    }
    async destroy() {
        var e;
        this.callbackList = [], [
            da.AudioDecode,
            da.AudioEncode,
            da.VideoDecode,
            da.VideoEncode
        ].forEach((e)=>{
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.updateQosSubscription(!1, e);
        });
        const t1 = null === (e = this.instance) || void 0 === e ? void 0 : e.destroy.bind(this.instance);
        this.instance = null, this.inProgress = !1, await (null == t1 ? void 0 : t1());
    }
    disconnect() {
        var e, t1;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(17, {}), null === (t1 = this.instance) || void 0 === t1 || t1.JsMediaSDK_UnInit();
    }
    muteAudio() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(8, {
            ssrc: 0
        });
    }
    unmuteAudio() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(7, {
            ssrc: 0,
            AudioSelectValue: 0
        });
    }
    joinComputerAudio(e, t1, o, r, i, n, s) {
        var a;
        const d = s ? {
            ...s,
            enableHID: !0
        } : {
            enableHID: !1
        };
        return null === (a = this.instance) || void 0 === a ? void 0 : a.Notify_MeidaSDK(22, {
            CaptureAudio: r,
            CaptureAudioInfo: {
                ssrc: e,
                AudioSelectValue: "default" === t1 ? null : t1,
                ...d,
                audioProfile: i
            },
            speakerInfo: {
                defaultDeviceId: o
            },
            ...n ? {
                useAudioBridge: !0,
                audioBridge: n
            } : {}
        });
    }
    leaveComputerAudio() {
        var e;
        return null === (e = this.instance) || void 0 === e ? void 0 : e.Notify_MeidaSDK(21, null);
    }
    joinSharingAudio(e) {
        var t1;
        let { ssrc: o, microphoneDeviceId: r, speakerDeviceId: i, isCaptureAudio: n, audioBridge: s } = e;
        return null === (t1 = this.instance) || void 0 === t1 ? void 0 : t1.Notify_MeidaSDK(72, {
            CaptureAudio: n,
            CaptureAudioInfo: {
                ssrc: o,
                AudioSelectValue: "default" === r ? null : r
            },
            speakerInfo: {
                defaultDeviceId: i
            },
            checkAutoplay: !1,
            ...s ? {
                useAudioBridge: !0,
                audioBridge: s
            } : {}
        });
    }
    leaveSharingAudio(e) {
        var t1;
        return null === (t1 = this.instance) || void 0 === t1 ? void 0 : t1.Notify_MeidaSDK(73, {
            isPause: e ? 1 : 0
        });
    }
    changeSpeaker(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(11, {
            ssrc: 0,
            AudioSelectValue: e
        });
    }
    changeMicrophone(e, t1, o) {
        var r;
        null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(18, {
            ssrc: 0,
            AudioSelectValue: "default" === e ? null : e,
            microphoneLabel: null != t1 ? t1 : "default",
            defaultMuted: o
        });
    }
    restoreWebRTC(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(19, {
            ssrc: 0,
            AudioSelectValue: "default" === e ? null : e
        });
    }
    renderVideo(e, t1, o, r, i, n, s, a, d, u, l) {
        var c;
        const p = {
            userId: t1,
            width: r,
            height: i,
            x: n,
            y: s,
            quality: a,
            isMyself: d,
            canvas: e,
            enableWaterMark: l,
            waterMarkText: u,
            zone: o
        };
        e instanceof HTMLVideoElement && Object.assign(p, {
            videodom: e
        }), null === (c = this.instance) || void 0 === c || c.Notify_MeidaSDK(1, p);
    }
    stopRenderVideo(e, t1, o, r) {
        var i;
        let n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        null === (i = this.instance) || void 0 === i || i.Notify_MeidaSDK(2, {
            canvas: e,
            userId: t1,
            RGBA: r,
            doNotClean: n,
            zone: o
        });
    }
    startCaptureVideo(e, t1, o, r, i, n) {
        var s;
        let a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], d = arguments.length > 8 ? arguments[8] : void 0;
        const u = (arguments.length > 7 ? arguments[7] : void 0) ? la.getPTZCapability() : void 0;
        null === (s = this.instance) || void 0 === s || s.Notify_MeidaSDK(3, {
            ssid: e,
            width: o,
            height: r,
            fps: d,
            video: i,
            usingFacingMode: n,
            VideoSelectValue: "default" === t1 ? null : t1,
            disableOriginalRatio: a,
            ...u
        });
    }
    stopCaptureVideo() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(4, {
            ssrc: 0
        });
    }
    changeCamera(e, t1, o) {
        var r;
        null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(12, {
            VideoSelectValue: "default" === e ? null : e,
            usingFacingMode: !!t1,
            ...o || {}
        });
    }
    switchCanvasForVideoCapture(e) {
        var t1;
        let o = e;
        "string" == typeof e && (o = [
            e
        ]), null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(25, o);
    }
    renderSharing(e, t1) {
        var o;
        let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "", n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        this.receivedSharingCanvas = t1, null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(23, {
            width: 0,
            height: 0,
            ssrc: e,
            canvas: t1,
            enableWaterMark: r,
            waterMarkText: i,
            isFromMainSession: n
        });
    }
    stopRenderSharing() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(24, {});
    }
    switchSharingSource(e) {
        var t1;
        let o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(36, {
            ssrc: e,
            isFromMainSession: Number(o)
        });
    }
    ajustmentReceivedSharingCanvas(e, t1) {
        if (this.receivedSharingCanvas && e && t1) try {
            if (ms.isAndroidOrIOSBrowser) {
                const [o, r] = [
                    1280,
                    720
                ], i = Math.max(e / o, t1 / r, 1);
                this.receivedSharingCanvas.width = Math.floor(e / i), this.receivedSharingCanvas.height = Math.floor(t1 / i);
            } else this.receivedSharingCanvas.width = e, this.receivedSharingCanvas.height = t1;
        } catch (e) {}
    }
    startRemoteControl(e, t1, o) {
        var r;
        null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(26, {
            socketURL: `wss://${this.svcUrl}`,
            meetingID: this.meetingNumber,
            condID: this.confId,
            os: t1,
            dom: e,
            ...o
        });
    }
    stopRemoteControl() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(28);
    }
    resendRemoteControlPositionPDU() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(41);
    }
    updateRemoteControlProperties(e) {
        var t1;
        const { dimension: o, ...r } = e;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(27, {
            ...o,
            ...r
        });
    }
    startDesktopSharing(e, t1, o, r) {
        var i;
        let n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], s = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 ? arguments[6] : void 0, d = arguments.length > 7 ? arguments[7] : void 0;
        this.sharingCanvas = t1;
        const u = {};
        r && Object.assign(u, {
            share2ndCamera: !0,
            share2ndCameraParams: {
                VideoSelectValue: "default" === r.cameraId ? null : r.cameraId,
                width: r.width,
                height: r.height
            }
        }), void 0 !== s && Object.assign(u, {
            videoParams: {
                displaySurface: s
            }
        }), void 0 !== d && Object.assign(u, {
            otherParams: {
                ...d
            }
        }), null === (i = this.instance) || void 0 === i || i.Notify_MeidaSDK(30, {
            ssid: e,
            canvas: t1,
            video: o,
            ...u,
            showShareAudioOption: n,
            sourceId: a
        });
    }
    stopDesktopSharing() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(31, {});
    }
    pauseDesktopSharing() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(32, {});
    }
    resumeDesktopSharing() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(33, {});
    }
    selectLanguageChannelForNewLTT(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(57, {
            lang: e
        });
    }
    changeSharingSecondCamera(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(49, {
            VideoSelectValue: e
        });
    }
    ajustmentSharingCanvas(e, t1) {
        if (this.sharingCanvas) try {
            this.sharingCanvas.width = e, this.sharingCanvas.height = t1;
        } catch (e) {}
    }
    checkChromeSharingExtension() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(34, {});
    }
    enableAudioEncode() {
        var e, t1;
        null === (e = this.instance) || void 0 === e || e.initAudioEncode(this.mediaWorkersPath, this.mediaSocketAddress.audioSocketAddress, this.currentUserId, kt, this.confId, this.meetingNumber, ys(null === (t1 = this.mediaOptions) || void 0 === t1 ? void 0 : t1.enableMultiDecodeVideoWithoutSAB));
    }
    sendUserNodeList(e, t1) {
        var o;
        null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(43, {
            userList: e,
            encryptKey: t1
        });
    }
    updateRenderedSharingDimension(e, t1) {
        var o;
        null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(44, {
            width: e,
            height: t1
        });
    }
    pauseOrResumeAudio(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(45, {
            bPause: e
        });
    }
    updateRenderedVideoCanvasDimension(e, t1, o) {
        var r;
        null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(46, {
            canvas: e,
            width: t1,
            height: o
        });
    }
    clearVideoCanvas(e, t1) {
        var o;
        null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(47, {
            id: e,
            RGBA: t1
        });
    }
    adjustRenderedVideoPosition(e, t1, o, r, i, n, s, a) {
        var d;
        null === (d = this.instance) || void 0 === d || d.Notify_MeidaSDK(48, {
            userId: t1,
            x: r,
            y: i,
            width: n,
            height: s,
            canvas: e,
            zone: o,
            RGBA: a
        });
    }
    mirrorVideo(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(75, {
            isMirrorMyVideo: e
        });
    }
    updateUserMediaSN(e) {
        var t1, o, r;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(80, {
            isFromMainSession: Number(e.isFromMainSession),
            mediaActionType: e.iVType,
            body: {
                add: null !== (o = e.added) && void 0 !== o ? o : [],
                remove: null !== (r = e.removed) && void 0 !== r ? r : []
            }
        });
    }
    updateMediaParams(e) {
        var t1;
        const { iVType: o, isFromMainSession: r, updateParams: i } = e;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(81, {
            mediaActionType: o,
            isFromMainSession: Number(r),
            updateParams: i
        });
    }
    createMainSessionChannel(e, t1) {
        var o, r;
        "sharing" === e ? null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(84, t1) : null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(85, t1);
    }
    addReceivedSharingChannelType(e) {
        var t1;
        const { isFromMainSession: o, ...r } = e;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(82, {
            isFromMainSession: Number(o),
            ...r
        });
    }
    removeReceivedSharingChannelType(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(83, {
            isFromMainSession: Number(e.isFromMainSession),
            ssrc: e.ssrc
        });
    }
    enableHardwareAccelerationForVideoDecode(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(70, {
            enable: e
        });
    }
    enableHardwareAccelerationForVideoEncode(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(71, {
            enable: e
        });
    }
    setSharingAudioVolume(e, t1, o) {
        var r;
        null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(74, {
            userid: e >> 10,
            shareVolume: t1 ? 0 : 100,
            isFromMainSession: o
        });
    }
    subscribeToQos(e, t1) {
        e.forEach((e)=>{
            var o;
            null === (o = this.instance) || void 0 === o || o.updateQosSubscription(!0, e, t1);
        });
    }
    unsubscribeFromQos(e) {
        e.forEach((e)=>{
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.updateQosSubscription(!1, e);
        });
    }
    passThroughRWGMessage(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(40, e);
    }
    startVirtualBackgroundSetting(e, t1, o, r, i, n) {
        var s;
        let a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
        null === (s = this.instance) || void 0 === s || s.Notify_MeidaSDK(91, {
            canvas: e,
            bgdom: t1,
            width: i,
            height: n,
            ssid: o,
            VideoSelectValue: "default" === r ? null : r,
            disableOriginalRatio: a
        });
    }
    updateVirtualBackgroundImage(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(92, {
            bgdom: e
        });
    }
    stopVirtualBackgroundSetting() {
        var e;
        let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(93, {
            isSwitch: t1
        });
    }
    startMaskSetting(e, t1, o, r, i, n, s, a, d) {
        var u;
        null === (u = this.instance) || void 0 === u || u.Notify_MeidaSDK(62, {
            canvas: e,
            maskdom: o,
            bgdom: t1,
            dx: 0,
            dy: 0,
            dWidth: n,
            dHeight: s,
            width: a,
            height: d,
            ssid: r,
            VideoSelectValue: "default" === i ? null : i
        });
    }
    updateMaskBackgroundImage(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(63, {
            bgdom: e
        });
    }
    updateMaskClip(e, t1, o) {
        var r;
        null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(64, {
            maskdom: e,
            dx: 0,
            dy: 0,
            dWidth: t1,
            dHeight: o
        });
    }
    stopMaskSetting() {
        var e;
        let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(65, {
            isSwitch: t1
        });
    }
    enableVideoObserver(e) {
        var t1;
        let o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(99, {
            enable: e,
            fpsdisbale: o
        });
    }
    enableShareAudioToBreakoutRoom(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(86, {
            enable: e
        });
    }
    sendUserAudioStatus(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(51, e);
    }
    muteOrUnmuteOtherAudio(e, t1) {
        var o;
        null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(50, {
            userId: e,
            volume: t1 ? 0 : 100
        });
    }
    adjustOtherAudioVolume(e, t1) {
        var o;
        null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(50, {
            userId: e,
            volume: t1
        });
    }
    notifySDKMeetingReady() {
        var e;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(113);
    }
    movePTZCamera(e) {
        var t1;
        return null === (t1 = window.JsMediaSDK_Instance) || void 0 === t1 || null === (t1 = t1.util) || void 0 === t1 ? void 0 : t1.queryPTZPermisson().then((t1)=>{
            var o;
            return t1 ? (null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(53, e), Promise.resolve("")) : Promise.reject("Cannot move camera without permission granted");
        });
    }
    switchSharingMode(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(101, {
            mode: e
        });
    }
    updateVideoHDValue(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK("update_videohd_value", {
            videohd: e
        });
    }
    updateVideoFullhdValue(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK("update_videofullhd_value", {
            videofullhd: e
        });
    }
    changeAudioProfile(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(126, e);
    }
    enableSyncButtonsOnHeadset(e, t1, o) {
        var r;
        null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(100, {
            enable: e,
            microphoneLabel: t1,
            defaultMuted: o
        });
    }
    stopAllIncomingAudio(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(123, e);
    }
    isSharingEntireScreen() {
        var e, t1;
        const o = null === (e = this.instance) || void 0 === e || null === (t1 = e.getShareStreamInfo) || void 0 === t1 ? void 0 : t1.call(e);
        if (o) {
            const { displaySurface: e } = o;
            return !e || "monitor" === e;
        }
        return !1;
    }
    getShareStreamInfo() {
        var e, t1;
        const o = null === (e = this.instance) || void 0 === e || null === (t1 = e.getShareStreamInfo) || void 0 === t1 ? void 0 : t1.call(e);
        if (o) {
            const { deviceId: e, width: t1, height: r } = o;
            return {
                deviceId: e,
                width: t1,
                height: r
            };
        }
        return {};
    }
    preInitAudioBridge(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.previewInit({
            audioBridge: {
                ...e
            }
        });
    }
    prefetchVideoSsrc(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(110, {
            ssrc: e
        });
    }
    cancelPrefetchVideoSsrc(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(112, {
            ssrc: e,
            haddata: !1
        });
    }
    setMobileRotateMode(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(124, {
            isLandScape: e
        });
    }
    changeActiveVideoSsrc(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(13, {
            ssrc: e
        });
    }
    setAudioCodecMode(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(122, {
            mode: e
        });
    }
    startRemoteControlQRCheck(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(54, {
            enable: e
        });
    }
    broadcastVoiceToBreakoutRoom(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(87, {
            enable: e
        });
    }
    share2ndAudio(e, t1) {
        var o;
        const r = {
            audioOnly: !0,
            deviceId: "default" === e ? null : e
        };
        t1 && Object.assign(r, t1), null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(129, r);
    }
    enablePlayAudioFileLocally(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(138, e);
    }
    bypassMediaMessage(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(128, e);
    }
}
la.agentInstance = void 0;
const ca = "ADD_CURRENT_USER_PARTICIPANT_ATTRIBUTE", pa = "UPDATE_CURRENT_USER_PARTICIPANT_ATTRIBUTE", ha = "ADD_USER_PARTICIPANT_ATTRIBUTE", ma = "UPDATE_USER_PARTICIPANT_ATTRIBUTE", ga = "REMOVE_USER_PARTICIPANT_ATTRIBUTE", va = "UPDATE_WEBINAR_PARTICIPANT_ATTRIBUTE", fa = "REMOVE_WEBINAR_ATTENDEE_ATTRIBUTE", ya = "JOIN_MEETING_SUCCESS", Sa = "JOIN_MEETING_FAILED", ba = "RECONNECTING_MEETING", Ea = "LEAVING_MEETING", Ia = "MEETING_IN_WAITING_ROOM", Aa = "UPDATE_MEETING_ATTRIBUTE", Ca = "SHARE_PRONOUN_TYPE_UPDATE", _a = "MEETING_RLB_TP_READY_STATUS_CHANGE";
var Ra = function(e) {
    return e.ConnectionChange = "connection-change", e.OnHoldChange = "on-hold-change", e.UserAdd = "user-added", e.UserUpdate = "user-updated", e.UserRemove = "user-removed", e.AttendeeUpdate = "attendee-updated", e.MeetingAttributeUpdate = "meeting-attribute-updated", e.PromoteAttendeeConsent = "promote-attendee-consent", e.ActiveAppsUpdate = "active-apps-updated", e.SharePronounTypeUpdate = "share-pronoun-type-update", e;
}(Ra || {});
const wa = {
    JoinMeeting: {
        success: ca,
        fail: [
            Sa
        ]
    }
}, Ta = {
    [Ra.ConnectionChange]: [
        {
            event: ya,
            payload: ()=>({
                    state: Zn.Connected
                })
        },
        {
            event: Sa,
            payload: (e)=>({
                    state: Zn.Fail,
                    ...e
                })
        },
        {
            event: ba,
            payload: (e)=>({
                    state: Zn.Reconnecting,
                    ...e
                })
        },
        {
            event: Ea,
            payload: (e)=>({
                    state: Zn.Closed,
                    ...e
                })
        }
    ],
    [Ra.OnHoldChange]: [
        {
            event: Ia,
            payload: (e)=>({
                    isOnHold: e
                })
        }
    ],
    [Ra.UserAdd]: [
        {
            event: ca,
            payload: (e)=>[
                    e
                ]
        },
        {
            event: ha,
            payload: (e)=>e
        }
    ],
    [Ra.UserUpdate]: [
        {
            event: pa,
            payload: (e)=>[
                    e
                ]
        },
        {
            event: ma,
            payload: (e)=>e
        }
    ],
    [Ra.UserRemove]: [
        {
            event: ga,
            payload: (e)=>e
        }
    ],
    [Ra.AttendeeUpdate]: [
        {
            event: va,
            payload: (e)=>e
        },
        {
            event: fa,
            payload: (e)=>e
        }
    ],
    [Ra.MeetingAttributeUpdate]: [
        {
            event: Aa,
            payload: (e)=>"bNoHostTimeOut" in e ? {
                    isHostLost: e.bNoHostTimeOut
                } : null
        }
    ],
    [Ra.PromoteAttendeeConsent]: [
        {
            event: "MEETING_WEBINAR_PROMOTE_CONSENT_REQ",
            payload: (e)=>{
                let { req_id: t1, sender_id: o } = e;
                return {
                    reqId: t1,
                    senderId: o
                };
            }
        }
    ],
    [Ra.ActiveAppsUpdate]: [
        {
            event: "ACTIVE_APPS_UPDATE",
            payload: ()=>{}
        }
    ],
    [Ra.SharePronounTypeUpdate]: [
        {
            event: Ca,
            payload: (e)=>e
        }
    ]
}, Oa = "LIVE_TRANSCRIPTION_RECEIVE_MESSAGE", Da = "LIVE_TRANSCRIPTION_CAPTION_STATUS_CHANGE_RESPONSE", Pa = "LIVE_TRANSCRIPTION_STATUS_CHANGE", Ma = "LIVE_TRANSCRIPTION_HOST_DISABLE_CHANGE", ka = {
    "caption-message": [
        {
            event: Oa,
            payload: (e)=>e
        }
    ],
    "caption-status": [
        {
            event: Da,
            payload: (e)=>e
        }
    ],
    "caption-enable": [
        {
            event: Pa,
            payload: (e)=>e
        }
    ],
    "caption-host-disable": [
        {
            event: Ma,
            payload: (e)=>e
        }
    ]
}, La = "CHAT_RECEIVE_MESSAGE_EVENTS", Na = "CHAT_PRIVILEGE_CHANGE", Va = "CHAT_MESSAGE_RESPONSE", Ua = "CHAT_DELETE_MESSAGE_REPONSE", ja = "CHAT_FILE_CHAT_UPLOAD_PROGRESS", xa = "CHAT_FILE_CHAT_DOWNLOAD_PROGRESS";
let Ba = function(e) {
    return e.ChatOnMessage = "chat-on-message", e.ChatPrivilegeChange = "chat-privilege-change", e.ChatDeleteMessage = "chat-delete-message", e.ChatFileUploadProgress = "chat-file-upload-progress", e.ChatFileDownloadProgress = "chat-file-download-progress", e;
}({});
const Fa = {
    [Ba.ChatOnMessage]: [
        {
            event: La,
            payload: (e)=>e
        }
    ],
    [Ba.ChatPrivilegeChange]: [
        {
            event: Na,
            payload: (e)=>e
        }
    ],
    [Ba.ChatDeleteMessage]: [
        {
            event: Ua,
            payload: (e)=>e
        }
    ],
    [Ba.ChatFileUploadProgress]: [
        {
            event: ja,
            payload: (e)=>e
        }
    ],
    [Ba.ChatFileDownloadProgress]: [
        {
            event: xa,
            payload: (e)=>e
        }
    ]
}, Ha = "COMMAND_RECEIVE_MESSAGE_EVENTS", $a = "COMMAND_STATUS_EVENTS";
let Wa = function(e) {
    return e.CommandChannelStatus = "command-channel-status", e.CommandChannelMessage = "command-channel-message", e;
}({});
const Ga = {
    [Wa.CommandChannelStatus]: [
        {
            event: $a,
            payload: (e)=>e
        }
    ],
    [Wa.CommandChannelMessage]: [
        {
            event: Ha,
            payload: (e)=>e
        }
    ]
};
let Ka = function(e) {
    return e.Recording = "Recording", e.Paused = "Paused", e.Stopped = "Stopped", e.Ask = "Ask", e.Accept = "Accept", e.Decline = "Decline", e;
}({}), za = function(e) {
    return e[e.None = 0] = "None", e[e.Init = 1] = "Init", e[e.Start = 2] = "Start", e[e.Pause = 3] = "Pause", e[e.Stop = 4] = "Stop", e;
}({}), qa = function(e) {
    return e[e.Stop = 0] = "Stop", e[e.Start = 1] = "Start", e[e.Pause = 2] = "Pause", e;
}({}), Ja = function(e) {
    return e[e.None = 0] = "None", e[e.Deny = 1] = "Deny", e[e.Allow = 2] = "Allow", e;
}({}), Qa = function(e) {
    return e[e.None = 0] = "None", e[e.DenyAllRequest = 1] = "DenyAllRequest", e[e.AllowAllRequest = 2] = "AllowAllRequest", e;
}({});
const Za = "CLOUD_RECORDING_STATUS_CHANGE", Ya = "CLOUD_RECORDING_ISO_STATUS_CHANGE", Xa = "LOCAL_RECORDING_CHANGE", ed = "LOCAL_RECORDING_PERMISSION_CHANGE", td = "RECORDING_FOR_IQ_STATUS_CHANGE", od = "RECORDING_FOR_IQ_OPERATION_CHANGE";
let rd = function(e) {
    return e.RecordingChange = "recording-change", e.IndividualRecordingChange = "individual-recording-change", e.LocalRecordingChange = "local-recording-change", e.LocalRecordingPermissionChange = "local-recording-permission-change", e.MediaCaptureStatusChange = "media-capture-status-change", e.MediaCapturePermissionChange = "media-capture-permission-change", e.RecordingIqChange = "recording-iq-change", e;
}({});
const id = {
    [rd.RecordingChange]: [
        {
            event: Za,
            payload: (e)=>{
                const { cmrServerStatus: t1 } = e;
                return t1 === za.Start ? Ka.Recording : t1 === za.Pause ? Ka.Paused : Ka.Stopped;
            }
        }
    ],
    [rd.IndividualRecordingChange]: [
        {
            event: Ya,
            payload: (e)=>e
        }
    ],
    [rd.LocalRecordingChange]: [
        {
            event: Xa,
            payload: (e)=>e
        }
    ],
    [rd.LocalRecordingPermissionChange]: [
        {
            event: ed,
            payload: (e)=>e
        }
    ],
    [rd.MediaCaptureStatusChange]: [
        {
            event: Xa,
            payload: (e)=>e
        }
    ],
    [rd.MediaCapturePermissionChange]: [
        {
            event: ed,
            payload: (e)=>e
        }
    ],
    [rd.RecordingIqChange]: [
        {
            event: td,
            payload: (e)=>e
        }
    ]
};
let nd = function(e) {
    return e[e.InitSuccess = 1] = "InitSuccess", e[e.InitSuccessVideo = 1.1] = "InitSuccessVideo", e[e.InitSuccessAudio = 1.2] = "InitSuccessAudio", e[e.InitSuccessSharing = 1.3] = "InitSuccessSharing", e[e.UserGrantCaptureAudio = 2] = "UserGrantCaptureAudio", e[e.CurrentVideoResolution = 3] = "CurrentVideoResolution", e[e.JpegDecThreadOk = 4] = "JpegDecThreadOk", e[e.JpegData = 5] = "JpegData", e[e.SharingPara = 6] = "SharingPara", e[e.VideoDecodeMaxSize = 7] = "VideoDecodeMaxSize", e[e.CurrentCaptureVideoWidthHeight = 8] = "CurrentCaptureVideoWidthHeight", e[e.StartVideoCaptureSuccess = 9] = "StartVideoCaptureSuccess", e[e.StopVideoCaptureSuccess = 10] = "StopVideoCaptureSuccess", e[e.StartRemoteControlSuccess = 11] = "StartRemoteControlSuccess", e[e.CancelRemoteControlSuccess = 12] = "CancelRemoteControlSuccess", e[e.RemoteControlCopiedTextNotify = 13] = "RemoteControlCopiedTextNotify", e[e.MonitorLog = 14] = "MonitorLog", e[e.CurrentDesktopSharingWidthHeight = 15] = "CurrentDesktopSharingWidthHeight", e[e.DesktopSharingCaptureSuccess = 16] = "DesktopSharingCaptureSuccess", e[e.CheckChromeSharingExtensionResponse = 17] = "CheckChromeSharingExtensionResponse", e[e.SharingDecodeMaxSize = 18] = "SharingDecodeMaxSize", e[e.DataChannelOffer = 19] = "DataChannelOffer", e[e.AesGcmIvResponse = 21] = "AesGcmIvResponse", e[e.SharingDesktopStreamHaveAudio = 23] = "SharingDesktopStreamHaveAudio", e[e.JoinComputerAudioComplete = 24] = "JoinComputerAudioComplete", e[e.JoinSharingAudioComplete = 25] = "JoinSharingAudioComplete", e[e.LeaveComputerAudioComplete = 26] = "LeaveComputerAudioComplete", e[e.LeaveSharingAudioComplete = 27] = "LeaveSharingAudioComplete", e[e.HidStatusMute = 28] = "HidStatusMute", e[e.AudioStreamFailed = 31] = "AudioStreamFailed", e[e.VideoStreamFailed = 32] = "VideoStreamFailed", e[e.AudioSpeakerSetSuccess = 33] = "AudioSpeakerSetSuccess", e[e.AudiobridgeSetCcLangSuccess = 36] = "AudiobridgeSetCcLangSuccess", e[e.AudioLevelIndicator = 38] = "AudioLevelIndicator", e[e.SyncRendererTypeResponse = 39] = "SyncRendererTypeResponse", e[e.SendRemoteControlQrCode = 55] = "SendRemoteControlQrCode", e[e.StartVideoStreamInMaskSettingSuccess = 66] = "StartVideoStreamInMaskSettingSuccess", e[e.CurrentDecodeVideoQuality = 66.5] = "CurrentDecodeVideoQuality", e[e.CurrentDecodeVideoFps = 66.6] = "CurrentDecodeVideoFps", e[e.SharingFirstDecodeFrameReceivedSsrc = 70] = "SharingFirstDecodeFrameReceivedSsrc", e[e.StartVideoStreamInVbSettingSuccess = 94] = "StartVideoStreamInVbSettingSuccess", e[e.VbModelPreloading_3S = 96] = "VbModelPreloading_3S", e[e.VbModelPreloading_10S = 97] = "VbModelPreloading_10S", e[e.VbModelPreloadingOk = 98] = "VbModelPreloadingOk", e[e.NewActiveSpeakerFirstFrameCallback = 111] = "NewActiveSpeakerFirstFrameCallback", e[e.AudioBridgeFirstRecvData = 114] = "AudioBridgeFirstRecvData", e[e.AudioBridgeCanSendData = 115] = "AudioBridgeCanSendData", e[e.InitFailed = -1] = "InitFailed", e[e.InitFailedVideo = -1.1] = "InitFailedVideo", e[e.InitFailedAudio = -1.2] = "InitFailedAudio", e[e.InitFailedSharing = -1.3] = "InitFailedSharing", e[e.UserForbiddedCaptureAudio = -2] = "UserForbiddedCaptureAudio", e[e.AudioWebsocketBroken = -3] = "AudioWebsocketBroken", e[e.VideoWebsocketBroken = -4] = "VideoWebsocketBroken", e[e.SharingDecThreadFailed = -5] = "SharingDecThreadFailed", e[e.AudioZeroData = -6] = "AudioZeroData", e[e.AudioCtxSamplerate = -7] = "AudioCtxSamplerate", e[e.UserForbiddedCaptureVideo = -8] = "UserForbiddedCaptureVideo", e[e.UserCameraIsTakenByOtherPrograms = -9] = "UserCameraIsTakenByOtherPrograms", e[e.StopVideoCaptureFailed = -10] = "StopVideoCaptureFailed", e[e.StartRemoteControlFailed = -11] = "StartRemoteControlFailed", e[e.CancelRemoteControlFailed = -12] = "CancelRemoteControlFailed", e[e.RemoteControlPasteTextLengthOverflow = -14] = "RemoteControlPasteTextLengthOverflow", e[e.UserStopDesktopSharing = -15] = "UserStopDesktopSharing", e[e.UserCancelPermissionRequest = -16] = "UserCancelPermissionRequest", e[e.DesktopSharingChromeExtensionUninstalled = -17] = "DesktopSharingChromeExtensionUninstalled", e[e.DesktopSharingPermissionDenied = -18] = "DesktopSharingPermissionDenied", e[e.DesktopSharingTimeOut = -19] = "DesktopSharingTimeOut", e[e.DesktopSharingError = -20] = "DesktopSharingError", e[e.AudioSpeakerSetError = -21] = "AudioSpeakerSetError", e[e.DesktopSharingSystemError = -22] = "DesktopSharingSystemError", e[e.SharingDesktopStreamHaveNoAudio = -27] = "SharingDesktopStreamHaveNoAudio", e.AudioQosData = "AUDIO_QOS_DATA", e.VideoQosData = "VIDEO_QOS_DATA", e.ShareQosData = "VIDEOSHARE_QOS_DATA", e.NetworkQualityChange = "NETWORK_QUALITY_CHANGE", e.NetworkQualityChangeAudio = "NETWORK_QUALITY_CHANGE_AUDIO", e[e.AudioBridgeReconnectStart = -29] = "AudioBridgeReconnectStart", e[e.AudioBridgeReconnectEnd = -31] = "AudioBridgeReconnectEnd", e[e.WebglLostInMultiView = -32] = "WebglLostInMultiView", e[e.MaskSettingParaError = -33] = "MaskSettingParaError", e[e.VbSettingParaError = -34] = "VbSettingParaError", e[e.NotifyUIFailover = -35] = "NotifyUIFailover", e[e.AudiobridgeSetCcLangFailure = -39] = "AudiobridgeSetCcLangFailure", e[e.RecoverWebrtcAudio = -44] = "RecoverWebrtcAudio", e[e.SharingHealthCheckFailed = -129] = "SharingHealthCheckFailed", e[e.VideoHealthCheckFailed = -130] = "VideoHealthCheckFailed", e[e.AudioHealthCheckFailed = -131] = "AudioHealthCheckFailed", e.AudioStreamMuted = "AUDIO_STREAM_MUTED", e.AudioStreamUnmuted = "AUDIO_STREAM_UNMUTED", e;
}({}), sd = function(e) {
    return e[e.EncodeSuccess = 1] = "EncodeSuccess", e[e.DecodeSuccess = 2] = "DecodeSuccess", e[e.EncodeFailed = -1] = "EncodeFailed", e[e.DecodeFailed = -2] = "DecodeFailed", e;
}({}), ad = function(e) {
    return e.Spotlight = "Spotlight", e.Unmute = "Unmute", e.AllowToTalk = "Allow to talk", e;
}({}), dd = function(e) {
    return e.Inherited = "inherited", e.Active = "active", e.PassiveByMuteOne = "passive(mute one)", e.PassiveByMuteAll = "passive(mute all)", e.SharingAudio = "sharing audio", e;
}({}), ud = function(e) {
    return e.Inherited = "inherited", e.Active = "active", e.Passive = "passive", e.SharingAudio = "sharing audio", e;
}({}), ld = function(e) {
    return e.Active = "active", e.Failover = "failover", e.EndedBySystem = "audio stream is ended by system", e.Pstn = "pstn", e.MicrophoneError = "microphone error", e;
}({}), cd = function(e) {
    return e.Join = "join", e.Leave = "leave", e.Muted = "muted", e.Unmuted = "unmuted", e;
}({}), pd = function(e) {
    return e[e.Calling = 1] = "Calling", e[e.Ringing = 2] = "Ringing", e[e.Accepted = 3] = "Accepted", e[e.Busy = 4] = "Busy", e[e.NotAvailable = 5] = "NotAvailable", e[e.HangUp = 6] = "HangUp", e[e.Fail = 7] = "Fail", e[e.Success = 8] = "Success", e[e.Timeout = 9] = "Timeout", e[e.Canceling = 10] = "Canceling", e[e.Canceled = 11] = "Canceled", e[e.CancelFailed = 12] = "CancelFailed", e;
}({});
const hd = (()=>{
    const e = new ArrayBuffer(684), t1 = new Uint32Array(e);
    return t1.set([
        1179011410,
        676,
        1163280727,
        544501094,
        16,
        65539,
        16e3,
        64e3,
        2097156,
        1635017060,
        640
    ], 0), new Blob([
        t1
    ], {
        type: "audio/wav"
    });
})(), md = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    2,
    1,
    0,
    5,
    4,
    1,
    3,
    1,
    1,
    10,
    11,
    1,
    9,
    0,
    65,
    0,
    254,
    16,
    2,
    0,
    26,
    11
]), gd = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    2,
    1,
    0,
    10,
    9,
    1,
    7,
    0,
    65,
    0,
    253,
    15,
    26,
    11
]);
let vd = function(e) {
    return e[e.HostGrab = 0] = "HostGrab", e[e.OnlyHost = 1] = "OnlyHost", e[e.AnyoneGrab = 2] = "AnyoneGrab", e[e.MultipleShare = 3] = "MultipleShare", e;
}({}), fd = function(e) {
    return e.Sharing = "sharing", e.Paused = "paused", e.End = "ended", e;
}({}), yd = function(e) {
    return e[e.Video_90P = 0] = "Video_90P", e[e.Video_180P = 1] = "Video_180P", e[e.Video_360P = 2] = "Video_360P", e[e.Video_720P = 3] = "Video_720P", e[e.Video_1080P = 4] = "Video_1080P", e;
}({}), Sd = function(e) {
    return e.Active = "Active", e.Inactive = "Inactive", e;
}({}), bd = function(e) {
    return e.Muted = "Muted", e.Unmuted = "Unmuted", e;
}({}), Ed = function(e) {
    return e.Started = "Started", e.Stopped = "Stopped", e.Failed = "Failed", e;
}({}), Id = function(e) {
    return e.Approved = "Approved", e.Rejected = "Rejected", e;
}({}), Ad = function(e) {
    return e.PrivilegeChange = "PrivilegeChange", e.StopScreenCapture = "StopScreenCapture", e.ShareFromMainSession = "ShareFromMainSession", e;
}({}), Cd = function(e) {
    return e[e.ImageNotMatch = 2] = "ImageNotMatch", e[e.CanvasNotMatch = 3] = "CanvasNotMatch", e[e.VBModelNotMatch = 4] = "VBModelNotMatch", e;
}({});
const _d = "blur";
let Rd = function(e) {
    return e.User = "user", e.Environment = "environment", e.Left = "left", e.Right = "right", e;
}({});
const wd = Object.values(Rd), Td = 1e3, Od = "__ZOOM_SDK_SHARING_VIDEO__", Dd = "__ZOOM_SDK_VIDEO_ZONE__", Pd = "__ZOOM_SDK_MEDIA_PLAYBACK_SOURCE_VIDEO__", Md = "__ZOOM_SDK_DYMMY_VIDEO_PLAYER_CANVAS_ID__", kd = "__ZOOM_SDK_DUMMY_HIDDEN_SELF_VIEW_VIDEO_ID__", Ld = {
    data: {
        sample_rate: 0,
        rtt: 0,
        jitter: 0,
        avg_loss: 0,
        max_loss: 0,
        rate: 0,
        bandwidth: 0
    }
}, Nd = {
    data: {
        sample_rate: 0,
        rtt: 0,
        jitter: 0,
        avg_loss: 0,
        max_loss: 0,
        width: 0,
        height: 0,
        fps: 0,
        rate: 0,
        bandwidth: 0
    }
};
let Vd = function(e) {
    return e[e.Request = 11] = "Request", e[e.Decline = 12] = "Decline", e[e.Approve = 13] = "Approve", e[e.GiveUp = 14] = "GiveUp", e[e.StartControl = 15] = "StartControl", e[e.ContinueControl = 16] = "ContinueControl", e[e.StopControl = 17] = "StopControl", e[e.SwitchCamera = 20] = "SwitchCamera", e;
}({}), Ud = function(e) {
    return e[e.Bk = 0] = "Bk", e[e.Center = 1] = "Center", e[e.ZoomIn = 2] = "ZoomIn", e[e.ZoomOut = 3] = "ZoomOut", e[e.Left = 4] = "Left", e[e.Right = 5] = "Right", e[e.Up = 6] = "Up", e[e.Down = 7] = "Down", e[e.SwitchCamera = 8] = "SwitchCamera", e;
}({}), jd = function(e) {
    return e[e.Pan = 192] = "Pan", e[e.Tilt = 48] = "Tilt", e[e.Zoom = 12] = "Zoom", e[e.Focus = 3] = "Focus", e;
}({}), xd = function(e) {
    return e[e.ZoomIn = 2] = "ZoomIn", e[e.ZoomOut = 3] = "ZoomOut", e[e.Left = 4] = "Left", e[e.Right = 5] = "Right", e[e.Up = 6] = "Up", e[e.Down = 7] = "Down", e[e.SwitchCamera = 8] = "SwitchCamera", e;
}({}), Bd = function(e) {
    return e[e.None = 0] = "None", e[e.ApproveAnother = 3] = "ApproveAnother", e[e.Stop = 5] = "Stop", e;
}({}), Fd = function(e) {
    return e[e.Null = 0] = "Null", e[e.Normal = 1] = "Normal", e[e.VideoMode = 2] = "VideoMode", e;
}({}), Hd = function(e) {
    return e[e.Null = 0] = "Null", e[e.VirtualBackground = 1] = "VirtualBackground", e[e.Mask = 2] = "Mask", e;
}({}), $d = function(e) {
    return e.Computer = "computer", e.Phone = "phone", e;
}({}), Wd = function(e) {
    return e[e.Decline = 0] = "Decline", e[e.Approve = 1] = "Approve", e[e.CacheClean = 2] = "CacheClean", e;
}({}), Gd = function(e) {
    return e.Unknown = "unknown", e.Uninstalled = "uninstalled", e.Installed = "installed", e;
}({}), Kd = function(e) {
    return e.Unlaunched = "unlaunched", e.Launched = "launched", e;
}({}), zd = function(e) {
    return e.Started = "started", e.Ended = "ended", e;
}({}), qd = function(e) {
    return e[e.Max = 30] = "Max", e[e.Min = 10] = "Min", e[e.Default = 24] = "Default", e;
}({}), Jd = function(e) {
    return e[e.Loading = 1] = "Loading", e[e.Done = 2] = "Done", e;
}({}), Qd = function(e) {
    return e.Browser = "Browser", e.Zoom = "Zoom", e;
}({}), Zd = function(e) {
    return e.Denoise = "backgroundNoiseSuppression", e.OriginalSound = "originalSound", e;
}({}), Yd = function(e) {
    return e[e.Undefined = 0] = "Undefined", e[e.WebGL = 1] = "WebGL", e[e.WebGPU = 2] = "WebGPU", e[e.WebGL2 = 3] = "WebGL2", e;
}({}), Xd = function(e) {
    return e[e.H323 = 1] = "H323", e[e.SIP = 2] = "SIP", e;
}({}), eu = function(e) {
    return e[e.Success = 0] = "Success", e[e.Ringing = 1] = "Ringing", e[e.Timeout = 2] = "Timeout", e[e.Busy = 101] = "Busy", e[e.Fail = 104] = "Fail", e;
}({}), tu = function(e) {
    return e[e.AudioConnectionFailed = 101] = "AudioConnectionFailed", e[e.AudioStreamEnded = 102] = "AudioStreamEnded", e[e.MicrophonePermissionReset = 103] = "MicrophonePermissionReset", e[e.AudioStreamFailed = 104] = "AudioStreamFailed", e[e.MicrophoneMuted = 105] = "MicrophoneMuted", e[e.AudioStreamMuted = 106] = "AudioStreamMuted", e[e.AudioPlaybackInterrupted = 107] = "AudioPlaybackInterrupted", e[e.VideoConnectionFailed = 201] = "VideoConnectionFailed", e[e.VideoStreamEnded = 202] = "VideoStreamEnded", e[e.CameraPermissionReset = 203] = "CameraPermissionReset", e[e.WebGlContextInvalid = 204] = "WebGlContextInvalid", e[e.WasmOutOfMemory = 205] = "WasmOutOfMemory", e[e.VideoStreamFailed = 206] = "VideoStreamFailed", e[e.SharingStreamFailed = 301] = "SharingStreamFailed", e;
}({});
const ou = "RECEIVE_VIDEO_ACTIVE_INDICATION", ru = "RECEIVE_VIDEO_MUTE_INDICATION", iu = "ASK_FOR_START_VIDEO_CONSENT", nu = "RECEIVE_VIDEO_DIMENSION_CHANGE", su = "CAPTURED_VIDEO_DIMENSION_CHANGE", au = "CAN_NOT_DETECT_CAMERA", du = "CAN_NOT_FIND_CAMERA", uu = "VIDEO_USER_FORBIDDEN_CAPTURE", lu = "VIDEO_CAMERA_IS_TAKEN", cu = "VIDEO_BACKGROUND_FAILED", pu = "VIDEO_ESTABLISH_STREAM_ERROR", hu = "VIDEO_CAPTURE_START_SUCCESS", mu = "VIDEO_CAPTURE_STOP_RESULT", gu = "VIDEO_SPOTLIGHT_CHANGE", vu = "VIDEO_FOLLOW_HOST_ORDER_CHANGE", fu = "VIDEO_HOST_DRAG_LAYOUT_CHANGE", yu = "VIDEO_NEW_USER_START", Su = "VIDEO_OLD_USER_STOP", bu = "VIDEO_VIRTUAL_BACKGROUND_PRELOAD_READY", Eu = "VIDEO_VIRTUAL_BACKGROUND_SETTING_SUCCESS", Iu = "VIDEO_STATISTIC_DATA", Au = "VIDEO_CELL_DETAILED_DATA", Cu = "VIDEO_NETWORK_QUALITY_CHANGE", _u = "VIDEO_FAR_END_CAMERA_CONTROL_REQUEST", Ru = "VIDEO_FAR_END_CAMERA_CONTROL_RESPONSE", wu = "VIDEO_FAR_END_CAMERA_IN_CONTROL_CHANGE", Tu = "VIDEO_FAR_END_CAMERA_CAPABILITY_CHANGE", Ou = "VIDEO_MASK_SETTING_SUCCESS", Du = "VIDEO_CAPTURE_SDK_SUCCESS", Pu = "VIDEO_PREFETCH_VIDEO_FRAME_CALLBACK", Mu = "VIDEO_CURRENT_USER_SSRC", ku = "VIDEO_RENDER_ASPECT_RATIO_CHANGE", Lu = "VIDEO_LEADERSHIP_USER_CHANGE", Nu = {
    startCaptureVideo: {
        success: hu,
        fail: [
            au,
            du,
            uu,
            pu,
            lu,
            cu
        ]
    },
    switchCameraVideo: {
        success: Du,
        fail: [
            au,
            du,
            uu,
            lu
        ]
    }
};
let Vu = function(e) {
    return e.VideoActiveChange = "video-active-change", e.PeerVideoStateChange = "peer-video-state-change", e.VideoSpotlightChange = "video-spotlight-change", e.VideoMutedChange = "video-muted-change", e.VideoCapturingChange = "video-capturing-change", e.AskForStartVideoConsent = "ask-for-start-video-consent", e.VideoDimensionChange = "video-dimension-change", e.VideoFollowHostOrder = "video-follow-host-order-change", e.VideoHostLayoutChange = "video-host-layout-change", e.VideoVBPreloadChange = "video-virtual-background-preload-change", e.VideoStatisticDataChange = "video-statistic-data-change", e.VideoDetailedDataChange = "video-detailed-data-change", e.VideoAspectRatioChange = "video-aspect-ratio-change", e.NetworkQualityChange = "network-quality-change", e.FarEndCameraRequestControl = "far-end-camera-request-control", e.FarEndCameraResponseControl = "far-end-camera-response-control", e.FarEndCameraInControlChange = "far-end-camera-in-control-change", e.FarEndCameraCapabilityChange = "far-end-camera-capability-change", e;
}({});
const Uu = {
    [Vu.VideoActiveChange]: [
        {
            event: ou,
            payload: (e)=>({
                    state: e.bVideoOn ? Sd.Active : Sd.Inactive,
                    userId: e.userId
                })
        }
    ],
    [Vu.VideoCapturingChange]: [
        {
            event: hu,
            payload: ()=>({
                    state: Ed.Started
                })
        },
        {
            event: mu,
            payload: (e)=>({
                    state: null != e && e.failed ? Ed.Failed : Ed.Stopped
                })
        }
    ],
    [Vu.VideoMutedChange]: [
        {
            event: ru,
            payload: (e)=>({
                    state: e.isVideoMuted ? bd.Muted : bd.Unmuted,
                    userId: e.id
                })
        }
    ],
    [Vu.AskForStartVideoConsent]: [
        {
            event: iu,
            payload: (e)=>({
                    state: e.isVideoMuted ? bd.Muted : bd.Unmuted,
                    userId: e.id
                })
        }
    ],
    [Vu.VideoSpotlightChange]: [
        {
            event: gu,
            payload: (e)=>({
                    spotlightList: e.spotlightList && e.spotlightList.map((e)=>({
                            userId: e
                        }))
                })
        },
        {
            event: Lu,
            payload: (e)=>{
                var t1;
                return {
                    spotlightList: null === (t1 = e.spotlightList) || void 0 === t1 ? void 0 : t1.map((e)=>({
                            userId: e
                        }))
                };
            }
        }
    ],
    [Vu.VideoDimensionChange]: [
        {
            event: nu,
            payload: (e)=>({
                    type: "received",
                    width: e.width,
                    height: e.height
                })
        },
        {
            event: su,
            payload: (e)=>({
                    type: "captured",
                    width: e.width,
                    height: e.height
                })
        }
    ],
    [Vu.VideoFollowHostOrder]: [
        {
            event: vu,
            payload: (e)=>({
                    isFollowHostOrder: e.bOn
                })
        }
    ],
    [Vu.VideoHostLayoutChange]: [
        {
            event: fu,
            payload: (e)=>Array.isArray(e.layout) ? e.layout.map((e)=>({
                        userId: e
                    })) : []
        }
    ],
    [Vu.PeerVideoStateChange]: [
        {
            event: yu,
            payload: (e)=>({
                    action: "Start",
                    ...e
                })
        },
        {
            event: Su,
            payload: (e)=>({
                    action: "Stop",
                    ...e
                })
        }
    ],
    [Vu.VideoVBPreloadChange]: [
        {
            event: bu,
            payload: (e)=>({
                    isReady: e
                })
        }
    ],
    [Vu.VideoStatisticDataChange]: [
        {
            event: Iu,
            payload: (e)=>{
                const { data: { rate: t1, ...o }, ...r } = null != e ? e : {
                    data: {}
                };
                return {
                    data: {
                        bitrate: t1,
                        ...o
                    },
                    ...r
                };
            }
        }
    ],
    [Vu.VideoDetailedDataChange]: [
        {
            event: Au,
            payload: (e)=>e
        }
    ],
    [Vu.VideoAspectRatioChange]: [
        {
            event: ku,
            payload: (e)=>e
        }
    ],
    [Vu.NetworkQualityChange]: [
        {
            event: Cu,
            payload: (e)=>e
        }
    ],
    [Vu.FarEndCameraRequestControl]: [
        {
            event: _u,
            payload: (e)=>e
        }
    ],
    [Vu.FarEndCameraResponseControl]: [
        {
            event: Ru,
            payload: (e)=>e
        }
    ],
    [Vu.FarEndCameraInControlChange]: [
        {
            event: wu,
            payload: (e)=>e
        }
    ],
    [Vu.FarEndCameraCapabilityChange]: [
        {
            event: Tu,
            payload: (e)=>e
        }
    ]
}, ju = "AUDIO_ACTIVE_SPEAKER", xu = "AUDIO_UNMUTE_CONSENT", Bu = "AUDIO_CURRENT_USER_JOIN_BY_VOIP", Fu = "AUDIO_CURRENT_USER_JOIN_BY_PHONE", Hu = "AUDIO_CURRENT_USER_LEAVE_AUDIO", $u = "AUDIO_CURRENT_USER_MUTED", Wu = "AUDIO_CURRENT_USER_UNMUTED", Gu = "AUDIO_PARTICIPANT_AUDIO_UPDATE", Ku = "AUDIO_DIALOUT_RESULT_CODE", zu = "AUDIO_DIALOUT_RESULT_SUCCESS", qu = "AUDIO_DIALOUT_RESULT_FAIL", Ju = "AUDIO_DIALOUT_CANCEL_SUCCESS", Qu = "DIALOUT_CANCEL_FAIL", Zu = "AUDIO_MERGE_AUDIO_INDICATION", Yu = "USER_FORBIDDEN_MICROPHONE", Xu = "ESTABLISH_AUDIO_STREAM_ERROR", el = "AUDIO_AUTO_PLAY_FAILED", tl = "INVALID_DEVICE_ID", ol = "AUDIO_ALLOW_TALK_CHANGE", rl = "SHARE_AUDIO_STATE_CHANGE", il = "AUDIO_STATISTIC_DATA", nl = "AUDIO_CURRENT_USER_SSRC", sl = "AUDIO_SET_SPEAKER_RESULT", al = "AUDIO_SHARE_SECONDARY_AUDIO_SUCCESS", dl = "AUDIO_CRC_CALL_OUT_RESULT_CODE", ul = "AUDIO_CRC_CALL_OUT_RESULT_SUCCESS", ll = "AUDIO_CRC_CALL_OUT_RESULT_FAIL", cl = "AUDIO_CURRENT_AUDIO_LEVEL_CHANGE";
let pl = function(e) {
    return e.ActiveSpeaker = "active-speaker", e.UnmuteAudioConsent = "unmute-audio-consent", e.CurrentAudioChange = "current-audio-change", e.CurrentAudioLevelChange = "current-audio-level-change", e.DialoutStateChange = "dialout-state-change", e.MergeAudio = "merged-audio", e.AutoPlayFailed = "auto-play-audio-failed", e.AllowTalkChange = "allow-talk-change", e.ShareAudioChange = "share-audio-change", e.AudioStatisticDataChange = "audio-statistic-data-change", e.CrcCallOutStateChange = "crc-call-out-state-change", e;
}({});
const hl = {
    JoinComputerAudio: {
        success: Bu,
        fail: [
            Yu,
            Xu
        ]
    },
    JoinAudioByCallMe: {
        success: zu,
        fail: [
            qu
        ]
    },
    cancelDialOut: {
        success: Ju,
        fail: [
            Qu
        ]
    },
    hangup: {
        success: Hu
    },
    crcCallOut: {
        success: ul,
        fail: [
            ll
        ]
    }
}, ml = {
    [pl.ActiveSpeaker]: [
        {
            event: ju,
            payload: (e)=>e
        }
    ],
    [pl.UnmuteAudioConsent]: [
        {
            event: xu,
            payload: (e)=>({
                    reason: e
                })
        }
    ],
    [pl.CurrentAudioChange]: [
        {
            event: Fu,
            payload: ()=>({
                    action: cd.Join,
                    type: $d.Phone
                })
        },
        {
            event: Bu,
            payload: ()=>({
                    action: cd.Join,
                    type: $d.Computer
                })
        },
        {
            event: Hu,
            payload: (e)=>{
                let { source: t1 } = e;
                return {
                    action: cd.Leave,
                    source: t1
                };
            }
        },
        {
            event: $u,
            payload: (e)=>{
                let { source: t1 } = e;
                return {
                    action: cd.Muted,
                    source: t1
                };
            }
        },
        {
            event: Wu,
            payload: (e)=>{
                let { source: t1 } = e;
                return {
                    action: cd.Unmuted,
                    source: t1
                };
            }
        }
    ],
    [pl.DialoutStateChange]: [
        {
            event: Ku,
            payload: (e)=>e
        }
    ],
    [pl.MergeAudio]: [
        {
            event: Zu,
            payload: (e)=>e
        }
    ],
    [pl.AutoPlayFailed]: [
        {
            event: el,
            payload: ()=>{}
        }
    ],
    [pl.AllowTalkChange]: [
        {
            event: ol,
            payload: (e)=>({
                    enabled: e
                })
        }
    ],
    [pl.ShareAudioChange]: [
        {
            event: rl,
            payload: (e)=>e
        }
    ],
    [pl.AudioStatisticDataChange]: [
        {
            event: il,
            payload: (e)=>{
                const { data: { rate: t1, ...o }, ...r } = null != e ? e : {
                    data: {}
                };
                return {
                    data: {
                        bitrate: t1,
                        ...o
                    },
                    ...r
                };
            }
        }
    ],
    [pl.CrcCallOutStateChange]: [
        {
            event: dl,
            payload: (e)=>e
        }
    ],
    [pl.CurrentAudioLevelChange]: [
        {
            event: cl,
            payload: (e)=>e
        }
    ]
}, gl = "SHARE_ACTIVE_INDICATION", vl = "SHARE_CHECK_CHROME_SHARING_EXTENSION", fl = "SHARE_START_DESKTOP_SHARE_FAILED", yl = "SHARE_DIMENSION_CHANGE", Sl = "SHARE_RECEIVED_DIMENSION_CHANGE", bl = "SHARE_VIDEO_STREAMS_END", El = "SHARE_PASSIVE_STOP_SHARE", Il = "SHARE_PASSIVE_BO_STOP", Al = "SHARE_NEW_USER_ADD", Cl = "SHARE_USER_REMOVE", _l = "SHARE_USER_PAUSED", Rl = "SHARE_USER_RESUMED", wl = "SHARE_AUTO_CHANGE_SOURCE", Tl = "SHARE_REMOTE_CONTROL_APPROVE", Ol = "SHARE_GRAB_REMOTE_CONTROL_CHANGE", Dl = "SHARE_REMOTE_CONTROL_CLIPBOARD_CHANGE", Pl = "SHARE_REMOTE_CONTROL_SUCCESS", Ml = "SHARE_REMOTE_CONTROL_FAILED", kl = "SHARE_PRIVILEGE_CHANGE", Ll = "SHARE_READ_RECEIPT", Nl = "SHARE_STATISTIC_DATA", Vl = "SHARE_REMOTE_CONTROL_REQUEST", Ul = "SHARE_REMOTE_CONTROL_APP_STATUS", jl = "SHARE_REMOTE_CONTROL_SESSION_STATUS", xl = "SHARE_REMOTE_CONTROL_APP_SCHEME";
let Bl = function(e) {
    return e.ShareActiveChange = "active-share-change", e.ShareDimensionChange = "share-content-dimension-change", e.SharePassiveStop = "passively-stop-share", e.SharePeerStateChange = "peer-share-state-change", e.ShareContentChange = "share-content-change", e.SharePrivilegeChange = "share-privilege-change", e.ShareReadReceipt = "share-can-see-screen", e.ShareStatisticDataChange = "share-statistic-data-change", e.RemoteControlApprovedChange = "remote-control-approved-change", e.RemoteControlInControlChange = "remote-control-in-control-change", e.RemoteControlClipboardChange = "remote-control-clipboard-change", e.RemoteControlRequestChange = "remote-control-request-change", e.RemoteControlAppStatusChange = "remote-control-app-status-change", e.RemoteControlControlledStatusChange = "remote-control-controlled-status-change", e;
}({});
const Fl = {
    [Bl.ShareActiveChange]: [
        {
            event: gl,
            payload: (e)=>{
                const { isActive: t1, activeUserId: o, ...r } = e;
                return {
                    state: t1 ? "Active" : "Inactive",
                    userId: o,
                    ...r
                };
            }
        }
    ],
    [Bl.ShareDimensionChange]: [
        {
            event: yl,
            payload: (e)=>({
                    type: "sended",
                    width: e.width,
                    height: e.height
                })
        },
        {
            event: Sl,
            payload: (e)=>({
                    type: "received",
                    width: e.width,
                    height: e.height
                })
        }
    ],
    [Bl.SharePassiveStop]: [
        {
            event: bl,
            payload: ()=>({
                    reason: Ad.StopScreenCapture
                })
        },
        {
            event: El,
            payload: ()=>({
                    reason: Ad.PrivilegeChange
                })
        },
        {
            event: Il,
            payload: ()=>({
                    reason: Ad.ShareFromMainSession
                })
        }
    ],
    [Bl.SharePeerStateChange]: [
        {
            event: Al,
            payload: (e)=>({
                    userId: e.id,
                    action: "Start"
                })
        },
        {
            event: Cl,
            payload: (e)=>({
                    userId: e.id,
                    action: "Stop"
                })
        },
        {
            event: _l,
            payload: (e)=>({
                    userId: e.id,
                    action: "Pause"
                })
        },
        {
            event: Rl,
            payload: (e)=>({
                    userId: e.id,
                    action: "Resume"
                })
        }
    ],
    [Bl.ShareContentChange]: [
        {
            event: wl,
            payload: (e)=>e
        }
    ],
    [Bl.SharePrivilegeChange]: [
        {
            event: kl,
            payload: (e)=>({
                    privilege: e
                })
        }
    ],
    [Bl.ShareReadReceipt]: [
        {
            event: Ll,
            payload: ()=>{}
        }
    ],
    [Bl.ShareStatisticDataChange]: [
        {
            event: Nl,
            payload: (e)=>{
                const { data: { rate: t1, ...o }, ...r } = null != e ? e : {
                    data: {}
                };
                return {
                    data: {
                        bitrate: t1,
                        ...o
                    },
                    ...r
                };
            }
        }
    ],
    [Bl.RemoteControlApprovedChange]: [
        {
            event: Tl,
            payload: (e)=>({
                    state: e ? Id.Approved : Id.Rejected
                })
        }
    ],
    [Bl.RemoteControlInControlChange]: [
        {
            event: Ol,
            payload: (e)=>({
                    isControlling: e
                })
        }
    ],
    [Bl.RemoteControlClipboardChange]: [
        {
            event: Dl,
            payload: (e)=>e
        }
    ],
    [Bl.RemoteControlRequestChange]: [
        {
            event: Vl,
            payload: (e)=>e
        }
    ],
    [Bl.RemoteControlAppStatusChange]: [
        {
            event: Ul,
            payload: (e)=>e
        }
    ],
    [Bl.RemoteControlControlledStatusChange]: [
        {
            event: jl,
            payload: (e)=>e
        }
    ]
};
let Hl = function(e) {
    return e.Question = "question", e.UpdateQuestion = "updateQuestion", e.Answer = "answer", e.DeleteComment = "deleteComment", e.DeleteQuestion = "deleteQuestion", e.Dismiss = "dismiss", e.Reopen = "reopen", e.Upvote = "upvote", e.AnswerLive = "answerLive", e;
}({}), $l = function(e) {
    return e.QaSettingChange = "qa-setting-change", e.QaActionChange = "qa-action-change", e;
}({});
const Wl = {
    [$l.QaSettingChange]: [
        {
            event: "QA_SETTING_OPTION_CHANGE",
            payload: (e)=>e
        }
    ],
    [$l.QaActionChange]: [
        {
            event: "QA_NEW_ASK_QUESTION",
            payload: (e)=>({
                    action: Hl.Question,
                    data: e
                })
        },
        {
            event: "QA_UPDATE_ANONYMOUS_QUESTION",
            payload: (e)=>({
                    action: Hl.UpdateQuestion,
                    data: e
                })
        },
        {
            event: "QA_ANSWER_QUESTION",
            payload: (e)=>({
                    action: Hl.Answer,
                    data: e
                })
        },
        {
            event: "QA_ANSWER_REMOVE_COMMENT",
            payload: (e)=>({
                    action: Hl.DeleteComment,
                    data: e
                })
        },
        {
            event: "QA_ANSWER_REMOVE_QUESTION",
            payload: (e)=>({
                    action: Hl.DeleteQuestion,
                    data: e
                })
        },
        {
            event: "QA_ANSWER_DISMISS_QUESTION",
            payload: (e)=>({
                    action: Hl.Dismiss,
                    data: e
                })
        },
        {
            event: "QA_ANSWER_REOPEN_QUESTION",
            payload: (e)=>({
                    action: Hl.Reopen,
                    data: e
                })
        },
        {
            event: "QA_ANSWER_VOTE_QUESTION",
            payload: (e)=>({
                    action: Hl.Upvote,
                    data: e
                })
        },
        {
            event: "QA_ANSWER_QUESTION_LIVE",
            payload: (e)=>({
                    action: Hl.AnswerLive,
                    data: e
                })
        }
    ]
}, Gl = "INVALID_OPERATION", Kl = "INTERNAL_ERROR", zl = "OPERATION_TIMEOUT", ql = "INSUFFICIENT_PRIVILEGES", Jl = "IMPROPER_MEETING_STATE", Ql = "INVALID_PARAMETERS", Zl = "AUDIO_ENCODE_SUCCESS", Yl = "AUDIO_DECODE_SUCCESS", Xl = "VIDEO_ENCODE_SUCCESS", ec = "VIDEO_DECODE_SUCCESS", tc = "SHARING_ENCODE_SUCCESS", oc = "SHARING_DECODE_SUCCESS", rc = "AUDIO_ENCODE_FAIL", ic = "AUDIO_DECODE_FAIL", nc = "VIDEO_ENCODE_FAIL", sc = "VIDEO_DECODE_FAIL", ac = "SHARING_ENCODE_FAIL", dc = "SHARING_DECODE_FAIL", uc = "MEDIA_DEVICE_CHANGE", lc = "MEDIS_SDK_PATHCH_LOADED", cc = "AUDIO_BRIDGE_PEER_CONNECTION_RECEIVE_READY", pc = "AUDIO_BRIDGE_PEER_CONNECTION_SEND_READY", hc = "DEVICE_PERMISSION_CHANGE", mc = "MEDIA_HEALTH_CHECK_FAILED";
let gc = function(e) {
    return e.DeviceChange = "device-change", e.MediaSDKChange = "media-sdk-change", e.DevicePermissionChange = "device-permission-change", e.MediaInternalError = "media-internal-error", e;
}({});
const vc = {
    [gc.DeviceChange]: [
        {
            event: uc,
            payload: ()=>({})
        }
    ],
    [gc.MediaSDKChange]: [
        {
            event: Zl,
            payload: ()=>({
                    type: "audio",
                    action: "encode",
                    result: "success"
                })
        },
        {
            event: rc,
            payload: ()=>({
                    type: "audio",
                    action: "encode",
                    result: "fail"
                })
        },
        {
            event: Yl,
            payload: ()=>({
                    type: "audio",
                    action: "decode",
                    result: "success"
                })
        },
        {
            event: ic,
            payload: ()=>({
                    type: "audio",
                    action: "decode",
                    result: "fail"
                })
        },
        {
            event: Xl,
            payload: ()=>({
                    type: "video",
                    action: "encode",
                    result: "success"
                })
        },
        {
            event: nc,
            payload: ()=>({
                    type: "video",
                    action: "encode",
                    result: "fail"
                })
        },
        {
            event: ec,
            payload: ()=>({
                    type: "video",
                    action: "decode",
                    result: "success"
                })
        },
        {
            event: sc,
            payload: ()=>({
                    type: "video",
                    action: "decode",
                    result: "fail"
                })
        },
        {
            event: tc,
            payload: ()=>({
                    type: "share",
                    action: "encode",
                    result: "success"
                })
        },
        {
            event: ac,
            payload: ()=>({
                    type: "share",
                    action: "encode",
                    result: "fail"
                })
        },
        {
            event: oc,
            payload: ()=>({
                    type: "share",
                    action: "decode",
                    result: "success"
                })
        },
        {
            event: dc,
            payload: ()=>({
                    type: "share",
                    action: "decode",
                    result: "fail"
                })
        }
    ],
    [gc.DevicePermissionChange]: [
        {
            event: hc,
            payload: (e)=>e
        }
    ],
    [gc.MediaInternalError]: [
        {
            event: mc,
            payload: (e)=>e
        }
    ]
}, fc = "BREAKOUT_ROOM_ADD_TOKEN", yc = "BREAKOUT_ROOM_INVITE_TO_JOIN_NOTIFICATION", Sc = "BREAKOUT_ROOM_ROOM_CLOSING_COUNTDOWN", bc = "BREAKOUT_ROOM_ROOM_COUTDOWN", Ec = "BREAKOUT_ROOM_BROADCAST_MESSAGE", Ic = "BREAKOUT_ROOM_ASK_HELP_REQUEST", Ac = "BREAKOUT_ROOM_ASK_HELP_RESPONSE", Cc = "BREAKOUT_ROOM_ATTRIBUTE_INDICATION", _c = "BREAKOUT_ROOM_JOIN_BO_RESPONSE", Rc = "BREAKOUT_ROOM_ROOM_COUNTDOWN_TIME_UP", wc = "BREAKOUT_ROOM_CURRENT_USER_PARTICIPANT_ROLE", Tc = "BREAKOUT_ROOM_LOAD_PRE_ASSIGNED_ROOMS", Oc = "BREAKOUT_ROOM_MAIN_SESSION_USER_UPDATE", Dc = "BREAKOUT_ROOM_INVITE_TO_BACK_NOTIFICATION", Pc = "BREAKOUT_ROOM_IN_ROOM_USER_STATUS_UPDATE", Mc = "BREAKOUT_ROOM_BROADCAST_VOICE";
let kc = function(e) {
    return e.InviteToJoin = "invite-to-join", e.RoomCountdown = "room-countdown", e.RoomTimeUp = "room-time-up", e.ClosingRoomCountdown = "closing-room-countdown", e.BroadcastMessage = "broadcast-message", e.AskForHelp = "ask-for-help", e.AskForHelpResponse = "ask-for-help-response", e.RoomStateChange = "room-state-change", e.MainSessionUserUpdate = "main-session-user-updated", e.InviteToBack = "invite-back-to-main-session", e.RoomUserUpdate = "room-user-update", e.BroadcastVoice = "broadcast-voice", e;
}({});
const Lc = {
    [kc.InviteToJoin]: [
        {
            event: yc,
            payload: (e)=>e
        }
    ],
    [kc.RoomCountdown]: [
        {
            event: bc,
            payload: (e)=>e
        }
    ],
    [kc.RoomTimeUp]: [
        {
            event: Rc,
            payload: (e)=>e
        }
    ],
    [kc.ClosingRoomCountdown]: [
        {
            event: Sc,
            payload: (e)=>e
        }
    ],
    [kc.BroadcastMessage]: [
        {
            event: Ec,
            payload: (e)=>e
        }
    ],
    [kc.AskForHelp]: [
        {
            event: Ic,
            payload: (e)=>e
        }
    ],
    [kc.AskForHelpResponse]: [
        {
            event: Ac,
            payload: (e)=>e
        }
    ],
    [kc.RoomStateChange]: [
        {
            event: Cc,
            payload: (e)=>({
                    status: e.controlStatus
                })
        }
    ],
    [kc.MainSessionUserUpdate]: [
        {
            event: Oc,
            payload: ()=>({})
        }
    ],
    [kc.InviteToBack]: [
        {
            event: Dc,
            payload: (e)=>e
        }
    ],
    [kc.RoomUserUpdate]: [
        {
            event: Pc,
            payload: (e)=>e
        }
    ],
    [kc.BroadcastVoice]: [
        {
            event: Mc,
            payload: (e)=>e
        }
    ]
};
var Nc = function(e) {
    return e.StatusUpdate = "archiving-status-update", e.OptionsUpdate = "archiving-options-update", e;
}(Nc || {});
const Vc = {
    [Nc.StatusUpdate]: [
        {
            event: "ARCHIVING_STATUS_UPDATE",
            payload: (e)=>e
        }
    ],
    [Nc.OptionsUpdate]: [
        {
            event: "ARCHIVING_OPTIONS_UPDATE",
            payload: (e)=>e
        }
    ]
};
let Uc = function(e) {
    return e.PollDataChange = "poll-data-change", e.PollSizeUpdate = "poll-size-update", e.PollStatusUpdate = "poll-status-update", e;
}({});
const jc = {
    [Uc.PollDataChange]: [
        {
            event: "POLL_DATA_CHANGE",
            payload: (e)=>e
        }
    ],
    [Uc.PollSizeUpdate]: [
        {
            event: "POLL_SIZE_UPDATE",
            payload: (e)=>e
        }
    ],
    [Uc.PollStatusUpdate]: [
        {
            event: "POLL_STATUS_UPDATE",
            payload: (e)=>e
        }
    ]
};
let xc = function(e) {
    return e.ReactionReceived = "reaction-received", e.ReactionRemoved = "reaction-removed", e;
}({});
const Bc = {
    [xc.ReactionReceived]: [
        {
            event: "REACTION_RECEIVED",
            payload: (e)=>e
        }
    ],
    [xc.ReactionRemoved]: [
        {
            event: "REACTION_REMOVED",
            payload: (e)=>e
        }
    ]
}, Fc = "SMART_SUMMARY_STATUS_CHANGE", Hc = "MEETING_QUERY_STATUS_CHANGE";
let $c = function(e) {
    return e.SummaryChange = "summary-status-change", e.MeetingQueryChang = "meeting-query-status-change", e;
}({});
const Wc = {
    [$c.SummaryChange]: [
        {
            event: Fc,
            payload: (e)=>e
        }
    ],
    [$c.MeetingQueryChang]: [
        {
            event: Hc,
            payload: (e)=>e
        }
    ]
}, Gc = "LIVE_STREAM_STATUS_CHANGE", Kc = {
    "live-stream-status": [
        {
            event: Gc,
            payload: (e)=>e
        }
    ]
}, zc = {
    ...Ta,
    ...ka,
    ...Fa,
    ...Ga,
    ...id,
    ...ml,
    ...Uu,
    ...Wl,
    ...Fl,
    ...vc,
    ...Lc,
    ...Vc,
    "closed-caption-message": [
        {
            event: "CC_RECEIVE_MESSAGE",
            payload: (e)=>e
        }
    ],
    "closed-caption-lt-status": [
        {
            event: "LT_STATUS_CHANGE",
            payload: (e)=>e
        }
    ],
    "closed-caption-lt-message": [
        {
            event: "LT_RECEIVE_MESSAGE",
            payload: (e)=>e
        }
    ],
    "closed-caption-status": [
        {
            event: "CC_ASSIGN_CC_EDITOR_SUCCESS",
            payload: (e)=>e
        },
        {
            event: "CC_STATUS_CHANGE",
            payload: (e)=>e
        }
    ],
    ...jc,
    ...Bc,
    ...Wc,
    ...Kc
}, qc = function(e) {
    return {
        all: e = e || new Map,
        on: function(t1, o) {
            var r = e.get(t1);
            r ? r.push(o) : e.set(t1, [
                o
            ]);
        },
        off: function(t1, o) {
            var r = e.get(t1);
            r && (o ? r.splice(r.indexOf(o) >>> 0, 1) : e.set(t1, []));
        },
        emit: function(t1, o) {
            var r = e.get(t1);
            r && r.slice().map(function(e) {
                e(o);
            }), (r = e.get("*")) && r.slice().map(function(e) {
                e(t1, o);
            });
        }
    };
}(), Jc = new Map, Qc = new Array, Zc = [
    Ea,
    Sa,
    ba
];
let Yc, Xc;
const ep = function(e) {
    let t1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
    qc.emit(e, t1);
};
function tp(e) {
    return Zc.includes(e) ? ze(qc, e) : (Yc && Xc || (Yc = new U, Xc = Ye(...Zc.map((e)=>ze(qc, e))).subscribe(Yc)), ze(qc, e).pipe(ht(Yc)));
}
const op = (e)=>new Promise((t1, o)=>{
        e.fail && e.fail.length > 0 ? ot(tp(e.success).pipe(it(1)), Ye(...e.fail.map((e)=>tp(e).pipe(it(1), Be((t1)=>Re({
                    type: e,
                    payload: t1
                })))))).subscribe({
            next: (e)=>t1(e),
            error (e) {
                "object" == typeof e.payload ? o({
                    type: e.type,
                    ...e.payload
                }) : void 0 === e.payload ? o({
                    type: e.type
                }) : o(e);
            }
        }) : tp(e.success).pipe(it(1)).subscribe((e)=>t1(e));
    }), rp = function(e, t1) {
    let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e4;
    return new Promise((r, i)=>{
        let n = ie;
        "string" == typeof e ? n = tp(e).pipe(it(1)) : (n = tp(e.event), e.operations && (n = e.operations.reduce((e, t1)=>e.pipe(t1), n))), ot(n, Qe(o).pipe(Be(()=>Re("timeout")))).subscribe({
            next (e) {
                if (t1) {
                    const o = t1(e);
                    "boolean" == typeof o ? o ? r("") : i({
                        type: Kl
                    }) : 0 === o.ret ? r(o.body) : i({
                        type: Kl,
                        reason: o.body
                    });
                } else r(e);
            },
            error () {
                i({
                    type: zl
                });
            }
        });
    });
}, ip = (e, t1)=>void 0 !== t1 ? tp(e).pipe(it(t1)) : tp(e);
function np(e) {
    return ot(...Zc.map((e)=>ip(e, 1)));
}
const sp = ()=>{
    var e;
    Qc.forEach((e)=>{
        e.unsubscribe();
    }), Qc.length = 0, Jc.clear(), Yc && (Yc.complete(), null === (e = Xc) || void 0 === e || e.unsubscribe(), Yc = void 0);
}, ap = "SET_ATTENDEES_LIST", dp = "SET_ASSISTANT_LIST", up = "RESET_PARTICIPANTS", lp = "SET_IS_ADMIT_ALL_SILENT_USERS", cp = "SET_CLEAR_RAISE_HAND", pp = "SET_CLEAR_ATTENDEE_FEEDBACK", hp = "ADD_FAILOVER_ATTENDEES", mp = "REMOVE_FAILOVER_ATTENDEES", gp = "UPDATE_ATTENDEE_DISPLAY_NAME", vp = "REMOVE_XMPP_ATTENDEE_USER", fp = "UPDATE_XMPP_ATTENDEE_LIST", yp = "SET_ATTENDEE_EXTRA_KEY", { setAttendeesList: Sp, setAssistantList: bp, setIsAdmitAllSilentUsers: Ep, resetParticipants: Ip, addFailoverAttendees: Ap, removeFailoverAttendees: Cp, setClearRaiseHand: _p, setClearAttendeeFeedback: Rp, updateAttendeeDisplayName: wp, removeXmppAttendeeUser: Tp, updateXmppAttendeeList: Op, setAttendeeExtraKey: Dp } = mo({
    [ap]: (e)=>e,
    [dp]: (e)=>e,
    [fp]: (e)=>e,
    [up]: ()=>({}),
    [lp]: (e)=>e,
    [mp]: (e)=>e,
    [hp]: (e)=>e,
    [cp]: ()=>({}),
    [pp]: ()=>({}),
    [gp]: (e)=>e,
    [vp]: (e)=>e,
    [yp]: (e)=>e
});
var Pp = "NOT_FOUND", Mp = function(e, t1) {
    return e === t1;
};
function kp(e, t1) {
    var o, r, i = "object" == typeof t1 ? t1 : {
        equalityCheck: t1
    }, n = i.equalityCheck, s = void 0 === n ? Mp : n, a = i.maxSize, d = void 0 === a ? 1 : a, u = i.resultEqualityCheck, l = function(e) {
        return function(t1, o) {
            if (null === t1 || null === o || t1.length !== o.length) return !1;
            for(var r = t1.length, i = 0; i < r; i++)if (!e(t1[i], o[i])) return !1;
            return !0;
        };
    }(s), c = 1 === d ? (o = l, {
        get: function(e) {
            return r && o(r.key, e) ? r.value : Pp;
        },
        put: function(e, t1) {
            r = {
                key: e,
                value: t1
            };
        },
        getEntries: function() {
            return r ? [
                r
            ] : [];
        },
        clear: function() {
            r = void 0;
        }
    }) : function(e, t1) {
        var o = [];
        function r(e) {
            var r = o.findIndex(function(o) {
                return t1(e, o.key);
            });
            if (r > -1) {
                var i = o[r];
                return r > 0 && (o.splice(r, 1), o.unshift(i)), i.value;
            }
            return Pp;
        }
        return {
            get: r,
            put: function(t1, i) {
                r(t1) === Pp && (o.unshift({
                    key: t1,
                    value: i
                }), o.length > e && o.pop());
            },
            getEntries: function() {
                return o;
            },
            clear: function() {
                o = [];
            }
        };
    }(d, l);
    function p() {
        var t1 = c.get(arguments);
        if (t1 === Pp) {
            if (t1 = e.apply(null, arguments), u) {
                var o = c.getEntries().find(function(e) {
                    return u(e.value, t1);
                });
                o && (t1 = o.value);
            }
            c.put(arguments, t1);
        }
        return t1;
    }
    return p.clearCache = function() {
        return c.clear();
    }, p;
}
function Lp(e) {
    for(var t1 = arguments.length, o = new Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
    return function() {
        for(var t1 = arguments.length, r = new Array(t1), i = 0; i < t1; i++)r[i] = arguments[i];
        var n, s = 0, a = {
            memoizeOptions: void 0
        }, d = r.pop();
        if ("object" == typeof d && (a = d, d = r.pop()), "function" != typeof d) throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof d + "]");
        var u = a.memoizeOptions, l = void 0 === u ? o : u, c = Array.isArray(l) ? l : [
            l
        ], p = function(e) {
            var t1 = Array.isArray(e[0]) ? e[0] : e;
            if (!t1.every(function(e) {
                return "function" == typeof e;
            })) {
                var o = t1.map(function(e) {
                    return "function" == typeof e ? "function " + (e.name || "unnamed") + "()" : typeof e;
                }).join(", ");
                throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + o + "]");
            }
            return t1;
        }(r), h = e.apply(void 0, [
            function() {
                return s++, d.apply(null, arguments);
            }
        ].concat(c)), m = e(function() {
            for(var e = [], t1 = p.length, o = 0; o < t1; o++)e.push(p[o].apply(null, arguments));
            return n = h.apply(null, e);
        });
        return Object.assign(m, {
            resultFunc: d,
            memoizedResultFunc: h,
            dependencies: p,
            lastResult: function() {
                return n;
            },
            recomputations: function() {
                return s;
            },
            resetRecomputations: function() {
                return s = 0;
            }
        }), m;
    };
}
var Np = Lp(kp);
const Vp = (e)=>{
    let { participants: { attendeesList: t1 } } = e;
    return t1;
}, Up = (e)=>{
    let { meeting: { userId: t1 } } = e;
    return t1;
}, jp = (e)=>{
    let { participants: { xmppAttendeeList: t1 } } = e;
    return t1;
};
let xp = function(e) {
    return e[e.Attendee = 0] = "Attendee", e[e.Host = 1] = "Host", e[e.Owner = 4] = "Owner", e[e.ViewOnly = 8] = "ViewOnly", e[e.HostOwner = 5] = "HostOwner", e[e.ViewOnlyCanTalk = 24] = "ViewOnlyCanTalk", e;
}({}), Bp = function(e) {
    return e[e.Host = 10] = "Host", e[e.Panelist = 20] = "Panelist", e[e.Attendee = 30] = "Attendee", e;
}({}), Fp = function(e) {
    return e[e.Client = 9] = "Client", e[e.Phone = 5] = "Phone", e[e.H323 = 15] = "H323", e[e.Assitant = 51] = "Assitant", e;
}({});
const Hp = (e)=>(e & xp.Host) === xp.Host, $p = (e)=>(e & Fp.Phone) === Fp.Phone, Wp = (e)=>e === xp.ViewOnlyCanTalk, Gp = (e)=>(e & xp.ViewOnly) === xp.ViewOnly;
let Kp = function(e) {
    return e[e.Automatically = 1] = "Automatically", e[e.Manually = 2] = "Manually", e[e.SelfSelect = 3] = "SelfSelect", e;
}({}), zp = function(e) {
    return e[e.NotStarted = 1] = "NotStarted", e[e.InProgress = 2] = "InProgress", e[e.Closing = 3] = "Closing", e[e.Closed = 4] = "Closed", e;
}({}), qp = function(e) {
    return e[e.NoToken = 1] = "NoToken", e[e.GotToken = 2] = "GotToken", e[e.Started = 3] = "Started", e[e.Closing = 4] = "Closing", e[e.Closed = 5] = "Closed", e;
}({}), Jp = function(e) {
    return e.Initial = "initial", e.Invited = "invited", e.Joining = "joining", e.InRoom = "in room", e.Leaving = "leaving", e.TimeUp = "time up", e.MainSession = "main session", e;
}({}), Qp = function(e) {
    return e.Join = "joinRequest", e.Switch = "switchRequest", e.Leave = "leaveRequest", e.Broadcast = "messageText", e.HelpReq = "helpRequest", e.HelpRes = "helpResponse", e.CoHostWantJoinThisBo = "wantJoinThisBO", e.BOActivity = "BOActivity", e;
}({});
const Zp = "Subsession";
let Yp = function(e) {
    return e[e.Received = 0] = "Received", e[e.Busy = 1] = "Busy", e[e.Ignore = 2] = "Ignore", e[e.AlreadyInRoom = 3] = "AlreadyInRoom", e;
}({}), Xp = function(e) {
    return e[e.AskToLeave = 0] = "AskToLeave", e[e.ClosingRoom = 1] = "ClosingRoom", e;
}({}), eh = function(e) {
    return e[e.Active = 0] = "Active", e[e.Ask = 1] = "Ask", e;
}({}), th = function(e) {
    return e[e.Connect = 1] = "Connect", e[e.Muted = 2] = "Muted", e[e.Voip = 4] = "Voip", e;
}({}), oh = function(e) {
    return e[e.Connect = 8] = "Connect", e[e.On = 16] = "On", e;
}({}), rh = function(e) {
    return e[e.Share = 32] = "Share", e[e.ShareAudio = 64] = "ShareAudio", e;
}({});
const ih = (e)=>{
    let { breakoutRoom: t1 } = e;
    return t1 && t1.controlStatus;
}, nh = (e)=>{
    let { breakoutRoom: t1 } = e;
    return t1 && t1.currentRoom.status;
}, sh = Np([
    Up,
    Vp
], (e, t1)=>t1.find((t1)=>t1.userId === e)), ah = Np([
    sh
], (e)=>(null == e ? void 0 : e.isHost) || (null == e ? void 0 : e.bCoHost)), dh = Np([
    sh
], (e)=>null == e ? void 0 : e.isHost), uh = Np([
    jp
], (e)=>e.filter((e)=>e.userRole === Bp.Attendee)), lh = Np([
    Vp
], (e)=>e.filter((e)=>e.bHold && !e.bid)), ch = Np([
    Vp,
    ih,
    nh
], (e, t1, o)=>t1 !== zp.InProgress && t1 !== zp.Closing || o !== Jp.InRoom ? e.filter((e)=>!e.bHold && !e.bid) : e.filter((e)=>!e.bHold)), ph = Np([
    (e)=>{
        let { participants: { assistantList: t1 } } = e;
        return t1;
    }
], (e)=>e), hh = Np([
    ch
], (e)=>e.find((e)=>e.isHost)), mh = Np([
    ch
], (e)=>e.filter((e)=>e.bCoHost)), gh = Np([
    sh,
    ch
], (e, t1)=>t1.filter((t1)=>t1.userId !== (null == e ? void 0 : e.userId)));
Np([
    jp
], (e)=>e.reduce((e, t1)=>{
        const { jid: o } = t1;
        return Object.assign(e, {
            [o]: t1
        }), e;
    }, {})), Np([
    jp,
    (e)=>{
        let { meeting: { jid: t1 } } = e;
        return t1;
    }
], (e, t1)=>{
    var o;
    return null === (o = e.find((e)=>e.jid === t1)) || void 0 === o ? void 0 : o.userId;
});
const vh = Np([
    Vp
], function() {
    return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).some((e)=>(null == e ? void 0 : e.bLocalRecord) === qa.Start);
}), fh = Np([
    ih,
    (e)=>{
        let { meeting: t1 } = e;
        return t1 && t1.meetingOptions;
    },
    Vp,
    dh
], (e, t1, o, r)=>{
    const i = o.filter((e)=>e.bCoHost), { moveToWRIfHostLeave: n } = t1, s = e === zp.InProgress;
    return r && !!n && i.length <= 0 && !s && o.length > 1;
});
Np([
    Vp,
    nh,
    (e)=>{
        let { breakoutRoom: t1 } = e;
        return t1 && t1.mainSessionAttendeeList;
    }
], (e, t1, o)=>(t1 === Jp.InRoom ? o : e).filter((e)=>{
        return !(e.bHold || e.isHost || e.audio === $d.Phone || $p(null == e ? void 0 : e.userType) || (t1 = null == e ? void 0 : e.caps, o = null == e ? void 0 : e.bMultiStreamVideoUser, ((e, t1)=>((e)=>!!(128 & e))(e) && void 0 !== t1)(t1, o) && o));
        "TURBOPACK unreachable";
        var t1, o;
    }));
let yh = function(e) {
    return e.Closed = "closed", e.Connecting = "connecting", e.Connected = "connected", e;
}({});
function Sh(e) {
    return 1 << e - 1;
}
let bh = function(e) {
    return e[e.SupportASL = Sh(1)] = "SupportASL", e[e.SidecarPhase2 = Sh(2)] = "SidecarPhase2", e[e.SupportBroadcastVoice = Sh(4)] = "SupportBroadcastVoice", e[e.SendMeetingTokenSeparately = Sh(5)] = "SendMeetingTokenSeparately", e[e.SupportPreview = Sh(6)] = "SupportPreview", e[e.WebCameraIndication = Sh(7)] = "WebCameraIndication", e[e.SupportFarEndCameraControl = Sh(9)] = "SupportFarEndCameraControl", e[e.SupportVideoShare = Sh(10)] = "SupportVideoShare", e[e.UnifyErrorType = Sh(11)] = "UnifyErrorType", e[e.WhiteBoard = Sh(12)] = "WhiteBoard", e[e.RequestRemoteControl = Sh(14)] = "RequestRemoteControl", e[e.SmartSummary = Sh(15)] = "SmartSummary", e[e.LocalRecording = Sh(16)] = "LocalRecording", e[e.LocalRecordingGrantPermission = Sh(17)] = "LocalRecordingGrantPermission", e[e.ShareMultiStream = Sh(18)] = "ShareMultiStream", e[e.VideoLTR = Sh(19)] = "VideoLTR", e[e.WebrtcAudioRtcpTime = Sh(20)] = "WebrtcAudioRtcpTime", e[e.SupportSend1080PVideo = Sh(29)] = "SupportSend1080PVideo", e[e.SupportSend1080PVideoShare = Sh(30)] = "SupportSend1080PVideoShare", e;
}({});
const { setAsnIds: Eh, setIsCanUnmute: Ih, setDialoutSequence: Ah, setDialoutResultCode: Ch, setIsAllowToTalk: _h, setAudioSsrc: Rh, setIsMutedUponEntry: wh, setIsUserGrantCaptureAudio: Th, setIsMicrophoneForbidden: Oh, setWebrtcRestartCount: Dh, setMicrophoneList: Ph, setSpeakerList: Mh, setActiveMicrophone: kh, setActiveSpeaker: Lh, setCanPlayAudio: Nh, resetAudio: Vh, setIsComputerAudioLoading: Uh, setIsAllowToTalkAttendeeConnected: jh, setIsMuteBeforeSharingAudio: xh, addLocalShareAudioUser: Bh, updateLocalShareAudioUser: Fh, setIsJoinComputerAudioBeforeSharingAudio: Hh, setIsShareAudioEnabled: $h, setIsShareAudioMuted: Wh, setIsSharingAudio: Gh, setAudioDataEncoding: Kh, setAudioDataDecoding: zh, addLocallyMutedAudio: qh, removeLocallyMutedAudio: Jh, updateUserAudioVolumeLocally: Qh, removeLocalUserAudioVolume: Zh, setCustomizedAudioOption: Yh, setIsBackgroundNoiseSuppression: Xh, setIsHidEnabled: em, setAudioMediaPlaybackFile: tm, setIsStopAllIncomingAudio: om, setIsVerifiedAudioPermissionOnIosMobile: rm, setIsAudioBridgeSignalReconnecting: im, setAudioMutedSource: nm, setAudioUnmutedSource: sm, setAudioOriginalSound: am, setLeaveAudioSource: dm, setSecondaryAudioMicrophoneId: um, setCrcCallOutSequence: lm, setCrcCallOutReturnCode: cm } = mo("SET_ASN_IDS", "SET_IS_CAN_UNMUTE", "SET_DIALOUT_SEQUENCE", "SET_DIALOUT_RESULT_CODE", "SET_IS_ALLOW_TO_TALK", "SET_AUDIO_SSRC", "SET_IS_MUTED_UPON_ENTRY", "SET_IS_USER_GRANT_CAPTURE_AUDIO", "SET_IS_MICROPHONE_FORBIDDEN", "SET_WEBRTC_RESTART_COUNT", "SET_MICROPHONE_LIST", "SET_SPEAKER_LIST", "SET_ACTIVE_MICROPHONE", "SET_ACTIVE_SPEAKER", "SET_CAN_PLAY_AUDIO", "RESET_AUDIO", "SET_IS_COMPUTER_AUDIO_LOADING", "SET_IS_ALLOW_TO_TALK_ATTENDEE_CONNECTED", "SET_IS_MUTE_BEFORE_SHARING_AUDIO", "SET_IS_SHARING_AUDIO", "ADD_LOCAL_SHARE_AUDIO_USER", "UPDATE_LOCAL_SHARE_AUDIO_USER", "SET_IS_JOIN_COMPUTER_AUDIO_BEFORE_SHARING_AUDIO", "SET_IS_SHARE_AUDIO_ENABLED", "SET_IS_SHARE_AUDIO_MUTED", "SET_AUDIO_DATA_ENCODING", "SET_AUDIO_DATA_DECODING", "ADD_LOCALLY_MUTED_AUDIO", "REMOVE_LOCALLY_MUTED_AUDIO", "UPDATE_USER_AUDIO_VOLUME_LOCALLY", "REMOVE_LOCAL_USER_AUDIO_VOLUME", "SET_CUSTOMIZED_AUDIO_OPTION", "SET_IS_BACKGROUND_NOISE_SUPPRESSION", "SET_IS_HID_ENABLED", "SET_AUDIO_MEDIA_PLAYBACK_FILE", "SET_IS_STOP_ALL_INCOMING_AUDIO", "SET_IS_VERIFIED_AUDIO_PERMISSION_ON_IOS_MOBILE", "SET_IS_AUDIO_BRIDGE_SIGNAL_RECONNECTING", "SET_AUDIO_MUTED_SOURCE", "SET_AUDIO_UNMUTED_SOURCE", "SET_AUDIO_ORIGINAL_SOUND", "SET_LEAVE_AUDIO_SOURCE", "SET_SECONDARY_AUDIO_MICROPHONE_ID", "SET_CRC_CALL_OUT_SEQUENCE", "SET_CRC_CALL_OUT_RETURN_CODE"), { setSharePrivilege: pm, setShareActiveNode: hm, setIsReceiveSharing: mm, setIsChromeExtensionInstalled: gm, setIsScreenShareForbidden: vm, setShareDimension: fm, setShareStatus: ym, setShareSsrc: Sm, setShareQuality: bm, setReceivedShareDimension: Em, setIsGrabRemoteControl: Im, setIsSdkGrabControl: Am, setIsReceiveSharingFromMainSession: Cm, setIsSharingToBreakoutRoom: _m, setIsSharingWithSecondCamera: Rm, setShringSecondCameraId: wm, setIsRequireReadReceipt: Tm, setIsOptimizedForSharedVideo: Om, setShareDataEncoding: Dm, setShareDataDecoding: Pm, addShareCapturedEnsuredCanvas: Mm, addShareRenderedEnsuredCanvas: km, setRemoteControlCurrentSsrc: Lm, setRemoteControllingSsrc: Nm, setApprovedRemoteControlSsrc: Vm, setRemoteControlAppDownloadUrl: Um, setRemoteControlAppInstallStatus: jm, remoteControlAppStatusFallbackCheck: xm, remoteControlAppLaunchedCheck: Bm, setIsEnableAutoDeleteRcApp: Fm, setRemoteControlAppLaunchSheme: Hm, addSharingUserIdSsrcMapping: $m, addRemoteControlledUser: Wm, removeRemoteControlledUser: Gm, setRemoteControlSetting: Km, setRemoteControlViewportDomSelector: zm, setIsFullHdVideoShareEnabled: qm, resetShare: Jm } = mo("SET_SHARE_PRIVILEGE", "SET_SHARE_ACTIVE_NODE", "SET_IS_RECEIVE_SHARING", "SET_IS_CHROME_EXTENSION_INSTALLED", "SET_IS_SCREEN_SHARE_FORBIDDEN", "SET_SHARE_DIMENSION", "SET_SHARE_STATUS", "SET_SHARE_SSRC", "SET_SHARE_QUALITY", "SET_RECEIVED_SHARE_DIMENSION", "SET_IS_GRAB_REMOTE_CONTROL", "SET_IS_SDK_GRAB_CONTROL", "SET_IS_RECEIVE_SHARING_FROM_MAIN_SESSION", "SET_IS_SHARING_TO_BREAKOUT_ROOM", "SET_IS_SHARING_WITH_SECOND_CAMERA", "SET_SHRING_SECOND_CAMERA_ID", "SET_IS_REQUIRE_READ_RECEIPT", "SET_IS_OPTIMIZED_FOR_SHARED_VIDEO", "SET_SHARE_DATA_ENCODING", "SET_SHARE_DATA_DECODING", "ADD_SHARE_CAPTURED_ENSURED_CANVAS", "ADD_SHARE_RENDERED_ENSURED_CANVAS", "SET_REMOTE_CONTROL_CURRENT_SSRC", "SET_REMOTE_CONTROLLING_SSRC", "SET_APPROVED_REMOTE_CONTROL_SSRC", "SET_REMOTE_CONTROL_APP_DOWNLOAD_URL", "SET_REMOTE_CONTROL_APP_INSTALL_STATUS", "REMOTE_CONTROL_APP_STATUS_FALLBACK_CHECK", "REMOTE_CONTROL_APP_LAUNCHED_CHECK", "SET_IS_ENABLE_AUTO_DELETE_RC_APP", "SET_REMOTE_CONTROL_APP_LAUNCH_SHEME", "ADD_SHARING_USER_ID_SSRC_MAPPING", "ADD_REMOTE_CONTROLLED_USER", "REMOVE_REMOTE_CONTROLLED_USER", "SET_REMOTE_CONTROL_SETTING", "SET_REMOTE_CONTROL_VIEWPORT_DOM_SELECTOR", "SET_IS_FULL_HD_VIDEO_SHARE_ENABLED", "RESET_SHARE"), { setVideoSsrc: Qm, setActiveVideoId: Zm, setCameraList: Ym, setActiveCamera: Xm, setIsCurrentUserStartedVideo: eg, setSpotlightVideo: tg, setIsCaptureForbidden: og, setVideoMaxQuality: rg, setIsVideoMuted: ig, setIsCaptureCameraLoading: ng, setIsCameraTaken: sg, resetVideo: ag, setReceivedVideoDimension: dg, addSubscribedVideoId: ug, removeSubscribedVideoId: lg, setIsFollowHostVideoLayout: cg, setHostDragLayout: pg, addRenderedVideoId: hg, removeRenderedVideoId: mg, setIsSupportHdVideo: gg, setMaximumNumbeOfHdSubscriptions: vg, setIsCanUnmuteVideo: fg, setIsVbPreloadReady: yg, setIsVbConfiged: Sg, setVbImageSrc: bg, setVideoDataEncoding: Eg, setVideoDataDecoding: Ig, setHardwareAccelerationState: Ag, setVideoCaptureCustomizedOption: Cg, setNetworkQuality: _g, setVideoCameraPtzCapabilities: Rg, setIsCurrentUserRequestCameraControlled: wg, setIsCurrentUserCameraInControl: Tg, addVideoFarEndCameraControlUser: Og, removeVideoFarEndCameraControlUser: Dg, setVideoPtzCameraMoving: Pg, setVideoPtzCameraValue: Mg, setIsControllingFarEndCamera: kg, setNetworkQualityBroadcastTime: Lg, setIsMaskConfiged: Ng, setVideoBackgroundMode: Vg, setVideoMask: Ug, setVideoCapturedDimension: jg, addVideoRenderedEnsuredCanvas: xg, setVideoMediaPlaybackFile: Bg, setPrefetchedVideoUser: Fg, setVideoQosSubscriptionStatus: Hg, setIsSupportFullHdVideo: $g, addVideoPlayerAttachment: Wg, removeVideoPlayerAttachment: Gg, setIsWebGl2RendererType: Kg, setIsWebGpuRendererType: zg, setVideoRendererType: qg, setIsVideoMirrored: Jg, addSelfPreviewVideoTag: Qg, removeSelfPreviewVideoTag: Zg, setVideoLeadershipUserId: Yg } = mo("SET_VIDEO_SSRC", "SET_ACTIVE_VIDEO_ID", "SET_CAMERA_LIST", "SET_ACTIVE_CAMERA", "SET_IS_CURRENT_USER_STARTED_VIDEO", "SET_SPOTLIGHT_VIDEO", "SET_IS_CAPTURE_FORBIDDEN", "SET_VIDEO_MAX_QUALITY", "SET_IS_VIDEO_MUTED", "SET_IS_CAPTURE_CAMERA_LOADING", "SET_IS_CAMERA_TAKEN", "RESET_VIDEO", "SET_RECEIVED_VIDEO_DIMENSION", "ADD_SUBSCRIBED_VIDEO_ID", "REMOVE_SUBSCRIBED_VIDEO_ID", "SET_IS_FOLLOW_HOST_VIDEO_LAYOUT", "SET_HOST_DRAG_LAYOUT", "ADD_RENDERED_VIDEO_ID", "REMOVE_RENDERED_VIDEO_ID", "SET_IS_SUPPORT_HD_VIDEO", "SET_MAXIMUM_NUMBE_OF_HD_SUBSCRIPTIONS", "SET_IS_CAN_UNMUTE_VIDEO", "SET_IS_VB_PRELOAD_READY", "SET_IS_VB_CONFIGED", "SET_VB_IMAGE_SRC", "SET_VIDEO_DATA_ENCODING", "SET_VIDEO_DATA_DECODING", "SET_HARDWARE_ACCELERATION_STATE", "SET_VIDEO_CAPTURE_CUSTOMIZED_OPTION", "SET_NETWORK_QUALITY", "SET_VIDEO_CAMERA_PTZ_CAPABILITIES", "SET_IS_CURRENT_USER_REQUEST_CAMERA_CONTROLLED", "SET_IS_CURRENT_USER_CAMERA_IN_CONTROL", "ADD_VIDEO_FAR_END_CAMERA_CONTROL_USER", "REMOVE_VIDEO_FAR_END_CAMERA_CONTROL_USER", "SET_VIDEO_PTZ_CAMERA_MOVING", "SET_VIDEO_PTZ_CAMERA_VALUE", "SET_IS_CONTROLLING_FAR_END_CAMERA", "SET_NETWORK_QUALITY_BROADCAST_TIME", "SET_IS_MASK_CONFIGED", "SET_VIDEO_BACKGROUND_MODE", "SET_VIDEO_MASK", "SET_VIDEO_CAPTURED_DIMENSION", "ADD_VIDEO_RENDERED_ENSURED_CANVAS", "SET_VIDEO_MEDIA_PLAYBACK_FILE", "SET_PREFETCHED_VIDEO_USER", "SET_VIDEO_QOS_SUBSCRIPTION_STATUS", "SET_IS_SUPPORT_FULL_HD_VIDEO", "ADD_VIDEO_PLAYER_ATTACHMENT", "REMOVE_VIDEO_PLAYER_ATTACHMENT", "SET_IS_WEB_GL2_RENDERER_TYPE", "SET_IS_WEB_GPU_RENDERER_TYPE", "SET_VIDEO_RENDERER_TYPE", "SET_IS_VIDEO_MIRRORED", "ADD_SELF_PREVIEW_VIDEO_TAG", "REMOVE_SELF_PREVIEW_VIDEO_TAG", "SET_VIDEO_LEADERSHIP_USER_ID"), { setQaSetting: Xg, addQaQuestion: ev, addQaAnswer: tv, removeQaComment: ov, removeQaQuestion: rv, dismissQaQuestion: iv, reopenQaQuestion: nv, voteQaQuestion: sv, answerQaQuestionLive: av, updateAttendeeAnonymousQuestion: dv, setQaEnabled: uv, resetQa: lv } = mo("SET_QA_SETTING", "ADD_QA_QUESTION", "ADD_QA_ANSWER", "REMOVE_QA_COMMENT", "REMOVE_QA_QUESTION", "DISMISS_QA_QUESTION", "REOPEN_QA_QUESTION", "VOTE_QA_QUESTION", "ANSWER_QA_QUESTION_LIVE", "UPDATE_ATTENDEE_ANONYMOUS_QUESTION", "SET_QA_ENABLED", "RESET_QA"), { setChatPrivilege: cv, setPanelistChatPrivilege: pv, addChatMessageHistory: hv, resetChat: mv, setIsAllowAttendeeChat: gv, setLatestChatMessageId: vv, removeChatMessage: fv, setFileChatSetting: yv, addChatFileRecord: Sv, updateChatFileRecord: bv, cancelSendFileChat: Ev, addFailedChatFileTransfer: Iv, setChatFileMessageId: Av, cancelDownloadFileChat: Cv } = mo("SET_CHAT_PRIVILEGE", "SET_PANELIST_CHAT_PRIVILEGE", "ADD_CHAT_MESSAGE_HISTORY", "RESET_CHAT", "SET_IS_ALLOW_ATTENDEE_CHAT", "SET_LATEST_CHAT_MESSAGE_ID", "REMOVE_CHAT_MESSAGE", "SET_FILE_CHAT_SETTING", "ADD_CHAT_FILE_RECORD", "UPDATE_CHAT_FILE_RECORD", "CANCEL_SEND_FILE_CHAT", "ADD_FAILED_CHAT_FILE_TRANSFER", "SET_CHAT_FILE_MESSAGE_ID", "CANCEL_DOWNLOAD_FILE_CHAT"), { setCcEditorInfo: _v, setTempSendCcText: Rv, setCcLtMessage: wv, setTempReceiveLtText: Tv, setTempReceiveCcText: Ov, setGatewayInfoList: Dv, setLtEnable: Pv, setIsListenClosedCaption: Mv, setCcEnable: kv, allowParticipantAskLt: Lv, receiveAskStartLt: Nv, setMeetingEnabledLtFeature: Vv, updateLtStatus: Uv, deleteMessage: jv, updateMessage: xv, resetClosedCaption: Bv } = mo("SET_CC_EDITOR_INFO", "SET_CC_LT_MESSAGE", "SET_TEMP_SEND_CC_TEXT", "SET_TEMP_RECEIVE_LT_TEXT", "SET_TEMP_RECEIVE_CC_TEXT", "SET_GATEWAY_INFO_LIST", "SET_LT_ENABLE", "SET_IS_LISTEN_CLOSED_CAPTION", "SET_CC_ENABLE", "ALLOW_PARTICIPANT_ASK_LT", "RECEIVE_ASK_START_LT", "SET_MEETING_ENABLED_LT_FEATURE", "UPDATE_LT_STATUS", "DELETE_MESSAGE", "UPDATE_MESSAGE", "RESET_CLOSED_CAPTION"), { addBreakoutRooms: Fv, setBreakoutRoomAllocationPattern: Hv, setBreakoutRoomSequenceId: $v, setMeetingElapsedTime: Wv, setStartRoomElapsedTime: Gv, setBreakoutRoomOptions: Kv, setBreakoutRoomControlStatus: zv, setBreakoutRooms: qv, setCurrentBreakoutRoom: Jv, setBreakoutRoomAttendeeStatus: Qv, setBreakoutRoomConfId: Zv, setBreakoutRoomToken: Yv, resetBreakoutRoom: Xv, setBreakoutRoomClosingRoomTime: ef, setBreakoutRoomBroadcastMessage: tf, setBreakoutRoomHostReplyType: of, setBreakoutRoomHostReplyRequestId: rf, setMainSessionAttendeeList: nf, setIsHugeBreakoutRoom: sf, setBreakoutRoomPreAssignedRoomList: af, setBreakoutRoomUserRoleUpdated: df, setBreakoutRoomMeetingOptions: uf, setBreakoutRoomUserActivityStatus: lf, setBreakoutRoomIsBroadcastVoice: cf } = mo("ADD_BREAKOUT_ROOMS", "SET_BREAKOUT_ROOM_ALLOCATION_PATTERN", "SET_BREAKOUT_ROOM_SEQUENCE_ID", "SET_MEETING_ELAPSED_TIME", "SET_START_ROOM_ELAPSED_TIME", "SET_BREAKOUT_ROOM_OPTIONS", "SET_BREAKOUT_ROOM_CONTROL_STATUS", "SET_BREAKOUT_ROOMS", "SET_CURRENT_BREAKOUT_ROOM", "SET_BREAKOUT_ROOM_ATTENDEE_STATUS", "SET_BREAKOUT_ROOM_CONF_ID", "SET_BREAKOUT_ROOM_TOKEN", "RESET_BREAKOUT_ROOM", "SET_BREAKOUT_ROOM_CLOSING_ROOM_TIME", "SET_BREAKOUT_ROOM_BROADCAST_MESSAGE", "SET_BREAKOUT_ROOM_HOST_REPLY_TYPE", "SET_BREAKOUT_ROOM_HOST_REPLY_REQUEST_ID", "SET_MAIN_SESSION_ATTENDEE_LIST", "SET_IS_HUGE_BREAKOUT_ROOM", "SET_BREAKOUT_ROOM_PRE_ASSIGNED_ROOM_LIST", "SET_BREAKOUT_ROOM_USER_ROLE_UPDATED", "SET_BREAKOUT_ROOM_MEETING_OPTIONS", "SET_BREAKOUT_ROOM_USER_ACTIVITY_STATUS", "SET_BREAKOUT_ROOM_IS_BROADCAST_VOICE"), { setCloudRecordingStatus: pf, setCloudRecordingEnable: hf, setCloudIsoRecordingEnable: mf, setAllowStopAutoRecording: gf, setAutomaticCloudRecordingEnable: vf, setIsZoomIQ: ff, setZoomIQChanging: yf, setLocalRecordStatus: Sf, setSupportLocalRecording: bf, setLocalGrantPermissionOption: Ef, setLocalPermissionUserList: If, resetRecording: Af } = mo("SET_CLOUD_RECORDING_STATUS", "SET_CLOUD_RECORDING_ENABLE", "SET_CLOUD_ISO_RECORDING_ENABLE", "SET_ALLOW_STOP_AUTO_RECORDING", "SET_AUTOMATIC_CLOUD_RECORDING_ENABLE", "SET_IS_ZOOM_I_Q", "SET_ZOOM_I_Q_CHANGING", "SET_LOCAL_RECORD_STATUS", "SET_SUPPORT_LOCAL_RECORDING", "SET_LOCAL_GRANT_PERMISSION_OPTION", "SET_LOCAL_PERMISSION_USER_LIST", "RESET_RECORDING"), { updateCmdJid: Cf, removeCmdJid: _f, setCmdChannelConnectionStatus: Rf, resetCmdChannel: wf } = mo("UPDATE_CMD_JID", "REMOVE_CMD_JID", "SET_CMD_CHANNEL_CONNECTION_STATUS", "RESET_CMD_CHANNEL"), Tf = "SET_ARCHIVING_STATUS", Of = "SET_ARCHIVING_SESSION_READY", Df = "SET_ARCHIVING_OPTIONS", Pf = "RESET_ARCHIVING", { setArchivingStatus: Mf, setArchivingSessionReady: kf, setArchivingOptions: Lf, resetArchiving: Nf } = mo({
    [Tf]: (e)=>e,
    [Of]: (e)=>e,
    [Df]: (e)=>e,
    [Pf]: ()=>{}
}), { setIsLiveTranscriptionEnabled: Vf, setLiveTranscriptionMeetingOptions: Uf, setIsLiveTranscriptionManualCaptionerEnabled: jf, setLiveTranscriptionGatewayId: xf, setLiveTranscriptionSupportedLanguage: Bf, setIsLiveTranscriptionSubscribed: Ff, setCurrentTranscriptionLang: Hf, setCurrentTranslationLang: $f, addLiveTranscriptionMessage: Wf, updateLiveTranscriptionMessage: Gf, reduceLiveTranscriptionMessages: Kf, setLiveTranscriptionEngineType: zf, removeLiveTranscriptionFailoverState: qf, setLiveTranscriptionLastCaptionMessage: Jf, resetLiveTranscription: Qf, setIsHostDisableCaptions: Zf } = mo("SET_IS_LIVE_TRANSCRIPTION_ENABLED", "SET_LIVE_TRANSCRIPTION_MEETING_OPTIONS", "SET_IS_LIVE_TRANSCRIPTION_MANUAL_CAPTIONER_ENABLED", "SET_LIVE_TRANSCRIPTION_GATEWAY_ID", "SET_LIVE_TRANSCRIPTION_SUPPORTED_LANGUAGE", "SET_IS_LIVE_TRANSCRIPTION_SUBSCRIBED", "SET_CURRENT_TRANSCRIPTION_LANG", "SET_CURRENT_TRANSLATION_LANG", "ADD_LIVE_TRANSCRIPTION_MESSAGE", "UPDATE_LIVE_TRANSCRIPTION_MESSAGE", "REDUCE_LIVE_TRANSCRIPTION_MESSAGES", "SET_LIVE_TRANSCRIPTION_ENGINE_TYPE", "REMOVE_LIVE_TRANSCRIPTION_FAILOVER_STATE", "SET_LIVE_TRANSCRIPTION_LAST_CAPTION_MESSAGE", "RESET_LIVE_TRANSCRIPTION", " SET_IS_HOST_DISABLE_CAPTIONS"), { setPollData: Yf, setPollingId: Xf, setPollingWebLinks: ey, setPollingDocMaxSize: ty, setPollingDocSize: oy, setPollingDocLibraryMaxSize: ry, setPollingDocLibrarySize: iy, setIsRwgEnablePolling: ny, setHasPollingInMeeting: sy, resetPoll: ay } = mo("SET_POLL_DATA", "SET_POLLING_ID", "SET_POLLING_WEB_LINKS", "SET_POLLING_DOC_MAX_SIZE", "SET_POLLING_DOC_SIZE", "SET_POLLING_DOC_LIBRARY_MAX_SIZE", "SET_POLLING_DOC_LIBRARY_SIZE", "SET_IS_RWG_ENABLE_POLLING", "SET_HAS_POLLING_IN_MEETING", "RESET_POLL"), { setLoggerInitOptions: dy, setIsLaplaceInitialized: uy, resetLogger: ly } = mo("SET_LOGGER_INIT_OPTIONS", "SET_IS_LAPLACE_INITIALIZED", "RESET_LOGGER"), { setIsLiveStreamEnable: cy, setLiveStreamStatus: py, resetLiveStream: hy } = mo("SET_IS_LIVE_STREAM_ENABLE", "SET_LIVE_STREAM_STATUS", "RESET_LIVE_STREAM");
var my, gy, vy = {
    exports: {}
}, fy = {
    exports: {}
}, yy = jt(Object.freeze({
    __proto__: null,
    default: {},
    loadAsync: function() {}
}));
var Sy = (gy || (gy = 1, function(e, t1) {
    var o = function(e, t1) {
        return o = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(e, t1) {
            e.__proto__ = t1;
        } || function(e, t1) {
            for(var o in t1)t1.hasOwnProperty(o) && (e[o] = t1[o]);
        }, o(e, t1);
    };
    function r(e, t1) {
        function r() {
            this.constructor = e;
        }
        o(e, t1), e.prototype = null === t1 ? Object.create(t1) : (r.prototype = t1.prototype, new r);
    }
    var i, n = function() {
        return n = Object.assign || function(e) {
            for(var t1, o = 1, r = arguments.length; o < r; o++)for(var i in t1 = arguments[o])Object.prototype.hasOwnProperty.call(t1, i) && (e[i] = t1[i]);
            return e;
        }, n.apply(this, arguments);
    };
    function s() {}
    function a() {
        a.init.call(this);
    }
    function d(e) {
        return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners;
    }
    function u(e, t1, o, r) {
        var i, n, a;
        if ("function" != typeof o) throw new TypeError('"listener" argument must be a function');
        if ((n = e._events) ? (n.newListener && (e.emit("newListener", t1, o.listener ? o.listener : o), n = e._events), a = n[t1]) : (n = e._events = new s, e._eventsCount = 0), a) {
            if ("function" == typeof a ? a = n[t1] = r ? [
                o,
                a
            ] : [
                a,
                o
            ] : r ? a.unshift(o) : a.push(o), !a.warned && (i = d(e)) && i > 0 && a.length > i) {
                a.warned = !0;
                var u = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + t1 + " listeners added. Use emitter.setMaxListeners() to increase limit");
                u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t1, u.count = a.length, function(e) {
                    "function" == typeof console.warn ? console.warn(e) : console.log(e);
                }(u);
            }
        } else a = n[t1] = o, ++e._eventsCount;
        return e;
    }
    function l(e, t1, o) {
        var r = !1;
        function i() {
            e.removeListener(t1, i), r || (r = !0, o.apply(e, arguments));
        }
        return i.listener = o, i;
    }
    function c(e) {
        var t1 = this._events;
        if (t1) {
            var o = t1[e];
            if ("function" == typeof o) return 1;
            if (o) return o.length;
        }
        return 0;
    }
    function p(e, t1) {
        for(var o = new Array(t1); t1--;)o[t1] = e[t1];
        return o;
    }
    s.prototype = Object.create(null), a.EventEmitter = a, a.usingDomains = !1, a.prototype.domain = void 0, a.prototype._events = void 0, a.prototype._maxListeners = void 0, a.defaultMaxListeners = 10, a.init = function() {
        this.domain = null, a.usingDomains && i.active && i.Domain, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new s, this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, a.prototype.setMaxListeners = function(e) {
        if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number');
        return this._maxListeners = e, this;
    }, a.prototype.getMaxListeners = function() {
        return d(this);
    }, a.prototype.emit = function(e) {
        var t1, o, r, i, n, s, a, d = "error" === e;
        if (s = this._events) d = d && null == s.error;
        else if (!d) return !1;
        if (a = this.domain, d) {
            if (t1 = arguments[1], !a) {
                if (t1 instanceof Error) throw t1;
                var u = new Error('Uncaught, unspecified "error" event. (' + t1 + ")");
                throw u.context = t1, u;
            }
            return t1 || (t1 = new Error('Uncaught, unspecified "error" event')), t1.domainEmitter = this, t1.domain = a, t1.domainThrown = !1, a.emit("error", t1), !1;
        }
        if (!(o = s[e])) return !1;
        var l = "function" == typeof o;
        switch(r = arguments.length){
            case 1:
                !function(e, t1, o) {
                    if (t1) e.call(o);
                    else for(var r = e.length, i = p(e, r), n = 0; n < r; ++n)i[n].call(o);
                }(o, l, this);
                break;
            case 2:
                !function(e, t1, o, r) {
                    if (t1) e.call(o, r);
                    else for(var i = e.length, n = p(e, i), s = 0; s < i; ++s)n[s].call(o, r);
                }(o, l, this, arguments[1]);
                break;
            case 3:
                !function(e, t1, o, r, i) {
                    if (t1) e.call(o, r, i);
                    else for(var n = e.length, s = p(e, n), a = 0; a < n; ++a)s[a].call(o, r, i);
                }(o, l, this, arguments[1], arguments[2]);
                break;
            case 4:
                !function(e, t1, o, r, i, n) {
                    if (t1) e.call(o, r, i, n);
                    else for(var s = e.length, a = p(e, s), d = 0; d < s; ++d)a[d].call(o, r, i, n);
                }(o, l, this, arguments[1], arguments[2], arguments[3]);
                break;
            default:
                for(i = new Array(r - 1), n = 1; n < r; n++)i[n - 1] = arguments[n];
                !function(e, t1, o, r) {
                    if (t1) e.apply(o, r);
                    else for(var i = e.length, n = p(e, i), s = 0; s < i; ++s)n[s].apply(o, r);
                }(o, l, this, i);
        }
        return !0;
    }, a.prototype.addListener = function(e, t1) {
        return u(this, e, t1, !1);
    }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(e, t1) {
        return u(this, e, t1, !0);
    }, a.prototype.once = function(e, t1) {
        if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
        return this.on(e, l(this, e, t1)), this;
    }, a.prototype.prependOnceListener = function(e, t1) {
        if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
        return this.prependListener(e, l(this, e, t1)), this;
    }, a.prototype.removeListener = function(e, t1) {
        var o, r, i, n, a;
        if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
        if (!(r = this._events)) return this;
        if (!(o = r[e])) return this;
        if (o === t1 || o.listener && o.listener === t1) 0 == --this._eventsCount ? this._events = new s : (delete r[e], r.removeListener && this.emit("removeListener", e, o.listener || t1));
        else if ("function" != typeof o) {
            for(i = -1, n = o.length; n-- > 0;)if (o[n] === t1 || o[n].listener && o[n].listener === t1) {
                a = o[n].listener, i = n;
                break;
            }
            if (i < 0) return this;
            if (1 === o.length) {
                if (o[0] = void 0, 0 == --this._eventsCount) return this._events = new s, this;
                delete r[e];
            } else !function(e, t1) {
                for(var o = t1, r = o + 1, i = e.length; r < i; o += 1, r += 1)e[o] = e[r];
                e.pop();
            }(o, i);
            r.removeListener && this.emit("removeListener", e, a || t1);
        }
        return this;
    }, a.prototype.removeAllListeners = function(e) {
        var t1, o;
        if (!(o = this._events)) return this;
        if (!o.removeListener) return 0 === arguments.length ? (this._events = new s, this._eventsCount = 0) : o[e] && (0 == --this._eventsCount ? this._events = new s : delete o[e]), this;
        if (0 === arguments.length) {
            for(var r, i = Object.keys(o), n = 0; n < i.length; ++n)"removeListener" !== (r = i[n]) && this.removeAllListeners(r);
            return this.removeAllListeners("removeListener"), this._events = new s, this._eventsCount = 0, this;
        }
        if ("function" == typeof (t1 = o[e])) this.removeListener(e, t1);
        else if (t1) do {
            this.removeListener(e, t1[t1.length - 1]);
        }while (t1[0])
        return this;
    }, a.prototype.listeners = function(e) {
        var t1, o = this._events;
        return o && (t1 = o[e]) ? "function" == typeof t1 ? [
            t1.listener || t1
        ] : function(e) {
            for(var t1 = new Array(e.length), o = 0; o < t1.length; ++o)t1[o] = e[o].listener || e[o];
            return t1;
        }(t1) : [];
    }, a.listenerCount = function(e, t1) {
        return "function" == typeof e.listenerCount ? e.listenerCount(t1) : c.call(e, t1);
    }, a.prototype.listenerCount = c, a.prototype.eventNames = function() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    var h = "ZipInfo:";
    function m(e) {
        var t1;
        return null === (t1 = null == e ? void 0 : e.path) || void 0 === t1 ? void 0 : t1.startsWith(h);
    }
    function g(e) {
        return "string" == typeof e && e.startsWith(h);
    }
    function v(e, t1) {
        return (Array.isArray(e) ? e : [
            e
        ]).some(function(e) {
            if ("number" != typeof e.version) throw new Error("file version must be an int number");
            return e.version < t1;
        });
    }
    function f(e, t1) {
        return e.reduce(function(e, o) {
            return e.then(function(e) {
                return t1(e, o);
            }).catch(function() {
                return t1(void 0, o);
            });
        }, Promise.resolve(void 0));
    }
    var y, S = function(e) {
        function t1() {
            return null !== e && e.apply(this, arguments) || this;
        }
        return r(t1, e), t1;
    }(a), b = "resource", E = function(e) {
        function o(t1) {
            var o = e.call(this) || this;
            if (o.ready = !1, o.openError = !1, o.isEnable()) {
                var r = t1 || {}, i = r.nameSpaceId, n = r.indexDbVersion;
                o.dbName = function(e) {
                    return "resource-manager" + (e ? "-" + e : "");
                }(i);
                var s = indexedDB.open(o.dbName, n || 1);
                s.addEventListener("error", function() {
                    o.openError = !0, o.checkReady(), o.emit("error", new Error("failed to open indexedDB"));
                }), s.addEventListener("success", function() {
                    o.db = s.result, o.checkReady();
                }), s.addEventListener("upgradeneeded", function() {
                    o.db = s.result, o.handleSuccess();
                }), setTimeout(function() {
                    o.checkReady();
                }, 5e3);
            } else o.checkReady();
            return o;
        }
        return r(o, e), o.prototype.checkReady = function() {
            this.ready || (this.ready = !0, this.emit("ready"));
        }, o.prototype.handleSuccess = function() {
            if (!this.db.objectStoreNames || 0 === this.db.objectStoreNames.length || !this.db.objectStoreNames.contains(b)) {
                var e = this.db.createObjectStore(b, {
                    keyPath: "path",
                    autoIncrement: !1
                });
                e.createIndex("path", "path"), e.createIndex("sourceURL", "sourceURL", {
                    unique: !1
                });
            }
        }, o.prototype.createAction = function(e) {
            var t1 = this.db.transaction([
                b
            ], e || "readonly");
            return {
                trans: t1,
                store: t1.objectStore(b)
            };
        }, o.prototype.handleAction = function(e, t1) {
            return new Promise(function(o, r) {
                var i = t1();
                e.addEventListener("complete", function() {
                    o(i.result);
                }), e.addEventListener("error", function() {
                    r(e.error || new Error("transaction error"));
                }), e.addEventListener("abort", function() {
                    r(e.error || new Error("transaction aborted"));
                });
            });
        }, o.prototype.put = function() {
            for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
            var o = this.createAction("readwrite"), r = o.trans, i = o.store;
            return this.handleAction(r, function() {
                return i.put.apply(i, e);
            });
        }, o.prototype.getAllKeysFromIndex = function(e) {
            for(var t1 = [], o = 1; o < arguments.length; o++)t1[o - 1] = arguments[o];
            if (IDBObjectStore.prototype.getAllKeys) {
                var r = this.createAction(), i = r.trans, n = r.store;
                return this.handleAction(i, function() {
                    var o;
                    return (o = n.index(e)).getAllKeys.apply(o, t1);
                });
            }
            return this.openKeyCursor(e);
        }, o.prototype.getAllFromIndex = function(e) {
            for(var t1 = [], o = 1; o < arguments.length; o++)t1[o - 1] = arguments[o];
            var r = this.createAction(), i = r.trans, n = r.store;
            return IDBObjectStore.prototype.getAll ? this.handleAction(i, function() {
                var o;
                return (o = n.index(e)).getAll.apply(o, t1);
            }) : this.openCursor(e);
        }, o.prototype.getFromIndex = function(e) {
            for(var t1 = [], o = 1; o < arguments.length; o++)t1[o - 1] = arguments[o];
            var r = this.createAction(), i = r.trans, n = r.store;
            return this.handleAction(i, function() {
                var o;
                return (o = n.index(e)).get.apply(o, t1);
            });
        }, o.prototype.deleteKey = function() {
            for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
            var o = this.createAction("readwrite"), r = o.trans, i = o.store;
            return this.handleAction(r, function() {
                return i.delete.apply(i, e);
            });
        }, o.prototype.handleCursorAction = function(e, t1, o, r) {
            return new Promise(function(i, n) {
                t1.addEventListener("success", function() {
                    t1.result ? (o(r, t1.result), t1.result.continue()) : i(r);
                }), t1.addEventListener("error", function() {
                    n(e.error || new Error("transaction error"));
                });
            });
        }, o.prototype.openKeyCursor = function(e) {
            for(var t1, o = [], r = 1; r < arguments.length; r++)o[r - 1] = arguments[r];
            var i = this.createAction("readwrite"), n = i.trans, s = i.store;
            return this.handleCursorAction(n, (t1 = s.index(e)).openKeyCursor.apply(t1, o), function(e, t1) {
                return e.push(t1.key), e;
            }, []);
        }, o.prototype.openCursor = function(e) {
            for(var t1, o = [], r = 1; r < arguments.length; r++)o[r - 1] = arguments[r];
            var i = this.createAction("readwrite"), n = i.trans, s = i.store;
            return this.handleCursorAction(n, (t1 = s.index(e)).openCursor.apply(t1, o), function(e, t1) {
                return e.push(t1.value), e;
            }, []);
        }, o.prototype.isEnable = function() {
            return !!window.indexedDB && !this.openError;
        }, o.prototype.saveFile = function(e) {
            return this.db ? this.put(e).then(function() {
                return !0;
            }) : Promise.resolve(!1);
        }, o.prototype.removeFile = function(e) {
            var o = this;
            return this.db ? "string" == typeof e ? this.getAllKeysFromIndex("path").then(function(r) {
                var i = (r || []).filter(function(o) {
                    return o === e || o.startsWith("" + e + t1.sep);
                });
                return Promise.all(i.map(function(e) {
                    return o.deleteKey(e);
                }));
            }).then(function() {
                return !0;
            }) : this.deleteKey(e.path).then(function() {
                return !0;
            }) : Promise.resolve(!1);
        }, o.prototype.clear = function() {
            if (!this.db) return Promise.resolve(!1);
            var e = this.createAction("readwrite"), t1 = e.trans, o = e.store;
            return this.handleAction(t1, function() {
                return o.clear();
            }).then(function() {
                return !0;
            });
        }, o.prototype.findFileByPath = function(e) {
            return this.db && e ? this.getFromIndex("path", e) : Promise.resolve(void 0);
        }, o.prototype.findFileBySourceURL = function(e) {
            return this.db && e ? this.getAllFromIndex("sourceURL", e) : Promise.resolve([]);
        }, o.prototype.isDirectory = function(e) {
            var o = this;
            return this.db ? new Promise(function(r) {
                g(e) ? r(!1) : o.getAllKeysFromIndex("path").then(function(o) {
                    return (o || []).some(function(o) {
                        return o.startsWith("" + e + t1.sep);
                    });
                }).then(r).catch(function() {
                    return r(!1);
                });
            }) : Promise.resolve(!1);
        }, o.prototype.ls = function(e) {
            var o = this;
            return this.db ? this.getAllKeysFromIndex("path").then(function(r) {
                var i = [];
                return Promise.all((r || []).map(function(r) {
                    if (g(r)) return Promise.resolve(void 0);
                    if (e) {
                        if (r.startsWith("" + e + t1.sep)) {
                            var n = r.split("" + e + t1.sep)[1] || "";
                            if (n.includes(t1.sep)) {
                                var s = "" + e + t1.sep + n.split(t1.sep)[0];
                                return s && !i.includes(s) ? (i.push(s), Promise.resolve(s)) : Promise.resolve(void 0);
                            }
                            return o.getFromIndex("path", r);
                        }
                        return Promise.resolve(void 0);
                    }
                    if (r.includes(t1.sep)) {
                        var a = r.split(t1.sep)[0] || "";
                        return a && !i.includes(a) ? (i.push(a), Promise.resolve(a)) : Promise.resolve(void 0);
                    }
                    return o.getFromIndex("path", r);
                })).then(function(e) {
                    return e.filter(function(e) {
                        return !!e;
                    });
                });
            }) : Promise.resolve([]);
        }, o;
    }(S), I = function(e) {
        function o() {
            var t1 = null !== e && e.apply(this, arguments) || this;
            return t1.memoryFiles = [], t1;
        }
        return r(o, e), o.prototype.isEnable = function() {
            return !0;
        }, o.prototype.saveFile = function(e) {
            var t1 = this;
            return new Promise(function(o) {
                t1.memoryFiles.some(function(o, r) {
                    return o.path === e.path && (t1.memoryFiles.splice(r, 1, e), !0);
                }) || t1.memoryFiles.push(e), o(!0);
            });
        }, o.prototype.removeFile = function(e) {
            var o = this;
            return new Promise(function(r) {
                for(var i = o.memoryFiles.length - 1; i >= 0; i--){
                    var n = o.memoryFiles[i];
                    ("string" == typeof e && (n.path === e || n.path.startsWith("" + e + t1.sep)) || e.path === n.path) && o.memoryFiles.splice(i, 1);
                }
                r(!0);
            });
        }, o.prototype.clear = function() {
            var e = this;
            return new Promise(function(t1) {
                e.memoryFiles = [], t1(!0);
            });
        }, o.prototype.findFileByPath = function(e) {
            var t1 = this;
            return new Promise(function(o) {
                o(t1.memoryFiles.filter(function(t1) {
                    return t1.path === e;
                })[0]);
            });
        }, o.prototype.findFileBySourceURL = function(e) {
            var t1 = this;
            return new Promise(function(o) {
                o(t1.memoryFiles.filter(function(t1) {
                    return t1.sourceURL === e;
                }));
            });
        }, o.prototype.isDirectory = function(e) {
            var o = this;
            return new Promise(function(r) {
                g(e) ? r(!1) : r(o.memoryFiles.some(function(o) {
                    return o.path.startsWith("" + e + t1.sep);
                }));
            });
        }, o.prototype.ls = function(e) {
            var o = this;
            return new Promise(function(r) {
                var i = [];
                o.memoryFiles.forEach(function(o) {
                    if (!m(o)) if (e) {
                        if (o.path.startsWith("" + e + t1.sep)) {
                            var r = o.path.split("" + e + t1.sep)[1] || "";
                            if (r.includes(t1.sep)) {
                                var n = "" + e + t1.sep + r.split(t1.sep)[0];
                                return void (n && !i.includes(n) && i.push(n));
                            }
                            i.push(o);
                        }
                    } else if (o.path.includes(t1.sep)) {
                        var s = o.path.split(t1.sep)[0] || "";
                        s && !i.includes(s) && i.push(s);
                    } else i.push(o);
                }), r(i);
            });
        }, o;
    }(S), A = function(e) {
        function o(t1) {
            var o = e.call(this) || this;
            if (o.isLocalAvaliable = void 0, o.isEnable()) {
                var r = (t1 || {}).nameSpaceId;
                o.storageName = function(e) {
                    return "resource-manager" + (e ? "-" + e : "");
                }(r);
            }
            return o;
        }
        return r(o, e), o.prototype.isEnable = function() {
            if (void 0 !== this.isLocalAvaliable) return this.isLocalAvaliable;
            try {
                this.isLocalAvaliable = !0, localStorage.setItem("privateTest", "");
            } catch (e) {
                this.isLocalAvaliable = !1;
            }
            return this.isLocalAvaliable;
        }, o.prototype.saveFile = function(e) {
            var t1 = this;
            return this.isEnable() ? new Promise(function(o) {
                var r = t1.getLocalFile();
                r.some(function(t1, o) {
                    return t1.path === e.path && (r.splice(o, 1, e), !0);
                }) || r.push(e), localStorage.setItem(t1.storageName, JSON.stringify(r)), o(!0);
            }) : Promise.resolve(!1);
        }, o.prototype.getLocalFile = function() {
            var e = localStorage.getItem(this.storageName), t1 = [];
            if (e) try {
                t1 = JSON.parse(e) || "[]";
            } catch (e) {
                console.log(e);
            }
            return t1;
        }, o.prototype.removeFile = function(e) {
            var o = this;
            return this.isEnable() ? new Promise(function(r) {
                for(var i = o.getLocalFile(), n = i.length - 1; n >= 0; n--){
                    var s = i[n];
                    ("string" == typeof e && (s.path === e || s.path.startsWith("" + e + t1.sep)) || e.path === s.path) && i.splice(n, 1);
                }
                localStorage.setItem(o.storageName, JSON.stringify(i)), r(!0);
            }) : Promise.resolve(!1);
        }, o.prototype.clear = function() {
            var e = this;
            return this.isEnable() ? new Promise(function(t1) {
                localStorage.removeItem(e.storageName), t1(!0);
            }) : Promise.resolve(!1);
        }, o.prototype.findFileByPath = function(e) {
            var t1 = this;
            return this.isEnable() ? new Promise(function(o) {
                o(t1.getLocalFile().filter(function(t1) {
                    return t1.path === e;
                })[0]);
            }) : Promise.resolve(void 0);
        }, o.prototype.findFileBySourceURL = function(e) {
            var t1 = this;
            return this.isEnable() ? new Promise(function(o) {
                o(t1.getLocalFile().filter(function(t1) {
                    return t1.sourceURL === e;
                }));
            }) : Promise.resolve([]);
        }, o.prototype.isDirectory = function(e) {
            var o = this;
            return this.isEnable() ? new Promise(function(r) {
                g(e) ? r(!1) : r(o.getLocalFile().some(function(o) {
                    return o.path.startsWith("" + e + t1.sep);
                }));
            }) : Promise.resolve(!1);
        }, o.prototype.ls = function(e) {
            var o = this;
            return this.isEnable() ? new Promise(function(r) {
                var i = [];
                o.getLocalFile().forEach(function(o) {
                    if (!m(o)) if (e) {
                        if (o.path.startsWith("" + e + t1.sep)) {
                            var r = o.path.split("" + e + t1.sep)[1] || "";
                            if (r.includes(t1.sep)) {
                                var n = "" + e + t1.sep + r.split(t1.sep)[0];
                                return void (n && !i.includes(n) && i.push(n));
                            }
                            i.push(o);
                        }
                    } else if (o.path.includes(t1.sep)) {
                        var s = o.path.split(t1.sep)[0] || "";
                        s && !i.includes(s) && i.push(s);
                    } else i.push(o);
                }), r(i);
            }) : Promise.resolve([]);
        }, o;
    }(S);
    (y = e.FileStoreEnum || (e.FileStoreEnum = {})).MEMORY = "memoryStore", y.INDEX_DB = "indexedDBStore", y.STORAGE = "storageStore";
    var C = function(o) {
        function i(e) {
            var t1 = o.call(this) || this;
            return t1.indexedDBStore = new E(e), t1.memoryStore = new I, t1.storageStore = new A(e), t1;
        }
        return r(i, o), i.prototype.saveFile = function(t1, o, r) {
            var i = this;
            void 0 === o && (o = !0);
            var s = (r || {}).forceSpecifyStore;
            return (o ? this.findFileByPath(t1.path, r) : Promise.resolve(void 0)).then(function(o) {
                if ((null == o ? void 0 : o.version) && v(t1, o.version)) throw new Error("there is an higher version file existed already");
                var r = n(n({}, t1), {
                    createTime: o && o.createTime || Date.now(),
                    updateTime: Date.now()
                });
                return s && i[s] && i[s].isEnable() && (s !== e.FileStoreEnum.STORAGE || i.isLocalStorageAvaliable(r)) ? i[s].saveFile(r) : i[i.saveToTargetStoreRule(r)].saveFile(r);
            });
        }, i.prototype.isLocalStorageAvaliable = function(e) {
            var o = e.data;
            return "string" === t1.getDataFormat(o) && o.length <= 102400 && this.storageStore.isEnable();
        }, i.prototype.saveToTargetStoreRule = function(t1) {
            return this.indexedDBStore.isEnable() ? e.FileStoreEnum.INDEX_DB : this.isLocalStorageAvaliable(t1) ? e.FileStoreEnum.STORAGE : e.FileStoreEnum.MEMORY;
        }, i.prototype.removeFile = function(e, t1) {
            var o = (t1 || {}).forceSpecifyStore;
            return o && this[o] ? this[o].removeFile(e) : Promise.all([
                this.indexedDBStore.removeFile(e),
                this.storageStore.removeFile(e),
                this.memoryStore.removeFile(e)
            ]).then(function() {
                return !0;
            });
        }, i.prototype.clear = function(e) {
            var t1 = (e || {}).forceSpecifyStore;
            return t1 && this[t1] ? this[t1].clear() : Promise.all([
                this.indexedDBStore.clear(),
                this.storageStore.clear(),
                this.memoryStore.clear()
            ]).then(function() {
                return !0;
            });
        }, i.prototype.findFileByPath = function(e, t1) {
            var o = this, r = (t1 || {}).forceSpecifyStore;
            return r && this[r] ? this[r].findFileByPath(e) : f(this.searchInTargetStoreRule(), function(t1, r) {
                return t1 ? Promise.resolve(t1) : o[r].findFileByPath(e);
            });
        }, i.prototype.findFileBySourceURL = function(e, t1) {
            var o = this, r = (t1 || {}).forceSpecifyStore;
            return r && this[r] ? this[r].findFileBySourceURL(e) : f(this.searchInTargetStoreRule(), function(t1, r) {
                return o[r].findFileBySourceURL(e).then(function(e) {
                    return t1 ? t1.filter(function(t1) {
                        return !e.some(function(e) {
                            return e.path === t1.path;
                        });
                    }).concat(e || []) : e || [];
                });
            });
        }, i.prototype.searchInTargetStoreRule = function() {
            return [
                e.FileStoreEnum.INDEX_DB,
                e.FileStoreEnum.STORAGE,
                e.FileStoreEnum.MEMORY
            ];
        }, i.prototype.isDirectory = function(e) {
            var t1 = this;
            return e ? f(this.searchInTargetStoreRule(), function(o, r) {
                return o ? Promise.resolve(!0) : t1[r].isDirectory(e);
            }) : Promise.resolve(!0);
        }, i.prototype.ls = function(e) {
            var t1 = this;
            return this.isDirectory(e).then(function(o) {
                if (!o) throw new Error("path: " + e + " is an invalid directory path");
                return f(t1.searchInTargetStoreRule(), function(o, r) {
                    return t1[r].ls(e).then(function(e) {
                        return o ? (e || []).concat(o.filter(function(t1) {
                            return !e.some(function(e) {
                                return "string" == typeof t1 ? e === t1 : "string" != typeof e && e.path === t1.path;
                            });
                        })) : e;
                    });
                });
            });
        }, i;
    }(a), _ = function(e) {
        function t1() {
            return null !== e && e.apply(this, arguments) || this;
        }
        return r(t1, e), t1;
    }(a), R = function(e) {
        function o(o) {
            var r = e.call(this) || this, i = o || {}, n = i.storeOptions, s = i.downloadManagerOptions;
            return r.downloadManager = new t1.IDownloadManager(s), r.store = new C(n), r.store.indexedDBStore.on("ready", function() {
                return r.emit("ready");
            }), r;
        }
        return r(o, e), o.prototype.getFile = function(e, t1, o) {
            var r = this, i = new _, n = Promise.resolve(void 0), s = t1 || {}, a = s.downloadOptions, d = s.forceDownload, u = s.saveRootPath;
            d ? n = Promise.resolve(void 0) : "string" == typeof e ? n = this.store.findFileByPath(e, o) : (null == e ? void 0 : e.sourceURL) ? n = this.store.findFileBySourceURL(e.sourceURL) : a && (a.domParams || a.socketParams || a.xhrParams) && (n = this.store.findFileBySourceURL(this.genSourceURL(a)));
            var l = null, c = new Promise(function(e) {
                l = e;
            });
            return i.getDownloadTask = function() {
                return c;
            }, n = n.then(function(e) {
                if (e && (!Array.isArray(e) || e.length)) {
                    var t1 = e;
                    if (Array.isArray(t1)) {
                        var r = t1.find(function(e) {
                            return m(e);
                        });
                        if (!r) return;
                        t1 = t1.filter(function(e) {
                            return !m(e);
                        });
                        var n = r.data;
                        if ("string" != typeof n) return;
                        if (!JSON.parse(n || "[]").every(function(e) {
                            return t1.some(function(t1) {
                                return t1.path === e;
                            });
                        })) return;
                    }
                    if (!(null == o ? void 0 : o.targetVersion) || !v(t1, o.targetVersion)) return i.emit("checkExpire", !1), t1;
                    i.emit("checkExpire", !0);
                }
            }).then(function(t1) {
                if (!t1 && a) {
                    var n = r.downloadManager.download(a);
                    return l(n), new Promise(function(t1, s) {
                        n.on("complete", function(n) {
                            setTimeout(function() {
                                var s = Array.isArray(n) ? n.map(function(e) {
                                    var t1 = e.data, i = e.path, n = e.extName;
                                    return {
                                        path: r.genFilePath(u, i),
                                        sourceURL: r.genSourceURL(a),
                                        data: t1,
                                        fileFormat: n || r.getFileFormat(a),
                                        version: (null == o ? void 0 : o.targetVersion) || 1
                                    };
                                }) : {
                                    path: r.genFilePath(u, void 0),
                                    sourceURL: r.genSourceURL(a),
                                    data: n,
                                    fileFormat: r.getFileFormat(a),
                                    version: (null == o ? void 0 : o.targetVersion) || 1
                                };
                                if (Array.isArray(s) && "string" == typeof e && e) {
                                    var d = s.find(function(t1) {
                                        return t1.path === e;
                                    });
                                    t1(d || s);
                                } else t1(s);
                                i.emit("beforeSet", s), r.beforeWrite(s, o).then(function() {
                                    i.emit("afterSet");
                                }).catch(function(e) {
                                    return i.emit("afterSet", e);
                                });
                            }, 0);
                        }), n.on("abort", s), n.on("error", s), n.on("timeout", function() {
                            return s(new Error("download timeout"));
                        });
                    });
                }
                return l(void 0), t1;
            }).catch(function(e) {
                return l(void 0), Promise.reject(e);
            }), i.getResult = function() {
                return n;
            }, i;
        }, o.prototype.genSourceURL = function(e) {
            var o = e.domParams, r = e.type, i = e.xhrParams;
            if (r === t1.DownloaderType.SOCKET) return null;
            var n = (r === t1.DownloaderType.DOM ? o : i) || {}, s = n.url, a = void 0 === s ? "" : s, d = n.body;
            return d && Object.keys(d).length ? a + (a.includes("?") ? "&" : "?") + "downloadBodyParams=" + JSON.stringify(d) : a;
        }, o.prototype.updateFile = function(e, t1) {
            return this.saveStore(e, !0, t1);
        }, o.prototype.beforeWrite = function(e, t1) {
            var o = this;
            return Array.isArray(e) ? Promise.all(e.concat(function(e) {
                var t1 = e[0].sourceURL || "";
                return {
                    path: "" + h + t1,
                    sourceURL: t1,
                    data: JSON.stringify(e.map(function(e) {
                        return e.path;
                    }))
                };
            }(e)).map(function(e) {
                return o.saveStore(e, !1, t1);
            })).then(function(e) {
                return e.filter(function(e) {
                    return !m(e);
                });
            }) : this.saveStore(e, !0, t1);
        }, o.prototype.getFileFormat = function(e) {
            var o = e || {}, r = o.xhrParams, i = o.domParams, n = o.socketParams, s = o.type;
            return s === t1.DownloaderType.DOM && (null == i ? void 0 : i.fileFormat) ? i.fileFormat : s === t1.DownloaderType.SOCKET && (null == n ? void 0 : n.fileFormat) ? n.fileFormat : (null == r ? void 0 : r.fileFormat) ? r.fileFormat : "unknow";
        }, o.prototype.genFilePath = function(e, o) {
            return o ? "" + (e || "") + (e ? t1.sep : "") + o : e || "";
        }, o.prototype.saveStore = function(e, t1, o) {
            return void 0 === t1 && (t1 = !0), this.store.saveFile(e, t1, o).then(function(t1) {
                if (t1) return e;
                throw new Error("fail to save file in local store");
            });
        }, o.prototype.remove = function(e, t1) {
            return this.store.removeFile(e, t1);
        }, o.prototype.clear = function(e) {
            return this.store.clear(e);
        }, o.prototype.list = function(e) {
            return this.store.ls(e);
        }, o.prototype.updateVersion = function(e, t1) {
            var o = this;
            return this.store.findFileByPath(e).then(function(r) {
                if (r) return o.saveStore(n(n({}, r), {
                    version: t1
                })).then(function() {});
                throw new Error("the target path: " + e + " isn't existed");
            });
        }, o.prototype.updateSourceURL = function(e, t1) {
            var o = this;
            return this.store.findFileByPath(e).then(function(r) {
                if (r) return o.saveStore(n(n({}, r), {
                    sourceURL: t1
                })).then(function() {});
                throw new Error("the target path: " + e + " isn't existed");
            });
        }, o;
    }(a);
    e.IResourceManager = R, Object.defineProperty(e, "__esModule", {
        value: !0
    });
}(vy.exports, (my || (my = 1, function(e, t1) {
    var o = function(e, t1) {
        return o = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(e, t1) {
            e.__proto__ = t1;
        } || function(e, t1) {
            for(var o in t1)t1.hasOwnProperty(o) && (e[o] = t1[o]);
        }, o(e, t1);
    };
    function r(e, t1) {
        function r() {
            this.constructor = e;
        }
        o(e, t1), e.prototype = null === t1 ? Object.create(t1) : (r.prototype = t1.prototype, new r);
    }
    var i, n = function() {
        return n = Object.assign || function(e) {
            for(var t1, o = 1, r = arguments.length; o < r; o++)for(var i in t1 = arguments[o])Object.prototype.hasOwnProperty.call(t1, i) && (e[i] = t1[i]);
            return e;
        }, n.apply(this, arguments);
    }, s = function(e, t1) {
        var o = new Uint8Array(e.byteLength + t1.byteLength);
        return o.set(new Uint8Array(e), 0), o.set(new Uint8Array(t1), e.byteLength), o.buffer;
    }, a = "/";
    (i = e.TransformDataFormat || (e.TransformDataFormat = {})).STRING = "string", i.BLOB = "blob", i.ARRAY_BUFFER = "arraybuffer";
    var d, u = function(e) {
        return Blob && e instanceof Blob ? "blob" : ArrayBuffer && e instanceof ArrayBuffer ? "arrayBuffer" : typeof e;
    }, l = [], c = function() {
        for(var e = [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "i",
            "j",
            "k",
            "l",
            "m",
            "n",
            "o",
            "p",
            "q",
            "r",
            "s",
            "t",
            "u",
            "v",
            "w",
            "x",
            "y",
            "z"
        ], t1 = "", o = 0; o < 32; o++)t1 += e[Math.round(61 * Math.random())];
        return -1 !== l.indexOf(t1) ? c() : (l.push(t1), t1);
    }, p = function(e) {
        return e.arrayBuffer ? e.arrayBuffer() : new Promise(function(t1, o) {
            var r = new FileReader;
            r.readAsArrayBuffer(e), r.onload = function(e) {
                t1(e.target && e.target.result);
            }, r.onerror = function(e) {
                o(e);
            };
        });
    }, h = function(e) {
        return e.text ? e.text() : new Promise(function(t1, o) {
            var r = new FileReader;
            r.readAsText(e), r.onload = function(e) {
                t1(e.target && e.target.result);
            }, r.onerror = function(e) {
                o(e);
            };
        });
    }, m = function(e, t1) {
        return Promise.resolve(new Blob([
            new Uint8Array(e)
        ], {
            type: t1
        }));
    }, g = function(e, t1) {
        var o = new Blob([
            e
        ], {
            type: t1 || "text/plain"
        });
        return h(o);
    }, v = function(e, t1) {
        return Promise.resolve(new Blob([
            e
        ], {
            type: t1 || "text/plain"
        }));
    }, f = function(e, t1) {
        return p(new Blob([
            e
        ], {
            type: t1 || "text/plain"
        }));
    };
    function y(e) {
        var t1 = (e || "").split(".");
        return t1[t1.length - 1] || "";
    }
    function S(e) {
        var t1 = (e || "").lastIndexOf(a);
        return t1 < 0 ? "" : e.slice(0, t1);
    }
    function b(e) {
        var t1 = (e || "").lastIndexOf(a), o = t1 < 0 ? e : e.slice(t1 + 1), r = (o || "").lastIndexOf(".");
        return r < 0 ? o : o.slice(0, r);
    }
    function E(e) {
        return [
            "png",
            "jpg",
            "jpeg",
            "svg"
        ].includes(y(e));
    }
    function I(e) {
        return "json" === y(e);
    }
    function A(e) {
        return "version" === y(e);
    }
    function C(e, t1) {
        return e.reduce(function(e, o) {
            var r, i = o.data, n = o.file, s = y(n.name), d = S(n.name), u = b(n.name), l = ((null == t1 ? void 0 : t1.combineExtNames) || []).includes(s) && "string" == typeof i, c = l ? "" + (d ? "" + d + a + s : s) : n.name;
            return l && e.some(function(e) {
                return e.path === c && (e.data[u] = i, !0);
            }) || e.push({
                path: c,
                extName: s,
                data: l ? (r = {}, r[u] = i, r) : i,
                shouldCombine: l
            }), e;
        }, []).map(function(e) {
            var t1 = e.data, o = e.shouldCombine, r = function(e, t1) {
                var o = {};
                for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && t1.indexOf(r) < 0 && (o[r] = e[r]);
                if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                    var i = 0;
                    for(r = Object.getOwnPropertySymbols(e); i < r.length; i++)t1.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (o[r[i]] = e[r[i]]);
                }
                return o;
            }(e, [
                "data",
                "shouldCombine"
            ]);
            return n(n({}, r), {
                data: o ? JSON.stringify(t1) : t1
            });
        });
    }
    function _(e, o) {
        return t1.loadAsync(e).then(function(e) {
            return Promise.all(e.filter(function(e, t1) {
                return !t1.dir;
            }).map(function(e) {
                var t1 = function(e) {
                    return I(e.name) ? "string" : E(e.name) ? "base64" : A(e.name) ? "text" : "blob";
                }(e);
                return (null == o ? void 0 : o.setUnZipFormat) && (t1 = o.setUnZipFormat(e) || t1), e.async(t1).then(function(o) {
                    var r = o, i = y(e.name), n = "svg" === i ? "svg+xml" : i;
                    return "base64" === t1 && E(e.name) && !o.startsWith("data") && (r = "data:image/" + n + ";base64," + r), {
                        data: r,
                        file: e
                    };
                });
            }));
        }).then(function(e) {
            return C(e, o);
        });
    }
    function R(t1, o) {
        var r = o || {}, i = r.encoding, n = r.blobType, s = r.unZipOptions;
        if (function(e) {
            return "blob" === u(e) && (e.type.includes("compressed") || e.type.includes("zip"));
        }(t1) && !(null == s ? void 0 : s.disableUnZip)) return _(t1, s);
        if (!i) return Promise.resolve(t1);
        var a = u(t1), d = "string" === a, l = "blob" === a, c = "arrayBuffer" === a;
        if (i === e.TransformDataFormat.BLOB) {
            var y = t1;
            if (d) return h(y);
            if (c) return p(y);
        } else if (i === e.TransformDataFormat.ARRAY_BUFFER) {
            var S = t1;
            if (d) return g(S, n);
            if (l) return m(S, n);
        } else if (i === e.TransformDataFormat.STRING) {
            var b = t1;
            if (l) return v(b, n);
            if (c) return f(b, n);
        }
        return Promise.resolve(t1);
    }
    function w(e) {
        var t1 = 0, o = !1, r = function() {
            t1 > 90 || o || (e(t1 += (100 - t1) / 50), requestAnimationFrame(r));
        };
        return r(), {
            finish: function() {
                100 === t1 || o || (t1 = 100, e(100));
            },
            abort: function() {
                100 === t1 || o || (o = !0);
            },
            get curProgress () {
                return t1;
            }
        };
    }
    function T() {}
    function O() {
        O.init.call(this);
    }
    function D(e) {
        return void 0 === e._maxListeners ? O.defaultMaxListeners : e._maxListeners;
    }
    function P(e, t1, o, r) {
        var i, n, s;
        if ("function" != typeof o) throw new TypeError('"listener" argument must be a function');
        if ((n = e._events) ? (n.newListener && (e.emit("newListener", t1, o.listener ? o.listener : o), n = e._events), s = n[t1]) : (n = e._events = new T, e._eventsCount = 0), s) {
            if ("function" == typeof s ? s = n[t1] = r ? [
                o,
                s
            ] : [
                s,
                o
            ] : r ? s.unshift(o) : s.push(o), !s.warned && (i = D(e)) && i > 0 && s.length > i) {
                s.warned = !0;
                var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + t1 + " listeners added. Use emitter.setMaxListeners() to increase limit");
                a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t1, a.count = s.length, function(e) {
                    "function" == typeof console.warn ? console.warn(e) : console.log(e);
                }(a);
            }
        } else s = n[t1] = o, ++e._eventsCount;
        return e;
    }
    function M(e, t1, o) {
        var r = !1;
        function i() {
            e.removeListener(t1, i), r || (r = !0, o.apply(e, arguments));
        }
        return i.listener = o, i;
    }
    function k(e) {
        var t1 = this._events;
        if (t1) {
            var o = t1[e];
            if ("function" == typeof o) return 1;
            if (o) return o.length;
        }
        return 0;
    }
    function L(e, t1) {
        for(var o = new Array(t1); t1--;)o[t1] = e[t1];
        return o;
    }
    T.prototype = Object.create(null), O.EventEmitter = O, O.usingDomains = !1, O.prototype.domain = void 0, O.prototype._events = void 0, O.prototype._maxListeners = void 0, O.defaultMaxListeners = 10, O.init = function() {
        this.domain = null, O.usingDomains && d.active && d.Domain, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new T, this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, O.prototype.setMaxListeners = function(e) {
        if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number');
        return this._maxListeners = e, this;
    }, O.prototype.getMaxListeners = function() {
        return D(this);
    }, O.prototype.emit = function(e) {
        var t1, o, r, i, n, s, a, d = "error" === e;
        if (s = this._events) d = d && null == s.error;
        else if (!d) return !1;
        if (a = this.domain, d) {
            if (t1 = arguments[1], !a) {
                if (t1 instanceof Error) throw t1;
                var u = new Error('Uncaught, unspecified "error" event. (' + t1 + ")");
                throw u.context = t1, u;
            }
            return t1 || (t1 = new Error('Uncaught, unspecified "error" event')), t1.domainEmitter = this, t1.domain = a, t1.domainThrown = !1, a.emit("error", t1), !1;
        }
        if (!(o = s[e])) return !1;
        var l = "function" == typeof o;
        switch(r = arguments.length){
            case 1:
                !function(e, t1, o) {
                    if (t1) e.call(o);
                    else for(var r = e.length, i = L(e, r), n = 0; n < r; ++n)i[n].call(o);
                }(o, l, this);
                break;
            case 2:
                !function(e, t1, o, r) {
                    if (t1) e.call(o, r);
                    else for(var i = e.length, n = L(e, i), s = 0; s < i; ++s)n[s].call(o, r);
                }(o, l, this, arguments[1]);
                break;
            case 3:
                !function(e, t1, o, r, i) {
                    if (t1) e.call(o, r, i);
                    else for(var n = e.length, s = L(e, n), a = 0; a < n; ++a)s[a].call(o, r, i);
                }(o, l, this, arguments[1], arguments[2]);
                break;
            case 4:
                !function(e, t1, o, r, i, n) {
                    if (t1) e.call(o, r, i, n);
                    else for(var s = e.length, a = L(e, s), d = 0; d < s; ++d)a[d].call(o, r, i, n);
                }(o, l, this, arguments[1], arguments[2], arguments[3]);
                break;
            default:
                for(i = new Array(r - 1), n = 1; n < r; n++)i[n - 1] = arguments[n];
                !function(e, t1, o, r) {
                    if (t1) e.apply(o, r);
                    else for(var i = e.length, n = L(e, i), s = 0; s < i; ++s)n[s].apply(o, r);
                }(o, l, this, i);
        }
        return !0;
    }, O.prototype.addListener = function(e, t1) {
        return P(this, e, t1, !1);
    }, O.prototype.on = O.prototype.addListener, O.prototype.prependListener = function(e, t1) {
        return P(this, e, t1, !0);
    }, O.prototype.once = function(e, t1) {
        if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
        return this.on(e, M(this, e, t1)), this;
    }, O.prototype.prependOnceListener = function(e, t1) {
        if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
        return this.prependListener(e, M(this, e, t1)), this;
    }, O.prototype.removeListener = function(e, t1) {
        var o, r, i, n, s;
        if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
        if (!(r = this._events)) return this;
        if (!(o = r[e])) return this;
        if (o === t1 || o.listener && o.listener === t1) 0 == --this._eventsCount ? this._events = new T : (delete r[e], r.removeListener && this.emit("removeListener", e, o.listener || t1));
        else if ("function" != typeof o) {
            for(i = -1, n = o.length; n-- > 0;)if (o[n] === t1 || o[n].listener && o[n].listener === t1) {
                s = o[n].listener, i = n;
                break;
            }
            if (i < 0) return this;
            if (1 === o.length) {
                if (o[0] = void 0, 0 == --this._eventsCount) return this._events = new T, this;
                delete r[e];
            } else !function(e, t1) {
                for(var o = t1, r = o + 1, i = e.length; r < i; o += 1, r += 1)e[o] = e[r];
                e.pop();
            }(o, i);
            r.removeListener && this.emit("removeListener", e, s || t1);
        }
        return this;
    }, O.prototype.removeAllListeners = function(e) {
        var t1, o;
        if (!(o = this._events)) return this;
        if (!o.removeListener) return 0 === arguments.length ? (this._events = new T, this._eventsCount = 0) : o[e] && (0 == --this._eventsCount ? this._events = new T : delete o[e]), this;
        if (0 === arguments.length) {
            for(var r, i = Object.keys(o), n = 0; n < i.length; ++n)"removeListener" !== (r = i[n]) && this.removeAllListeners(r);
            return this.removeAllListeners("removeListener"), this._events = new T, this._eventsCount = 0, this;
        }
        if ("function" == typeof (t1 = o[e])) this.removeListener(e, t1);
        else if (t1) do {
            this.removeListener(e, t1[t1.length - 1]);
        }while (t1[0])
        return this;
    }, O.prototype.listeners = function(e) {
        var t1, o = this._events;
        return o && (t1 = o[e]) ? "function" == typeof t1 ? [
            t1.listener || t1
        ] : function(e) {
            for(var t1 = new Array(e.length), o = 0; o < t1.length; ++o)t1[o] = e[o].listener || e[o];
            return t1;
        }(t1) : [];
    }, O.listenerCount = function(e, t1) {
        return "function" == typeof e.listenerCount ? e.listenerCount(t1) : k.call(e, t1);
    }, O.prototype.listenerCount = k, O.prototype.eventNames = function() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    var N = function(e) {
        function t1(t1) {
            var o = e.call(this) || this;
            return o.timeout = (null == t1 ? void 0 : t1.timeout) || 3e4, o;
        }
        return r(t1, e), t1.prototype.clearTimeoutCheck = function() {
            this.timeoutTimer && (clearTimeout(this.timeoutTimer), this.timeoutTimer = null);
        }, t1.prototype.startTimeoutCheck = function() {
            var e = this;
            !this.timeoutTimer && !this.finished && this.timeout > 0 && (this.timeoutTimer = setTimeout(function() {
                e.finished || (e.finished = !0, e.data = null, e.emit("timeout")), e.clearTimeoutCheck();
            }, this.timeout));
        }, t1;
    }(O), V = function(e) {
        function t1(t1) {
            var o = e.call(this, t1) || this;
            return o.uuid = c(), o.domParams = t1 || {}, o;
        }
        return r(t1, e), t1.prototype.jsonp = function() {
            var e = this;
            if (!this.finished) {
                var t1 = this.domParams, o = t1.url, r = t1.jsonpCallbackName, i = void 0 === r ? "callback" : r, n = t1.body, s = t1.integrity;
                this.script = document.createElement("script"), s && (this.script.integrity = s, this.script.crossOrigin = "anonymous");
                var a = "";
                n && Object.entries(n).forEach(function(e) {
                    var t1 = e[0], o = e[1];
                    a += (a ? "&" : "") + t1 + "=" + o;
                }), a += (a ? "&" : "") + i + "=" + this.uuid, this.script.src = o + (o.includes("?") ? "" : "?") + a, this.jsonpCallback(), this.progressMonitory = w(function(t1) {
                    e.finished || e.emit("progressUpdated", t1);
                }), document.body.appendChild(this.script);
            }
        }, t1.prototype.clearSideEffect = function(e) {
            if (void 0 === e && (e = !1), document.body.removeChild(this.script), e) {
                var t1 = this.uuid;
                window[this.uuid] = function() {
                    window[t1] && delete window[t1];
                };
            } else delete window[this.uuid];
            this.script = null, this.uuid = null, this.finished = !0, this.data = null, this.clearTimeoutCheck();
        }, t1.prototype.jsonpCallback = function() {
            var e = this;
            this.script.onerror = function(t1) {
                var o;
                e.finished || (e.clearSideEffect(), null === (o = e.progressMonitory) || void 0 === o || o.abort(), e.emit("error", new Error("string" == typeof t1 ? t1 : "load jsonp script failed")));
            }, window[this.uuid] = function(t1) {
                var o;
                if (!e.finished) {
                    var r = e.domParams, i = r.encoding, n = r.blobType, s = r.unZipOptions, a = r.beforeTransformData, d = r.afterTransformData;
                    null === (o = e.progressMonitory) || void 0 === o || o.finish(), e.clearSideEffect(), (a ? a(t1 || "") : Promise.resolve(t1 || "")).then(function(t1) {
                        return R(t1, {
                            encoding: i,
                            blobType: n,
                            unZipOptions: s
                        }).then(function(t1) {
                            return (d ? d(t1) : Promise.resolve(t1)).then(function(t1) {
                                return e.emit("finished", t1);
                            });
                        });
                    }).catch(function(t1) {
                        return e.emit("error", t1);
                    });
                }
            };
        }, t1.prototype.abort = function() {
            this.clearSideEffect(!0);
        }, t1;
    }(N), U = function(e) {
        function t1(t1) {
            var o = e.call(this, t1) || this;
            return o.socketParams = t1 || {}, o;
        }
        return r(t1, e), t1.prototype.write = function(e, t1) {
            e && !this.finished && (e instanceof Error ? this.handleError(e) : (this.data ? this.appendData(e) : this.data = e, this.handlePerCentUpdate(t1)));
        }, t1.prototype.handlePerCentUpdate = function(e) {
            void 0 === e || this.finished || this.emit("progressUpdated", e);
        }, t1.prototype.handleError = function(e) {
            this.data = null, this.finished = !0, this.clearTimeoutCheck(), this.emit("error", e);
        }, t1.prototype.appendData = function(e) {
            u(e) === u(this.data) ? "string" == typeof e ? this.data += e : Blob && e instanceof Blob ? this.data = new Blob([
                this.data,
                e
            ], {
                type: e.type
            }) : ArrayBuffer && e instanceof ArrayBuffer && (this.data = s(this.data, e)) : this.handleError(new Error("every piece of the data format must be the same"));
        }, t1.prototype.end = function(e) {
            var t1 = this;
            if (!this.finished) {
                this.handlePerCentUpdate(100), e && this.write(e);
                var o = this.socketParams, r = o.encoding, i = o.blobType, n = o.unZipOptions, s = o.beforeTransformData, a = o.afterTransformData;
                (s ? s(this.data) : Promise.resolve(this.data)).then(function(e) {
                    return R(e, {
                        encoding: r,
                        blobType: i,
                        unZipOptions: n
                    }).then(function(e) {
                        return (a ? a(e) : Promise.resolve(e)).then(function(e) {
                            return t1.emit("finished", e);
                        });
                    });
                }).catch(function(e) {
                    return t1.emit("error", e);
                }), this.data = null, this.finished = !0, this.clearTimeoutCheck();
            }
        }, t1.prototype.abort = function() {
            this.data = null, this.finished = !0, this.clearTimeoutCheck();
        }, t1;
    }(N), j = function(t1) {
        function o(e) {
            var o = t1.call(this, e) || this;
            return o.xhrParams = e || {}, o.xhrParams.headers = n({}, o.xhrParams.headers || {}), o;
        }
        return r(o, t1), o.prototype.supportFetch = function() {
            return !!window.fetch && window.AbortController && window.Request;
        }, o.prototype.ajax = function() {
            var t1 = this;
            if (!this.finished) if (this.xhrParams.url) {
                var o = this.xhrParams, r = o.headers, i = void 0 === r ? {} : r, s = o.url, a = o.body, d = void 0 === a ? {} : a, u = o.method, l = void 0 === u ? "POST" : u, c = o.encoding, p = o.integrity;
                this.controller = this.supportFetch() ? new AbortController : new XMLHttpRequest;
                var h = this.supportFetch() ? w(function(e) {
                    t1.finished || t1.emit("progressUpdated", e);
                }) : null;
                (this.supportFetch() ? fetch(new Request(s, n({
                    method: l,
                    headers: i,
                    body: "GET" === l ? void 0 : JSON.stringify(d),
                    signal: this.controller.signal
                }, p ? {
                    integrity: p,
                    mode: "cors"
                } : {}))).then(function(t1) {
                    return t1.ok ? c === e.TransformDataFormat.STRING ? t1.text() : c === e.TransformDataFormat.ARRAY_BUFFER ? t1.arrayBuffer() : t1.blob() : Promise.reject(new Error("xhr download " + s + " failed!"));
                }) : new Promise(function(o, r) {
                    var n = new XMLHttpRequest;
                    t1.controller = n, n.open(l, s), n.responseType = c === e.TransformDataFormat.STRING ? "text" : c === e.TransformDataFormat.ARRAY_BUFFER ? "arraybuffer" : "blob", Object.entries(i).forEach(function(e) {
                        var t1 = e[0], o = e[1];
                        n.setRequestHeader(t1, o);
                    }), n.onload = function() {
                        var e = n.status, t1 = n.response, i = n.statusText;
                        e >= 200 && e < 300 || 304 === e ? o(t1) : r(new Error(e + ": " + i));
                    }, n.onprogress = function(e) {
                        var o = e || {}, r = o.total, i = o.loaded;
                        void 0 === i || t1.finished || (r ? t1.emit("progressUpdated", i / r * 100) : i && !h && (h = w(function(e) {
                            t1.finished || t1.emit("progressUpdated", e);
                        })));
                    }, n.onerror = function() {
                        r(new Error("xhr download " + s + " failed!"));
                    }, n.send(JSON.stringify(d));
                })).then(function(e) {
                    if (!t1.finished) {
                        var o = t1.xhrParams, r = o.encoding, i = o.blobType, n = o.unZipOptions, s = o.beforeTransformData, a = o.afterTransformData;
                        null == h || h.finish(), t1.finished = !0, t1.clearTimeoutCheck(), (s ? s(e) : Promise.resolve(e)).then(function(e) {
                            return R(e, {
                                encoding: r,
                                blobType: i,
                                unZipOptions: n
                            }).then(function(e) {
                                return (a ? a(e) : Promise.resolve(e)).then(function(e) {
                                    return t1.emit("finished", e);
                                });
                            });
                        }).catch(function(e) {
                            return t1.emit("error", e);
                        });
                    }
                }).catch(function(e) {
                    t1.finished || (t1.finished = !0, t1.clearTimeoutCheck(), null == h || h.abort(), t1.emit("error", e));
                });
            } else this.emit("error", new Error("xhrDownloader url params invalid!"));
        }, o.prototype.abort = function() {
            this.data = null, this.finished = !0, this.clearTimeoutCheck(), this.controller.abort();
        }, o;
    }(N), x = 0;
    O.defaultMaxListeners = 500;
    var B, F = new O, H = "ThreadPoolReady", $ = function() {
        x -= 1, F.emit(H);
    };
    (B = e.DownloaderType || (e.DownloaderType = {})).XHR = "xhr", B.DOM = "dom", B.SOCKET = "socket";
    var W = function(t1) {
        function o(o) {
            var r = t1.call(this) || this;
            return r.aborted = !1, r.downloadParmas = n({
                type: e.DownloaderType.XHR
            }, o), r.id = c(), r;
        }
        return r(o, t1), o.prototype.start = function() {
            var t1 = this;
            x += 1, this.progress = 0, this.emit("downloadStart"), this.onDownloadStartCallback && this.onDownloadStartCallback();
            var o = this.downloadParmas, r = o.type, i = o.xhrParams, n = o.domParams, s = o.socketParams;
            switch(r){
                case e.DownloaderType.DOM:
                    this.downloader = new V(n), this.downloader.jsonp();
                    break;
                case e.DownloaderType.SOCKET:
                    this.downloader = new U(s);
                    break;
                default:
                    this.downloader = new j(i), this.downloader.ajax();
            }
            return this.downloader.startTimeoutCheck(), this.downloader.on("error", function(e) {
                t1.emit("error", e), t1.onErrorCallback && t1.onErrorCallback(e), $();
            }).on("finished", function(e) {
                t1.emit("complete", e), t1.onCompleteCallback && t1.onCompleteCallback(e), $();
            }).on("progressUpdated", function(e) {
                t1.progress = e, t1.emit("progressUpdated", e), t1.onProgressUpdatedCallback && t1.onProgressUpdatedCallback(e);
            }).on("timeout", function() {
                t1.emit("timeout"), t1.onTimeoutCallback && t1.onTimeoutCallback(), $();
            }), this;
        }, o.prototype.abort = function() {
            if (this.aborted) return this;
            this.aborted = !0, this.downloader && !this.downloader.finished && this.downloader.abort();
            var e = new Error("file download has been aborted");
            return this.emit("abort", e), this.onAbortCallback && this.onAbortCallback(e), $(), this;
        }, o.prototype.onDownloadStart = function(e) {
            return this.onDownloadStartCallback = e, this;
        }, o.prototype.onProgressUpdated = function(e) {
            return this.onProgressUpdatedCallback = e, this;
        }, o.prototype.onError = function(e) {
            return this.onErrorCallback = e, this;
        }, o.prototype.onComplete = function(e) {
            return this.onCompleteCallback = e, this;
        }, o.prototype.onAbort = function(e) {
            return this.onAbortCallback = e, this;
        }, o.prototype.onTimeout = function(e) {
            return this.onTimeoutCallback = e, this;
        }, o.prototype.isInProgress = function() {
            return void 0 !== this.progress;
        }, o.prototype.isFinished = function() {
            return 100 === this.progress;
        }, o;
    }(O), G = function() {
        function e(e) {
            this.taskList = [], this.options = e || {};
            var t1 = this.options.threadLimit;
            if ((void 0 === t1 ? 6 : t1) > 6) throw new Error("threadLimit must be lower than 6");
            F.on(H, this.startNextTask.bind(this));
        }
        return e.prototype.download = function(e) {
            var t1 = new W(e), o = this.removeTask.bind(this, t1);
            return t1.on("abort", o), this.taskList.push(t1), this.checkTaskReady(t1), t1;
        }, e.prototype.startNextTask = function() {
            var e = this.taskList.find(function(e) {
                return !e.isInProgress();
            });
            e && this.checkTaskReady(e);
        }, e.prototype.checkTaskReady = function(e) {
            var t1 = this.options.threadLimit, o = void 0 === t1 ? 6 : t1;
            if (!(this.taskList.findIndex(function(e) {
                return !e.isInProgress();
            }) >= o || x + 1 > 6)) {
                var r = this.removeTask.bind(this, e);
                e.on("complete", r), e.on("error", r), e.on("timeout", r), setTimeout(function() {
                    return e.start();
                }, 0);
            }
        }, e.prototype.removeTask = function(e) {
            var t1 = this;
            this.taskList.some(function(o, r) {
                return o === e && (setTimeout(function() {
                    return e.removeAllListeners();
                }, 0), t1.taskList.splice(r, 1), !0);
            });
        }, e;
    }();
    e.DownloadTask = W, e.IDownloadManager = G, e.appendBuffer = s, e.arrayBufferToBlob = m, e.arrayBufferToString = g, e.blobToArrayBuffer = p, e.blobToText = h, e.genUuid = c, e.getDataFormat = u, e.getExtName = y, e.getFileName = b, e.getFullPathName = S, e.isImgFile = E, e.isJsonFile = I, e.isVersionFile = A, e.monitorProgress = w, e.sep = a, e.stringToArrayBuffer = f, e.stringToBlob = v, e.transformData = R, Object.defineProperty(e, "__esModule", {
        value: !0
    });
}(fy.exports, yy)), fy.exports))), vy.exports);
class by {
    constructor(e){
        this._cancelError = new Error("request for lock canceled"), this._locked = void 0, this._queue = [], this._waiters = [], this._currentReleaser = void 0, e && (this._cancelError = e), this._locked = !1;
    }
    acquire() {
        const e = this.isLocked(), t1 = new Promise((e, t1)=>this._queue.push({
                resolve: e,
                reject: t1
            }));
        return e || this._dispatch(), t1;
    }
    async runExclusive(e) {
        const t1 = await this.acquire();
        try {
            return await e();
        } finally{
            t1();
        }
    }
    async waitForUnlock() {
        return this.isLocked() ? new Promise((e)=>this._waiters.push({
                resolve: e
            })) : Promise.resolve();
    }
    isLocked() {
        return this._locked;
    }
    release() {
        if (this._currentReleaser) {
            const e = this._currentReleaser;
            this._currentReleaser = void 0, e();
        }
    }
    cancel() {
        this._queue.forEach((e)=>e.reject(this._cancelError)), this._queue = [];
    }
    _dispatch() {
        const e = this._queue.shift();
        if (!e) return;
        let t1 = !1;
        this._currentReleaser = ()=>{
            t1 || (t1 = !0, this._locked = !1, this._resolveWaiters(), this._dispatch());
        }, this._locked = !0, e.resolve(this._currentReleaser);
    }
    _resolveWaiters() {
        this._waiters.forEach((e)=>e.resolve()), this._waiters = [];
    }
}
const Ey = (e, t1, o)=>$e([
        t1,
        o
    ].map((t1, o)=>{
        if ("initial" !== t1) return Ce([
            "success" === t1
        ]);
        {
            const t1 = 0 === o ? "ENCODE" : "DECODE";
            return ot(ip(`${e.toUpperCase()}_${t1}_SUCCESS`, 1).pipe(ke(()=>!0)), ip(`${e.toUpperCase()}_${t1}_FAIL`, 1).pipe(ke(()=>!1)));
        }
    })), Iy = (e)=>{
    const t1 = sh(e.value);
    return t1 ? _e(t1) : ip(ca, 1).pipe(Ee(X), vt(e), ke((e)=>{
        let [, t1] = e;
        return sh(t1);
    }));
};
function Ay(e, t1) {
    var o, r;
    const i = "audio" === e ? null === (o = t1.audio) || void 0 === o ? void 0 : o.audioSsrc : null === (r = t1.video) || void 0 === r ? void 0 : r.videoSsrc, n = "audio" === e ? nl : Mu;
    return "audio" === e && gs() || i ? Promise.resolve() : rp(n);
}
const Cy = ()=>Ce(navigator.mediaDevices.enumerateDevices()).pipe(ke((e)=>{
        const t1 = [], o = [], r = [];
        return e.forEach((e)=>{
            const { kind: i, deviceId: n, label: s } = e, a = s.replace(/\([\w,\d]+:[\w,\d]+\)/i, "").trim();
            switch(i){
                case "audioinput":
                    "communications" === n || /ZoomAudioDevice/i.test(a) || /Zoom-\S*/.test(a) || /CubebAggregateDevice\S*/.test(a) || /Microsoft Teams Audio/i.test(a) || t1.push({
                        deviceId: n,
                        label: a
                    });
                    break;
                case "audiooutput":
                    "communications" === n || /ZoomAudioDevice/i.test(a) || /Microsoft Teams Audio/i.test(a) || o.push({
                        deviceId: n,
                        label: a
                    });
                    break;
                case "videoinput":
                    r.push({
                        deviceId: n,
                        label: a
                    });
            }
        }), {
            microphones: t1,
            speakers: o,
            cameras: r
        };
    }));
function _y(e) {
    const { x: t1, y: o, width: r, height: i } = e.getBoundingClientRect();
    return {
        scaleWidth: r,
        scaleHeight: i,
        srcOffsetX: t1,
        srcOffsetY: o
    };
}
function Ry(e) {
    if (e) {
        let o = e;
        try {
            const t1 = e.width;
            e.width = t1;
        } catch (r) {
            var t1;
            o = e.cloneNode(!0), null === (t1 = e.parentNode) || void 0 === t1 || t1.replaceChild(o, e);
        }
        return o;
    }
    return e;
}
function wy() {
    try {
        return "undefined" != typeof MessageChannel && (new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(md);
    } catch (e) {
        return !1;
    }
}
function Ty() {
    var e;
    return null === (e = WebAssembly) || void 0 === e ? void 0 : e.validate(gd);
}
const Oy = (()=>{
    const e = new by;
    return {
        withAudioAction: (t1)=>function() {
                for(var o = arguments.length, r = new Array(o), i = 0; i < o; i++)r[i] = arguments[i];
                return new Promise(async (o, i)=>{
                    let n = !1;
                    const s = setTimeout(()=>{
                        n = !0, e.release();
                    }, 3e4);
                    try {
                        await e.acquire(), n || clearTimeout(s), o(t1(...r));
                    } catch (e) {
                        n || (clearTimeout(s), i(e));
                    }
                });
            },
        processAudioAction: (t1)=>e.acquire().then(()=>t1()),
        completeAudioAction: ()=>{
            e.release();
        },
        cancelAllAudioAction: ()=>{
            e.cancel();
        }
    };
})();
function Dy(e) {
    const t1 = [
        "joinComputerAudio",
        "joinSharingAudio",
        "leaveComputerAudio",
        "leaveSharingAudio"
    ];
    return new Proxy(e, {
        get: (e, o)=>"string" == typeof o && t1.includes(o) ? function() {
                return Oy.withAudioAction(e[o].bind(e))(...arguments);
            } : Reflect.get(e, o)
    });
}
function Py(e) {
    var t1;
    const { browserVersion: o, isChrome: r, isFirefox: i, isSafari: n, isAndroidOrIOSBrowser: s, isSupportMediaStreamTrackProcessor: a, isSupportOffscreenCanvas: d } = ms, u = Number(null == o || null === (t1 = o.match(/^\d+/)) || void 0 === t1 ? void 0 : t1[0]), l = r && u >= 91, c = i && u >= 89, p = n && qr(o, "17.4") >= 0, h = navigator.hardwareConcurrency > 2;
    let m = fs();
    return e && !m && (m = d && a), !s && m && (l || c || p) && h;
}
const My = (e, t1)=>{
    const o = document.createElement("link");
    return o.rel = "preload", o.href = e, o.as = t1, o.crossOrigin = "anonymous", o;
}, ky = (e, t1, o)=>{
    const r = [], i = [], n = Array.isArray(e) ? e : [
        e
    ];
    return na.filter((e)=>{
        var o;
        return n.includes(e.category) && (e.tag === t1 || (null === (o = e.tag) || void 0 === o ? void 0 : o.split(",").includes(t1)));
    }).forEach((e)=>{
        "worker" === e.type ? r.push(`${o}${e.name}`) : "wasm" === e.type && i.push(`${o}${e.name}`);
    }), {
        workers: r,
        wasms: i
    };
};
function Ly(e, t1, o) {
    const r = {};
    if ("function" != typeof window.SharedArrayBuffer) {
        const { isIOSMobile: e, isSafari: i, isSupportOffscreenCanvas: n, isSupportMediaStreamTrackProcessor: s } = ms, a = e || i || n && s;
        Object.assign(r, {
            enableMultiDecodeVideoWithoutSAB: !!t1 && a
        }), n && s && Object.assign(r, {
            enableVirtualBackgroundWithoutSAB: !!o
        });
    }
    return Py(o) && Object.assign(r, {
        resourceManager: Sy.IResourceManager,
        file: [
            {
                path: `${e}/vb-resource/dualModel.bin`,
                type: "bin"
            },
            {
                path: `${e}/vb-resource/tf.min.js`,
                type: "js"
            }
        ]
    }), r;
}
function Ny(e, t1) {
    const { media: { isAudioBridgeReceiveReady: o, isAudioBridgeSendReady: r }, audio: { customizeAudioOption: i } } = e, n = void 0 !== t1 ? t1 : !(null == i || !i.speakerOnly);
    return $e([
        o ? Ce([
            !0
        ]) : ip(cc, 1).pipe(st(!0)),
        r || n ? Ce([
            !0
        ]) : ip(pc, 1).pipe(st(!0))
    ]);
}
function Vy(e, t1, o) {
    if (e.deviceId === t1) return !0;
    if ("default" === t1) {
        const r = o.find((e)=>e.deviceId === t1);
        if (r) return r.label.indexOf(e.label) > -1;
    }
    return !1;
}
function Uy(e) {
    return e.find((e)=>"default" === e.deviceId);
}
const jy = (()=>{
    let e, t1 = !1;
    return {
        watch: function(o) {
            t1 = !0, e = Promise.race([
                o,
                Yr(()=>!0, 1e4)
            ]).then(()=>{
                e = void 0, t1 = !1;
            }).finally(()=>{
                e = void 0, t1 = !1;
            });
        },
        acquire: function() {
            return t1 && e ? e : Promise.resolve();
        }
    };
})(), xy = (e, t1)=>rp({
        event: Aa,
        operations: [
            tt((t1)=>void 0 !== t1[`${e}`]),
            it(1)
        ]
    }, (o)=>o[`${e}`] === t1);
function By(e, t1, o, r) {
    const i = {
        play: ()=>e.play(),
        pause: ()=>e.pause(),
        get paused () {
            return e.paused;
        },
        get muted () {
            return e.muted;
        },
        set muted (t){
            e.muted = t;
        },
        get currentTime () {
            return e.currentTime;
        },
        set currentTime (t){
            e.currentTime = t;
        },
        get loop () {
            return e.loop;
        },
        set loop (t){
            e.loop = t;
        }
    };
    if ("audio" === t1) {
        const { audio: { mediaPlaybackFile: t1 } } = o;
        Object.defineProperty(i, "playback", {
            get () {
                const o = e.dataset.playback;
                return void 0 !== o ? "1" === o : !(null == t1 || !t1.playback);
            },
            set (t1) {
                r.enablePlayAudioFileLocally(t1), e.dataset.playback = t1 ? "1" : "0";
            }
        });
    }
    return i;
}
function Fy() {
    var e, t1;
    return "orientation" in window.screen ? null === (e = screen.orientation.type) || void 0 === e ? void 0 : e.startsWith("landscape") : "orientation" in window ? 90 === Math.abs(window.orientation) : "matchMedia" in window ? !(null === (t1 = window.matchMedia("(orientation: landscape)")) || void 0 === t1 || !t1.matches) : screen.availWidth > screen.availHeight;
}
function Hy() {
    return "orientation" in window.screen ? ze(screen.orientation, "change").pipe(ht(np()), ke(()=>{
        var e;
        return null === (e = screen.orientation.type) || void 0 === e ? void 0 : e.startsWith("landscape");
    })) : ze(window, "orientationchange").pipe(ht(np()), ke((e)=>{
        var t1;
        const o = null === (t1 = e.target) || void 0 === t1 || null === (t1 = t1.screen) || void 0 === t1 || null === (t1 = t1.orientation) || void 0 === t1 ? void 0 : t1.angle;
        return 90 === Math.abs(o);
    }));
}
class $y {
    constructor(){
        this.audioPlaybackUrl = void 0, this.videoPlaybackUrl = void 0, this._audioElement = void 0, this._videoElement = void 0, this.videoSrc = void 0, this.isUsingSameFile = void 0;
    }
    static getInstance() {
        return void 0 === this.instance && (this.instance = new $y), this.instance;
    }
    static destroyInstance() {
        if (this.instance) {
            this.instance.stopAudioElement(), this.instance.stopVideoElement();
            const t1 = document.getElementById(Pd);
            var e;
            t1 && (null === (e = t1.parentNode) || void 0 === e || e.removeChild(t1)), this.instance = void 0;
        }
    }
    setAudioElement(e) {
        return void 0 === this._audioElement && (this._audioElement = new Audio), new Promise((t1, o)=>{
            if (this.videoSrc === e.url) this._audioElement.pause(), this.isUsingSameFile = !0, this._videoElement.muted = !1, (i = this._videoElement).currentTime > 0 && !i.paused && !i.ended && i.readyState > 2 ? t1("") : this._videoElement.play().then(()=>{
                t1("");
            }).catch(()=>{
                o();
            });
            else {
                var r;
                this.isUsingSameFile = !1;
                const i = ms.isFirefox ? "canplay" : "canplaythrough", n = ()=>{
                    this._audioElement.play().then(()=>{
                        this._audioElement.removeEventListener(i, n), t1("");
                    });
                }, s = ()=>{
                    this._audioElement.removeEventListener(i, n), this._audioElement.removeEventListener("error", s), o();
                };
                this._audioElement.addEventListener(i, n), this._audioElement.addEventListener("error", s), this._audioElement.src = e.url, this._audioElement.loop = !!e.loop, ei(e.url) && this._audioElement.setAttribute("crossorigin", ""), this._audioElement.currentTime = Math.max(null !== (r = e.currentTime) && void 0 !== r ? r : 0, 1e-4), ms.isIOSMobile && this._audioElement.load();
            }
            var i;
        });
    }
    setVideoElement(e) {
        return void 0 === this._videoElement && (this._videoElement = document.createElement("video")), new Promise((t1, o)=>{
            var r;
            this.videoSrc = e.url;
            const i = ms.isFirefox ? "canplay" : "canplaythrough", n = ()=>{
                this._videoElement.play().then(()=>{
                    this._videoElement.removeEventListener(i, n), t1("");
                });
            }, s = ()=>{
                this._videoElement.removeEventListener(i, n), this._videoElement.removeEventListener("error", s), o();
            };
            this._videoElement.addEventListener(i, n), this._videoElement.addEventListener("error", s), this._videoElement.src = e.url, this.isUsingSameFile || (this._videoElement.muted = !0), this._videoElement.loop = !!e.loop, this._videoElement.currentTime = Math.max(null !== (r = e.currentTime) && void 0 !== r ? r : 0, 1e-4), this._videoElement.playsInline = !0, ei(e.url) && this._videoElement.setAttribute("crossorigin", ""), ms.isSafari && !document.getElementById(Pd) && (this._videoElement.id = Pd, this._videoElement.setAttribute("style", "position:fixed;top:-10000px;left:-10000px"), document.body.appendChild(this._videoElement)), ms.isIOSMobile && this._videoElement.load();
        });
    }
    get audioElement() {
        return this.isUsingSameFile ? this._videoElement : this._audioElement;
    }
    get videoElement() {
        return this._videoElement;
    }
    stopAudioElement() {
        this.isUsingSameFile || this._audioElement && (this._audioElement.currentTime = 0, this._audioElement.pause());
    }
    stopVideoElement() {
        this._videoElement && this._videoElement.pause(), this.videoSrc = void 0;
    }
}
$y.instance = void 0;
const Wy = function(e) {
    let t1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const { socket: { zoomSocketStatus: o, xmppSocketStatus: r, mainSessionSocketStatus: i }, meeting: { meetingStatus: n } } = e, s = [];
    if (n === Yn.Joined) {
        var a;
        const t1 = la.getInstance(), o = ra.createAgent();
        if ((null === (a = sh(e)) || void 0 === a ? void 0 : a.audio) === $d.Computer && t1.leaveComputerAudio(), t1.disconnect(), jy.watch(t1.destroy()), e.video && (e.video.subscribedVideoList.length > 0 && e.video.subscribedVideoList.forEach((e)=>{
            o.unsubscribeVideo(e);
        }), e.video.isCurrentUserStartedVideo && ep(mu)), e.share && e.share.isReceiveSharing) {
            const t1 = e.share.activeNodeId;
            e.share.remoteControlledUserList.length > 0 && e.share.remoteControlledUserList.forEach((e)=>{
                o.sharingRequestRemoteControl(e, !1);
            }), o.unsubscribeSharing(t1);
        }
        $y.destroyInstance();
    }
    if (t1 || (is.clearSession(), [
        ns.WebclientTk,
        ns.WebclientZsk,
        ns.WebclientZtk,
        ns.WebclientRecordingToken
    ].forEach((e)=>{
        sessionStorage.removeItem(e);
    }), ws.destroy()), o !== yh.Closed && s.push(Io()), r !== yh.Closed && s.push(Ao()), i !== yh.Closed && s.push(To()), t1) {
        const o = sh(e);
        s.push(En({
            audio: null == o ? void 0 : o.audio,
            muted: null == o ? void 0 : o.muted,
            video: null == o ? void 0 : o.bVideoOn,
            isFailover: t1
        }));
    } else s.push(En({
        audio: !1,
        muted: void 0,
        video: !1,
        isFailover: t1
    }));
    return s.push(No(), er(), Ip(), Vh(t1), Jm(), ag(t1), lv(), mv(), Af(), Bv(), Xv(), wf(), Nf(), Qf(t1), ay(), ly(t1), hy(t1), On(Yn.Closed)), s;
}, Gy = function(e) {
    for(var t1 = arguments.length, o = new Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
    return rp({
        event: ma,
        operations: [
            ke((t1)=>t1.find((t1)=>t1.userId === e.userId && (!e.key || void 0 !== t1[`${e.key}`]))),
            tt((e)=>!!e),
            it(1)
        ]
    }, ...o);
}, Ky = {
    [`${Xn.AudioBridgeEnable}`]: {
        mask: 240,
        action: Vn
    },
    [`${Xn.AudioDecodeInWorklet}`]: {
        mask: 15,
        action: Ko
    },
    [`${Xn.VideoFullHD}`]: {
        mask: 15,
        action: $g
    },
    [`${Xn.VideoShareFullHD}`]: {
        mask: 15,
        action: qm
    },
    [`${Xn.WebGL2Render}`]: {
        mask: 15,
        action: Kg
    },
    [`${Xn.WebGPURender}`]: {
        mask: 15,
        action: zg
    },
    [`${Xn.ZMKFromRWG}`]: {
        mask: 15,
        action: Gn
    }
};
function zy(e) {
    if (!e) return "";
    const t1 = e.match(/rid=(.*)/);
    return t1 ? t1[1] : "";
}
function qy(e) {
    return T(ke((t1, o)=>e(t1, o)), tt((e)=>null != e));
}
function Jy(e) {
    return T(Be((t1, o)=>e(t1, o) || ie));
}
function Qy(e) {
    return T(Be((t1, o)=>e(t1, o)), Be((e)=>Array.isArray(e) ? Ce(e) : _e(e)));
}
const Zy = {
    period: 500,
    rules: [
        {
            peak: 50,
            throttle: 300
        },
        {
            peak: 60,
            throttle: 400
        }
    ]
}, Yy = {
    [`${Ds}`]: ()=>({
            payloads: {
                add: [],
                update: [],
                remove: []
            },
            onThrottle (e) {
                e.add && this.payloads.add.push(...e.add), e.update && this.payloads.update.push(...e.update), e.remove && this.payloads.remove.push(...e.remove);
            }
        })
};
function Xy() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zy;
    return (t1)=>new D((o)=>{
            const r = new Map;
            let i = 0, n = null;
            const { period: s, rules: a } = e;
            let d = null;
            n || (n = ((e, t1)=>{
                const o = performance.now();
                let r = 0, i = !1;
                return setTimeout(function n() {
                    r += t1, e();
                    const s = performance.now() - o - r, a = setTimeout(n, Math.max(t1 - s, 0));
                    i && clearTimeout(a);
                }, t1), ()=>{
                    i = !0;
                };
            })(()=>{
                i = 0;
            }, s));
            const u = Object.keys(Yy), l = t1.subscribe({
                next (e) {
                    if (e && e.evt && null !== n) {
                        i += 1;
                        const { evt: t1, body: n } = e, s = String(t1);
                        if (u.indexOf(s) >= 0) if (d) {
                            const e = r.get(s);
                            if (e) e.onThrottle(n);
                            else {
                                const e = Yy[s]();
                                e.onThrottle(n), r.set(s, e);
                            }
                        } else {
                            let t1 = 0;
                            if (a.forEach((e)=>{
                                i > e.peak && (t1 = e.throttle);
                            }), t1 > 0) {
                                const e = Yy[s]();
                                e.onThrottle(n), r.set(s, e), d = setTimeout(()=>{
                                    r.forEach((e, t1)=>{
                                        const r = {
                                            evt: Number(t1),
                                            body: e.payloads
                                        };
                                        o.next(r);
                                    }), r.clear(), d = null;
                                }, t1);
                            } else o.next(e);
                        }
                        else o.next(e);
                    } else o.next(e);
                },
                error (e) {
                    o.error(e);
                },
                complete () {
                    o.complete();
                }
            });
            return ()=>{
                l.unsubscribe(), n && (n(), n = null), i = 0;
            };
        });
}
let eS = function(e) {
    return e[e.Unknown = 0] = "Unknown", e[e.Windows = 1] = "Windows", e[e.Mac = 2] = "Mac", e[e.Pad = 3] = "Pad", e[e.Mobile = 4] = "Mobile", e[e.CallIn = 5] = "CallIn", e[e.Linux = 6] = "Linux", e[e.WebClient = 7] = "WebClient", e[e.ChromeOs = 8] = "ChromeOs", e;
}({});
const tS = 262144, oS = 1048576, rS = (e)=>!(4 & ~e), iS = (e)=>(e & oS) === oS, nS = (e)=>{
    let { share: { isReceiveSharing: t1 } } = e;
    return t1;
}, sS = (e)=>{
    let { share: { activeNodeId: t1 } } = e;
    return t1;
}, aS = Np([
    ch,
    nS,
    sS
], function() {
    let e = arguments.length > 2 ? arguments[2] : void 0;
    if (arguments.length > 1 ? arguments[1] : void 0) {
        const t1 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).find((t1)=>t1.userId === e && !0 === t1.sharerOn);
        if (t1) {
            let { os: e } = t1;
            const { pwaOS: o } = t1;
            return "mac" === o ? e = eS.Mac : "win" === o && (e = eS.Windows), {
                ...t1,
                os: e
            };
        }
    }
    return null;
}), dS = Np([
    ch
], (e)=>e.filter((e)=>e.sharerOn)), uS = Np([
    dS
], (e)=>e.some((e)=>!!e.bVideoShare)), lS = Np([
    (e)=>{
        let { share: { remoteControlledUserList: t1 } } = e;
        return t1;
    },
    nS,
    sS
], (e, t1, o)=>!!t1 && e.some((e)=>Zr(e, o)));
var cS, pS = new Uint8Array(16);
function hS() {
    if (!cS && !(cS = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return cS(pS);
}
for(var mS = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, gS = [], vS = 0; vS < 256; ++vS)gS.push((vS + 256).toString(16).substr(1));
function fS(e, t1, o) {
    var r = (e = e || {}).random || (e.rng || hS)();
    return r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, function(e) {
        var t1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, o = (gS[e[t1 + 0]] + gS[e[t1 + 1]] + gS[e[t1 + 2]] + gS[e[t1 + 3]] + "-" + gS[e[t1 + 4]] + gS[e[t1 + 5]] + "-" + gS[e[t1 + 6]] + gS[e[t1 + 7]] + "-" + gS[e[t1 + 8]] + gS[e[t1 + 9]] + "-" + gS[e[t1 + 10]] + gS[e[t1 + 11]] + gS[e[t1 + 12]] + gS[e[t1 + 13]] + gS[e[t1 + 14]] + gS[e[t1 + 15]]).toLowerCase();
        if (!function(e) {
            return "string" == typeof e && mS.test(e);
        }(o)) throw TypeError("Stringified UUID is invalid");
        return o;
    }(r);
}
function yS(e) {
    var t1 = typeof e;
    return null != e && ("object" == t1 || "function" == t1);
}
var SS = "object" == typeof global && global && global.Object === Object && global, bS = "object" == typeof self && self && self.Object === Object && self, ES = SS || bS || Function("return this")(), IS = function() {
    return ES.Date.now();
}, AS = /\s/, CS = /^\s+/;
var _S = ES.Symbol, RS = Object.prototype, wS = RS.hasOwnProperty, TS = RS.toString, OS = _S ? _S.toStringTag : void 0, DS = Object.prototype.toString, PS = _S ? _S.toStringTag : void 0;
function MS(e) {
    return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : PS && PS in Object(e) ? function(e) {
        var t1 = wS.call(e, OS), o = e[OS];
        try {
            e[OS] = void 0;
            var r = !0;
        } catch (e) {}
        var i = TS.call(e);
        return r && (t1 ? e[OS] = o : delete e[OS]), i;
    }(e) : function(e) {
        return DS.call(e);
    }(e);
}
function kS(e) {
    return null != e && "object" == typeof e;
}
var LS = /^[-+]0x[0-9a-f]+$/i, NS = /^0b[01]+$/i, VS = /^0o[0-7]+$/i, US = parseInt;
function jS(e) {
    if ("number" == typeof e) return e;
    if (function(e) {
        return "symbol" == typeof e || kS(e) && "[object Symbol]" == MS(e);
    }(e)) return NaN;
    if (yS(e)) {
        var t1 = "function" == typeof e.valueOf ? e.valueOf() : e;
        e = yS(t1) ? t1 + "" : t1;
    }
    if ("string" != typeof e) return 0 === e ? e : +e;
    e = function(e) {
        return e ? e.slice(0, function(e) {
            for(var t1 = e.length; t1-- && AS.test(e.charAt(t1)););
            return t1;
        }(e) + 1).replace(CS, "") : e;
    }(e);
    var o = NS.test(e);
    return o || VS.test(e) ? US(e.slice(2), o ? 2 : 8) : LS.test(e) ? NaN : +e;
}
var xS, BS, FS, HS, $S = Math.max, WS = Math.min;
!function(e) {
    e[e.PLAIN = 0] = "PLAIN", e[e.RSA = 1] = "RSA", e[e.AESGCM256 = 2] = "AESGCM256";
}(xS || (xS = {})), function(e) {
    e[e.info = 0] = "info", e[e.debug = 1] = "debug", e[e.log = 2] = "log", e[e.warn = 3] = "warn", e[e.error = 4] = "error";
}(BS || (BS = {})), function(e) {
    e[e.PROTECT_LOCAL_KEY = 0] = "PROTECT_LOCAL_KEY";
}(FS || (FS = {})), function(e) {
    e.beforeInit = "beforeInit", e.afterInit = "afterInit", e.beforeLog = "beforeLog", e.hitSizeLimit = "hitSizeLimit", e.afterLog = "afterLog", e.beforeReport = "beforeReport", e.afterReport = "afterReport";
}(HS || (HS = {}));
class GS {
    constructor(){}
}
var KS, zS, qS = {
    exports: {}
}, JS = {
    exports: {}
}, QS = jt(Object.freeze({
    __proto__: null,
    default: {}
}));
function ZS() {
    return KS || (KS = 1, JS.exports = (e = e || function(e) {
        var t1;
        if ("undefined" != typeof window && window.crypto && (t1 = window.crypto), "undefined" != typeof self && self.crypto && (t1 = self.crypto), "undefined" != typeof globalThis && globalThis.crypto && (t1 = globalThis.crypto), !t1 && "undefined" != typeof window && window.msCrypto && (t1 = window.msCrypto), !t1 && void 0 !== Vt && Vt.crypto && (t1 = Vt.crypto), !t1) try {
            t1 = QS;
        } catch (e) {}
        var o = function() {
            if (t1) {
                if ("function" == typeof t1.getRandomValues) try {
                    return t1.getRandomValues(new Uint32Array(1))[0];
                } catch (e) {}
                if ("function" == typeof t1.randomBytes) try {
                    return t1.randomBytes(4).readInt32LE();
                } catch (e) {}
            }
            throw new Error("Native crypto module could not be used to get secure random number.");
        }, r = Object.create || function() {
            function e() {}
            return function(t1) {
                var o;
                return e.prototype = t1, o = new e, e.prototype = null, o;
            };
        }(), i = {}, n = i.lib = {}, s = n.Base = {
            extend: function(e) {
                var t1 = r(this);
                return e && t1.mixIn(e), t1.hasOwnProperty("init") && this.init !== t1.init || (t1.init = function() {
                    t1.$super.init.apply(this, arguments);
                }), t1.init.prototype = t1, t1.$super = this, t1;
            },
            create: function() {
                var e = this.extend();
                return e.init.apply(e, arguments), e;
            },
            init: function() {},
            mixIn: function(e) {
                for(var t1 in e)e.hasOwnProperty(t1) && (this[t1] = e[t1]);
                e.hasOwnProperty("toString") && (this.toString = e.toString);
            },
            clone: function() {
                return this.init.prototype.extend(this);
            }
        }, a = n.WordArray = s.extend({
            init: function(e, t1) {
                e = this.words = e || [], this.sigBytes = null != t1 ? t1 : 4 * e.length;
            },
            toString: function(e) {
                return (e || u).stringify(this);
            },
            concat: function(e) {
                var t1 = this.words, o = e.words, r = this.sigBytes, i = e.sigBytes;
                if (this.clamp(), r % 4) for(var n = 0; n < i; n++){
                    var s = o[n >>> 2] >>> 24 - n % 4 * 8 & 255;
                    t1[r + n >>> 2] |= s << 24 - (r + n) % 4 * 8;
                }
                else for(var a = 0; a < i; a += 4)t1[r + a >>> 2] = o[a >>> 2];
                return this.sigBytes += i, this;
            },
            clamp: function() {
                var t1 = this.words, o = this.sigBytes;
                t1[o >>> 2] &= 4294967295 << 32 - o % 4 * 8, t1.length = e.ceil(o / 4);
            },
            clone: function() {
                var e = s.clone.call(this);
                return e.words = this.words.slice(0), e;
            },
            random: function(e) {
                for(var t1 = [], r = 0; r < e; r += 4)t1.push(o());
                return new a.init(t1, e);
            }
        }), d = i.enc = {}, u = d.Hex = {
            stringify: function(e) {
                for(var t1 = e.words, o = e.sigBytes, r = [], i = 0; i < o; i++){
                    var n = t1[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    r.push((n >>> 4).toString(16)), r.push((15 & n).toString(16));
                }
                return r.join("");
            },
            parse: function(e) {
                for(var t1 = e.length, o = [], r = 0; r < t1; r += 2)o[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4;
                return new a.init(o, t1 / 2);
            }
        }, l = d.Latin1 = {
            stringify: function(e) {
                for(var t1 = e.words, o = e.sigBytes, r = [], i = 0; i < o; i++){
                    var n = t1[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    r.push(String.fromCharCode(n));
                }
                return r.join("");
            },
            parse: function(e) {
                for(var t1 = e.length, o = [], r = 0; r < t1; r++)o[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8;
                return new a.init(o, t1);
            }
        }, c = d.Utf8 = {
            stringify: function(e) {
                try {
                    return decodeURIComponent(escape(l.stringify(e)));
                } catch (e) {
                    throw new Error("Malformed UTF-8 data");
                }
            },
            parse: function(e) {
                return l.parse(unescape(encodeURIComponent(e)));
            }
        }, p = n.BufferedBlockAlgorithm = s.extend({
            reset: function() {
                this._data = new a.init, this._nDataBytes = 0;
            },
            _append: function(e) {
                "string" == typeof e && (e = c.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes;
            },
            _process: function(t1) {
                var o, r = this._data, i = r.words, n = r.sigBytes, s = this.blockSize, d = n / (4 * s), u = (d = t1 ? e.ceil(d) : e.max((0 | d) - this._minBufferSize, 0)) * s, l = e.min(4 * u, n);
                if (u) {
                    for(var c = 0; c < u; c += s)this._doProcessBlock(i, c);
                    o = i.splice(0, u), r.sigBytes -= l;
                }
                return new a.init(o, l);
            },
            clone: function() {
                var e = s.clone.call(this);
                return e._data = this._data.clone(), e;
            },
            _minBufferSize: 0
        });
        n.Hasher = p.extend({
            cfg: s.extend(),
            init: function(e) {
                this.cfg = this.cfg.extend(e), this.reset();
            },
            reset: function() {
                p.reset.call(this), this._doReset();
            },
            update: function(e) {
                return this._append(e), this._process(), this;
            },
            finalize: function(e) {
                return e && this._append(e), this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function(e) {
                return function(t1, o) {
                    return new e.init(o).finalize(t1);
                };
            },
            _createHmacHelper: function(e) {
                return function(t1, o) {
                    return new h.HMAC.init(e, o).finalize(t1);
                };
            }
        });
        var h = i.algo = {};
        return i;
    }(Math), e)), JS.exports;
    "TURBOPACK unreachable";
    var e;
}
var YS, XS, eb = zS ? qS.exports : (zS = 1, qS.exports = ZS().enc.Utf8), tb = {
    exports: {}
}, ob = (YS || (YS = 1, tb.exports = (XS = ZS(), function() {
    var e = XS, t1 = e.lib.WordArray;
    function o(e, o, r) {
        for(var i = [], n = 0, s = 0; s < o; s++)if (s % 4) {
            var a = r[e.charCodeAt(s - 1)] << s % 4 * 2 | r[e.charCodeAt(s)] >>> 6 - s % 4 * 2;
            i[n >>> 2] |= a << 24 - n % 4 * 8, n++;
        }
        return t1.create(i, n);
    }
    e.enc.Base64 = {
        stringify: function(e) {
            var t1 = e.words, o = e.sigBytes, r = this._map;
            e.clamp();
            for(var i = [], n = 0; n < o; n += 3)for(var s = (t1[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 16 | (t1[n + 1 >>> 2] >>> 24 - (n + 1) % 4 * 8 & 255) << 8 | t1[n + 2 >>> 2] >>> 24 - (n + 2) % 4 * 8 & 255, a = 0; a < 4 && n + .75 * a < o; a++)i.push(r.charAt(s >>> 6 * (3 - a) & 63));
            var d = r.charAt(64);
            if (d) for(; i.length % 4;)i.push(d);
            return i.join("");
        },
        parse: function(e) {
            var t1 = e.length, r = this._map, i = this._reverseMap;
            if (!i) {
                i = this._reverseMap = [];
                for(var n = 0; n < r.length; n++)i[r.charCodeAt(n)] = n;
            }
            var s = r.charAt(64);
            if (s) {
                var a = e.indexOf(s);
                -1 !== a && (t1 = a);
            }
            return o(e, t1, i);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    };
}(), XS.enc.Base64)), tb.exports), rb = function(e, t1, o, r) {
    return new (o || (o = Promise))(function(i, n) {
        function s(e) {
            try {
                d(r.next(e));
            } catch (e) {
                n(e);
            }
        }
        function a(e) {
            try {
                d(r.throw(e));
            } catch (e) {
                n(e);
            }
        }
        function d(e) {
            var t1;
            e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                e(t1);
            })).then(s, a);
        }
        d((r = r.apply(e, t1 || [])).next());
    });
};
const ib = (e)=>{
    try {
        const t1 = ob.parse(e);
        return eb.stringify(t1);
    } catch (t1) {
        return e;
    }
}, nb = (e)=>{
    for(var t1 = e.length, o = e.length - 1; o >= 0; o--){
        var r = e.charCodeAt(o);
        r > 127 && r <= 2047 ? t1++ : r > 2047 && r <= 65535 && (t1 += 2), r >= 56320 && r <= 57343 && o--;
    }
    return t1;
}, sb = ()=>rb(void 0, void 0, void 0, function*() {
        return yield self.crypto.subtle.generateKey({
            name: "AES-GCM",
            length: 256
        }, !0, [
            "encrypt",
            "decrypt"
        ]);
    }), ab = (e, t1, o)=>rb(void 0, void 0, void 0, function*() {
        try {
            return yield self.crypto.subtle.encrypt({
                name: "AES-GCM",
                iv: o
            }, t1, e);
        } catch (e) {
            throw e;
        }
    }), db = (e, t1)=>{
    const o = "string" == typeof e ? function(e) {
        const t1 = new ArrayBuffer(e.length), o = new Uint8Array(t1);
        for(let t1 = 0, r = e.length; t1 < r; t1++)o[t1] = e.charCodeAt(t1);
        return t1;
    }(e) : e;
    return self.crypto.subtle.encrypt({
        name: "RSA-OAEP"
    }, t1, o);
}, ub = {}, lb = (e, t1)=>{
    ub[t1] = e;
}, cb = ub, pb = (e)=>{
    try {
        return JSON.stringify(e);
    } catch (e) {
        return "json stringify failed";
    }
}, hb = (e)=>{
    try {
        return JSON.parse(e);
    } catch (t1) {
        return e;
    }
};
const mb = (e)=>{
    let t1 = 0;
    return t1 += nb(e.message), e.tags.forEach((e)=>{
        t1 += nb(e);
    }), t1;
};
class gb {
    constructor(e){
        this.uuid = "randomUUID" in self.crypto ? self.crypto.randomUUID() : "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (e)=>(e ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e / 4).toString(16));
        const { databaseName: t1, maxSize: o, publicKey: r, reportUrl: i, plugins: n, idbManager: s, logManager: a, currentSize: d, externalKeys: u, codecWorkerFilePath: l } = e;
        this.databaseName = t1, this.maxSize = o, this.publicKey = null != r ? r : "", this.reportUrl = null != i ? i : "", this.plugins = null != n ? n : [], this.idbManager = s, this.logManager = a, this.currentSize = null != d ? d : 0, this.externalKeys = u, this.commonMethods = Object.assign({}, cb);
    }
    getLocalAESGCM256Key() {
        var e;
        return function(e, t1, o, r) {
            return new (o || (o = Promise))(function(i, n) {
                function s(e) {
                    try {
                        d(r.next(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function a(e) {
                    try {
                        d(r.throw(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function d(e) {
                    var t1;
                    e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                        e(t1);
                    })).then(s, a);
                }
                d((r = r.apply(e, t1 || [])).next());
            });
        }(this, void 0, void 0, function*() {
            if (this.localAESGCM256Key) return this.localAESGCM256Key;
            this.localAESGCM256Key = yield sb();
            const t1 = this.externalKeys ? null === (e = this.externalKeys.filter((e)=>e.usage === FS.PROTECT_LOCAL_KEY)[0]) || void 0 === e ? void 0 : e.key : void 0;
            return yield this.idbManager.saveAESGCM256Key(this.uuid, this.localAESGCM256Key, t1), this.localAESGCM256Key;
        });
    }
    updateCurrentSize(e) {
        var t1;
        let o = null !== (t1 = this.currentSize) && void 0 !== t1 ? t1 : 0;
        if (e instanceof Map) for (const [t1, r] of e)o += mb(r);
        else o += mb(e);
        return this.currentSize = o, o >= this.maxSize;
    }
}
const vb = (...e)=>{
    const t1 = {}, o = [];
    for (const r of e)r.forEach((e)=>{
        t1[e.id] || (t1[e.id] = !0, o.push(e));
    });
    const r = new Map;
    return o.sort((e, t1)=>(null == e ? void 0 : e.id) - (null == t1 ? void 0 : t1.id)).forEach((e)=>{
        r.set(e.id, e);
    }), r;
}, fb = (e, t1)=>{
    const o = new Map;
    return t1.forEach((t1)=>{
        e(t1) && o.set(t1.id, t1);
    }), o;
};
class yb {
    constructor(){
        this.getStore = ()=>({
                byTag: Object.assign({}, this.store.byTag),
                byTime: new Map(this.store.byTime)
            }), this.pushByTime = (e)=>{
            for (const t1 of e)this.store.byTime.set(t1.id, t1);
        }, this.pushByTag = (e)=>{
            e.forEach((e)=>{
                const t1 = e.tags;
                Array.isArray(t1) && t1.forEach((t1)=>{
                    this.store.byTag[t1] || (this.store.byTag[t1] = new Map), this.store.byTag[t1].set(e.id, e);
                });
            });
        }, this.addLog = (e)=>{
            let t1 = e;
            Array.isArray(e) || (t1 = [
                e
            ]), this.pushByTime(t1), this.pushByTag(t1);
        }, this.syncFromIDB = (e)=>(function(e, t1, o, r) {
                return new (o || (o = Promise))(function(i, n) {
                    function s(e) {
                        try {
                            d(r.next(e));
                        } catch (e) {
                            n(e);
                        }
                    }
                    function a(e) {
                        try {
                            d(r.throw(e));
                        } catch (e) {
                            n(e);
                        }
                    }
                    function d(e) {
                        var t1;
                        e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                            e(t1);
                        })).then(s, a);
                    }
                    d((r = r.apply(e, t1 || [])).next());
                });
            })(this, void 0, void 0, function*() {
                const t1 = yield e.getAllLogs();
                this.addLog(t1);
            }), this.reset = ()=>{
            this.store = {
                byTag: {},
                byTime: new Map
            };
        }, this.deleteLogs = (e)=>{
            for (const t1 of e){
                const e = this.store.byTime.get(t1);
                if (!e) continue;
                const { tags: o } = e;
                for (const e of o)this.store.byTag[e].delete(t1);
                this.store.byTime.delete(t1);
            }
        }, this.filterStore = (e)=>{
            const t1 = ((e, t1)=>{
                if (!t1) return e.byTime;
                if ("string" == typeof t1) return e.byTag[t1] || new Map;
                if (Array.isArray(t1)) {
                    if (t1.every((e)=>"string" == typeof e)) return vb(...t1.map((t1)=>e.byTag[t1]).filter((e)=>Boolean(e)));
                } else {
                    if ("function" == typeof t1) return fb(t1, e.byTime);
                    if ("object" == typeof t1) if (t1.tags && t1.filter) {
                        if ("string" == typeof t1.tags) return fb(t1.filter, e.byTag[t1.tags]);
                        if (Array.isArray(t1.tags) && t1.tags.every((e)=>"string" == typeof e)) return vb(...t1.tags.map((o)=>{
                            const r = e.byTag[o];
                            return r ? fb(t1.filter, r) : new Map;
                        }));
                    } else {
                        if (t1.filter) return fb(t1.filter, e.byTime);
                        if (t1.tags) {
                            if ("string" == typeof t1) return e.byTag[t1] || new Map;
                            if (Array.isArray(t1) && t1.every((e)=>"string" == typeof e)) return vb(...t1.map((t1)=>e.byTag[t1]));
                        }
                    }
                    else console.error("Wrong filter type");
                }
                return new Map;
            })(this.store, e), o = new Map;
            for (const [e, r] of t1){
                const t1 = Object.assign(Object.assign({}, r), {
                    message: hb(ib(r.message))
                });
                o.set(e, t1);
            }
            return o;
        }, this.store = {
            byTag: {},
            byTime: new Map
        };
    }
}
function Sb(e, t1, o) {
    const r = e.plugins;
    if (!Array.isArray(r)) return o;
    let i = o;
    return r.forEach((o)=>{
        const r = o[t1];
        if ("function" == typeof r) {
            const t1 = r(e, i);
            t1 && (i = t1);
        }
    }), i;
}
const bb = (e, t1, o, r, i, n = {})=>(function(e, t1, o, r) {
        return new (o || (o = Promise))(function(i, n) {
            function s(e) {
                try {
                    d(r.next(e));
                } catch (e) {
                    n(e);
                }
            }
            function a(e) {
                try {
                    d(r.throw(e));
                } catch (e) {
                    n(e);
                }
            }
            function d(e) {
                var t1;
                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                    e(t1);
                })).then(s, a);
            }
            d((r = r.apply(e, t1 || [])).next());
        });
    })(void 0, void 0, void 0, function*() {
        const { noCache: s, extraProperties: a = {} } = n, d = ((e, t1, o, r, i, n)=>{
            const s = Array.isArray(t1) ? t1 : [
                t1
            ], a = Date.now();
            return Object.assign({
                message: e,
                logLevel: o,
                tags: s,
                encryptMode: r,
                timestamp: a,
                laplaceSessionId: i
            }, n);
        })(`${t1}`, o, r, i, e.uuid, a), u = Sb(e, HS.beforeLog, d);
        if (s) Sb(e, HS.afterLog, d);
        else {
            const { idbManager: t1, logManager: o } = e, r = yield t1.makeNextId();
            u.message = ((e)=>{
                try {
                    const t1 = eb.parse(e);
                    return ob.stringify(t1);
                } catch (t1) {
                    return e;
                }
            })(u.message);
            const i = Object.assign(Object.assign({}, u), {
                id: r
            });
            e.updateCurrentSize(i) && Sb(e, HS.hitSizeLimit, i), o.addLog(i), yield t1.addLog(i), Sb(e, HS.afterLog, i);
        }
    });
lb(bb, "commonLog");
const Eb = (e)=>new Promise((t1)=>{
        const o = new XMLHttpRequest;
        o.open(e.type || "GET", e.url, !0), o.withCredentials = e.withCredentials, o.onerror = (o)=>{
            t1({
                error: o,
                report: e.reportItem
            });
        }, o.onreadystatechange = function() {
            if (4 === o.readyState) {
                const r = o.status;
                t1(r >= 200 && r < 300 ? {
                    report: e.reportItem
                } : {
                    error: `Request failed, status: ${r}, responseText: ${o.responseText}`,
                    report: e.reportItem
                });
            }
        }, Object.entries(e.headers).forEach(([e, t1])=>{
            t1 && e && o.setRequestHeader(e, t1);
        }), o.send(e.data);
    });
const Ib = (e, t1 = 2)=>{
    let o = `${e}`;
    for(; o.length < t1;)o = `0${o}`;
    return o;
}, Ab = (e)=>{
    const t1 = new Date(e);
    return `${t1.getUTCFullYear()}-${Ib(t1.getUTCMonth() + 1)}-${Ib(t1.getUTCDate())} ${Ib(t1.getUTCHours())}:${Ib(t1.getUTCMinutes())}:${Ib(t1.getUTCSeconds())}.${Ib(t1.getUTCMilliseconds(), 3)}`;
}, Cb = {
    version: "000001",
    flag: "0"
}, _b = (e, t1)=>Array.from(e.values()).reduce((e, o)=>{
        const r = ((e, t1)=>{
            const { message: o, logLevel: r, tags: i, timestamp: n, encryptMode: s, id: a } = e, d = function(e, t1) {
                var o = {};
                for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && t1.indexOf(r) < 0 && (o[r] = e[r]);
                if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                    var i = 0;
                    for(r = Object.getOwnPropertySymbols(e); i < r.length; i++)t1.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (o[r[i]] = e[r[i]]);
                }
                return o;
            }(e, [
                "message",
                "logLevel",
                "tags",
                "timestamp",
                "encryptMode",
                "id"
            ]), u = Object.assign(Object.assign({
                time: Ab(n),
                logLevel: BS[r],
                message: o,
                tags: i
            }, t1), d);
            return pb(u);
        })(o, t1), i = nb(r), n = e[e.length - 1];
        return n.currentSize + i > 30720 ? e.push({
            messages: [
                r
            ],
            ids: [
                o.id
            ],
            currentSize: i
        }) : (n.messages.push(r), n.ids.push(o.id), n.currentSize += i), e;
    }, [
        {
            messages: [],
            ids: [],
            currentSize: 0
        }
    ]).filter((e)=>e.currentSize > 0).map((e)=>({
            messages: e.messages.join("\n"),
            ids: e.ids,
            meta: Cb
        })), Rb = (e, t1, o)=>((e, t1, o)=>Promise.all(e.map((e)=>Object.assign({
                url: t1 || "",
                type: "POST",
                withCredentials: !1,
                headers: {},
                data: pb({
                    messages: e.messages,
                    meta: e.meta
                }),
                reportItem: e
            }, o)).map(Eb)))(e, t1.reportUrl, o).then((e)=>{
        e.forEach((e)=>{
            var o;
            Sb(t1, HS.afterReport, {
                report: e.report,
                error: null !== (o = e.error) && void 0 !== o ? o : null
            });
        });
    }), wb = (e, t1, o)=>(function(e, t1, o, r) {
        return new (o || (o = Promise))(function(i, n) {
            function s(e) {
                try {
                    d(r.next(e));
                } catch (e) {
                    n(e);
                }
            }
            function a(e) {
                try {
                    d(r.throw(e));
                } catch (e) {
                    n(e);
                }
            }
            function d(e) {
                var t1;
                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                    e(t1);
                })).then(s, a);
            }
            d((r = r.apply(e, t1 || [])).next());
        });
    })(void 0, void 0, void 0, function*() {
        const r = e.logManager.filterStore(t1);
        if (!r || 0 === (null == r ? void 0 : r.size) || !o) return;
        const { xhrOptions: i = {}, additionalContext: n } = o, s = Sb(e, HS.beforeReport, r), a = _b(s, n);
        Rb(a, e, i);
    });
lb(wb, "commonReport");
var Tb = function(e, t1, o, r) {
    return new (o || (o = Promise))(function(i, n) {
        function s(e) {
            try {
                d(r.next(e));
            } catch (e) {
                n(e);
            }
        }
        function a(e) {
            try {
                d(r.throw(e));
            } catch (e) {
                n(e);
            }
        }
        function d(e) {
            var t1;
            e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                e(t1);
            })).then(s, a);
        }
        d((r = r.apply(e, t1 || [])).next());
    });
};
const Ob = (e, t1, o)=>Tb(void 0, void 0, void 0, function*() {
        const { idbManager: r, logManager: i } = e;
        if (Array.isArray(o) && (yield r.deleteLogs(o), i.deleteLogs(o), !t1)) return;
        const n = e.logManager.filterStore(t1), s = [];
        for (const [e, t1] of n)s.push(t1.id);
        let a = s;
        Array.isArray(s) || (a = [
            s
        ]), yield r.deleteLogs(a), i.deleteLogs(a);
    }), Db = (e)=>Tb(void 0, void 0, void 0, function*() {
        const { idbManager: t1, logManager: o } = e;
        yield t1.reset(), o.reset();
    });
function Pb(e) {
    return new Promise((t1, o)=>{
        e.oncomplete = e.onsuccess = ()=>t1(e.result), e.onabort = e.onerror = ()=>o(e.error);
    });
}
function Mb(e, t1) {
    const o = indexedDB.open(e);
    o.onupgradeneeded = ()=>o.result.createObjectStore(t1);
    const r = Pb(o);
    return (e, o)=>r.then((r)=>o(r.transaction(t1, e).objectStore(t1)));
}
let kb;
function Lb() {
    return kb || (kb = Mb("keyval-store", "keyval")), kb;
}
function Nb(e, t1 = Lb()) {
    return t1("readwrite", (t1)=>(e.forEach((e)=>t1.delete(e)), Pb(t1.transaction)));
}
function Vb(e = Lb()) {
    return e("readonly", (t1)=>{
        if (t1.getAll && t1.getAllKeys) return Promise.all([
            Pb(t1.getAllKeys()),
            Pb(t1.getAll())
        ]).then(([e, t1])=>e.map((e, o)=>[
                    e,
                    t1[o]
                ]));
        const o = [];
        return e("readonly", (e)=>(function(e) {
                return e.openCursor().onsuccess = function() {
                    this.result && (((e)=>{
                        o.push([
                            e.key,
                            e.value
                        ]);
                    })(this.result), this.result.continue());
                }, Pb(e.transaction);
            })(e).then(()=>o));
    });
}
lb(Ob, "commonDelete"), lb(Db, "commonReset");
const Ub = {
    default: {
        queue: [],
        isRunning: !1,
        listeners: []
    }
}, jb = (e)=>{
    let t1 = Ub[e];
    return t1 || (t1 = {
        queue: [],
        isRunning: !1,
        listeners: []
    }, Ub[e] = t1), t1;
};
function xb(e) {
    return function(e, t1, o, r) {
        return new (o || (o = Promise))(function(i, n) {
            function s(e) {
                try {
                    d(r.next(e));
                } catch (e) {
                    n(e);
                }
            }
            function a(e) {
                try {
                    d(r.throw(e));
                } catch (e) {
                    n(e);
                }
            }
            function d(e) {
                var t1;
                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                    e(t1);
                })).then(s, a);
            }
            d((r = r.apply(e, t1 || [])).next());
        });
    }(this, void 0, void 0, function*() {
        const t1 = jb(e), { queue: o, listeners: r } = t1;
        for(; o.length > 0 && !t1.isRunning;){
            const r = o.shift();
            t1.isRunning = !0;
            try {
                const e = yield r.task();
                r.resolution(e);
            } catch (e) {
                r.rejection(e);
            }
            t1.isRunning = !1, xb(e);
        }
        r.length && r.forEach((e)=>{
            e();
        });
    });
}
function Bb(e, t1 = "default") {
    const o = jb(t1);
    try {
        return new Promise((r, i)=>{
            o.queue.push({
                task: e,
                resolution: r,
                rejection: i
            }), xb(t1);
        });
    } catch (e) {
        return Promise.reject(e);
    }
}
const Fb = (e, t1)=>{
    jb(e).listeners.push(t1);
};
var Hb = function(e, t1, o, r) {
    return new (o || (o = Promise))(function(i, n) {
        function s(e) {
            try {
                d(r.next(e));
            } catch (e) {
                n(e);
            }
        }
        function a(e) {
            try {
                d(r.throw(e));
            } catch (e) {
                n(e);
            }
        }
        function d(e) {
            var t1;
            e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                e(t1);
            })).then(s, a);
        }
        d((r = r.apply(e, t1 || [])).next());
    });
};
const $b = "change_meta", Wb = "change_log", Gb = ()=>Promise.resolve();
class Kb {
    constructor(e){
        this.waitingForReset = !1, this.resetting = !1, this.isChangingMeta = !1, this.isChangingLog = !1, this.dbFailCount = {
            read: 0,
            write: 0
        }, this.get = (e)=>(function(e, t1 = Lb()) {
                return t1("readonly", (t1)=>Pb(t1.get(e)));
            })(e, this.store), this.set = (e, t1)=>Hb(this, void 0, void 0, function*() {
                try {
                    return !(this.dbFailCount.write > 3) && (yield function(e, t1, o = Lb()) {
                        return o("readwrite", (o)=>(o.put(t1, e), Pb(o.transaction)));
                    }(e, t1, this.store));
                } catch (o) {
                    o instanceof DOMException && (o && "QuotaExceededError" === o.name ? (yield this.deleteOldLogsForSetNewOne(), yield this.set(e, t1)) : this.dbFailCount.write += 1), console.error(o);
                }
            }), this.deleteOldLogsForSetNewOne = ()=>Hb(this, void 0, void 0, function*() {
                var e;
                const t1 = yield this.getAllLogs(), o = [];
                for(let r = 0; r < 13; r++){
                    const i = null === (e = t1[r]) || void 0 === e ? void 0 : e.id;
                    (i || 0 === i) && o.push(`${i}`);
                }
                return Nb(o, this.store);
            }), this.adjustMaxId = ()=>Hb(this, void 0, void 0, function*() {
                return this.resetting ? Gb() : (this.isChangingMeta = !0, yield Bb(()=>Hb(this, void 0, void 0, function*() {
                        var e;
                        const t1 = yield this.getAllLogs(), o = t1[t1.length - 1], r = null !== (e = null == o ? void 0 : o.id) && void 0 !== e ? e : 0;
                        return yield this.set("maxId", r), r;
                    }), $b));
            }), this.makeNextId = ()=>Hb(this, void 0, void 0, function*() {
                return this.resetting ? Gb() : (this.isChangingMeta = !0, yield Bb(()=>Hb(this, void 0, void 0, function*() {
                        const e = yield this.get("maxId");
                        if (!e && 0 !== e) return yield this.set("maxId", 0), 0;
                        const t1 = e + 1;
                        return yield this.set("maxId", t1), t1;
                    }), $b));
            }), this.addLog = (e)=>Hb(this, void 0, void 0, function*() {
                if (this.resetting) return Gb();
                this.isChangingLog = !0, yield Bb(()=>Hb(this, void 0, void 0, function*() {
                        const { id: t1 } = e;
                        return this.set(`${t1}`, e);
                    }), Wb);
            }), this.getAllLogs = ()=>Hb(this, void 0, void 0, function*() {
                return (yield Vb(this.store)).filter(([e])=>"maxId" !== e).sort((e, t1)=>{
                    var o, r;
                    return (null === (o = e[1]) || void 0 === o ? void 0 : o.id) - (null === (r = t1[1]) || void 0 === r ? void 0 : r.id);
                }).map(([, e])=>e);
            }), this.deleteLogs = (e)=>Hb(this, void 0, void 0, function*() {
                if (this.resetting) return Gb();
                this.isChangingLog = !0, yield Bb(()=>Hb(this, void 0, void 0, function*() {
                        return Nb(e.map((e)=>`${e}`), this.store);
                    }), Wb), yield this.adjustMaxId();
            }), this.saveAESGCM256Key = (e, t1, o)=>Hb(this, void 0, void 0, function*() {
                if (o) {
                    const r = yield self.crypto.subtle.exportKey("raw", t1), i = yield ((e, t1, o)=>rb(void 0, void 0, void 0, function*() {
                            return new Promise((r, i)=>{
                                requestAnimationFrame(()=>rb(void 0, void 0, void 0, function*() {
                                        var i;
                                        const n = null === (i = null == t1 ? void 0 : t1.algorithm) || void 0 === i ? void 0 : i.name;
                                        let s;
                                        if ("RSA-OAEP" === n ? s = db : "AES-GCM" === n && (s = ab), !s) throw new Error("Unsupported encrypt key type");
                                        if ("string" == typeof e) {
                                            const i = new TextEncoder, n = yield s(i.encode(e), t1, o);
                                            r(n);
                                        } else {
                                            const i = yield s(e, t1, o);
                                            r(i);
                                        }
                                    }));
                            });
                        }))(r, o, new Uint8Array(16));
                    yield this.set(`aes-gcm-256-${e}`, i);
                } else yield this.set(`aes-gcm-256-${e}`, t1);
            }), this.reset = ()=>Hb(this, void 0, void 0, function*() {
                return this.resetting ? Gb() : (this.waitingForReset = !0, this.isChangingLog || this.isChangingMeta ? Gb() : (this.resetting = !0, yield function(e = Lb()) {
                    return e("readwrite", (e)=>(e.clear(), Pb(e.transaction)));
                }(this.store), this.resetting = !1, void (this.waitingForReset = !1)));
            }), this.store = Mb(e, e + "-store"), Fb($b, ()=>{
            if (this.isChangingMeta = !1, this.waitingForReset) return this.reset();
        }), Fb(Wb, ()=>{
            if (this.isChangingLog = !1, this.waitingForReset) return this.reset();
        });
    }
}
var zb = function(e, t1, o, r) {
    return new (o || (o = Promise))(function(i, n) {
        function s(e) {
            try {
                d(r.next(e));
            } catch (e) {
                n(e);
            }
        }
        function a(e) {
            try {
                d(r.throw(e));
            } catch (e) {
                n(e);
            }
        }
        function d(e) {
            var t1;
            e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                e(t1);
            })).then(s, a);
        }
        d((r = r.apply(e, t1 || [])).next());
    });
};
const qb = {
    databaseName: "laplace-default-db",
    maxSize: 49283072
};
class Jb {
    constructor(e){
        this.commonLogWithContext = (e, t1, o, r, i)=>zb(this, void 0, void 0, function*() {
                yield bb(this.runtimeMetaManager, e, t1, o, r, i);
            }), this.commonReportWithContext = (e, t1)=>zb(this, void 0, void 0, function*() {
                yield wb(this.runtimeMetaManager, e, t1);
            }), this.commonDeleteWithContext = (e)=>zb(this, void 0, void 0, function*() {
                yield Ob(this.runtimeMetaManager, e);
            }), this.resetWithContext = ()=>zb(this, void 0, void 0, function*() {
                yield Db(this.runtimeMetaManager);
            }), this.initLocalAESGCM256Key = ()=>zb(this, void 0, void 0, function*() {
                return yield sb();
            }), this.doNotUseDirtyGetStore = ()=>this.runtimeMetaManager.logManager.getStore(), this.log = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.log, xS.PLAIN, {
                    extraProperties: o
                });
            }), this.info = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.info, xS.PLAIN, {
                    extraProperties: o
                });
            }), this.warn = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.warn, xS.PLAIN, {
                    extraProperties: o
                });
            }), this.debug = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.debug, xS.PLAIN, {
                    extraProperties: o
                });
            }), this.error = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.error, xS.PLAIN, {
                    extraProperties: o
                });
            }), this.logWithEncryption = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.log, xS.AESGCM256, {
                    extraProperties: o
                });
            }), this.infoWithEncryption = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.info, xS.AESGCM256, {
                    extraProperties: o
                });
            }), this.debugWithEncryption = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.debug, xS.AESGCM256, {
                    extraProperties: o
                });
            }), this.warnWithEncryption = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.warn, xS.AESGCM256, {
                    extraProperties: o
                });
            }), this.errorWithEncryption = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.error, xS.AESGCM256, {
                    extraProperties: o
                });
            }), this.logWithoutCache = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.log, xS.PLAIN, {
                    extraProperties: o,
                    noCache: !0
                });
            }), this.infoWithoutCache = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.info, xS.PLAIN, {
                    extraProperties: o,
                    noCache: !0
                });
            }), this.warnWithoutCache = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.warn, xS.PLAIN, {
                    extraProperties: o,
                    noCache: !0
                });
            }), this.debugWithoutCache = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.debug, xS.PLAIN, {
                    extraProperties: o,
                    noCache: !0
                });
            }), this.errorWithoutCache = (e, t1, o)=>zb(this, void 0, void 0, function*() {
                yield this.commonLogWithContext(e, t1, BS.error, xS.PLAIN, {
                    extraProperties: o,
                    noCache: !0
                });
            }), this.getLogs = (e)=>{
            const t1 = this.runtimeMetaManager.logManager;
            return t1 ? t1.filterStore(e) : new Map;
        }, this.report = (...e)=>((e, t1, o = {})=>(function(e, t1, o, r) {
                    return new (o || (o = Promise))(function(i, n) {
                        function s(e) {
                            try {
                                d(r.next(e));
                            } catch (e) {
                                n(e);
                            }
                        }
                        function a(e) {
                            try {
                                d(r.throw(e));
                            } catch (e) {
                                n(e);
                            }
                        }
                        function d(e) {
                            var t1;
                            e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                                e(t1);
                            })).then(s, a);
                        }
                        d((r = r.apply(e, t1 || [])).next());
                    });
                })(void 0, void 0, void 0, function*() {
                    var r, i;
                    const n = null !== (r = o.sampleRate) && void 0 !== r ? r : 1;
                    if (Math.random() > n) return;
                    if (nb(t1) > 30720) throw new Error("ERROR: Laplace .report(strMsg) size bigger than 30KB is NOT allowed.");
                    const s = Object.assign({
                        message: Object.assign({
                            strMsg: t1
                        }, o.extraMsg),
                        time: Ab(Date.now())
                    }, o.extraData);
                    return (null === (i = null == o ? void 0 : o.tags) || void 0 === i ? void 0 : i.length) && (s.tags = null == o ? void 0 : o.tags), Rb([
                        {
                            messages: JSON.stringify(s),
                            meta: Cb
                        }
                    ], e, o.xhrOptions);
                }))(this.runtimeMetaManager, ...e), this.reportByHttps = (e, t1)=>zb(this, void 0, void 0, function*() {
                yield this.commonReportWithContext(e, t1);
            }), this.deleteLog = (e)=>zb(this, void 0, void 0, function*() {
                yield this.commonDeleteWithContext(e);
            }), this.deleteAll = ()=>zb(this, void 0, void 0, function*() {
                yield this.resetWithContext();
            });
        const { runtimeMetaManager: t1 } = e;
        this.runtimeMetaManager = t1;
    }
}
Jb.init = (e)=>zb(void 0, void 0, void 0, function*() {
        const { databaseName: t1 = "laplace-default-db" } = e, o = new Kb(t1), r = new yb, i = new gb(Object.assign(Object.assign(Object.assign({}, qb), e), {
            idbManager: o,
            logManager: r
        }));
        Sb(i, HS.beforeInit), yield r.syncFromIDB(i.idbManager);
        const n = new Jb({
            runtimeMetaManager: i
        });
        return Sb(i, HS.afterInit), n;
    });
class Qb extends GS {
    constructor(e){
        super(), this.config = {
            verbose: !1
        }, this.beforeLog = (e, t1)=>{
            const { verbose: o } = this.config;
            switch(o && console.log("beforeLog, ", "state: ", t1, "meta: ", e), t1.logLevel){
                case BS.error:
                    console.error(t1.message);
                    break;
                case BS.warn:
                    console.warn(t1.message);
                    break;
                case BS.log:
                    console.log(t1.message);
                    break;
                case BS.debug:
                    console.debug(t1.message);
                    break;
                case BS.info:
                    console.info(t1.message);
            }
        }, this.afterLog = (e, t1)=>{
            const { verbose: o } = this.config;
            o && console.log("afterLog, ", "state: ", t1, "meta: ", e);
        }, this.beforeReport = (e, t1)=>{
            const { verbose: o } = this.config;
            o && console.log("beforeReport, ", "pluginParams: ", t1, "meta: ", e);
        }, this.afterReport = (e, t1)=>{
            const { verbose: o } = this.config;
            o && console.log("afterReport, ", "pluginParams: ", t1, "runtimeMetaManager: ", e);
        }, e && (this.config = e);
    }
}
const Zb = (e)=>{
    const t1 = [];
    for (const [o, r] of e)t1.push(r);
    return t1;
};
class Yb extends GS {
    constructor(e){
        super(), this.config = {
            debug: !1
        }, this.debugLog = (e)=>{
            const { debug: t1 } = this.config;
            t1 && console.log(`[AutoCleanLogPlugin]: ${e}`);
        }, this.afterInit = (e)=>{
            const { expireBefore: t1 } = this.config;
            if (!t1) return void this.debugLog("early return on beforeInit because expireBefore is falsy");
            const { logManager: o, commonMethods: { commonDelete: r } } = e, i = o.getStore().byTime, n = ("function" == typeof t1 ? Zb(i).filter(t1) : Zb(i).filter((e)=>e.timestamp < t1)).map((e)=>e.id);
            r(e, void 0, n), this.debugLog(`afterInit, clean log id: ${n}`);
        }, this.afterReport = (e, { report: t1, error: o })=>{
            if (o) return this.debugLog("error"), void console.error(o);
            const { cleanAfterReport: r } = this.config;
            if (!r) return void this.debugLog("early return on afterReport because cleanAfterReport is falsy");
            const { commonMethods: { commonDelete: i } } = e;
            i(e, void 0, t1.ids), this.debugLog(`afterReport, clean log id: ${t1.ids}`);
        }, e && (this.config = e);
    }
}
var Xb, eE, tE = function() {
    if (eE) return Xb;
    eE = 1;
    var e = "Expected a function", t1 = /^\s+|\s+$/g, o = /^[-+]0x[0-9a-f]+$/i, r = /^0b[01]+$/i, i = /^0o[0-7]+$/i, n = parseInt, s = "object" == typeof Vt && Vt && Vt.Object === Object && Vt, a = "object" == typeof self && self && self.Object === Object && self, d = s || a || Function("return this")(), u = Object.prototype.toString, l = Math.max, c = Math.min, p = function() {
        return d.Date.now();
    };
    function h(e) {
        var t1 = typeof e;
        return !!e && ("object" == t1 || "function" == t1);
    }
    function m(e) {
        if ("number" == typeof e) return e;
        if (function(e) {
            return "symbol" == typeof e || function(e) {
                return !!e && "object" == typeof e;
            }(e) && "[object Symbol]" == u.call(e);
        }(e)) return NaN;
        if (h(e)) {
            var s = "function" == typeof e.valueOf ? e.valueOf() : e;
            e = h(s) ? s + "" : s;
        }
        if ("string" != typeof e) return 0 === e ? e : +e;
        e = e.replace(t1, "");
        var a = r.test(e);
        return a || i.test(e) ? n(e.slice(2), a ? 2 : 8) : o.test(e) ? NaN : +e;
    }
    return Xb = function(t1, o, r) {
        var i = !0, n = !0;
        if ("function" != typeof t1) throw new TypeError(e);
        return h(r) && (i = "leading" in r ? !!r.leading : i, n = "trailing" in r ? !!r.trailing : n), function(t1, o, r) {
            var i, n, s, a, d, u, g = 0, v = !1, f = !1, y = !0;
            if ("function" != typeof t1) throw new TypeError(e);
            function S(e) {
                var o = i, r = n;
                return i = n = void 0, g = e, a = t1.apply(r, o);
            }
            function b(e) {
                var t1 = e - u;
                return void 0 === u || t1 >= o || t1 < 0 || f && e - g >= s;
            }
            function E() {
                var e = p();
                if (b(e)) return I(e);
                d = setTimeout(E, function(e) {
                    var t1 = o - (e - u);
                    return f ? c(t1, s - (e - g)) : t1;
                }(e));
            }
            function I(e) {
                return d = void 0, y && i ? S(e) : (i = n = void 0, a);
            }
            function A() {
                var e = p(), t1 = b(e);
                if (i = arguments, n = this, u = e, t1) {
                    if (void 0 === d) return function(e) {
                        return g = e, d = setTimeout(E, o), v ? S(e) : a;
                    }(u);
                    if (f) return d = setTimeout(E, o), S(u);
                }
                return void 0 === d && (d = setTimeout(E, o)), a;
            }
            return o = m(o) || 0, h(r) && (v = !!r.leading, s = (f = "maxWait" in r) ? l(m(r.maxWait) || 0, o) : s, y = "trailing" in r ? !!r.trailing : y), A.cancel = function() {
                void 0 !== d && clearTimeout(d), g = 0, i = u = n = d = void 0;
            }, A.flush = function() {
                return void 0 === d ? a : I(p());
            }, A;
        }(t1, o, {
            leading: i,
            maxWait: o,
            trailing: n
        });
    };
}(), oE = Ut(tE);
const rE = [
    "RESOURCE_ERROR",
    "JS_ERROR",
    "UNHANDLED_PROMISE_REJECTION"
];
class iE extends GS {
    constructor(e){
        super(), this.config = {
            debug: !1,
            publicTags: []
        }, this.errorCount = 0, this.hashErrors = {}, this.runtimeMetaManager = null, this.addPublicTags = (e)=>{
            var t1;
            return null === (t1 = this.config.publicTags) || void 0 === t1 ? void 0 : t1.concat(e).filter((e)=>e);
        }, this.debugLog = (e)=>{
            const { debug: t1 } = this.config;
            t1 && console.log("[AutoLogErrorPlugin]:", e);
        }, this.ignore = (e)=>{
            var t1, o, r, i, n;
            return void 0 !== (null === (t1 = this.config) || void 0 === t1 ? void 0 : t1.maxErrorCount) && this.errorCount >= (null === (o = this.config) || void 0 === o ? void 0 : o.maxErrorCount) || !!(null === (r = this.config) || void 0 === r ? void 0 : r.ignoredErrorMsgKeywords) && e && (null === (n = null === (i = this.config) || void 0 === i ? void 0 : i.ignoredErrorMsgKeywords) || void 0 === n ? void 0 : n.some((t1)=>null == e ? void 0 : e.includes(t1)));
        }, this.report = oE(()=>{
            if (null === this.runtimeMetaManager) return;
            const { autoReport: e } = this.config, { commonMethods: { commonReport: t1 } } = this.runtimeMetaManager;
            return t1(this.runtimeMetaManager, rE, e);
        }, 600, {
            trailing: !0,
            leading: !1
        }), this.afterInit = (e)=>{
            if (this.runtimeMetaManager = e, !self.addEventListener) return;
            const { commonMethods: { commonLog: t1 } } = e, o = (o, r, i)=>{
                this.debugLog(i), this.errorCount += 1;
                try {
                    return (function(e) {
                        const t1 = (new TextEncoder).encode(e);
                        return crypto.subtle.digest("SHA-1", t1).then((e)=>Array.from(new Uint8Array(e)).map((e)=>e.toString(16).padStart(2, "0")).join(""));
                    })(o).then((i)=>this.hashErrors[i] ? "dismissed" : (this.hashErrors[i] = !0, t1(e, o, this.addPublicTags([].concat(r)), BS.error, xS.PLAIN, {
                            extraProperties: {
                                messageHash: i
                            }
                        }).then(this.report))).catch(console.error);
                } catch (e) {
                    return console.error(e), Promise.resolve(e);
                }
            };
            try {
                self.addEventListener("error", (e)=>{
                    var t1, r, i, n, s, a, d;
                    if (!this.ignore(null == e ? void 0 : e.message)) {
                        if ((null == e ? void 0 : e.target) && ((null === (t1 = null == e ? void 0 : e.target) || void 0 === t1 ? void 0 : t1.src) || (null === (r = null == e ? void 0 : e.target) || void 0 === r ? void 0 : r.href))) {
                            const t1 = `Load Resource Error in ${null === (i = null == e ? void 0 : e.target) || void 0 === i ? void 0 : i.tagName} element: ${(null === (n = null == e ? void 0 : e.target) || void 0 === n ? void 0 : n.src) || (null === (s = null == e ? void 0 : e.target) || void 0 === s ? void 0 : s.href)}`;
                            return o(t1, "RESOURCE_ERROR", e);
                        }
                        {
                            const t1 = `Javascript Runtime Error in ${null == e ? void 0 : e.filename} (${null == e ? void 0 : e.lineno}:${null == e ? void 0 : e.colno}): ${null == e ? void 0 : e.message}\nStack: ${null !== (d = null === (a = null == e ? void 0 : e.error) || void 0 === a ? void 0 : a.stack) && void 0 !== d ? d : null == e ? void 0 : e.stack}`;
                            return o(t1, "JS_ERROR", e);
                        }
                    }
                }), self.addEventListener("unhandledrejection", (e)=>{
                    var t1;
                    if (this.ignore(null === (t1 = null == e ? void 0 : e.reason) || void 0 === t1 ? void 0 : t1.message)) return;
                    let r;
                    const i = null == e ? void 0 : e.reason;
                    return r = "string" == typeof i ? `Promise Error: ${i}` : i instanceof Error ? `Promise Error: ${i.message} ${i.name} ${i.stack}` : "object" == typeof i ? `Promise Error with reason: ${pb(i)}` : `Promise Error with unrecognized reason: ${i}`, o(r, "UNHANDLED_PROMISE_REJECTION", e);
                });
            } catch (e) {
                console.error(e);
            }
            this.debugLog("afterInit, add listener");
        }, e && (this.config = e), this.config.publicTags = [].concat(null == e ? void 0 : e.publicTags);
    }
}
let nE = function(e) {
    return e.DeviceAudioStreamCaptured = "device audio stream captured", e.AudioJoinComplete = "audio join complete", e.AudioLeaveComplete = "audio leave complete", e.SharingAudioStartComplete = "sharing audio start complete", e.SharingAudioStopComplete = "sharing audio stop complete", e.AudioBridgeReconnectStart = "audio bridge reconnect start", e.AudioBridgeReconnectEnd = "audio bridge reconnect end", e;
}({}), sE = function(e) {
    return e.VBSettingSuccess = "video VB setting success", e.VBSettingFailed = "init video VB failed", e.VBPreloadSuccess = "preload video VB success", e.VBPreloading3S = "preload video VB 3s", e.VBPreloading10S = "preload video VB 10s", e.StartCaptureVideoSuccess = "start capture video success", e.StopCaptureVideoSuccess = "stop capture video success", e;
}({});
function aE(e) {
    return `{E}${e}{/E}`;
}
const dE = [
    "exception flow",
    "MEDIA SDK"
], uE = {
    enable: !1,
    enableReport: !1,
    gatewayEndPoint: "",
    newGatewayEndPoint: "",
    logLevel: {
        debug: !1,
        log: !1,
        info: !1,
        print: !1,
        warn: !1,
        error: !1
    },
    performanceReportRatio: .25,
    trackingCount: 7
}, lE = [
    "debug",
    "log",
    "info",
    "print",
    "warn",
    "error"
], cE = (e, t1)=>[
        ...e,
        ...t1
    ].filter((e)=>!!e);
class pE {
    static getInstance() {
        return this.agentInstance || (this.agentInstance = new pE), this.agentInstance;
    }
    constructor(){
        var e = this;
        this.laplace = void 0, this.trackingId = void 0, this.logConfig = void 0, this.reportUrl = void 0, this.publicTags = void 0, this.accountId = void 0, this.disableAutoReport = void 0, this.debouncedReport = void 0, this.initConfig = async (e)=>{
            let t1, o = uE;
            try {
                e.logConfig && (o = JSON.parse(e.logConfig), o.gatewayEndPoint && (this.reportUrl = o.gatewayEndPoint), o.newGatewayEndPoint && (this.reportUrl = o.newGatewayEndPoint));
                const { enable: r, enableReport: i, reportUrl: n, logLevel: s, encryptKeys: a, trackingId: d, accountId: u } = e;
                if (void 0 !== r && (o = {
                    ...o,
                    enable: !!r
                }), void 0 !== i && (o = {
                    ...o,
                    enableReport: !!i
                }), n && (this.reportUrl = n), "string" == typeof s) {
                    const e = lE.indexOf(s), t1 = lE.reduce((t1, o, r)=>r < e ? {
                            ...t1,
                            [`${o}`]: !1
                        } : {
                            ...t1,
                            [`${o}`]: !0
                        }, {});
                    o = {
                        ...o,
                        logLevel: t1
                    };
                } else void 0 !== s && (o = {
                    ...o,
                    logLevel: s
                });
                if (d && (this.trackingId = d, o = {
                    ...o,
                    enable: !0,
                    enableReport: !0
                }), void 0 !== a) {
                    const e = Array.isArray(a) ? a : [
                        a
                    ];
                    t1 = await Promise.all(e.map((e)=>(function(e) {
                            return window.crypto.subtle.importKey("raw", (new TextEncoder).encode(e.slice(0, 32)), "AES-GCM", !1, [
                                "encrypt",
                                "decrypt"
                            ]);
                        })(e).then((e)=>({
                                usage: FS.PROTECT_LOCAL_KEY,
                                key: e
                            }))));
                }
                void 0 !== u && (this.accountId = u);
            } catch (e) {
                console.error("parse log config error", e);
            }
            const r = (new Date).getTime() - 6048e5, i = o.enableReport && this.reportUrl ? {
                gzip: !1,
                encrypt: !1,
                additionalContext: {
                    trackingId: this.trackingId
                }
            } : void 0;
            this.publicTags = [
                "VideoSDK",
                this.trackingId
            ];
            const n = [
                e.debugMode && new Qb({
                    verbose: !1
                }),
                new Yb({
                    debug: !1,
                    cleanAfterReport: !0,
                    expireBefore: r
                }),
                new iE({
                    debug: !1,
                    autoReport: i,
                    ignoredErrorMsgKeywords: [
                        "table index is out of bounds"
                    ],
                    maxErrorCount: 223,
                    publicTags: this.accountId ? [
                        ...this.publicTags,
                        aE(this.accountId)
                    ] : this.publicTags
                })
            ].filter(Boolean);
            return {
                laplaceConfig: {
                    databaseName: "ZM-VSDK-LOG-DATABASE",
                    maxSize: 49283072,
                    publicKey: e.logEncryptionPubKey,
                    reportUrl: this.reportUrl,
                    externalKeys: t1,
                    plugins: n
                },
                logConfig: o
            };
        }, this.handleInitLaplaceSuccess = (e, t1)=>{
            var o;
            this.laplace = e;
            const r = is.get(ss.VSDKLogTrackingId);
            let i = [];
            try {
                i = JSON.parse(r ? window.atob(r) : "[]");
            } catch (e) {}
            i.length >= (null !== (o = null == t1 ? void 0 : t1.trackingCount) && void 0 !== o ? o : 7) && i.shift();
            const n = i.reduce((e, t1)=>({
                    ...e,
                    [`${t1}`]: !0
                }), {});
            e.deleteLog((e)=>{
                var t1;
                return !(null !== (t1 = e.tags) && void 0 !== t1 && t1.some((e)=>n[e]));
            }), i.push(this.trackingId), is.set(ss.VSDKLogTrackingId, window.btoa(JSON.stringify(i)), os.LocalStorage), this.debouncedReport = function(e) {
                const t1 = [];
                let o;
                const r = function(e, t1, o) {
                    var r, i, n, s, a, d, u = 0, l = !1, c = !1, p = !0;
                    if ("function" != typeof e) throw new TypeError("Expected a function");
                    function h(t1) {
                        var o = r, n = i;
                        return r = i = void 0, u = t1, s = e.apply(n, o);
                    }
                    function m(e) {
                        var o = e - d;
                        return void 0 === d || o >= t1 || o < 0 || c && e - u >= n;
                    }
                    function g() {
                        var e = IS();
                        if (m(e)) return v(e);
                        a = setTimeout(g, function(e) {
                            var o = t1 - (e - d);
                            return c ? WS(o, n - (e - u)) : o;
                        }(e));
                    }
                    function v(e) {
                        return a = void 0, p && r ? h(e) : (r = i = void 0, s);
                    }
                    function f() {
                        var e = IS(), o = m(e);
                        if (r = arguments, i = this, d = e, o) {
                            if (void 0 === a) return function(e) {
                                return u = e, a = setTimeout(g, t1), l ? h(e) : s;
                            }(d);
                            if (c) return clearTimeout(a), a = setTimeout(g, t1), h(d);
                        }
                        return void 0 === a && (a = setTimeout(g, t1)), s;
                    }
                    return t1 = jS(t1) || 0, yS(o) && (l = !0, n = (c = "maxWait" in o) ? $S(jS(o.maxWait) || 0, t1) : n, p = "trailing" in o || p), f.cancel = function() {
                        void 0 !== a && clearTimeout(a), u = 0, r = d = i = a = void 0;
                    }, f.flush = function() {
                        return void 0 === a ? s : v(IS());
                    }, f;
                }((o, r)=>{
                    const i = e(o, r);
                    return t1.length = 0, i;
                }, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3, {
                    leading: !0,
                    trailing: !0,
                    maxWait: 1e4
                });
                return window.addEventListener("beforeunload", ()=>{
                    r.cancel && r.cancel(), t1.length > 0 && e(t1, o);
                }), (e, i)=>(Array.isArray(e) ? t1.push(...e) : "string" == typeof e && t1.push(e), o = i, r(t1, i));
            }(this.laplace.reportByHttps.bind(this.laplace));
        }, this.init = async (e)=>{
            const { laplaceConfig: t1, logConfig: o } = await this.initConfig(e);
            return o.enable ? (this.logConfig = o, Jb.init(t1).then((e)=>{
                this.handleInitLaplaceSuccess(e, o);
            }).catch((e)=>{
                throw {
                    type: Kl,
                    reason: "Logger init failed.",
                    error: e
                };
            })) : Promise.reject({
                type: Gl,
                reason: "Logger feature is not enabled."
            });
        }, this.check = (e)=>{
            var t1;
            return !(!this.checkLaplace() || (null === (t1 = this.logConfig) || void 0 === t1 || null === (t1 = t1.logLevel) || void 0 === t1 || !t1[e]) && (console.warn(`Logger ${e} is not enabled.`), 1));
        }, this.log = (e, t1, o)=>{
            if (this.check("log")) try {
                var r;
                return null === (r = this.laplace.logWithEncryption(e, cE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
            } catch (e) {
                return;
            }
        }, this.logWithExtraProperties = (e, t1, o)=>{
            if (this.check("log")) try {
                var r;
                return null === (r = this.laplace.log(e, t1, o)) || void 0 === r ? void 0 : r.catch(()=>{});
            } catch (e) {
                return;
            }
        }, this.warn = (e, t1, o)=>{
            if (this.check("warn")) try {
                var r;
                return null === (r = this.laplace.warnWithEncryption(e, cE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
            } catch (e) {
                return;
            }
        }, this.info = (e, t1, o)=>{
            if (this.check("info")) try {
                var r;
                return null === (r = this.laplace.infoWithEncryption(e, cE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
            } catch (e) {
                return;
            }
        }, this.debug = (e, t1, o)=>{
            if (this.check("debug")) try {
                var r;
                return null === (r = this.laplace.debugWithEncryption(e, cE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
            } catch (e) {
                return;
            }
        }, this.error = (e, t1, o)=>{
            if (this.check("error")) try {
                var r;
                return null === (r = this.laplace.errorWithEncryption(e, cE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
            } catch (e) {
                return;
            }
        }, this.checkLaplace = ()=>{
            var e;
            return !(null === (e = this.laplace) || void 0 === e || !e.log);
        }, this.makeLogger = (e)=>{
            var t1;
            const o = cE(null !== (t1 = this.publicTags) && void 0 !== t1 ? t1 : [], e);
            return {
                log: (e, t1)=>this.log(e, o, null != t1 ? t1 : []),
                logWithExtraProperties: (e, t1)=>this.logWithExtraProperties(e, o, t1),
                warn: (e, t1)=>this.warn(e, o, null != t1 ? t1 : []),
                info: (e, t1)=>this.info(e, o, null != t1 ? t1 : []),
                debug: (e, t1)=>this.debug(e, o, null != t1 ? t1 : []),
                error: (e, t1)=>this.error(e, o, null != t1 ? t1 : []),
                directReport: (e, t1)=>{
                    const o = "string" != typeof e ? JSON.stringify(e) : e, r = (Array.isArray(t1) ? t1 : [
                        t1
                    ]).filter(Boolean);
                    r.push("MEDIA SDK Direct"), this.report(o, r, "info");
                }
            };
        }, this.reportToGlobalTracing = function(t1) {
            var o;
            let r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (!e.checkLaplace()) return Promise.reject({
                type: Gl,
                reason: "Logger has not been enabled or initialized."
            });
            if (null === (o = e.logConfig) || void 0 === o || !o.enableReport || !e.reportUrl) return Promise.reject({
                type: Gl,
                reason: "Please use getLogs to obtain log data and report by yourself."
            });
            if (function() {
                try {
                    return !!is.get(as.DisableAutoReportLogs);
                } catch (e) {
                    return !1;
                }
            }() && !r) return Promise.resolve();
            const i = function(e) {
                let t1 = !0;
                return e && (t1 = !(Array.isArray(e) ? e : [
                    e
                ]).some((e)=>dE.some((t1)=>`${e}`.indexOf(t1) > -1))), t1;
            }(t1);
            return (r || i ? e.laplace.reportByHttps.bind(e.laplace) : e.debouncedReport)(t1, {
                gzip: !1,
                encrypt: !1,
                xhrOptions: {
                    url: e.reportUrl
                },
                additionalContext: {
                    trackingId: e.trackingId
                }
            });
        }, this.report = function(t1, o) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "warn";
            if (e.checkLaplace() && e.logConfig.enableReport && e.reportUrl) {
                var i, n;
                const s = Array.isArray(o) ? o : [
                    o
                ], a = e.accountId ? [
                    ...s,
                    aE(e.accountId)
                ] : s;
                null === (i = (n = e.makeLogger(a))[`${r}`]) || void 0 === i || null === (i = i.call(n, t1)) || void 0 === i || i.then(()=>{
                    e.reportToGlobalTracing(s);
                });
            }
        }, this.getLogs = (e, t1)=>{
            if (!this.checkLaplace()) return console.warn("Logger has not been enabled or initialized."), [];
            const o = e.getState(), { meeting: { meetingNumber: r, userId: i, userEmail: n, userName: s } } = o, a = {
                meetingNumber: r,
                userId: i,
                userEmail: n,
                userName: s
            }, d = this.laplace.getLogs(t1), u = [];
            for (const [, e] of d)u.push({
                ...e,
                ...a
            });
            return u;
        }, this.doNotUseDirtyGetStore = ()=>this.checkLaplace() ? this.laplace.doNotUseDirtyGetStore() : (console.warn("Logger has not been enabled or initialized."), {
                byTag: {},
                byTime: new Map
            }), this.trackingId = fS();
    }
}
pE.agentInstance = void 0;
const hE = pE.getInstance(), mE = [
    {
        type: "MediaMeta",
        methods: [
            "sendUserNodeList",
            "updateUserMediaSN",
            "updateMediaParams",
            "subscribeToQos",
            "unsubscribeFromQos",
            "sendUserAudioStatus",
            "destroy",
            "createMainSessionChannel",
            "notifySDKMeetingReady"
        ]
    },
    {
        type: "Audio",
        methods: [
            "joinComputerAudio",
            "leaveComputerAudio",
            "joinSharingAudio",
            "leaveSharingAudio",
            "changeSpeaker",
            "changeMicrophone",
            "enableAudioEncode",
            "pauseOrResumeAudio",
            "setSharingAudioVolume",
            "enableShareAudioToBreakoutRoom",
            "enableAudioDenoise",
            "enableSyncButtonsOnHeadset",
            "stopAllIncomingAudio",
            "preInitAudioBridge",
            "setAudioCodecMode",
            "muteOrUnmuteOtherAudio",
            "adjustOtherAudioVolume",
            "changeAudioProfile",
            "unmuteAudio",
            "muteAudio"
        ]
    },
    {
        type: "Video",
        methods: [
            "startCaptureVideo",
            "stopCaptureVideo",
            "renderVideo",
            "stopRenderVideo",
            "changeCamera",
            "updateRenderedVideoCanvasDimension",
            "adjustRenderedVideoPosition",
            "mirrorVideo",
            "enableHardwareAccelerationForVideoDecode",
            "enableHardwareAccelerationForVideoEncode",
            "startVirtualBackgroundSetting",
            "updateVirtualBackgroundImage",
            "stopVirtualBackgroundSetting",
            "startMaskSetting",
            "updateMaskBackgroundImage",
            "updateMaskClip",
            "stopMaskSetting",
            "enableVideoObserver",
            "prefetchVideoSsrc",
            "cancelPrefetchVideoSsrc",
            "setMobileRotateMode",
            "changeActiveVideoSsrc",
            "updateVideoHDValue",
            "updateVideoFullhdValue",
            "clearVideoCanvas"
        ]
    },
    {
        type: "Sharing",
        methods: [
            "stopDesktopSharing",
            "startDesktopSharing",
            "pauseDesktopSharing",
            "resumeDesktopSharing",
            "renderSharing",
            "stopRenderSharing",
            "switchSharingSource",
            "ajustmentReceivedSharingCanvas",
            "changeSharingSecondCamera",
            "updateRenderedSharingDimension",
            "addReceivedSharingChannelType",
            "removeReceivedSharingChannelType",
            "switchSharingMode",
            "ajustmentSharingCanvas"
        ]
    },
    {
        type: "RemoteControl",
        methods: [
            "startRemoteControl",
            "stopRemoteControl",
            "resendRemoteControlPositionPDU",
            "updateRemoteControlProperties",
            "ajustmentReceivedSharingCanvas",
            "startRemoteControlQRCheck"
        ]
    },
    {
        type: "LiveTranscription",
        methods: [
            "selectLanguageChannelForNewLTT"
        ]
    },
    {
        type: "RemoteCamera",
        methods: [
            "movePTZCamera"
        ]
    }
].reduce((e, t1)=>{
    const { type: o, methods: r } = t1;
    return [
        ...e,
        ...r.map((e)=>({
                name: e,
                type: o
            }))
    ];
}, []), gE = mE.map((e)=>e.name), vE = function(e) {
    const t1 = mE.find((t1)=>t1.name === e);
    if (t1) {
        const { type: n } = t1;
        for(var o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)r[i - 1] = arguments[i];
        const s = null == r ? void 0 : r.map((e)=>si(e));
        hE.makeLogger([
            n,
            `${n} Media SDK`
        ]).info(`${e},params:${JSON.stringify(s)}`);
    }
};
function fE(e) {
    return new Proxy(e, {
        get: (e, t1)=>"string" == typeof t1 && gE.includes(t1) ? function() {
                for(var o = arguments.length, r = new Array(o), i = 0; i < o; i++)r[i] = arguments[i];
                try {
                    Reflect.apply(vE, void 0, [
                        t1,
                        ...r
                    ]);
                } catch (e) {}
                return Reflect.apply(Reflect.get(e, t1), e, r);
            } : Reflect.get(e, t1)
    });
}
const yE = pE.getInstance().makeLogger([
    "Remote Control"
]), SE = fE(la.getInstance());
function bE(e, t1, o, r) {
    let { share: { activeNodeId: i, shareQuality: n } } = t1;
    const { share: { isReceiveSharingFromMainSession: s } } = t1;
    o && (i = o), void 0 !== r && (n = r);
    const a = uS(t1);
    e.subscribeSharing(i, n, s, a);
}
class EE {
    constructor(){
        this.checkerSubject = void 0, this.checkerSubscription = void 0;
    }
    startCheck(e) {
        return this.checkerSubject && this.stopCheck(), this.checkerSubject = new U, this.checkerSubscription = Qe(e).subscribe(this.checkerSubject), this.checkerSubject;
    }
    stopCheck() {
        var e;
        this.checkerSubject && (this.checkerSubject.complete(), null === (e = this.checkerSubscription) || void 0 === e || e.unsubscribe(), this.checkerSubject = void 0);
    }
}
const IE = new EE, AE = new EE;
function CE() {
    return IE.stopCheck();
}
function _E() {
    return AE.stopCheck();
}
function RE(e, t1) {
    CE(), _E();
    const { share: { remoteControllingSsrc: o }, meeting: { userId: r } } = e;
    o && (TE(), t1.takeBackRemoteControlPermission(r, o));
}
async function wE(e, t1, o, r, i) {
    const { share: { isSDKGrabControl: n, isGrabRemoteControl: s } } = o;
    if (!s) {
        r.subscribeGrabRemoteControl(e, !0);
        try {
            await Te(ip(Ol, 1).pipe(tt((e)=>!!e)));
        } catch (e) {}
    }
    const a = aS(o);
    a && (n ? (i.resendRemoteControlPositionPDU(), i.updateRemoteControlProperties({
        os: a.os,
        isControllerNow: !0,
        dimension: t1 && _y(t1)
    })) : t1 && i.startRemoteControl(t1, a.os, _y(t1)));
}
function TE() {
    yE.log("qr scanning stop"), SE.startRemoteControlQRCheck(!1);
}
function OE(e, t1, o) {
    var r;
    const { audio: i, share: { isReceiveSharingFromMainSession: n } } = t1;
    if ((null == i || null === (r = i.localShareAudioUserMutedList) || void 0 === r ? void 0 : r.length) > 0) {
        const { localShareAudioUserMutedList: t1 } = i, r = t1.find((t1)=>t1.userId === e);
        t1.filter((t1)=>t1.userId !== e).forEach((e)=>{
            o.setSharingAudioVolume(e.userId, !0, e.isFromMainSession);
        }), o.setSharingAudioVolume(e, !(null == r || !r.muted), !!n);
    }
}
const DE = ra.createAgent(), PE = fE(la.getInstance()), ME = ra.createAgent(), kE = fE(la.getInstance());
function LE(e) {
    for(var t1 = arguments.length, o = Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
    throw Error("[Immer] minified error nr: " + e + (o.length ? " " + o.map(function(e) {
        return "'" + e + "'";
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function NE(e) {
    return !!e && !!e[SI];
}
function VE(e) {
    var t1;
    return !!e && (function(e) {
        if (!e || "object" != typeof e) return !1;
        var t1 = Object.getPrototypeOf(e);
        if (null === t1) return !0;
        var o = Object.hasOwnProperty.call(t1, "constructor") && t1.constructor;
        return o === Object || "function" == typeof o && Function.toString.call(o) === bI;
    }(e) || Array.isArray(e) || !!e[yI] || !!(null === (t1 = e.constructor) || void 0 === t1 ? void 0 : t1[yI]) || FE(e) || HE(e));
}
function UE(e, t1, o) {
    void 0 === o && (o = !1), 0 === jE(e) ? (o ? Object.keys : EI)(e).forEach(function(r) {
        o && "symbol" == typeof r || t1(r, e[r], e);
    }) : e.forEach(function(o, r) {
        return t1(r, o, e);
    });
}
function jE(e) {
    var t1 = e[SI];
    return t1 ? t1.i > 3 ? t1.i - 4 : t1.i : Array.isArray(e) ? 1 : FE(e) ? 2 : HE(e) ? 3 : 0;
}
function xE(e, t1) {
    return 2 === jE(e) ? e.has(t1) : Object.prototype.hasOwnProperty.call(e, t1);
}
function BE(e, t1, o) {
    var r = jE(e);
    2 === r ? e.set(t1, o) : 3 === r ? e.add(o) : e[t1] = o;
}
function FE(e) {
    return mI && e instanceof Map;
}
function HE(e) {
    return gI && e instanceof Set;
}
function $E(e) {
    return e.o || e.t;
}
function WE(e) {
    if (Array.isArray(e)) return Array.prototype.slice.call(e);
    var t1 = II(e);
    delete t1[SI];
    for(var o = EI(t1), r = 0; r < o.length; r++){
        var i = o[r], n = t1[i];
        !1 === n.writable && (n.writable = !0, n.configurable = !0), (n.get || n.set) && (t1[i] = {
            configurable: !0,
            writable: !0,
            enumerable: n.enumerable,
            value: e[i]
        });
    }
    return Object.create(Object.getPrototypeOf(e), t1);
}
function GE(e, t1) {
    return void 0 === t1 && (t1 = !1), zE(e) || NE(e) || !VE(e) || (jE(e) > 1 && (e.set = e.add = e.clear = e.delete = KE), Object.freeze(e), t1 && UE(e, function(e, t1) {
        return GE(t1, !0);
    }, !0)), e;
}
function KE() {
    LE(2);
}
function zE(e) {
    return null == e || "object" != typeof e || Object.isFrozen(e);
}
function qE(e) {
    var t1 = AI[e];
    return t1 || LE(18, e), t1;
}
function JE() {
    return pI;
}
function QE(e, t1) {
    t1 && (qE("Patches"), e.u = [], e.s = [], e.v = t1);
}
function ZE(e) {
    YE(e), e.p.forEach(eI), e.p = null;
}
function YE(e) {
    e === pI && (pI = e.l);
}
function XE(e) {
    return pI = {
        p: [],
        l: pI,
        h: e,
        m: !0,
        _: 0
    };
}
function eI(e) {
    var t1 = e[SI];
    0 === t1.i || 1 === t1.i ? t1.j() : t1.g = !0;
}
function tI(e, t1) {
    t1._ = t1.p.length;
    var o = t1.p[0], r = void 0 !== e && e !== o;
    return t1.h.O || qE("ES5").S(t1, e, r), r ? (o[SI].P && (ZE(t1), LE(4)), VE(e) && (e = oI(t1, e), t1.l || iI(t1, e)), t1.u && qE("Patches").M(o[SI].t, e, t1.u, t1.s)) : e = oI(t1, o, []), ZE(t1), t1.u && t1.v(t1.u, t1.s), e !== fI ? e : void 0;
}
function oI(e, t1, o) {
    if (zE(t1)) return t1;
    var r = t1[SI];
    if (!r) return UE(t1, function(i, n) {
        return rI(e, r, t1, i, n, o);
    }, !0), t1;
    if (r.A !== e) return t1;
    if (!r.P) return iI(e, r.t, !0), r.t;
    if (!r.I) {
        r.I = !0, r.A._--;
        var i = 4 === r.i || 5 === r.i ? r.o = WE(r.k) : r.o, n = i, s = !1;
        3 === r.i && (n = new Set(i), i.clear(), s = !0), UE(n, function(t1, n) {
            return rI(e, r, i, t1, n, o, s);
        }), iI(e, i, !1), o && e.u && qE("Patches").N(r, o, e.u, e.s);
    }
    return r.o;
}
function rI(e, t1, o, r, i, n, s) {
    if (NE(i)) {
        var a = oI(e, i, n && t1 && 3 !== t1.i && !xE(t1.R, r) ? n.concat(r) : void 0);
        if (BE(o, r, a), !NE(a)) return;
        e.m = !1;
    } else s && o.add(i);
    if (VE(i) && !zE(i)) {
        if (!e.h.D && e._ < 1) return;
        oI(e, i), t1 && t1.A.l || iI(e, i);
    }
}
function iI(e, t1, o) {
    void 0 === o && (o = !1), !e.l && e.h.D && e.m && GE(t1, o);
}
function nI(e, t1) {
    var o = e[SI];
    return (o ? $E(o) : e)[t1];
}
function sI(e, t1) {
    if (t1 in e) for(var o = Object.getPrototypeOf(e); o;){
        var r = Object.getOwnPropertyDescriptor(o, t1);
        if (r) return r;
        o = Object.getPrototypeOf(o);
    }
}
function aI(e) {
    e.P || (e.P = !0, e.l && aI(e.l));
}
function dI(e) {
    e.o || (e.o = WE(e.t));
}
function uI(e, t1, o) {
    var r = FE(t1) ? qE("MapSet").F(t1, o) : HE(t1) ? qE("MapSet").T(t1, o) : e.O ? function(e, t1) {
        var o = Array.isArray(e), r = {
            i: o ? 1 : 0,
            A: t1 ? t1.A : JE(),
            P: !1,
            I: !1,
            R: {},
            l: t1,
            t: e,
            k: null,
            o: null,
            j: null,
            C: !1
        }, i = r, n = CI;
        o && (i = [
            r
        ], n = _I);
        var s = Proxy.revocable(i, n), a = s.revoke, d = s.proxy;
        return r.k = d, r.j = a, d;
    }(t1, o) : qE("ES5").J(t1, o);
    return (o ? o.A : JE()).p.push(r), r;
}
function lI(e, t1) {
    switch(t1){
        case 2:
            return new Map(e);
        case 3:
            return Array.from(e);
    }
    return WE(e);
}
var cI, pI, hI = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), mI = "undefined" != typeof Map, gI = "undefined" != typeof Set, vI = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, fI = hI ? Symbol.for("immer-nothing") : ((cI = {})["immer-nothing"] = !0, cI), yI = hI ? Symbol.for("immer-draftable") : "__$immer_draftable", SI = hI ? Symbol.for("immer-state") : "__$immer_state", bI = "" + Object.prototype.constructor, EI = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Object.getOwnPropertyNames, II = Object.getOwnPropertyDescriptors || function(e) {
    var t1 = {};
    return EI(e).forEach(function(o) {
        t1[o] = Object.getOwnPropertyDescriptor(e, o);
    }), t1;
}, AI = {}, CI = {
    get: function(e, t1) {
        if (t1 === SI) return e;
        var o = $E(e);
        if (!xE(o, t1)) return function(e, t1, o) {
            var r, i = sI(t1, o);
            return i ? "value" in i ? i.value : null === (r = i.get) || void 0 === r ? void 0 : r.call(e.k) : void 0;
        }(e, o, t1);
        var r = o[t1];
        return e.I || !VE(r) ? r : r === nI(e.t, t1) ? (dI(e), e.o[t1] = uI(e.A.h, r, e)) : r;
    },
    has: function(e, t1) {
        return t1 in $E(e);
    },
    ownKeys: function(e) {
        return Reflect.ownKeys($E(e));
    },
    set: function(e, t1, o) {
        var r = sI($E(e), t1);
        if (null == r ? void 0 : r.set) return r.set.call(e.k, o), !0;
        if (!e.P) {
            var i = nI($E(e), t1), n = null == i ? void 0 : i[SI];
            if (n && n.t === o) return e.o[t1] = o, e.R[t1] = !1, !0;
            if (function(e, t1) {
                return e === t1 ? 0 !== e || 1 / e == 1 / t1 : e != e && t1 != t1;
            }(o, i) && (void 0 !== o || xE(e.t, t1))) return !0;
            dI(e), aI(e);
        }
        return e.o[t1] === o && (void 0 !== o || t1 in e.o) || Number.isNaN(o) && Number.isNaN(e.o[t1]) || (e.o[t1] = o, e.R[t1] = !0), !0;
    },
    deleteProperty: function(e, t1) {
        return void 0 !== nI(e.t, t1) || t1 in e.t ? (e.R[t1] = !1, dI(e), aI(e)) : delete e.R[t1], e.o && delete e.o[t1], !0;
    },
    getOwnPropertyDescriptor: function(e, t1) {
        var o = $E(e), r = Reflect.getOwnPropertyDescriptor(o, t1);
        return r ? {
            writable: !0,
            configurable: 1 !== e.i || "length" !== t1,
            enumerable: r.enumerable,
            value: o[t1]
        } : r;
    },
    defineProperty: function() {
        LE(11);
    },
    getPrototypeOf: function(e) {
        return Object.getPrototypeOf(e.t);
    },
    setPrototypeOf: function() {
        LE(12);
    }
}, _I = {};
UE(CI, function(e, t1) {
    _I[e] = function() {
        return arguments[0] = arguments[0][0], t1.apply(this, arguments);
    };
}), _I.deleteProperty = function(e, t1) {
    return _I.set.call(this, e, t1, void 0);
}, _I.set = function(e, t1, o) {
    return CI.set.call(this, e[0], t1, o, e[0]);
};
var RI = function() {
    function e(e) {
        var t1 = this;
        this.O = vI, this.D = !0, this.produce = function(e, o, r) {
            if ("function" == typeof e && "function" != typeof o) {
                var i = o;
                o = e;
                var n = t1;
                return function(e) {
                    var t1 = this;
                    void 0 === e && (e = i);
                    for(var r = arguments.length, s = Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)s[a - 1] = arguments[a];
                    return n.produce(e, function(e) {
                        var r;
                        return (r = o).call.apply(r, [
                            t1,
                            e
                        ].concat(s));
                    });
                };
            }
            var s;
            if ("function" != typeof o && LE(6), void 0 !== r && "function" != typeof r && LE(7), VE(e)) {
                var a = XE(t1), d = uI(t1, e, void 0), u = !0;
                try {
                    s = o(d), u = !1;
                } finally{
                    u ? ZE(a) : YE(a);
                }
                return "undefined" != typeof Promise && s instanceof Promise ? s.then(function(e) {
                    return QE(a, r), tI(e, a);
                }, function(e) {
                    throw ZE(a), e;
                }) : (QE(a, r), tI(s, a));
            }
            if (!e || "object" != typeof e) {
                if (void 0 === (s = o(e)) && (s = e), s === fI && (s = void 0), t1.D && GE(s, !0), r) {
                    var l = [], c = [];
                    qE("Patches").M(e, s, l, c), r(l, c);
                }
                return s;
            }
            LE(21, e);
        }, this.produceWithPatches = function(e, o) {
            if ("function" == typeof e) return function(o) {
                for(var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)i[n - 1] = arguments[n];
                return t1.produceWithPatches(o, function(t1) {
                    return e.apply(void 0, [
                        t1
                    ].concat(i));
                });
            };
            var r, i, n = t1.produce(e, o, function(e, t1) {
                r = e, i = t1;
            });
            return "undefined" != typeof Promise && n instanceof Promise ? n.then(function(e) {
                return [
                    e,
                    r,
                    i
                ];
            }) : [
                n,
                r,
                i
            ];
        }, "boolean" == typeof (null == e ? void 0 : e.useProxies) && this.setUseProxies(e.useProxies), "boolean" == typeof (null == e ? void 0 : e.autoFreeze) && this.setAutoFreeze(e.autoFreeze);
    }
    var t1 = e.prototype;
    return t1.createDraft = function(e) {
        VE(e) || LE(8), NE(e) && (e = function(e) {
            return NE(e) || LE(22, e), function e(t1) {
                if (!VE(t1)) return t1;
                var o, r = t1[SI], i = jE(t1);
                if (r) {
                    if (!r.P && (r.i < 4 || !qE("ES5").K(r))) return r.t;
                    r.I = !0, o = lI(t1, i), r.I = !1;
                } else o = lI(t1, i);
                return UE(o, function(t1, i) {
                    r && function(e, t1) {
                        return 2 === jE(e) ? e.get(t1) : e[t1];
                    }(r.t, t1) === i || BE(o, t1, e(i));
                }), 3 === i ? new Set(o) : o;
            }(e);
        }(e));
        var t1 = XE(this), o = uI(this, e, void 0);
        return o[SI].C = !0, YE(t1), o;
    }, t1.finishDraft = function(e, t1) {
        var o = (e && e[SI]).A;
        return QE(o, t1), tI(void 0, o);
    }, t1.setAutoFreeze = function(e) {
        this.D = e;
    }, t1.setUseProxies = function(e) {
        e && !vI && LE(20), this.O = e;
    }, t1.applyPatches = function(e, t1) {
        var o;
        for(o = t1.length - 1; o >= 0; o--){
            var r = t1[o];
            if (0 === r.path.length && "replace" === r.op) {
                e = r.value;
                break;
            }
        }
        o > -1 && (t1 = t1.slice(o + 1));
        var i = qE("Patches").$;
        return NE(e) ? i(e, t1) : this.produce(e, function(e) {
            return i(e, t1);
        });
    }, e;
}(), wI = new RI, TI = wI.produce;
wI.produceWithPatches.bind(wI), wI.setAutoFreeze.bind(wI), wI.setUseProxies.bind(wI), wI.applyPatches.bind(wI), wI.createDraft.bind(wI), wI.finishDraft.bind(wI);
const OI = {
    ssrc: 0,
    status: fd.End,
    shareDimension: {
        width: 0,
        height: 0
    },
    receivedShareDimension: {
        width: 1920,
        height: 1080,
        logicWidth: 1920,
        logicHeight: 1080
    },
    sharePrivilege: vd.OnlyHost,
    activeNodeId: 0,
    activeSsrc: 0,
    shareQuality: 1,
    isRemoteSharingActive: !1,
    isReceiveSharing: !1,
    isGrabRemoteControl: !1,
    isSDKGrabControl: !1,
    isChromeExtensionInstalled: !1,
    isScreenShareForbidden: !1,
    isReceiveSharingFromMainSession: !1,
    isSharingToBreakoutRoom: !1,
    isSharingWithSecondCamera: !1,
    secondCameraId: "default",
    isRequireReadReceipt: !1,
    capturedEnsuredCanvas: [],
    renderedEnsuredCanvas: [],
    remoteControllingSsrc: 0,
    remoteControlApprovedSsrc: 0,
    remoteControlAppDownloadUrl: "",
    remoteControlAppInstallStatus: Gd.Unknown,
    isEnableAutoDeleteRcApp: !1,
    remoteControlledUserList: [],
    isRemoteControlEnabled: !1,
    isFullHDVideoShareEnabled: !1,
    userSsrcMapping: {},
    statistic: {
        encode: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            width: 0,
            height: 0,
            fps: 0,
            bandwidth: 0,
            bitrate: 0
        },
        decode: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            width: 0,
            height: 0,
            fps: 0,
            bandwidth: 0,
            bitrate: 0
        }
    }
}, DI = So({
    [`${pm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.sharePrivilege = o;
    }),
    [`${hm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isRemoteSharingActive = 1 === o.bStatus, e.activeNodeId = o.activeNodeID, e.activeSsrc = o.ssrc;
    }),
    [`${mm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isReceiveSharing = o;
    }),
    [`${gm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isChromeExtensionInstalled = o;
    }),
    [`${fm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.shareDimension = {
            ...o
        };
    }),
    [`${ym}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.status = o;
    }),
    [`${Sm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.ssrc = o;
    }),
    [`${bm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.shareQuality = o;
    }),
    [`${Em}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.receivedShareDimension = {
            ...o
        };
    }),
    [`${Wm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.remoteControlledUserList.includes(o) || e.remoteControlledUserList.push(o);
    }),
    [`${Gm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.remoteControlledUserList.indexOf(o);
        r >= 0 && e.remoteControlledUserList.splice(r, 1);
    }),
    [`${Im}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isGrabRemoteControl = o, !1 === o && (e.remoteControlViewportDomSelector = void 0);
    }),
    [`${Am}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isSDKGrabControl = o;
    }),
    [`${Cm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isReceiveSharingFromMainSession = o;
    }),
    [`${_m}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isSharingToBreakoutRoom = o;
    }),
    [`${Rm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isSharingWithSecondCamera = o;
    }),
    [`${wm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.secondCameraId = o;
    }),
    [`${Tm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isRequireReadReceipt = o;
    }),
    [`${Om}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isOptimizedForSharedVideo = o;
    }),
    [`${Dm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { data: { encoding: r, rate: i, ...n } } = o;
        e.statistic.encode = {
            bitrate: i,
            ...n
        };
    }),
    [`${Pm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { data: { encoding: r, rate: i, ...n } } = o;
        e.statistic.decode = {
            bitrate: i,
            ...n
        };
    }),
    [`${Mm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.capturedEnsuredCanvas.includes(o) || e.capturedEnsuredCanvas.push(o);
    }),
    [`${km}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.renderedEnsuredCanvas.includes(o) || e.renderedEnsuredCanvas.push(o);
    }),
    [`${Nm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.remoteControllingSsrc = o;
    }),
    [`${Vm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.remoteControlApprovedSsrc = o;
    }),
    [`${Um}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.remoteControlAppDownloadUrl = o;
    }),
    [`${jm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        (e.remoteControlAppInstallStatus !== Gd.Installed || Gd.Unknown) && (e.remoteControlAppInstallStatus = o);
    }),
    [`${Hm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.remoteControlAppLaunchSheme = o;
    }),
    [`${$m}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { userId: r, ssrc: i } = o;
        Object.assign(e.userSsrcMapping, {
            [`${r}`]: i
        });
    }),
    [`${Km}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        Object.assign(e, o);
    }),
    [`${zm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.remoteControlViewportDomSelector = o;
    }),
    [`${qm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isFullHDVideoShareEnabled = o;
    }),
    [`${Jm}`]: ()=>({
            ...OI
        })
}, OI), PI = {
    remoteControlEpics0: (e)=>e.pipe(Ot(`${cn}`), ke((e)=>{
            const { payload: { meetingOptions: t1, rcAutoDelete: o, jwtRc: r, opRc: i } } = e, n = (null == t1 ? void 0 : t1.isRemoteControlEnbaled) && i && 1 === r;
            return Km({
                isRemoteControlEnabled: n,
                isEnableAutoDeleteRcApp: 1 === o
            });
        })),
    remoteControlEpics1: (e, t1)=>ir(e, 16391).pipe(Be((e)=>{
            const { payload: { body: { bOn: o, sendID: r, receiveID: i } } } = e, { meeting: { userId: n }, share: { status: s, activeNodeId: a, isGrabRemoteControl: d } } = t1.value, u = [];
            if (s === fd.End && u.push(Nm(0)), s !== fd.End) if (Zr(n, r)) if (o) {
                CE(), _E(), s === fd.Paused && (ME.resumeSharing(), kE.resumeDesktopSharing(), u.push(ym(fd.Sharing))), u.push(Nm(i));
                const e = ch(t1.value).find((e)=>Zr(e.userId, i));
                e && u.push($m({
                    userId: e.userId,
                    ssrc: i
                }));
            } else u.push(Nm(0));
            else {
                var l;
                const e = null === (l = ch(t1.value)) || void 0 === l ? void 0 : l.find((e)=>Zr(e.userId, r));
                e && (u.push($m({
                    userId: e.userId,
                    ssrc: r
                })), ep(Vl, {
                    userId: e.userId,
                    displayName: e.displayName,
                    isSharingEntireScreen: kE.isSharingEntireScreen()
                }));
            }
            else if (!i || Zr(i, n)) {
                const e = sh(t1.value);
                if (!Gp(e.userRole) && !ms.isAndroidOrIOSBrowser) {
                    const e = r && Zr(a, r);
                    o ? (u.push(Wm(a)), e && (d || ME.subscribeGrabRemoteControl(a, !0))) : (u.push(Gm(a)), e && (d && (ME.subscribeGrabRemoteControl(a, !1), u.push(Im(!1)), ep(Ol, !1)), kE.updateRemoteControlProperties({
                        isControllerNow: !1
                    }))), ep(Tl, o);
                }
            }
            return Ce(u);
        })),
    remoteControlEpics2: (e, t1)=>ir(e, 16395).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            return t1.payload.body.id === o.meeting.userId;
        }), ke((e)=>{
            let [t1] = e;
            const { payload: { body: { bOn: o } } } = t1;
            return kE.updateRemoteControlProperties({
                isControllerNow: o
            }), ep(Ol, o), Im(o);
        })),
    remoteControlEpics3: (e)=>dr(e, [
            nd.StartRemoteControlSuccess,
            nd.StartRemoteControlFailed,
            nd.CancelRemoteControlSuccess
        ]).pipe(qy((e)=>e.payload.type === nd.StartRemoteControlSuccess ? (ep(Pl), Am(!0)) : e.payload.type === nd.CancelRemoteControlSuccess ? Am(!1) : void (e.payload.type === nd.StartRemoteControlFailed && ep(Ml)))),
    remoteControlEpics4: (e)=>dr(e, [
            nd.RemoteControlCopiedTextNotify,
            nd.RemoteControlPasteTextLengthOverflow
        ]).pipe(gt((e)=>{
            if (e.payload.type === nd.RemoteControlCopiedTextNotify) {
                const { payload: { data: t1 } } = e;
                ep(Dl, {
                    content: t1.data,
                    x: t1.x,
                    y: t1.y
                });
            } else ep(Dl, {
                error: "length of pasted text is too long"
            });
        }), dt(ie)),
    remoteControlEpics5: (e, t1)=>ir(e, 4342).pipe(tt((e)=>0 === e.payload.body.result), Be((e)=>{
            const { payload: { body: { downloadUrl: o, ssrc: r, urlScheme: i } } } = e, { share: { remoteControlApprovedSsrc: n, status: s } } = t1.value, a = [], { isMacOS: d } = ms;
            if (s !== fd.End) {
                if (!n || n === r) {
                    CE();
                    try {
                        const e = JSON.parse(o || "{}"), t1 = d ? e.macDownloadUrl : e.winDownloadUrl;
                        a.push(Um(t1));
                    } catch (e) {
                        console.warn("unsupported JSON string", e);
                    }
                }
                const s = {}, u = ch(t1.value).find((e)=>Zr(e.userId, r));
                u && Object.assign(s, {
                    controllerName: Hr(u.displayName)
                }), Object.assign(s, {
                    ssrc: r
                });
                const { deviceId: l } = kE.getShareStreamInfo();
                l && Object.assign(s, {
                    DeviceID: l
                });
                const c = `${i}&${new URLSearchParams(s).toString()}`;
                a.push(Hm(c), jm(Gd.Unknown)), ep(xl, c);
            }
            return Ce(a);
        })),
    remoteControlEpics6: (e)=>e.pipe(Ot(`${xm}`), Be(()=>IE.startCheck(1e4).pipe(ke(()=>(ep(Ul, Gd.Unknown), jm(Gd.Unknown)))))),
    remoteControlEpics7: (e, t1)=>e.pipe(Ot(`${Bm}`), tt(()=>{
            const { share: { remoteControlAppInstallStatus: e } } = t1.value;
            return e === Gd.Installed;
        }), Be(()=>AE.startCheck(12e4).pipe(Be(()=>{
                ep(Ul, Kd.Unlaunched);
                const { share: { remoteControlApprovedSsrc: e, isEnableAutoDeleteRcApp: o }, meeting: { userId: r } } = t1.value, i = [], { isMacOS: n } = ms;
                return e && (ME.remoteControlConsent(Wd.CacheClean, e, r, {
                    ...kE.getShareStreamInfo(),
                    platform: n ? "mac" : "win"
                }, o), i.push(Hm(""), Vm(0))), Ce(i);
            })))),
    remoteControlEpics8: (e, t1)=>e.pipe(Ot(`${Hm}`), tt((e)=>!!e.payload), Be((e)=>{
            const { payload: o } = e, r = [];
            let i;
            if (o) {
                !function(e) {
                    if (!e.startsWith("zoomprc://")) return;
                    const t1 = Xr("__ZOOM_SDK_RC_APP_SCHEME_@__");
                    let o = document.getElementById(t1);
                    o || (o = document.createElement("iframe"), o.id = t1, o.style.display = "none", document.body.appendChild(o)), o.contentWindow.location.href = e;
                }(o), r.push(Bm());
                const e = performance.now();
                document.hasFocus() ? i = Ze(25).pipe(mt(()=>{
                    const o = performance.now() - e < 500;
                    return o || ep(Ul, Gd.Uninstalled), o && t1.value.share.remoteControlAppInstallStatus === Gd.Unknown;
                }), pt(()=>{
                    const t1 = performance.now() - e, o = [];
                    return document.hasFocus() || (t1 > 75 ? o.push(xm()) : CE(), ep(Ul, Gd.Installed), o.push(jm(Gd.Installed), Bm())), Ce(o);
                }), function() {
                    for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
                    return function(t1) {
                        return He(t1, _e.apply(void 0, s([], n(e))));
                    };
                }(jm(Gd.Uninstalled))) : (ep(Ul, Gd.Unknown), r.push(jm(Gd.Unknown)));
            }
            return i ? Ye(i, Ce(r)) : Ce(r);
        })),
    remoteControlEpics9: (e, t1)=>ir(e, Us).pipe(Be(()=>(ep(jl, zd.Ended), RE(t1.value, ME), Ce([
                Hm(""),
                Vm(0)
            ])))),
    remoteControlEpics10: (e, t1)=>e.pipe(Ot(`${ym}`), tt((e)=>{
            const { share: { remoteControllingSsrc: o, remoteControlApprovedSsrc: r } } = t1.value;
            return !(e.payload !== fd.End || !o && !r);
        }), gt(()=>{
            const { share: { remoteControllingSsrc: e, remoteControlApprovedSsrc: o, isEnableAutoDeleteRcApp: r }, meeting: { userId: i } } = t1.value, { isMacOS: n } = ms;
            e && RE(t1.value, ME), o !== e && ME.remoteControlConsent(Wd.Decline, o, i, {
                ...kE.getShareStreamInfo(),
                platform: n ? "mac" : "win"
            }, r);
        }), dt(ie)),
    remoteControlEpics11: (e, t1)=>ir(e, 16430).pipe(Be(()=>(CE(), _E(), ep(Ul, Kd.Launched), t1.value.share.status !== fd.End && function(e, t1) {
                (async function(e) {
                    const { media: { assetsPath: t1 } } = e, o = `${t1}/qrscanner.min.js`;
                    return "WebQrscanner" in window ? Promise.resolve("") : new Promise((e, t1)=>{
                        yE.log(`load qr scanner script start. url:${o}`), lr(o, ()=>{
                            yE.log("load qr scanner script done."), e("");
                        }, t1);
                    });
                })(e).then(()=>{
                    yE.log("qr scanning start"), t1.startRemoteControlQRCheck(!0);
                });
            }(t1.value, kE), Ce([
                Hm(""),
                Vm(0)
            ])))),
    remoteControlEpics12: (e)=>dr(e, nd.CurrentDesktopSharingWidthHeight).pipe(gt(()=>{
            ME.syncSharedContentMetaWithRcApp(kE.getShareStreamInfo());
        }), dt(ie)),
    remoteControlEpics13: (e, t1)=>dr(e, nd.SendRemoteControlQrCode).pipe(gt((e)=>{
            const { payload: { data: o } } = e, { share: { status: r } } = t1.value;
            r !== fd.End && Array.isArray(o) && o.length > 0 && o.forEach((e)=>{
                null != e && e.startsWith("zrc_") && ME.sendRemoteControlAuth(e);
            });
        }), dt(ie)),
    remoteControlEpics14: (e)=>ir(e, 16434).pipe(gt((e)=>{
            const { payload: { body: { result: t1 } } } = e;
            0 === t1 && (TE(), ep(jl, zd.Started));
        }), dt(ie)),
    remoteControlEpics15: (e, t1)=>ir(e, Ds).pipe(tt((e)=>{
            var o, r;
            const { meeting: { userId: i }, share: { remoteControlledUserList: n } } = t1.value, { payload: { body: s } } = e;
            return n.length > 0 && ((null === (o = s.update) || void 0 === o ? void 0 : o.some((e)=>e.id !== i && !1 === e.bShareOn)) || (null === (r = s.remove) || void 0 === r ? void 0 : r.some((e)=>e.id !== i)));
        }), Be((e)=>{
            var o, r, i, n;
            const { payload: { body: s } } = e, { share: { remoteControlledUserList: a, activeNodeId: d, isGrabRemoteControl: u }, meeting: { userId: l } } = t1.value, c = (null !== (o = null === (r = s.update) || void 0 === r ? void 0 : r.filter((e)=>e.id !== l && !1 === e.bShareOn)) && void 0 !== o ? o : []).concat(null !== (i = null === (n = s.remove) || void 0 === n ? void 0 : n.filter((e)=>e.id !== l)) && void 0 !== i ? i : []), p = [];
            return a.forEach((e)=>{
                c.find((t1)=>t1.id === e) && (p.push(Gm(e)), e === d && u && (p.push(Im(!1)), ep(Ol, !1)));
            }), Ce(p);
        })),
    remoteControlEpics16: (e, t1)=>e.pipe(Ot(`${nn}`), gt(()=>{
            const { share: { remoteControllingSsrc: e, status: o } } = t1.value;
            o === fd.Sharing && e && ep(jl, zd.Ended);
        }), dt(ie))
}, MI = {
    epics0: (e, t1)=>ir(e, Ps).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.lockShare);
        }), vt(t1), gt((e)=>{
            let [t1, o] = e;
            const { share: { sharePrivilege: r } } = o, { payload: { body: { lockShare: i } } } = t1;
            r !== i && ep(kl, i);
        }), ke((e)=>{
            let [t1] = e;
            return pm(t1.payload.body.lockShare);
        })),
    epics1: (e)=>ir(e, 20227).pipe(ke((e)=>Sm(e.payload.body.ssrc))),
    epics2: (e, t1)=>ir(e, Ts).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            const { payload: { body: r } } = t1, { share: { isReceiveSharingFromMainSession: i } } = o;
            return !i || i && r.fromMainSession;
        }), ke((e)=>{
            let [o, r] = e;
            const { share: { isReceiveSharing: i, activeNodeId: n, isReceiveSharingFromMainSession: s }, breakoutRoom: a } = r, { payload: { body: d } } = o;
            if (i && 1 === d.bStatus) {
                let e = !1;
                (null == a ? void 0 : a.currentRoom.status) === Jp.InRoom && a.mainSessionAttendeeList.length > 0 && (e = a.mainSessionAttendeeList.findIndex((e)=>e.userId === n) > -1), DE.unsubscribeSharing(n, e), bE(DE, r, d.activeNodeID), PE.switchSharingSource(d.ssrc, s), OE(d.activeNodeID, t1.value, PE), ep(wl, {
                    userId: d.activeNodeID
                });
            } else if (1 === d.bStatus) {
                const e = {
                    activeUserId: d.activeNodeID,
                    isActive: !0
                };
                s && Object.assign(e, {
                    isFromMainSession: !0
                }), ep(gl, e);
            } else if (i) {
                const e = {
                    activeUserId: d.activeNodeID,
                    isActive: !1
                };
                s && Object.assign(e, {
                    isFromMainSession: !0
                }), ep(gl, e);
            }
            return hm(d);
        })),
    epics3: (e)=>dr(e, nd.CheckChromeSharingExtensionResponse).pipe(ke((e)=>(ep(vl, e.payload.data), gm(e.payload.data)))),
    epics4: (e, t1)=>dr(e, [
            nd.SharingDesktopStreamHaveAudio,
            nd.SharingDesktopStreamHaveNoAudio
        ]).pipe(tt((e)=>e.payload.type !== nd.SharingDesktopStreamHaveAudio || !t1.value.audio.secondaryAudioMicrophoneId), vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { meeting: { userId: r }, share: { isSharingToBreakoutRoom: i, isOptimizedForSharedVideo: n } } = o, { payload: { type: s } } = t1, a = s === nd.SharingDesktopStreamHaveAudio;
            return DE.startSharing(r, {
                bShareToBO: i,
                bShareAudio: a,
                bShareVideo: !!n
            }), PE.switchSharingMode(n ? Fd.VideoMode : Fd.Normal), vm(!1);
        })),
    epics5: (e)=>dr(e, [
            nd.DesktopSharingError,
            nd.DesktopSharingChromeExtensionUninstalled,
            nd.DesktopSharingPermissionDenied,
            nd.DesktopSharingSystemError
        ]).pipe(Be((e)=>{
            const t1 = [];
            let o = "";
            return [
                nd.DesktopSharingPermissionDenied,
                nd.DesktopSharingSystemError
            ].includes(e.payload.type) && (t1.push(vm(!0)), e.payload.type === nd.DesktopSharingSystemError ? ms.isMacOS && (o = "To use screen share on Chrome, please allow screen recording access in system setting.") : o = "To use screen share, please allow the permission request."), ep(fl, {
                reason: o
            }), Ce(t1);
        })),
    epics6: (e)=>dr(e, nd.CurrentDesktopSharingWidthHeight).pipe(tt((e)=>!!e.payload.data), ke((e)=>{
            ep(yl, e.payload.data);
            const { payload: { data: { width: t1, height: o } } } = e;
            return PE.ajustmentSharingCanvas(t1, o), fm(e.payload.data);
        })),
    epics7: (e, t1)=>dr(e, nd.SharingDecodeMaxSize).pipe(tt((e)=>!!e.payload.data), vt(t1), qy((e)=>{
            let [t1, o] = e;
            const { share: { shareQuality: r, activeNodeId: i } } = o, { payload: { data: { fps: n } } } = t1, s = Number(n);
            if (r !== s) return bE(DE, o, i, s), bm(s);
        })),
    epics8: (e)=>ir(e, 20226).pipe(gt((e)=>{
            var t1, o;
            if (ep(Sl, null === (t1 = e.payload) || void 0 === t1 ? void 0 : t1.body), null !== (o = e.payload) && void 0 !== o && o.body) {
                const { payload: { body: { width: t1, height: o } } } = e;
                PE.ajustmentReceivedSharingCanvas(t1, o);
            }
        }), ke((e)=>Em(e.payload.body))),
    epics9: (e)=>dr(e, nd.SharingPara).pipe(gt((e)=>{
            var t1, o;
            if (ep(Sl, null === (t1 = e.payload.data) || void 0 === t1 ? void 0 : t1.body), null !== (o = e.payload.data) && void 0 !== o && o.body) {
                const { payload: { data: { body: { width: t1, height: o } } } } = e;
                PE.ajustmentReceivedSharingCanvas(t1, o);
            }
        }), ke((e)=>{
            var t1;
            return Em(null === (t1 = e.payload.data) || void 0 === t1 ? void 0 : t1.body);
        })),
    epics10: (e, t1)=>dr(e, nd.UserStopDesktopSharing).pipe(vt(t1), ke((e)=>{
            let [, t1] = e;
            const { meeting: { userId: o }, share: { status: r } } = t1;
            return r !== fd.End && (DE.stopSharing(o), PE.stopDesktopSharing(), ep(bl)), ym(fd.End);
        })),
    epics11: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            const { meeting: { userId: r } } = o, i = t1.payload.body.update;
            return i && i.length > 0 && i.findIndex((e)=>e.id === r && void 0 !== e.bShareOn) > -1;
        }), Be((e)=>{
            let [t1, o] = e;
            const { meeting: { userId: r }, share: { status: i, isReceiveSharing: n, activeNodeId: s } } = o, { payload: { body: { update: a } } } = t1, d = a.find((e)=>e.id === r && !1 === e.bShareOn), u = a.find((e)=>e.id === r && !0 === e.bShareOn), l = [];
            return d && i !== fd.End && (DE.stopSharing(r), PE.stopDesktopSharing(), l.push(ym(fd.End)), ep(El)), u && i === fd.End && (n && (PE.stopRenderSharing(), DE.unsubscribeSharing(s), l.push(mm(!1))), l.push(ym(fd.Sharing))), Ce(l);
        })),
    epics12: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            const { meeting: { userId: r } } = o, i = t1.payload.body.update;
            return i && i.length > 0 && i.findIndex((e)=>e.id !== r && void 0 !== e.bShareOn) > -1;
        }), Be((o)=>{
            let [r, i] = o;
            const { payload: { body: { update: n } } } = r, { share: { activeNodeId: s, isReceiveSharing: a } } = i, d = dS(i), u = n.filter((e)=>!0 === e.bShareOn && !1 === e.bSharePause), l = n.filter((e)=>!0 === e.bShareOn && !0 === e.bSharePause), c = n.filter((e)=>!1 === e.bShareOn);
            return u.length > 0 && u.forEach((e)=>{
                -1 === d.findIndex((t1)=>t1.userId === e.id) ? ep(Al, e) : ep(Rl, e);
            }), l.length > 0 && l.forEach((e)=>{
                ep(_l, e);
            }), c.length > 0 && (c.forEach((e)=>{
                ep(Cl, e);
            }), a && c.some((e)=>e.id === s)) ? ot(ir(e, Ts).pipe(it(1), dt(ie)), Qe(50).pipe(dt(Re("timeout")))).pipe(rt(()=>{
                const { share: { activeNodeId: e, isReceiveSharingFromMainSession: o } } = t1.value, r = d.filter((t1)=>t1.userId !== e);
                if (r.length > 0) {
                    const i = r[0], { userId: n } = i;
                    return DE.unsubscribeSharing(e, o), bE(DE, t1.value, n), PE.switchSharingSource(n, o), OE(n, t1.value, PE), ep(wl, {
                        userId: n
                    }), _e(hm({
                        activeNodeID: n,
                        bStatus: 1,
                        ssrc: n
                    }));
                }
                return ie;
            })) : ie;
        })),
    epics13: (e, t1)=>ir(e, Os).pipe(vt(t1), pt((e)=>{
            let [o, r] = e;
            const { payload: { body: { encryptKey: i, additionalType: n } } } = o, { media: { sharingDecodeStatus: s, sharingEncodeStatus: a }, meeting: { confId: d, userId: u, zoomId: l, meetingId: c, meetingNumber: p, isWebinar: h } } = r;
            return Iy(t1).pipe(pt((e)=>{
                let o = a;
                return (!ms.isSupportSendScreenSharing || h && e && Gp(e.userRole)) && (o = "failed"), Ey("sharing", o, s).pipe(gt((e)=>{
                    let [o, r] = e;
                    const s = {
                        userId: u,
                        sn: Kr(l),
                        confId: d,
                        encryptKey: Kr(i),
                        encryptType: n,
                        meetingId: c,
                        meetingNumber: p
                    };
                    if (o && (null == PE || PE.updateMediaParams({
                        iVType: Es.SHARING_ENCODE,
                        isFromMainSession: !1,
                        updateParams: s
                    })), r) {
                        PE.updateMediaParams({
                            iVType: Es.SHARING_DECODE,
                            isFromMainSession: !1,
                            updateParams: s
                        });
                        const { participants: { attendeesList: e } } = t1.value;
                        if (e.length > 0) {
                            const t1 = e.map((e)=>({
                                    userid: e.userId,
                                    sn: e.zoomID && Kr(e.zoomID)
                                }));
                            PE.updateUserMediaSN({
                                added: t1,
                                isFromMainSession: !1,
                                iVType: Es.SHARING_DECODE
                            });
                        }
                    }
                }), dt(ie));
            }));
        })),
    epics14: (e, t1)=>ar(e, 20235).pipe(vt(t1), gt((e)=>{
            let [t1, o] = e;
            const { media: { sharingDecodeStatus: r } } = o, { type: i, payload: { body: n } } = t1, s = i === `${Oo}`;
            Ey("sharing", "success", r).subscribe((e)=>{
                let [, t1] = e;
                t1 && PE.addReceivedSharingChannelType({
                    isFromMainSession: s,
                    ...n
                });
            });
        }), dt(ie)),
    epics15: (e, t1)=>ar(e, 20236).pipe(vt(t1), gt((e)=>{
            let [t1, o] = e;
            const { media: { sharingDecodeStatus: r } } = o, { type: i, payload: { body: { ssrc: n } } } = t1, s = i === `${Oo}`;
            Ey("sharing", "success", r).subscribe((e)=>{
                let [, t1] = e;
                t1 && PE.removeReceivedSharingChannelType({
                    isFromMainSession: s,
                    ssrc: n
                });
            });
        }), dt(ie)),
    epics16: (e)=>dr(e, nd.SharingFirstDecodeFrameReceivedSsrc).pipe(tt((e)=>!!e.payload.data), gt((e)=>{
            const { payload: { data: { ssrc: t1 } } } = e;
            DE.sendReceivingSharingReady(t1);
        }), dt(ie)),
    epics17: (e, t1)=>ir(e, 20233).pipe(tt(()=>!!t1.value.share.isRequireReadReceipt), gt((e)=>{
            const { payload: { body: { bReceiveOk: t1 } } } = e;
            t1 && ep(Ll);
        }), dt(ie)),
    epics18: (e, t1)=>ir(e, Ps).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.lockShare);
        }), Be((e)=>{
            const { payload: { body: { lockShare: o } } } = e, { share: { isOptimizedForSharedVideo: r, isSharingToBreakoutRoom: i }, audio: { isSharingAudio: n }, meeting: { userId: s } } = t1.value, a = [];
            return o === vd.MultipleShare && r && (DE.startSharing(s, {
                bShareAudio: n,
                bShareToBO: i,
                bShareVideo: !1
            }), PE.switchSharingMode(Fd.Normal), a.push(Om(!1))), Ce(a);
        })),
    epics19: (e, t1)=>dr(e, nd.ShareQosData).pipe(vt(t1), ke((e)=>{
            var t1;
            let [o, r] = e;
            const { meeting: { isWebinar: i }, media: { sharingEncodeStatus: n, sharingDecodeStatus: s }, share: { status: a, isReceiveSharing: d }, participants: { xmppAttendeeList: u } } = r;
            let l = gh(r).length > 0;
            i && (l = l || Boolean(u.length));
            const c = a !== fd.End && "success" === n && l, p = d && "success" === s;
            return null !== (t1 = o.payload.data) && void 0 !== t1 && t1.encoding ? c ? (ep(Nl, o.payload), Dm(o.payload)) : Dm(Nd) : p ? (ep(Nl, o.payload), Pm(o.payload)) : Pm(Nd);
        }))
}, kI = rr(MI, PI), LI = ra.createAgent();
let NI = function(e) {
    return e.Add = "add", e.List = "list", e.Remove = "memberremove", e.rename = "rename", e.update = "UPDATE", e;
}({}), VI = function(e) {
    return e.Open = "open", e.Message = "message", e.Error = "error", e.Close = "close", e;
}({});
class UI {
    constructor(){
        this.eventHandlers = void 0, this.websocket = void 0, this.seq = void 0, this.eventHandlers = new Map, this.websocket = null, this.seq = 1;
    }
    static getInstance() {
        return this.xmppInstance || (this.xmppInstance = new UI), this.xmppInstance;
    }
    on(e, t1) {
        let o = this.eventHandlers.get(e);
        o || (o = []), o.push(t1), this.eventHandlers.set(e, o);
    }
    off(e, t1) {
        const o = this.eventHandlers.get(e);
        if (o) {
            const r = o.filter((e)=>e !== t1);
            this.eventHandlers.set(e, r);
        }
    }
    emit(e, t1) {
        const o = this.eventHandlers.get(e);
        o && o instanceof Array && o.slice(0).forEach((e)=>{
            try {
                e(t1);
            } catch (e) {
                console.error(e);
            }
        });
    }
    sendMessageToRwg(e) {
        this.seq += 1;
        const t1 = this.seq;
        return this.websocket && this.websocket.readyState === WebSocket.OPEN && this.websocket.send(JSON.stringify(Object.assign(e, {
            seq: t1
        }))), t1;
    }
    connect(e, t1) {
        this.websocket = t1 ? new window.ZoomTPModule.ZoomTPWebSocket(e) : new WebSocket(e), this.websocket.binaryType = "arraybuffer", this.addWebSocketEventListeners();
    }
    close() {
        var e;
        null === (e = this.websocket) || void 0 === e || e.close();
    }
    addWebSocketEventListeners() {
        this.websocket && (this.websocket.addEventListener("open", (e)=>{
            this.emit(VI.Open, e);
        }), this.websocket.addEventListener("message", (e)=>{
            const { data: t1 } = e;
            var o;
            if (t1 instanceof ArrayBuffer) 0 === new Uint8Array(t1)[0] && (null === (o = this.websocket) || void 0 === o || o.send(t1));
            else try {
                this.emit(VI.Message, JSON.parse(t1));
            } catch (e) {
                console.warn("Unsupported format", t1);
            }
        }), this.websocket.addEventListener("close", (e)=>{
            this.emit(VI.Close, e);
        }), this.websocket.addEventListener("error", (e)=>{
            this.emit(VI.Error, e);
        }));
    }
    join(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 24576,
                body: {
                    clientCap: e
                }
            })
        };
    }
    raiseHand() {
        return {
            seq: this.sendMessageToRwg({
                evt: 24580,
                body: null
            })
        };
    }
    lowerHand(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 24578,
                jids: e || []
            })
        };
    }
    sendWebinarMseeage(e, t1, o) {
        const r = {
            msg: e,
            jid: t1 ? [
                t1
            ] : [],
            type: o,
            bcm: arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
        };
        return {
            seq: this.sendMessageToRwg({
                evt: 24582,
                body: r
            })
        };
    }
    sendAnswer(e, t1, o) {
        return {
            seq: this.sendMessageToRwg({
                evt: 24584,
                body: {
                    question_attendeejid: t1.jid,
                    question_attendeename: t1.displayName,
                    question_text: t1.questionText,
                    question_id: t1.questionId,
                    question_anonymous: t1.isAnonymous,
                    question_time: t1.questionTime,
                    text: e,
                    isPrivate: o
                }
            })
        };
    }
    answerOnline(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                evt: 24586,
                body: {
                    question_attendeejid: e.jid,
                    question_attendeename: e.displayName,
                    question_text: e.questionText,
                    question_id: e.questionId,
                    question_anonymous: e.isAnonymous,
                    question_time: e.questionTime,
                    isLiveStart: t1
                }
            })
        };
    }
    dismissQuestion(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 24590,
                body: {
                    question_attendeejid: e.jid,
                    question_attendeename: e.displayName,
                    question_text: e.questionText,
                    question_id: e.questionId,
                    question_anonymous: e.isAnonymous,
                    question_time: e.questionTime,
                    bOpen: !1
                }
            })
        };
    }
    deleteQuestion(e) {
        return {
            seq: this.sendMessageToRwg({
                evt: 24614,
                body: {
                    question_id: e,
                    bDelete: !0
                }
            })
        };
    }
    deleteComment(e) {
        return {
            seq: this.sendMessageToRwg({
                body: {
                    comment_id: e,
                    bDelete: !0
                },
                evt: 24616
            })
        };
    }
    reopenQuestion(e) {
        return {
            seq: this.sendMessageToRwg({
                body: {
                    question_attendeejid: e.jid,
                    question_attendeename: e.displayName,
                    question_text: e.questionText,
                    question_id: e.questionId,
                    question_anonymous: e.isAnonymous,
                    question_time: e.questionTime,
                    bOpen: !0
                },
                evt: 24590
            })
        };
    }
    askQuestion(e, t1) {
        let o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = arguments.length > 3 ? arguments[3] : void 0;
        const i = Jr();
        return {
            seq: this.sendMessageToRwg({
                body: {
                    id: i,
                    text: e,
                    isAnonymous: o,
                    bAllowAttendeeViewAllQuestion: r,
                    name: t1
                },
                evt: 24592
            }),
            questionId: i
        };
    }
    upOrDownVote(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                body: {
                    question_attendeejid: e.jid,
                    question_attendeename: e.displayName,
                    question_text: e.questionText,
                    question_id: e.questionId,
                    question_anonymous: e.isAnonymous,
                    question_time: e.questionTime,
                    bUpVote: t1
                },
                evt: 24598
            })
        };
    }
    rename(e, t1) {
        return {
            seq: this.sendMessageToRwg({
                body: {
                    jid: e,
                    displayName: t1
                },
                evt: 24600
            })
        };
    }
    setSkinTome(e) {
        return {
            seq: this.sendMessageToRwg({
                body: {
                    skinTone: e
                },
                evt: 24618
            })
        };
    }
}
UI.xmppInstance = null;
const jI = pE.getInstance();
let xI, BI;
const FI = ra.createAgent();
let HI = null;
function $I(e) {
    switch(e.responseType){
        case "json":
            if ("response" in e) return e.response;
            var t1 = e;
            return JSON.parse(t1.responseText);
        case "document":
            return e.responseXML;
        default:
            return "response" in e ? e.response : (t1 = e).responseText;
    }
}
var WI = function(e, t1, o, r) {
    void 0 === r && (r = "download_load"), this.originalEvent = e, this.xhr = t1, this.request = o, this.type = r;
    var i = t1.status, n = t1.responseType;
    this.status = null != i ? i : 0, this.responseType = null != n ? n : "";
    var s = t1.getAllResponseHeaders();
    this.responseHeaders = s ? s.split("\n").reduce(function(e, t1) {
        var o = t1.indexOf(": ");
        return e[t1.slice(0, o)] = t1.slice(o + 2), e;
    }, {}) : {}, this.response = $I(t1);
    var a = e.loaded, d = e.total;
    this.loaded = a, this.total = d;
}, GI = l(function(e) {
    return function(e, t1, o) {
        var r;
        this.message = e, this.name = "AjaxError", this.xhr = t1, this.request = o, this.status = t1.status, this.responseType = t1.responseType;
        try {
            r = $I(t1);
        } catch (e) {
            r = t1.responseText;
        }
        this.response = r;
    };
}), KI = function() {
    function e(e, t1) {
        return GI.call(this, "ajax timeout", e, t1), this.name = "AjaxTimeoutError", this;
    }
    return e.prototype = Object.create(GI.prototype), e;
}();
var zI = ke(function(e) {
    return e.response;
});
var qI, JI = (qI = function(e) {
    return function(e) {
        return new D(function(t1) {
            var r, i, n, s = o({
                async: !0,
                crossDomain: !1,
                withCredentials: !1,
                method: "GET",
                timeout: 0,
                responseType: "json"
            }, e), a = s.queryParams, d = s.body, u = s.headers, l = s.url;
            if (!l) throw new TypeError("url is required");
            if (a) if (l.includes("?")) {
                var c = l.split("?");
                if (2 < c.length) throw new TypeError("invalid url");
                n = new URLSearchParams(c[1]), new URLSearchParams(a).forEach(function(e, t1) {
                    return n.set(t1, e);
                }), l = c[0] + "?" + n;
            } else l = l + "?" + (n = new URLSearchParams(a));
            var p = {};
            if (u) for(var h in u)u.hasOwnProperty(h) && (p[h.toLowerCase()] = u[h]);
            var m = s.crossDomain;
            m || "x-requested-with" in p || (p["x-requested-with"] = "XMLHttpRequest");
            var g = s.withCredentials, v = s.xsrfCookieName, f = s.xsrfHeaderName;
            if ((g || !m) && v && f) {
                var y = null !== (i = null === (r = null === document || void 0 === document ? void 0 : document.cookie.match(new RegExp("(^|;\\s*)(" + v + ")=([^;]*)"))) || void 0 === r ? void 0 : r.pop()) && void 0 !== i ? i : "";
                y && (p[f] = y);
            }
            var S, b = function(e, t1) {
                var o;
                if (!e || "string" == typeof e || function(e) {
                    return "undefined" != typeof FormData && e instanceof FormData;
                }(e) || function(e) {
                    return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams;
                }(e) || function(e) {
                    return oA(e, "ArrayBuffer");
                }(e) || function(e) {
                    return oA(e, "File");
                }(e) || function(e) {
                    return oA(e, "Blob");
                }(e) || function(e) {
                    return "undefined" != typeof ReadableStream && e instanceof ReadableStream;
                }(e)) return e;
                if (function(e) {
                    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView(e);
                }(e)) return e.buffer;
                if ("object" == typeof e) return t1["content-type"] = null !== (o = t1["content-type"]) && void 0 !== o ? o : "application/json;charset=utf-8", JSON.stringify(e);
                throw new TypeError("Unknown body type");
            }(d, p), E = o(o({}, s), {
                url: l,
                headers: p,
                body: b
            });
            S = e.createXHR ? e.createXHR() : new XMLHttpRequest;
            var I = e.progressSubscriber, A = e.includeDownloadProgress, C = void 0 !== A && A, _ = e.includeUploadProgress, R = void 0 !== _ && _, w = function(e, o) {
                S.addEventListener(e, function() {
                    var e, r = o();
                    null === (e = null == I ? void 0 : I.error) || void 0 === e || e.call(I, r), t1.error(r);
                });
            };
            w("timeout", function() {
                return new KI(S, E);
            }), w("abort", function() {
                return new GI("aborted", S, E);
            });
            var T = function(e, t1) {
                return new WI(t1, S, E, e + "_" + t1.type);
            }, O = function(e, o, r) {
                e.addEventListener(o, function(e) {
                    t1.next(T(r, e));
                });
            };
            R && [
                YI,
                XI,
                eA
            ].forEach(function(e) {
                return O(S.upload, e, QI);
            }), I && [
                YI,
                XI
            ].forEach(function(e) {
                return S.upload.addEventListener(e, function(e) {
                    var t1;
                    return null === (t1 = null == I ? void 0 : I.next) || void 0 === t1 ? void 0 : t1.call(I, e);
                });
            }), C && [
                YI,
                XI
            ].forEach(function(e) {
                return O(S, e, ZI);
            });
            var D = function(e) {
                var o = "ajax error" + (e ? " " + e : "");
                t1.error(new GI(o, S, E));
            };
            S.addEventListener("error", function(e) {
                var t1;
                null === (t1 = null == I ? void 0 : I.error) || void 0 === t1 || t1.call(I, e), D();
            }), S.addEventListener(eA, function(e) {
                var o, r, i = S.status;
                if (i < 400) {
                    null === (o = null == I ? void 0 : I.complete) || void 0 === o || o.call(I);
                    var n = void 0;
                    try {
                        n = T(ZI, e);
                    } catch (e) {
                        return void t1.error(e);
                    }
                    t1.next(n), t1.complete();
                } else null === (r = null == I ? void 0 : I.error) || void 0 === r || r.call(I, e), D(i);
            });
            var P = E.user, M = E.method, k = E.async;
            for(var h in P ? S.open(M, l, k, P, E.password) : S.open(M, l, k), k && (S.timeout = E.timeout, S.responseType = E.responseType), "withCredentials" in S && (S.withCredentials = E.withCredentials), p)p.hasOwnProperty(h) && S.setRequestHeader(h, p[h]);
            return b ? S.send(b) : S.send(), function() {
                S && 4 !== S.readyState && S.abort();
            };
        });
    }("string" == typeof e ? {
        url: e
    } : e);
}, qI.get = function(e, t1) {
    return JI({
        method: "GET",
        url: e,
        headers: t1
    });
}, qI.post = function(e, t1, o) {
    return JI({
        method: "POST",
        url: e,
        body: t1,
        headers: o
    });
}, qI.delete = function(e, t1) {
    return JI({
        method: "DELETE",
        url: e,
        headers: t1
    });
}, qI.put = function(e, t1, o) {
    return JI({
        method: "PUT",
        url: e,
        body: t1,
        headers: o
    });
}, qI.patch = function(e, t1, o) {
    return JI({
        method: "PATCH",
        url: e,
        body: t1,
        headers: o
    });
}, qI.getJSON = function(e, t1) {
    return zI(JI({
        method: "GET",
        url: e,
        headers: t1
    }));
}, qI), QI = "upload", ZI = "download", YI = "loadstart", XI = "progress", eA = "load", tA = Object.prototype.toString;
function oA(e, t1) {
    return tA.call(e) === "[object " + t1 + "]";
}
const rA = pE.getInstance(), iA = (e)=>{
    const { meeting: { encryptedRWC: t1, encryptedGEORWC: o, discardedRwcList: r, meetingOptions: i } } = e;
    let n = [];
    return (null == i ? void 0 : i.isEnableGeoFenceRWC) && o && (null == o ? void 0 : o.length) > 0 ? n = o.filter((e)=>!r.includes(e.rwc)).reduce((e, t1)=>{
        const { dl: o, rwc: r, rwcToken: i } = t1, n = e.find((e)=>e.dl === o);
        if (n) n.items.push({
            rwc: r,
            rwcToken: i
        });
        else {
            const t1 = {
                dl: o,
                items: []
            };
            t1.items.push({
                rwc: r,
                rwcToken: i
            }), e.push(t1);
        }
        return e;
    }, []) : t1 && (n = [
        {
            dl: 0,
            items: Object.keys(t1).map((e)=>({
                    rwc: e,
                    rwcToken: t1[e]
                }))
        }
    ]), n;
}, nA = (e)=>Ye(...e.map((e)=>0 === e.dl ? Ce(e.items) : Qe(e.dl).pipe(Be(()=>Ce(e.items))))), sA = ()=>ot(ip(Ea, 1), ip(Sa, 1), ip(ba, 1)), aA = (e, t1)=>e.pipe(Ot(`${rn}`), vt(t1), tt((e)=>{
        let [, t1] = e;
        return void 0 !== t1.meeting.encryptedRWC || void 0 !== t1.meeting.encryptedGEORWC && t1.meeting.encryptedGEORWC.length > 0;
    }), pt((e)=>{
        let [, o] = e;
        const { meeting: { ts: r, auth: i, meetingNumber: n, meetingOptions: s, meetingId: a, userName: d }, breakoutRoom: u } = o, l = null == s ? void 0 : s.isEnableGeoFenceRWC, c = iA(o);
        if (c.length > 0) {
            const e = {
                serversLength: c.reduce((e, t1)=>e + t1.items.length, 0),
                pingFailedServerList: [],
                pingRwcServerCounts: 0,
                retryCounts: 0
            };
            let o;
            return l && (o = new F, nA(c).subscribe((e)=>{
                var t1;
                return null === (t1 = o) || void 0 === t1 ? void 0 : t1.next(e);
            })), (l ? o : nA(c)).pipe(ht(sA()), mt(()=>{
                const { meeting: { meetingStatus: r, meetingId: i } } = t1.value, n = r === Yn.Initial && !!i && e.pingFailedServerList.length < e.serversLength && e.serversLength > 0;
                return !n && o && o.complete(), n;
            }), gt(()=>{
                if (e.pingRwcServerCounts = e.pingRwcServerCounts + 1, l && e.pingRwcServerCounts === e.serversLength) {
                    const r = 1e3 * Math.floor(5 * Math.pow(2, e.retryCounts));
                    e.retryCounts = e.retryCounts + 1, rA.makeLogger([
                        "Join Meeting Flow"
                    ]).info(`ping rwc retry,current rwc list:${JSON.stringify(iA(t1.value))},retry counts:${e.retryCounts}, ${JSON.stringify({
                        meetingId: a,
                        meetingNumber: aE(n),
                        userName: aE(d)
                    })}`, [
                        "Ping RWC Retry"
                    ]), Qe(r).pipe(ke(()=>{
                        const o = iA(t1.value);
                        return Object.assign(e, {
                            serversLength: o.reduce((e, t1)=>e + t1.items.length, 0),
                            pingFailedServerList: [],
                            pingRwcServerCounts: 0
                        }), o;
                    })).subscribe((e)=>{
                        nA(e).subscribe((e)=>{
                            o.next(e);
                        });
                    });
                }
            }), Be((s)=>{
                const { rwc: c, rwcToken: p } = s, h = ((e, t1, o, r, i, n)=>{
                    const s = {
                        ts: r,
                        auth: i,
                        rwcToken: o,
                        dmz: 1
                    };
                    return n && Object.assign(s, {
                        confID: n
                    }), `https://${e}/wc/ping/${t1}?${new URLSearchParams(s).toString()}`;
                })(c, n, p, r, i, null == u ? void 0 : u.currentRoom.boConfId);
                return JI({
                    url: h,
                    crossDomain: ei(h)
                }).pipe(ht(sA()), Be((e)=>{
                    let t1 = {};
                    return t1 = e.response ? {
                        ...e.response,
                        rwc: c,
                        fromNginx: !1
                    } : {
                        rwc: c,
                        rwg: c,
                        rwcToken: p,
                        fromNginx: !0
                    }, Ce([
                        Po(t1),
                        bo()
                    ]);
                }), rt(()=>{
                    const { pingFailedServerList: r, serversLength: i } = e;
                    return r.push(h), r.length === i ? (l && o && o.complete(), rA.report(`ping rwc error, ${JSON.stringify({
                        meetingId: a,
                        meetingNumber: aE(n),
                        userName: aE(d)
                    })}`, [
                        "Join Meeting Flow",
                        "Ping RWC Error"
                    ], "error"), ep(Sa, {
                        reason: "connection error",
                        errorCode: pi.CommonError
                    }), Ce([
                        ...Wy(t1.value)
                    ])) : ie;
                }));
            }), ct(yn(performance.now())));
        }
        return ie;
    }));
let dA = 0;
const uA = pE.getInstance(), lA = {
    meetingStatus: Yn.Initial,
    isWindowOpen: !1,
    apiKey: "",
    signature: "",
    signatureType: "",
    lang: "en-US",
    tk: "",
    customerKey: "",
    mtkGuid: "",
    pingRWCTimestamp: 0,
    meetingInfoTimestamp: 0,
    passWord: "",
    meetingNumber: 0,
    userName: "",
    userEmail: "",
    sdkUrl: "",
    sdkOrigin: "",
    proxy: 1,
    cv: "",
    meetingId: "",
    tid: "",
    ts: "",
    auth: "",
    sign: "",
    isSupportCallOut: !1,
    tollNumbers: void 0,
    recordingEnable: !1,
    callOutCountry: void 0,
    inviteEmail: "",
    xmppConfig: null,
    isSupportH323: !1,
    h323GatewayInfo: "",
    h323Password: "",
    trackAuth: "",
    isOriginHost: !1,
    isWebinar: !1,
    encryptedRWC: void 0,
    meetingOptions: {},
    meetingTopic: "",
    bLock: !1,
    bHoldUponEntry: !1,
    viewOnly: 0,
    listenOnlyPhone: 0,
    bAllowRaiseHand: !1,
    bAllowAttendeeRename: !1,
    bBroadcast: void 0,
    bAllowPlayChimeForEnterOrExit: !1,
    bIbDisableShare: !1,
    bIbDisableChat: !1,
    bAllowShowCount: !1,
    encryptKey: "",
    bNoHostTimeOut: !1,
    confId: "",
    conId: "",
    e2eEncrypt: !1,
    zoomId: "",
    jid: "",
    xtoken: "",
    groups: void 0,
    svcUrl: "",
    encType: NaN,
    userGUID: "",
    userId: NaN,
    isHost: !1,
    isCoHost: !1,
    participantID: 0,
    isOnHold: !1,
    isMeetingReset: !1,
    bRecord: !1,
    audioVideoBeforeOnHold: void 0,
    region: void 0,
    network: void 0,
    joinMeetingTimeStamp: 0,
    activeAppInfo: void 0,
    recordingDisclaimerForRecorder: {},
    recordingDisclaimer: {},
    ccUrl: "",
    sessionIdleTimeoutMins: 40,
    reportDomain: "",
    isAudioBridgeEnabled: !0,
    discardedRwcList: [],
    sharePronounType: void 0,
    stayAwake: !1,
    wrInfo: {},
    meetingInfo: {},
    isNewJoinFlow: !1,
    gatewayUserList: [],
    logConfig: "",
    logEncryptionPubKey: "",
    failover: {
        count: 0,
        isCurrentFailoverRecorded: !1,
        reason: -1,
        interval: 0,
        joinMeetingSuccessTimestamp: 0,
        sequence: ""
    },
    enableLongPollingCheckStart: !1,
    rsPwd: "",
    chatModerationPolicy: {},
    isAlternativeHost: !1,
    isAssistant: !1,
    isRlbTP: !1,
    isRlbTPReady: !1
}, cA = So({
    [`${cn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        o.customerKey = e.customerKey || o.customerKey || "", Object.assign(e, o), e.meetingStatus = Yn.Initial;
    }),
    [`${pn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        o.customerKey = e.customerKey || o.customerKey || "", Object.assign(e, o);
    }),
    [`${hn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isWindowOpen = o;
    }),
    [`${mn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        o.useSDK ? e.signatureType = "sdk" : e.signatureType = "api", e.apiKey = o.apiKey, e.signature = o.signature, e.lang = o.language;
    }),
    [`${gn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.ztk = o;
    }),
    [`${vn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.zsk = o;
    }),
    [`${fn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.tk = o.tk, e.mtkGuid = o.mtkGuid;
    }),
    [`${yn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.pingRWCTimestamp = o;
    }),
    [`${Wn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.meetingInfoTimestamp = o;
    }),
    [`${Sn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.confId = o.confID, e.conId = o.conID, e.e2eEncrypt = o.e2eEncrypt, e.meetingNumber = parseInt(o.mn, 10), e.zoomId = o.zoomID, e.meetingStatus = Yn.Joined, e.jid = o.jid, e.xtoken = o.xtoken, e.groups = o.groups, e.svcUrl = o.svcUrl, e.encType = o.encType, e.userGUID = o.userGUID, e.userId = o.userID, e.role = o.role, e.participantID = o.participantID, e.reportDomain = o.reportDomain, e.abToken = o.ABtoken, e.supportLocalAB = !!o.supportLocalAB, e.mediasdkConfig = o.mediasdkConfig, o.enableWebTransport && (e.enableWebtransport = o.enableWebTransport, e.webtransportPort = o.WebTransportPort);
    }),
    [`${bn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        if (o.gatewayUser) {
            var r;
            const { userId: t1, sn: n } = o.gatewayUser, s = null === (r = e.gatewayUserList) || void 0 === r ? void 0 : r.find((e)=>e.userId === t1);
            var i;
            s ? s.sn = n : null === (i = e.gatewayUserList) || void 0 === i || i.push(o.gatewayUser);
        } else Object.assign(e, o);
    }),
    [`${In}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isHost = o;
    }),
    [`${An}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isCoHost = o;
    }),
    [`${Cn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isOnHold = o;
    }),
    [`${_n}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isMeetingReset = o;
    }),
    [`${Rn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.audioVideoBeforeOnHold = o;
    }),
    [`${wn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.currentUserAudioBeforeReset = o;
    }),
    [`${Tn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isCurrentUserMutedBeforeReset = o;
    }),
    [`${On}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.meetingStatus = o;
    }),
    [`${Dn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.region = o.region, e.network = o.network;
    }),
    [`${Pn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isCurrentUserStartVideoBeforeReset = o;
    }),
    [`${Mn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.joinMeetingTimeStamp = o;
    }),
    [`${kn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.activeAppInfo = o;
    }),
    [`${Ln}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.idleStartTime = o;
    }),
    [`${Nn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.sessionIdleTimeoutMins = o;
    }),
    [`${Vn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAudioBridgeEnabled = o;
    }),
    [`${Un}`]: TI((e, t1)=>{
        var o;
        let { payload: r } = t1;
        const i = null === (o = e.encryptedGEORWC) || void 0 === o || null === (o = o.find((e)=>e.rwc === r)) || void 0 === o ? void 0 : o.dc;
        if (i) {
            var n;
            const t1 = null === (n = e.encryptedGEORWC) || void 0 === n ? void 0 : n.filter((e)=>e.dc === i);
            t1 && e.discardedRwcList.some((e)=>(null == t1 ? void 0 : t1.findIndex((t1)=>t1.rwc === e)) >= 0) && e.discardedRwcList.push(...t1.map((e)=>e.rwc)), e.discardedRwcList.push(r);
        }
    }),
    [`${jn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.sharePronounType = o;
    }),
    [`${xn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.stayAwake = o;
    }),
    [`${Bn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.failover.joinMeetingSuccessTimestamp = o;
    }),
    [`${Fn}`]: TI((e)=>{
        Object.assign(e.failover, {
            ...lA.failover,
            count: e.failover.count,
            joinMeetingSuccessTimestamp: e.failover.joinMeetingSuccessTimestamp
        });
    }),
    [`${Hn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { count: r, reason: i, interval: n, sequence: s } = o;
        e.failover.count = r, e.failover.reason = i, e.failover.interval = n, e.failover.isCurrentFailoverRecorded = !0, e.failover.sequence = s;
    }),
    [`${$n}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.quicklyLeave = o;
    }),
    [`${Gn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isEnableZmkFromRWG = o;
    }),
    [`${Kn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isRlbTP = o;
    }),
    [`${zn}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isRlbTPReady = o;
    }),
    [`${En}`]: (e, t1)=>{
        let { payload: o } = t1;
        const { isFailover: r } = o, i = {
            isMeetingReset: !0,
            apiKey: e.apiKey,
            signatureType: e.signatureType,
            signature: e.signature,
            lang: e.lang,
            proxy: 1,
            stayAwake: e.stayAwake
        };
        return r && Object.assign(i, {
            currentUserAudioBeforeReset: e.audioVideoBeforeOnHold ? e.audioVideoBeforeOnHold.audio : o.audio,
            isCurrentUserMutedBeforeReset: e.audioVideoBeforeOnHold ? e.audioVideoBeforeOnHold.muted : o.muted,
            isCurrentUserStartVideoBeforeReset: e.audioVideoBeforeOnHold ? e.audioVideoBeforeOnHold.video : o.video,
            meetingNumber: e.meetingNumber,
            userName: e.userName,
            passWord: e.passWord,
            userEmail: e.userEmail,
            sdkUrl: e.sdkUrl,
            sdkOrigin: e.sdkOrigin,
            cv: e.cv,
            zsk: e.zsk,
            ztk: e.ztk,
            idleStartTime: e.idleStartTime,
            sessionIdleTimeoutMins: e.sessionIdleTimeoutMins,
            customerKey: e.customerKey,
            failover: e.failover,
            stayAwake: e.stayAwake,
            quicklyLeave: e.quicklyLeave
        }), {
            ...lA,
            ...i
        };
    }
}, lA), pA = {
    meetingFailoverReportEpic0: (e, t1)=>e.pipe(Ot(`${cn}`), pt(()=>{
            const o = 0 === t1.value.meeting.failover.joinMeetingSuccessTimestamp && !!is.get(ns.WebclientZoomId);
            return e.pipe(Ot(`${Sn}`), it(1), Be(()=>{
                const e = [], { count: r, sequence: i } = is.get(ns.WebclientFailoverCount) || {};
                let { meeting: { failover: { count: n, reason: s, interval: a } } } = t1.value;
                const { meeting: { pingRWCTimestamp: d } } = t1.value;
                if (o) {
                    n = r + 1, s = es.RefreshPage, a = 0;
                    const t1 = i ? `${i}-${s}` : `${s}`;
                    is.set(ns.WebclientFailoverCount, {
                        count: n,
                        sequence: t1
                    }, os.SessionStorage), e.push(Hn({
                        count: n,
                        reason: s,
                        interval: a,
                        sequence: t1
                    }));
                }
                const u = performance.now();
                let l = `WCL_M, JMCT(${u - d})`;
                return n > 0 && s !== es.NormalCase && (l = `${l},FAILOVER(${n},${s},${(a / 1e3).toFixed(1)})`), FI.sendRWGConnectionPerformance(l), e.push(Fn(), Bn(u)), Ce(e);
            }));
        })),
    meetingFailoverReportEpic1: (e, t1)=>e.pipe(Ot(`${nn}`), Be((e)=>{
            const { payload: o } = e, { meeting: { failover: { joinMeetingSuccessTimestamp: r, isCurrentFailoverRecorded: i }, userGUID: n, userId: s, meetingId: a } } = t1.value, d = [];
            if (!i) {
                let { count: e, sequence: t1 } = is.get(ns.WebclientFailoverCount) || {};
                t1 = t1 ? `${t1}-${o}` : `${o}`, o !== es.NormalCase && (e += 1, is.set(ns.WebclientFailoverCount, {
                    count: e,
                    sequence: t1
                }, os.SessionStorage));
                const i = performance.now() - r;
                d.push(Hn({
                    reason: o,
                    count: e,
                    interval: i,
                    sequence: t1,
                    userGUID: n,
                    userId: s,
                    meetingId: a
                }));
            }
            return Ce(d);
        }))
}, hA = {
    sessionIdleEpic0: (e, t1)=>e.pipe(Ot(`${Sn}`), vt(t1), tt((e)=>{
            let [, t1] = e;
            return void 0 !== t1.meeting.zlkJwtToken;
        }), pt(()=>(xI && xI.complete(), xI = new U, BI = Ze(6e4).pipe(ke(()=>performance.now())).subscribe(xI), xI.pipe(ke((e)=>un(e)))))),
    sessionIdleEpic1: (e)=>e.pipe(Ot(`${Io}`)).pipe(gt(()=>{
            xI && (xI.complete(), BI.unsubscribe());
        }), dt(ie)),
    sessionIdleEpic2: (e, t1)=>e.pipe(Ot(`${un}`), vt(t1), Be((e)=>{
            var t1;
            let [o, r] = e;
            const { meeting: { idleStartTime: i, sessionIdleTimeoutMins: n, isOriginHost: s, isWebinar: a }, participants: { attendeesList: d, xmppAttendeeList: u }, recording: l, breakoutRoom: c } = r, p = o.payload, h = [];
            if (1 !== d.length || a && 0 !== u.length || (null == c || null === (t1 = c.currentRoom) || void 0 === t1 ? void 0 : t1.status) === Jp.InRoom || (null == l ? void 0 : l.cmrStatus) === za.Start) h.push(Ln(void 0));
            else if (i) {
                const e = s && Hp(d[0].userRole) ? n : 40;
                p - i > 60 * e * 1e3 && (console.warn(`No active for ${e} minutes, will end the session.`), jI.report(`Session idle timeout(${e} minutes), end the session automatically!`, [
                    "Join Meeting Flow",
                    "Session idle"
                ], "warn"), h.push(dn()), Qe(500).subscribe(()=>{
                    sp();
                }));
            } else h.push(Ln(p));
            return Ce(h);
        })),
    sessionIdleEpic3: (e, t1)=>e.pipe(Ot(`${Co}`), tt((e)=>[
                Ds,
                Ps
            ].includes(e.payload.evt) && void 0 !== t1.value.meeting.idleStartTime), Ee(ee), Be(()=>{
            var e;
            const { participants: { attendeesList: o, xmppAttendeeList: r }, recording: i, breakoutRoom: n } = t1.value, s = [];
            return (o.length > 1 || r.length > 0 || (null == i ? void 0 : i.cmrStatus) === za.Start || (null == n || null === (e = n.currentRoom) || void 0 === e ? void 0 : e.status) === Jp.InRoom) && s.push(Ln(void 0)), Ce(s);
        })),
    sessionIdleEpic4: (e)=>e.pipe(Ot(`${sn}`, `${dn}`), st(Ln(void 0)))
}, mA = {
    meetingMainEpics0: (e, t1)=>ir(e, 0).pipe(gt((e)=>{
            var o;
            if ("READY" === (null === (o = e.payload.body) || void 0 === o ? void 0 : o.status)) {
                const { meeting: { zlkJwtToken: e, signatureType: o, sign: r, passWord: i, isHost: n, isOriginHost: s, ztk: a, zsk: d, tk: u, userEmail: l }, breakoutRoom: c } = t1.value, p = e ? {
                    zlkJwtToken: e
                } : {
                    signType: o,
                    sign: r
                };
                if (i && "" !== i && (e ? Object.assign(p, {
                    mpwd: Hr(i)
                }) : n && s || Object.assign(p, {
                    mpwd: i
                })), (null == c ? void 0 : c.currentRoom.status) === Jp.Joining) {
                    const { currentRoom: { boId: e, boConfId: t1, boToken: o } } = c;
                    e && t1 && o && Object.assign(p, {
                        botk: o
                    });
                }
                if (!e) {
                    a && Object.assign(p, {
                        zak: a
                    }), (sessionStorage.getItem(ns.WebclientZsk) || d) && Object.assign(p, {
                        zak: d
                    }), u && Object.assign(p, {
                        tk: u
                    });
                    const e = is.get(ns.WebclientWebinarToken);
                    void 0 !== e && Object.assign(p, {
                        tk: e
                    });
                    const t1 = sessionStorage.getItem(ns.WebclientRecordingToken);
                    t1 && Object.assign(p, {
                        localRecordToken: t1
                    }), l && Object.assign(p, {
                        email: l
                    });
                }
                LI.sendLaunchParams(p);
                const h = is.get(ns.WebclientMeetingToken);
                h && LI.joinMeeting(h);
            }
        }), dt(ie)),
    meetingMainEpics1: (e, t1)=>{
        return ir(e, Ls).pipe(vt(t1), (o = (e)=>{
            let [t1, o] = e;
            const { payload: { body: { res: r, userID: i, zoomID: n, mn: s, participantID: a, meetingtoken: d, role: u } } } = t1, { meeting: { userEmail: l, userName: c, isMeetingReset: p, apiKey: h, zsk: m, signatureType: g } } = o;
            if (ui.Success === r) {
                const { WebclientParticipantId: e, WebclientZoomId: o, WebclientUserEmail: r, WebclientUserName: v, WebclientMeetingToken: f } = ns;
                is.set(o, n, os.SessionStorage), is.set(e, a, os.SessionStorage), l && is.set(r, l, os.SessionStorage), is.set(v, c, os.SessionStorage), d && is.set(f, d, os.SessionStorage), m && LI.sendSdkKeyToMonitor(g, h, i);
                const y = [
                    Sn(t1.payload.body),
                    Mn(performance.now())
                ];
                return p && y.push(_n(!1)), (u & xp.Owner) === xp.Owner && (ep(Sa, {
                    reason: "dont support assisnt join through widget",
                    errorCode: -1
                }), LI.leaveMeeting()), ep(ya, {
                    meetingNumber: s
                }), Ce(y);
            }
            if (ui.MeetingLocked === r) ep(Sa, gi(r));
            else if (ui.UserFull === r) ep(Sa, Object.assign({}, gi(r), {
                lmUrl: t1.payload.body.lmURL
            }));
            else if (ui.MeetingIsOver === r) ep(Sa, gi(r));
            else if (ui.MMRIBReject === r) ep(Sa, gi(r));
            else if (ui.MMRConfParticipantExists === r) ep(Sa, gi(r));
            else if ([
                ui.UserHasBeenRemoved,
                ui.WebinarBlockedEmail
            ].includes(r)) ep(Sa, gi(r));
            else if (ui.MeetingNotStarted === r) {
                var v;
                const e = gi(r), { meeting: { meetingNumber: t1, passWord: i, userName: n, userEmail: s, inviteEmail: a, meetingTopic: d, region: u, network: l, userId: c, lang: p, meetingId: h, participantID: m, wrInfo: g, meetingInfo: f, isNewJoinFlow: y, enableLongPollingCheckStart: S, tid: b, signature: E, rsPwd: I } } = o;
                Object.assign(e, {
                    meetingInfo: {
                        meetingNumber: t1,
                        password: i,
                        userName: n,
                        userEmail: s,
                        inviteEmail: a,
                        meetingTopic: d,
                        region: u,
                        network: l,
                        userId: c,
                        lang: p,
                        webEndpoint: yr(),
                        meetingId: h,
                        participantId: m,
                        wrInfo: Object.assign({}, g, {
                            isNew: y
                        }),
                        scheduleInfo: f,
                        enableLongPollingCheckStart: S,
                        rid: zy(b),
                        role: Number(null === (v = ti(E)) || void 0 === v ? void 0 : v.role),
                        rsPwd: I
                    }
                }), ep(Sa, e);
            } else ep(Sa, gi(r));
            return Ce(Wy(o, !1));
        }, T(pt((e, t1)=>o(e) || ie))));
        "TURBOPACK unreachable";
        var o;
    },
    meetingMainEpics2: (e, t1)=>ir(e, Ps).pipe(vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { payload: { body: r } } = t1, { meeting: { zoomId: i, encType: n, gcmSessinKey: s } } = o;
            if (void 0 !== (null == r ? void 0 : r.encryptKey) && ws.init(i, r.encryptKey, n), void 0 !== (null == r ? void 0 : r.gatewayKey)) {
                const e = la.getInstance(), [, t1, o] = r.gatewayKey.split(".");
                e.sendUserNodeList([
                    {
                        userid: Number(t1),
                        sn: o && Kr(o)
                    }
                ], s);
            }
            return ep(Aa, r), bn(r);
        })),
    meetingMainEpics3: (e, t1)=>ir(e, 7939).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { payload: { body: r } } = t1;
            if (void 0 !== r.reason) {
                if (li.Reconnect === r.reason) return ci.WaitingRoomFailover === r.subReason ? ep(ba, {
                    reason: qn.OnHold
                }) : ep(ba, {
                    reason: qn.Failover
                }), _e(nn(es.NormalCase));
                li.KickedByHost === r.reason ? ep(Ea, {
                    reason: "kicked by host"
                }) : [
                    li.EndByHost,
                    li.EndByNone,
                    li.EndByAdmin,
                    li.EndByHostStartAnotherMeeting
                ].includes(r.reason) ? ep(Ea, {
                    reason: "ended by host"
                }) : li.FreeMeetingTimeout === r.reason ? ep(Ea, {
                    reason: "free meeting ended"
                }) : [
                    li.DuplicateSession,
                    li.MeetingTransfer
                ].includes(r.reason) && ep(Ea, {
                    reason: "duplicated session"
                });
            }
            return o.meeting.isMeetingReset ? ie : Ce(Wy(o, !1));
        })),
    meetingMainEpics4: (e, t1)=>e.pipe(Ot(`${nn}`), vt(t1), Be((e)=>{
            let [, t1] = e;
            const o = Wy(t1, !0);
            let r;
            if (t1.meeting.zlkJwtToken) {
                const e = function(e) {
                    if (e) {
                        const { meeting: { topic: t1, passWord: o, userName: r, zlkJwtToken: i, lang: n, cv: s, customerKey: a } } = e;
                        return {
                            topic: t1,
                            passWord: o,
                            userName: r,
                            zlkJwtToken: i,
                            lang: n,
                            cv: s,
                            customerKey: a
                        };
                    }
                    return null;
                }(t1), o = {
                    topic: null == e ? void 0 : e.topic,
                    password: null != e && e.passWord ? encodeURIComponent(null == e ? void 0 : e.passWord) : "",
                    userName: null == e ? void 0 : e.userName,
                    zlk: null == e ? void 0 : e.zlkJwtToken,
                    lang: null == e ? void 0 : e.lang,
                    cv: null == e ? void 0 : e.cv,
                    customerKey: null == e ? void 0 : e.customerKey
                };
                r = _e(on(o)).pipe(at(1e3));
            } else {
                const e = function(e) {
                    var t1;
                    const { meeting: { apiKey: o, signature: r, signatureType: i, meetingNumber: n, userName: s, lang: a, passWord: d, userEmail: u, sdkUrl: l, sdkOrigin: c, proxy: p, cv: h, ztk: m, zsk: g, tk: v } } = e;
                    let f = m || sessionStorage.getItem(ns.WebclientZtk), y = g || sessionStorage.getItem(ns.WebclientZsk);
                    const S = 1 === Number(null === (t1 = ti(r)) || void 0 === t1 ? void 0 : t1.role);
                    return S || (f = y, y = ""), {
                        apiKey: o,
                        signature: r,
                        signatureType: i,
                        meetingNumber: n,
                        userName: s,
                        lang: a,
                        passWord: d ? encodeURIComponent(d) : "",
                        userEmail: u,
                        sdkUrl: l,
                        sdkOrigin: c,
                        proxy: p,
                        cv: h,
                        ztk: f,
                        zsk: y,
                        tk: v || sessionStorage.getItem(ns.WebclientTk),
                        ulsm: S && y ? 1 : 0
                    };
                }(t1);
                r = _e(tn(e)).pipe(at(1e3));
            }
            return He(Ce(o), r);
        })),
    meetingMainEpics5: (e)=>ar(e, 7940).pipe(gt((e)=>{
            ep("MEETING_HOST_CHANGE_INDICATION", e.payload.body.bHost);
        }), ke((e)=>In(e.payload.body))),
    meetingMainEpics6: (e)=>ar(e, 7941).pipe(gt((e)=>{
            ep("MEETING_COHOST_CHANGE_INDICATION", e.payload.body.bCoHost);
        }), ke((e)=>An(e.payload.body))),
    meetingMainEpics7: (e)=>ar(e, 7945).pipe(gt((e)=>{
            const { payload: { body: { opt: t1 } } } = e;
            is.set(ns.WebclientOpt, t1, os.SessionStorage);
        }), dt(ie)),
    meetingMainEpics8: (e, t1)=>ir(e, 7942).pipe(gt((e)=>{
            const { payload: { body: { bHold: t1 } } } = e;
            is.set(ns.WebclientIsOnHold, t1 ? 1 : 0, os.SessionStorage), ep(Ia, t1);
        }), vt(t1), Be((e)=>{
            let [t1, o] = e;
            const r = [
                Cn(t1.payload.body.bHold)
            ];
            if (t1.payload.body.bHold) {
                const e = sh(o);
                if (e) {
                    r.push(Rn({
                        audio: e.audio,
                        video: e.bVideoOn,
                        muted: e.muted
                    }));
                    const t1 = fE(la.getInstance());
                    if ("computer" === e.audio && (t1.leaveComputerAudio(), LI.joinOrLeaveVoip(!1)), e.bVideoOn && t1.stopCaptureVideo(), e.sharerOn && (LI.stopSharing(e.userId), t1.stopDesktopSharing(), r.push(ym(fd.End))), o.video && o.video.subscribedVideoList.length > 0 && o.video.subscribedVideoList.forEach((e)=>{
                        LI.unsubscribeVideo(e);
                    }), o.share && o.share.isReceiveSharing) {
                        const e = o.share.activeNodeId;
                        o.share.remoteControlledUserList.length > 0 && (o.share.remoteControlledUserList.forEach((e)=>{
                            LI.sharingRequestRemoteControl(e, !1);
                        }), lS(o) && t1.stopRemoteControl()), LI.unsubscribeSharing(e), t1.stopRenderSharing();
                    }
                }
            }
            return Ce(r);
        })),
    meetingMainEpics9: (e)=>ir(e, 7954).pipe(ke((e)=>Dn(e.payload.body))),
    meetingMainEpics10: (e)=>ir(e, 4216).pipe(gt((e)=>{
            ep("MEETING_CLAIM_HOST_KEY_RESPONSE", e.payload.body.bresult);
        }), dt(ie)),
    meetingMainEpics11: (e, t1)=>e.pipe(Ot(`${sn}`, `${dn}`), vt(t1), Be((e)=>{
            let [t1, o] = e;
            const r = fh(o), { socket: { zoomSocketStatus: i }, meeting: { meetingId: n } } = o;
            return i === yh.Connected && (t1.type === `${sn}` ? LI.leaveMeeting(r) : t1.type === `${dn}` && LI.endMeeting()), n && ep(Ea, {}), Ce(Wy(o, !1));
        })),
    meetingMainEpics12: (e, t1)=>e.pipe(Ot(`${an}`), vt(t1), Be((e)=>{
            let [t1, o] = e;
            if (t1.type === `${an}` && o.meeting.meetingNumber && !o.meeting.zlkJwtToken) {
                const e = {
                    mn: o.meeting.meetingNumber.toString(),
                    name: o.meeting.userName,
                    customerKey: o.meeting.customerKey ? Hr(o.meeting.customerKey) : ""
                }, { jbhLeave: t1 } = {
                    jbhLeave: `https://${hr}/wc/jbhLeave`
                }, r = `${t1}/?${new URLSearchParams(e).toString()}`;
                fetch(r, {
                    method: "POST",
                    headers: {
                        "Content-type": "application/json; charset=UTF-8"
                    }
                });
            }
            return ie;
        })),
    meetingMainEpics13: (e)=>ir(e, 2).pipe(gt(()=>{
            console.warn("Upgrade to latest version to optimize meeting experience");
        }), dt(ie)),
    meetingMainEpics14: (e)=>ir(e, 1).pipe(gt((e)=>{
            const { payload: { body: { upgradeVersion: t1 } } } = e, o = gi(1e4);
            if (o && o.reason) {
                const e = o.reason.replace(/{(\d+)}/g, ()=>t1);
                o.reason = e;
            }
            ep(Sa, o);
        }), dt(ie)),
    meetingMainEpics15: (e)=>ir(e, 4265).pipe(ke((e)=>{
            const { payload: { body: t1 } } = e, { nShareType: o } = t1;
            return ep(Ca, {
                userSharePronounType: o
            }), jn(o);
        })),
    meetingMainEpics16: (e)=>ir(e, 4128).pipe(gt((e)=>{
            const { payload: { body: { meetingtoken: t1 } } } = e, { WebclientMeetingToken: o } = ns;
            t1 && is.set(o, t1, os.SessionStorage);
        }), dt(ie)),
    meetingMainEpics17: (e, t1)=>e.pipe(Ot(`${Sn}`), tt(()=>!!t1.value.meeting.quicklyLeave), pt(()=>ze(window, "beforeunload").pipe(gt(()=>{
                LI.leaveMeeting();
            }), dt(ie)))),
    meetingMainEpics18: (e, t1)=>ir(e, 8025).pipe(tt((e)=>!!e.payload.body.Zmk && !!t1.value.meeting.isEnableZmkFromRWG), ke((e)=>{
            const { payload: { body: { Zmk: t1 } } } = e;
            return bn({
                zmk: t1
            });
        })),
    meetingMainEpics19: (e, t1)=>e.pipe(Ot(`${cn}`), Be((e)=>{
            const { payload: { mediaSDKPath: o } } = e, { media: { skipJsMedia: r, patchJsMedia: i, assetsPath: n } } = t1.value, s = `${!r && i && di(n) && o ? oi(o) : n}/tp.min.js`;
            return Ce(void 0 === window.ZoomTPModule || "function" != typeof window.ZoomTPModule.ZoomTPWebSocket ? new Promise((e, t1)=>lr(s, ()=>e(""), ()=>t1())) : Promise.resolve("")).pipe(Be(()=>{
                const { logger: e } = t1.value, o = e ? pE.getInstance().makeLogger([
                    "TP MODULE"
                ]) : void 0;
                return Ce(window.ZoomTPModule.initTPModule({
                    options: "",
                    logInstance: o
                }).then(()=>(ep(_a, !0), zn(!0))).catch(()=>(ep(_a, !1), Kn(!1))));
            }), rt(()=>(setTimeout(()=>{
                    pE.getInstance().report(`Unable to load tp.min.js,url:${s}`, [
                        "TP MODULE"
                    ], "error");
                }, 5e3), ep(_a, !1), Ce([
                    Kn(!1)
                ]))), ct(Kn(!0)));
        }))
}, gA = rr(mA, {
    wakeLockEpic0: (e, t1)=>e.pipe(Ot(`${Sn}`), vt(t1), tt((e)=>{
            let [, t1] = e;
            return !!t1.meeting.stayAwake;
        }), gt(async ()=>{
            try {
                const { isSafari: e, isIOSMobile: t1 } = ms;
                HI && HI.release().then(()=>{
                    HI = null;
                }), "wakeLock" in navigator && ((e || t1) && await Te(ot(ze(document, "click").pipe(it(1)), ze(document, "touchend").pipe(it(1)))), HI = await navigator.wakeLock.request("screen"), HI.addEventListener("release", ()=>{}));
            } catch (e) {}
        }), pt(()=>ze(document, "visibilitychange").pipe(Be(async ()=>{
                if ("visible" === document.visibilityState) {
                    const { isSafari: e, isIOSMobile: t1 } = ms;
                    HI && HI.release().then(()=>{
                        HI = null;
                    }), "wakeLock" in navigator && ((e || t1) && await Te(ot(ze(document, "click").pipe(it(1)), ze(document, "touchend").pipe(it(1)))), HI = await navigator.wakeLock.request("screen"));
                } else HI && HI.release().then(()=>{
                    HI = null;
                });
            }), dt(ie)))),
    wakeLockEpic1: (e)=>e.pipe(Ot(`${Io}`)).pipe(gt(()=>{
            HI && HI.release().then(()=>{
                HI = null;
            });
        }), dt(ie))
}, pA, hA, {
    meetingInfoEpic: (e, t1)=>e.pipe(Ot(`${on}`), pt((o)=>{
            const r = Object.assign({}, o.payload, {
                password: Hr(o.payload.password),
                topic: Hr(o.payload.topic)
            }), { videoSDKUrl: i } = {
                meetingSDKUrl: `https://${hr}/api/v1/wc/info`,
                videoSDKUrl: `https://${hr}/wc/lsdk`
            };
            return (function(e, t1) {
                let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "zoomsdkjsonpcallback";
                return new D((r)=>{
                    dA++;
                    const i = `${o}${dA}`, n = document.createElement("script");
                    Object.keys(t1).forEach((e)=>(void 0 === t1[e] || null === t1[e]) && delete t1[e]), n.src = `${e}?${new URLSearchParams(Object.assign(t1, {
                        callback: i
                    })).toString()}`, n.async = !0, n.onerror = (e)=>r.error(e), document.getElementsByTagName("head")[0].appendChild(n), window[i] = (e)=>{
                        n.parentNode && n.parentNode.removeChild(n), delete window[i], r.next(e), r.complete();
                    };
                });
            })(i, r).pipe(ht(e.pipe(Ot(`${sn}`), it(1))), rt((e)=>_e({
                    status: !1,
                    result: e.toString(),
                    errorCode: -3e3
                })), Be((e)=>{
                const [r, i] = (n = _e(e), [
                    tt(s = (e)=>!0 === e.status && void 0 !== e.result, a)(ye(n)),
                    tt(et(s, a))(ye(n))
                ]);
                var n, s, a;
                return i.subscribe((e)=>{
                    uA.report(`get meeting info error, ${JSON.stringify(e)}`, [
                        "Join Meeting Flow",
                        "Get Meeting Info Error"
                    ], "error"), e.state || (3e3 === e.errorCode && "Meeting password is incorrect" === e.errorMessage ? ep(Sa, {
                        errorCode: pi.WrongPasscode,
                        reason: "Incorrect passcode."
                    }) : 3e3 === e.errorCode && "The role type error" === e.errorMessage ? ep(Sa, {
                        errorCode: pi.RoleTypeMissing,
                        reason: "Role type error"
                    }) : -3e3 === e.errorCode ? ep(Sa, {
                        errorCode: pi.CommonError,
                        reason: "connection error"
                    }) : 3e3 === e.errorCode ? ep(Sa, {
                        reason: e.errorMessage,
                        errorCode: pi.CommonError
                    }) : 300 === e.errorCode ? ep(Sa, {
                        reason: "This account does not exist or does not belong to you",
                        errorCode: pi.CommonError
                    }) : 124 === e.errorCode && "Parse lite sdk topic and pwd fail" === e.errorMessage ? ep(Sa, {
                        reason: "Topic is invalid",
                        errorCode: pi.CommonError
                    }) : 124 === e.errorCode && "The java web token is expired or more than 2 days or ineffective." === e.errorMessage ? ep(Sa, {
                        reason: "The token has expired, is over 2 days old, or is ineffective.",
                        errorCode: pi.CommonError
                    }) : 124 === e.errorCode && ep(Sa, {
                        reason: "Verify JWT failed",
                        errorCode: pi.CommonError
                    }));
                }), r.pipe(Jy((e)=>{
                    if (!0 === e.status) {
                        const { result: { mid: i, websdkClientFeatureOptions: n, showRecommendVersion: s } } = e;
                        is.init(i);
                        const a = ((e, t1)=>{
                            if (e.result) {
                                const { result: { mn: o, ts: r, auth: i, track_auth: n, mid: s, tid: a, encryptedRWC: d, encryptedGEORWC: u, user_identity: l, meetingOptions: c, can_recording: p, wcXMPPConfig: h, call_out_country_json: m, isOriginalHost: g, support_call_out: v, liveTranscription: f, logConfig: y, logEncryptionPubKey: S, toll_numbers_json: b, h323Password: E, liveStreamInfo: I, rc_auto_delete: A, jwt_rc: C, op_rc: _, mediaSDKVersion: R, mediaSDKPathPrefix: w, zmk: T, fileTransfer: O, fileServerDomain: D, accountId: P } } = e, { lang: M, password: k, topic: L, zlk: N, cv: V, userName: U } = t1;
                                return {
                                    meetingNumber: o,
                                    meetingId: s,
                                    tid: a,
                                    ts: r,
                                    auth: i,
                                    passWord: k,
                                    trackAuth: n,
                                    customerKey: l,
                                    encryptedRWC: JSON.parse(d || "{}"),
                                    encryptedGEORWC: JSON.parse(u || "{}"),
                                    meetingOptions: JSON.parse(c || "{}"),
                                    recordingEnable: "1" === p,
                                    topic: L,
                                    userName: is.get(ns.WebclientUserName) || U,
                                    cv: V,
                                    zlkJwtToken: N,
                                    xmppConfig: JSON.parse(h || "{}"),
                                    callOutCountry: JSON.parse(m || "{}"),
                                    lang: M,
                                    isOriginHost: g,
                                    isSupportCallOut: "1" === v,
                                    liveTranscription: JSON.parse(f || "{}"),
                                    logConfig: y,
                                    logEncryptionPubKey: S,
                                    tollNumbers: void 0 === b ? void 0 : JSON.parse(b),
                                    h323Password: E,
                                    liveStreamInfo: JSON.parse(I || "{}"),
                                    rcAutoDelete: A,
                                    jwtRc: C,
                                    opRc: _,
                                    mediaSDKPath: R && w ? `${oi(w)}/${R}` : void 0,
                                    zmk: T,
                                    fileTransfer: JSON.parse(O || "{}"),
                                    fileServerDomain: D,
                                    accountId: P
                                };
                            }
                            return e;
                        })(e, o.payload);
                        var r;
                        s && (null == o || null === (r = o.payload) || void 0 === r || r.lang, console.log("Update VideoSDK-Web to the latest version to optimize meeting experience", "https://developers.zoom.us/docs/video-sdk/web/"));
                        const d = [
                            _e(cn(a)),
                            tr(aA, t1, rn())
                        ], u = ((e)=>{
                            const t1 = [];
                            if (e) {
                                const o = e.split("").reverse();
                                Object.keys(Xn).filter((e)=>/M:\d+(,\d+)*;V:\d+(,\d+)*/.test(Xn[e])).forEach((e)=>{
                                    const r = Xn[e];
                                    let [i, n] = r.split(";");
                                    i.startsWith("V:") && ([i, n] = [
                                        n,
                                        i
                                    ]);
                                    const s = n.slice(2).split(",").map((e)=>o[Number(e) - 1]).reverse().join(""), a = parseInt(s, 16), d = Ky[r];
                                    d && (Array.isArray(d) ? d : [
                                        d
                                    ]).forEach((e)=>{
                                        const o = e.mask ? (a & e.mask) > 0 : a;
                                        t1.push(_e(e.action(o)));
                                    });
                                });
                            }
                            return t1;
                        })(n);
                        u.length > 0 && d.unshift(...u);
                        const l = ((e)=>{
                            const t1 = [];
                            if (e) {
                                const r = e.split("").reverse(), i = [];
                                ts.forEach((e)=>{
                                    var t1;
                                    const [o, n] = e.split("-"), s = Number(n) - 1;
                                    i.length < s && (i.length = s + 1), i[s] = null !== (t1 = r[Number(o) - 1]) && void 0 !== t1 ? t1 : "0";
                                });
                                for(let e = 0; e < i.length; e++){
                                    var o;
                                    i[e] = null !== (o = i[e]) && void 0 !== o ? o : "0";
                                }
                                t1.push(_e(Xo(i.reverse().join(""))));
                            }
                            return t1;
                        })(n);
                        return l.length > 0 && d.unshift(...l), He(...d);
                    }
                }));
            }), ct(Wn(performance.now())));
        })),
    pingRWCEpic: aA
});
function vA(e) {
    for(var t1 = 1; t1 < arguments.length; t1++){
        var o = arguments[t1];
        for(var r in o)e[r] = o[r];
    }
    return e;
}
var fA = function e(t1, o) {
    function r(e, r, i) {
        if ("undefined" != typeof document) {
            "number" == typeof (i = vA({}, o, i)).expires && (i.expires = new Date(Date.now() + 864e5 * i.expires)), i.expires && (i.expires = i.expires.toUTCString()), e = encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var n = "";
            for(var s in i)i[s] && (n += "; " + s, !0 !== i[s] && (n += "=" + i[s].split(";")[0]));
            return document.cookie = e + "=" + t1.write(r, e) + n;
        }
    }
    return Object.create({
        set: r,
        get: function(e) {
            if ("undefined" != typeof document && (!arguments.length || e)) {
                for(var o = document.cookie ? document.cookie.split("; ") : [], r = {}, i = 0; i < o.length; i++){
                    var n = o[i].split("="), s = n.slice(1).join("=");
                    try {
                        var a = decodeURIComponent(n[0]);
                        if (r[a] = t1.read(s, a), e === a) break;
                    } catch (e) {}
                }
                return e ? r[e] : r;
            }
        },
        remove: function(e, t1) {
            r(e, "", vA({}, t1, {
                expires: -1
            }));
        },
        withAttributes: function(t1) {
            return e(this.converter, vA({}, this.attributes, t1));
        },
        withConverter: function(t1) {
            return e(vA({}, this.converter, t1), this.attributes);
        }
    }, {
        attributes: {
            value: Object.freeze(o)
        },
        converter: {
            value: Object.freeze(t1)
        }
    });
}({
    read: function(e) {
        return '"' === e[0] && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
    },
    write: function(e) {
        return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
    }
}, {
    path: "/"
});
const { WebclientIsOnHold: yA, WebclientOpt: SA, WebclientParticipantId: bA, WebclientZoomId: EA, WebclientMeetingToken: IA } = ns, { WebclientDeviceId: AA } = ss;
function CA(e) {
    let { retryCount: t1, rwgServerList: o, userName: r, auth: i, trackAuth: n, meetingId: s, customerKey: a, tid: d, lang: u, ts: l, bid: c, botk: p, confID: h, zlkJwtToken: m, isAudioBridgeEnabled: g, isMeetingReset: v, cameraDevicesList: f, isFullHDVideoEnabled: y, isFullHDVideoShareEnabled: S } = e;
    const b = fA.get("_zm_mtk_guid");
    let E = is.get(AA);
    if (E || (E = fS(), is.set(AA, E, os.LocalStorage)), o.length > t1) {
        var I;
        const A = o[t1], C = {
            dn2: Hr(r),
            auth: i,
            browser: `${ms.browser}${ms.browserVersion} ${null !== (I = window) && void 0 !== I && I.crossOriginIsolated ? "SAB" : ""}`,
            trackAuth: n,
            mid: s,
            tid: d,
            lang: u,
            ts: l,
            "ZM-CID": E,
            _ZM_MTG_TRACK_ID: b || "",
            customer_key: Hr(a),
            cfs: 0,
            islch: 1
        };
        if (m) try {
            const { vendor: e } = ti(m);
            e && Object.assign(C, {
                vendor: e
            });
        } catch (e) {
            console.log(e);
        }
        A.rwcAuth ? Object.assign(C, {
            rwcAuth: A.rwcAuth
        }) : A.rwcToken && Object.assign(C, {
            rwcToken: A.rwcToken
        });
        const _ = vs() ? 1 : ms.isIE || ms.isSupportEssentialAudioAndVideoAbility ? 2 : 0;
        Object.assign(C, {
            as_type: _
        }), [
            {
                key: SA,
                queryKey: "opt"
            },
            {
                key: bA,
                queryKey: "participantID"
            },
            {
                key: EA,
                queryKey: "zoomid"
            }
        ].forEach((e)=>{
            const t1 = is.get(e.key);
            void 0 !== t1 && (C[e.queryKey] = t1);
        });
        const R = c && p && h;
        R && Object.assign(C, {
            bid: Hr(c),
            confID: h
        }), is.get(IA) && Object.assign(C, {
            isdj: 1
        }), gs() && (Object.assign(C, {
            from: ms.isAndroidBrowser ? "android" : "ios"
        }), g && Object.assign(C, {
            useABAudio: 1
        })), Object.assign(C, {
            clientCaps: _A({
                isAudioBridgeEnabled: g && gs(),
                isBO: R,
                isFullHDVideoEnabled: y,
                isFullHDVideoShareEnabled: S
            })
        });
        const w = v ? f.length > 0 ? 1 : 0 : 1;
        return Object.assign(C, {
            isCamera: w
        }), Object.assign(C, {
            clientOS: ms.isAndroidOrIOSBrowser ? ms.isIOSMobile ? "ios" : "android" : ms.isMacOS ? "mac" : "win"
        }), Object.assign(C, {
            audioFeature: la.getAudioFeatureFlag()
        }), {
            queryObject: {
                ...C
            },
            rwgServer: A
        };
    }
    return null;
}
function _A(e) {
    const { isAudioBridgeEnabled: t1, isBO: o, isFullHDVideoEnabled: r, isFullHDVideoShareEnabled: i } = e;
    let n = bh.WebCameraIndication | bh.SendMeetingTokenSeparately | bh.SmartSummary | bh.LocalRecording | bh.LocalRecordingGrantPermission | bh.UnifyErrorType;
    const s = la.getPTZCapability();
    return (s.pan || s.tilt || s.zoom) && (n |= bh.SupportFarEndCameraControl), la.isSupportVideoShare() && (n |= bh.SupportVideoShare), t1 && la.isSupportAudioBridgeAVSync() && (n |= bh.WebrtcAudioRtcpTime), la.isSupportShareMultiStream() && (n |= bh.ShareMultiStream), la.isSupportVideoLTR() && (n |= bh.VideoLTR), o || (n |= bh.RequestRemoteControl), r && la.isSupportFullHDVideo() && (n |= bh.SupportSend1080PVideo), i && la.isSupportFullHDVideoShare() && (n |= bh.SupportSend1080PVideoShare), n;
}
function RA(e, t1) {
    return t1 ? T(at(t1), tt(()=>{
        const { socket: { zoomSocketStatus: t1 }, meeting: { meetingStatus: o, isMeetingReset: r } } = e.value;
        return t1 !== yh.Closed && o === Yn.Joined && !r;
    })) : T(tt(()=>{
        const { socket: { zoomSocketStatus: t1 }, meeting: { meetingStatus: o, isMeetingReset: r } } = e.value;
        return t1 !== yh.Closed && o === Yn.Joined && !r;
    }));
}
const wA = ra.createAgent();
let TA;
const OA = UI.getInstance();
let DA;
const PA = ia.getInstance();
let MA;
const kA = {
    zoomSocketStatus: yh.Closed,
    xmppSocketStatus: yh.Closed,
    mainSessionSocketStatus: yh.Closed,
    retryCount: 0,
    rwgServerList: []
}, LA = So({
    [`${Do}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.zoomSocketStatus = o.status;
    }),
    [`${Po}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { rwgServerList: r } = e;
        r.find((e)=>e.rwg === o.rwg) || r.push(o);
    }),
    [`${Mo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.retryCount = o;
    }),
    [`${ko}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.xmppSocketStatus = o;
    }),
    [`${Lo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.mainSessionSocketStatus = o;
    }),
    [`${No}`]: ()=>kA
}, kA), NA = {
    epics0: (e, t1)=>e.pipe(Ot(`${bo}`), vt(t1), tt((e)=>{
            let [, t1] = e;
            return t1.socket.zoomSocketStatus === yh.Closed && !!t1.meeting.meetingId;
        }), pt((e)=>{
            let [, o] = e;
            return (function(e) {
                const { media: { patchedMediaSDKStatus: t1 }, meeting: { isRlbTP: o, isRlbTPReady: r } } = e;
                return $e([
                    t1 === Jd.Loading ? ip(lc, 1).pipe(Ee(X)) : Ce([
                        0
                    ]),
                    o ? r ? Ce([
                        0
                    ]) : ip(_a, 1).pipe(Ee(X)) : Ce([
                        0
                    ])
                ]);
            })(o).pipe(pt(()=>{
                const { socket: { retryCount: e, rwgServerList: o }, meeting: r, breakoutRoom: i, video: n, share: s } = t1.value;
                let a;
                const d = {
                    ...r,
                    retryCount: e,
                    rwgServerList: o
                };
                if (n) {
                    const { cameraDevicesList: e, isFullHDVideoEnabled: t1 } = n;
                    Object.assign(d, {
                        cameraDevicesList: e,
                        isFullHDVideoEnabled: t1
                    });
                }
                if (s) {
                    const { isFullHDVideoShareEnabled: e } = s;
                    Object.assign(d, {
                        isFullHDVideoShareEnabled: e
                    });
                }
                if (i && i.currentRoom.status === Jp.Joining) {
                    const { currentRoom: { boId: e, boConfId: t1, boToken: o } } = i;
                    Object.assign(d, {
                        bid: e,
                        botk: o,
                        confID: t1
                    });
                }
                if (a = r.zlkJwtToken ? function(e) {
                    const t1 = CA(e);
                    if (t1) {
                        const { queryObject: o, rwgServer: r } = t1, { topic: i, cv: n, meetingNumber: s } = e;
                        return Object.assign(o, {
                            topic: Hr(i),
                            iccv: n
                        }), `wss://${r.rwg}/instantsdk/${s}?${new URLSearchParams(o).toString()}`;
                    }
                    return null;
                }(d) : function(e) {
                    const t1 = CA(e);
                    if (t1) {
                        const { queryObject: o, rwgServer: r } = t1, { cv: i, meetingNumber: n } = e;
                        return Object.assign(o, {
                            jscv: i,
                            browser: o.browser + " ComponentView"
                        }), [
                            {
                                key: yA,
                                queryKey: "cfs"
                            }
                        ].forEach((e)=>{
                            const t1 = is.get(e.key);
                            void 0 !== t1 && (o[e.queryKey] = t1);
                        }), `wss://${r.rwg}/wc/api/${n}?${new URLSearchParams(o).toString()}`;
                    }
                    return null;
                }(d), a) {
                    const e = (u = a, l = r.isRlbTP, wA.connect(u, l), TA = new U, Je((e)=>wA.on(ta.Message, e), (e)=>wA.off(ta.Message, e), (e)=>e.data).subscribe(TA), TA);
                    return Ye(e.pipe(tt((e)=>"string" == typeof e), ke((e)=>{
                        try {
                            return JSON.parse(e);
                        } catch (e) {
                            return console.error(e), {
                                evt: 0
                            };
                        }
                    }), Xy(), qy((e)=>{
                        if (0 !== e.evt || !e.body || "invalid parameters!" !== e.body.test) return Co(e);
                        ep(Sa, {
                            errorCode: pi.InvalidParameter,
                            reason: "Invalid parameter"
                        });
                    }), ct(Do({
                        status: yh.Connecting,
                        rwgUrl: a
                    }))), e.pipe(tt((e)=>e instanceof ArrayBuffer), ke((e)=>_o(e))));
                }
                var u, l;
                return ie;
            }));
        })),
    epics1: (e, t1)=>e.pipe(Ot(`${bo}`), vt(t1), tt((e)=>{
            let [, t1] = e;
            return t1.socket.zoomSocketStatus === yh.Closed && !!t1.meeting.meetingId;
        }), pt(()=>{
            const [e, o, r, i] = [
                ta.Open,
                ta.Close,
                ta.Error,
                ta.Inactive
            ].map((e)=>Je((t1)=>wA.on(e, t1), (t1)=>wA.on(e, t1)));
            return Ye(e.pipe(Be(()=>Ye(_e(Do({
                    status: yh.Connected
                })), Qe(6e4).pipe(vt(t1), tt((e)=>{
                    let [, t1] = e;
                    return t1.meeting.meetingStatus === Yn.Initial && !t1.meeting.isMeetingReset;
                }), ke(()=>(ep(ba, {
                        reason: qn.Failover
                    }), nn(es.NoHeartbeat))))))), o.pipe(RA(t1), ke(()=>(ep(ba, {
                    reason: qn.Failover
                }), nn(es.Disconnect)))), i.pipe(RA(t1), ke(()=>(ep(ba, {
                    reason: qn.Failover
                }), nn(es.NoHeartbeat)))), r.pipe(vt(t1), Be((e)=>{
                let [, o] = e;
                const { meeting: { meetingStatus: r, isMeetingReset: i }, socket: { rwgServerList: n, retryCount: s } } = o, a = [];
                if (r === Yn.Initial && null != n && n.length) {
                    const e = n[s];
                    return Qe(5e3).pipe(tt(()=>t1.value.meeting.meetingStatus === Yn.Initial), Be(()=>{
                        const { socket: { rwgServerList: e, retryCount: o } } = t1.value, r = [];
                        return e.length > o + 1 ? r.push(Mo(o + 1), Io({
                            retry: !0
                        })) : (ep(Sa, {
                            reason: "connection error",
                            errorCode: pi.CommonError
                        }), r.push(...Wy(t1.value))), Ce(r);
                    }), ct(Un(null == e ? void 0 : e.rwc)));
                }
                return i || r !== Yn.Joined || (ep(ba, {
                    reason: qn.Failover
                }), a.push(nn(es.OnError))), Ce(a);
            })));
        })),
    epics2: (e, t1)=>e.pipe(Ot(`${Io}`), pt((e)=>e.payload && e.payload.retry ? _e(bo()).pipe(at(1e3), ct(Do({
                status: yh.Closed
            }))) : _e(Do({
                status: yh.Closed
            }))), at(100), gt(()=>{
            var e;
            t1.value.socket.zoomSocketStatus === yh.Closed && (wA.close(), null === (e = TA) || void 0 === e || e.complete());
        }))
}, VA = rr(NA, {
    xmppEpics0: (e, t1)=>e.pipe(Ot(`${Sn}`), Be(()=>{
            const { meeting: { meetingOptions: e, zlkJwtToken: o, isWebinar: r } } = t1.value, i = [];
            return (e.isPollingEnabled || o || r) && i.push(Eo()), Ce(i);
        })),
    xmppEpics1: (e, t1)=>e.pipe(Ot(`${Eo}`), vt(t1), tt((e)=>{
            let [, t1] = e;
            return "closed" === t1.socket.xmppSocketStatus;
        }), pt((e)=>{
            let [, t1] = e;
            const { meeting: { svcUrl: o, meetingNumber: r, conId: i, isRlbTP: n } } = t1, s = function(e, t1, o) {
                return `wss://${e}/wc/media/${t1}?type=x&cid=${o}`;
            }(o, r, i);
            return ((e, t1)=>(OA.connect(e, t1), DA = new U, Je((e)=>OA.on(VI.Message, e), (e)=>OA.off(VI.Message, e)).subscribe(DA), DA))(s, n).pipe(tt((e)=>void 0 !== (null == e ? void 0 : e.evt)), ke((e)=>Ro(e)), ct(ko(yh.Connecting)));
        })),
    xmppEpics2: (e, t1)=>e.pipe(Ot(`${Eo}`), pt(()=>{
            const [e, o, r] = [
                VI.Open,
                VI.Close,
                VI.Error
            ].map((e)=>Je((t1)=>OA.on(e, t1), (t1)=>OA.on(e, t1)));
            return Ye(e.pipe(gt(()=>{
                const e = function() {
                    const { isSupportEssentialAudioAndVideoAbility: e, isSupportAudioWorklet: t1 } = ms;
                    return e && t1 ? 11 : 10;
                }();
                OA.join(e);
            }), st(ko(yh.Connected))), o.pipe(RA(t1, 500), ke(()=>(ep(ba, {
                    reason: qn.Failover
                }), nn(es.DisconnectXmpp)))), r.pipe(RA(t1, 500), ke(()=>(ep(ba, {
                    reason: qn.Failover
                }), nn(es.OnErrorXmppChannel)))));
        })),
    xmppEpics3: (e)=>e.pipe(Ot(`${Ao}`), st(ko(yh.Closed)), at(100), gt(()=>{
            var e;
            OA.close(), null === (e = DA) || void 0 === e || e.complete();
        }))
}, {
    mainSessionEpics0: (e, t1)=>e.pipe(Ot(`${wo}`), vt(t1), tt((e)=>{
            let [, t1] = e;
            return "closed" === t1.socket.mainSessionSocketStatus;
        }), pt((e)=>{
            let [, t1] = e;
            const { meeting: { svcUrl: o, meetingNumber: r, conId: i, isRlbTP: n } } = t1, s = function(e, t1, o) {
                return `wss://${e}/wc/media/${t1}?type=m&cid=${o}&mode=2`;
            }(o, r, i);
            return ((e, t1)=>(PA.connect(e, t1), MA = new U, Je((e)=>PA.on(ta.Message, e), (e)=>PA.off(ta.Message, e)).pipe(ke((e)=>e.data)).subscribe(MA), MA))(s, n).pipe(ke((e)=>{
                try {
                    return JSON.parse(e);
                } catch (e) {
                    return console.error(e), {
                        evt: 0
                    };
                }
            }), tt((e)=>0 !== e.evt), Xy(), ke((e)=>Oo(e)), ct(Lo(yh.Connecting)));
        })),
    mainSessionEpics1: (e, t1)=>e.pipe(Ot(`${wo}`), pt(()=>{
            const [e, o, r] = [
                ta.Open,
                ta.Close,
                ta.Error
            ].map((e)=>Je((t1)=>PA.on(e, t1), (t1)=>PA.on(e, t1)));
            return Ye(e.pipe(st(Lo(yh.Connected))), o.pipe(RA(t1, 500), ke(()=>(ep(ba, {
                    reason: qn.Failover
                }), nn(es.DisconnectMChannel)))), r.pipe(RA(t1, 500), ke(()=>(ep(ba, {
                    reason: qn.Failover
                }), nn(es.OnErrorMChannel)))));
        })),
    mainSessionEpics2: (e)=>e.pipe(Ot(`${To}`), st(Lo(yh.Closed)), gt(()=>{
            var e;
            PA.close(), null === (e = MA) || void 0 === e || e.complete();
        }))
}), UA = {
    id: "userId",
    type: (e)=>$p(e) ? {
            userType: e,
            avatarBackgroundType: Math.floor(8 * Math.random()) + 1
        } : {
            userType: e
        },
    role: (e)=>({
            userRole: e,
            isHost: Hp(e)
        }),
    dn2: (e)=>({
            displayName: $r(e)
        }),
    bShareOn: "sharerOn",
    bSharePause: "sharerPause",
    bLocalRecordStatus: (e)=>({
            bLocalRecord: e
        }),
    bGuest: "isGuest",
    bCapsRequestLT: "isRequestLT",
    customerKey: "userIdentity"
}, jA = (e)=>{
    const t1 = {};
    return [
        "add",
        "remove",
        "update"
    ].forEach((o)=>{
        const r = o, i = e[r];
        null != i && (t1[r] = i.reduce((e, t1)=>{
            const o = Object.keys(t1).reduce((e, o)=>{
                const r = UA[o];
                return "function" == typeof r ? Object.assign(e, r(t1[o])) : "string" == typeof r ? Object.assign(e, {
                    [`${r}`]: t1[o]
                }) : Object.assign(e, {
                    [`${o}`]: t1[o]
                }), e;
            }, {}), r = e.find((e)=>e.userId === o.userId);
            return void 0 !== r ? Object.assign(r, o) : e.push(o), e;
        }, []));
    }), t1;
}, xA = {
    name: "displayName",
    node: (e)=>({
            userId: Number(e)
        }),
    role: (e)=>({
            userRole: Number(e)
        })
}, BA = (e)=>Object.keys(e).reduce((t1, o)=>{
        const r = xA[o];
        return "function" == typeof r ? Object.assign(t1, r(e[o])) : "string" == typeof r ? Object.assign(t1, {
            [`${r}`]: e[o]
        }) : Object.assign(t1, {
            [`${o}`]: e[o]
        }), t1;
    }, {}), FA = {
    attendeesList: [],
    assistantList: [],
    xmppAttendeeList: [],
    allowTalkAttendeesList: [],
    failoverAttendeesList: [],
    isAdmitAllSilentUsers: !1
}, HA = So({
    [`${Sp}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        void 0 !== o.add && o.add.length > 0 && o.add.forEach((t1)=>{
            if (t1.userType === Fp.Assitant) {
                const o = e.assistantList.find((e)=>e.userId === t1.userId);
                void 0 !== o ? Object.assign(o, t1) : e.assistantList.push(t1);
            } else if (Wp(t1.userRole)) {
                const o = e.allowTalkAttendeesList.find((e)=>e.userId === t1.userId);
                void 0 !== o ? Object.assign(o, t1) : e.allowTalkAttendeesList.push(t1);
            } else {
                const o = e.attendeesList.find((e)=>e.userId === t1.userId);
                void 0 !== o ? Object.assign(o, t1) : e.attendeesList.push(t1);
            }
        }), void 0 !== o.update && o.update.length > 0 && o.update.forEach((t1)=>{
            const o = e.attendeesList.find((e)=>e.userId === t1.userId);
            if (void 0 !== o) Object.assign(o, t1);
            else {
                const o = e.allowTalkAttendeesList.find((e)=>e.userId === t1.userId);
                if (void 0 !== o) Object.assign(o, t1);
                else {
                    const o = e.assistantList.find((e)=>e.userId === t1.userId);
                    void 0 !== o && Object.assign(o, t1);
                }
            }
        }), void 0 !== o.remove && o.remove.length > 0 && o.remove.forEach((t1)=>{
            const o = e.attendeesList.findIndex((e)=>e.userId === t1.userId);
            if (-1 !== o) e.attendeesList.splice(o, 1);
            else {
                const o = e.allowTalkAttendeesList.findIndex((e)=>e.userId === t1.userId);
                if (-1 !== o) e.allowTalkAttendeesList.splice(o, 1);
                else {
                    const o = e.assistantList.findIndex((e)=>e.userId === t1.userId);
                    -1 !== o && e.assistantList.splice(o, 1);
                }
            }
        });
    }),
    [`${Op}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { xmppAttendeeList: r } = e, i = r.map((e)=>e.jid);
        o.forEach((e)=>{
            const { jid: t1 } = e, o = i.indexOf(t1);
            -1 !== o ? Object.assign(r[o], e) : r.push(e);
        });
    }),
    [`${Ep}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAdmitAllSilentUsers = o;
    }),
    [`${_p}`]: TI((e)=>{
        e.attendeesList.forEach((e)=>{
            e.bRaiseHand && (e.bRaiseHand = !1);
        });
    }),
    [`${Rp}`]: TI((e)=>{
        e.attendeesList.forEach((e)=>{
            e.feedback > 0 && (e.feedback = 0);
        });
    }),
    [`${Ap}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.failoverAttendeesList.push(o);
    }),
    [`${Cp}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        o.forEach((t1)=>{
            const o = e.failoverAttendeesList.findIndex((e)=>e.zoomID === t1.zoomID);
            -1 !== o && e.failoverAttendeesList.splice(o, 1);
        });
    }),
    [`${wp}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { jid: r, name: i } = o, n = e.xmppAttendeeList.find((e)=>e.jid === r);
        n && (n.displayName = i);
    }),
    [`${Tp}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { jid: r } = o, i = e.xmppAttendeeList.findIndex((e)=>e.jid === r);
        -1 !== r && e.xmppAttendeeList.splice(i, 1);
    }),
    [`${Dp}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { userId: r, key: i, value: n } = o, s = e.attendeesList.find((e)=>e.userId === r);
        s && (s[`${i}`] = n);
    }),
    [`${Ip}`]: ()=>FA
}, FA), $A = {
    epics0: (e, t1)=>ir(e, Ds).pipe(ke((e)=>jA(e.payload.body)), vt(t1), Be((e)=>{
            let [t1, o] = e, r = [
                Sp(t1)
            ];
            const { meeting: { userId: i, isWebinar: n, isOnHold: s }, participants: { attendeesList: a, failoverAttendeesList: d, allowTalkAttendeesList: u } } = o, l = u.map((e)=>e.userId);
            if (t1.add) {
                const e = t1.add.filter((e)=>e.userId === i);
                e.length > 0 && e.forEach((e)=>{
                    void 0 !== e.bHold && r.push(Cn(e.bHold)), a.some((t1)=>t1.userId === e.userId) ? ep(pa, e) : ep(ca, e);
                });
                const s = t1.add.filter((e)=>e.userId !== i);
                if (s.length > 0) {
                    const e = s.filter((e)=>!Wp(e.userRole)).map((e)=>{
                        const t1 = {
                            ...e
                        };
                        if ($p(e.userType)) {
                            var r;
                            const i = null === (r = o.audio) || void 0 === r ? void 0 : r.dialout.find((t1)=>t1.phoneNodeId === e.userId);
                            i && Object.assign(t1, {
                                phoneNumber: i.phoneNumber
                            });
                        }
                        const i = d.find((t1)=>t1.zoomID === e.zoomID);
                        return i && Object.assign(t1, {
                            source: i.isOnHold ? "on hold" : "failover"
                        }), t1;
                    }), t1 = e.filter((e)=>!!e.source).map((e)=>({
                            zoomID: e.zoomID
                        }));
                    if (r.push(Cp(t1)), ep(ha, e), n) {
                        const e = s.filter((e)=>Wp(e.userRole));
                        e.length > 0 && ep(va, e.map((e)=>({
                                userId: e.userId,
                                isAllowToTalk: !0
                            })));
                    }
                }
            }
            if (t1.update) {
                const e = t1.update.filter((e)=>e.userId === i);
                e.length > 0 && e.forEach((e)=>{
                    ep(pa, e), void 0 !== e.bHold && r.push(Cn(e.bHold));
                });
                const o = t1.update.filter((e)=>!(e.userId === i || l.includes(e.userId)));
                if (o.length > 0 && ep(ma, o), n) {
                    const e = t1.update.filter((e)=>e.userId !== i && l.includes(e.userId));
                    e.length > 0 && ep(va, e);
                }
            }
            if (t1.remove) {
                const e = t1.remove.map((e)=>{
                    const t1 = a.find((t1)=>t1.userId === e.userId);
                    return t1 ? 2 === e.action && 1 === e.nUserStatus ? t1.bHold ? (r.push(Ap({
                        zoomID: t1.zoomID,
                        isOnHold: !0
                    })), {
                        ...e,
                        ...t1,
                        reason: "on hold"
                    }) : (r.push(Ap({
                        zoomID: t1.zoomID,
                        isOnHold: !1
                    })), {
                        ...e,
                        ...t1,
                        reason: "failover"
                    }) : {
                        ...e,
                        ...t1
                    } : null;
                }).filter((e)=>!!e);
                if (ep(ga, e), n) {
                    const e = t1.remove.filter((e)=>l.includes(e.userId));
                    e.length > 0 && ep(va, e.map((e)=>({
                            userId: e.userId,
                            isAllowToTalk: !1
                        })));
                }
            }
            const c = r.filter((e)=>e.type === `${Cn}`);
            if (c.length > 0) {
                const e = c[c.length - 1];
                r = r.filter((e)=>e.type !== `${Cn}`), e.payload !== s && (r.push(e), ep(Ia, !s));
            }
            return Ce(r);
        })),
    epics1: (e, t1)=>sr(e, 24595).pipe(Be((e)=>{
            const { payload: { body: { action: o, data: r } } } = e, { meeting: { jid: i }, participants: { xmppAttendeeList: n } } = t1.value, s = [];
            if (o === NI.rename) {
                r.forEach((e)=>{
                    s.push(wp(e));
                });
                const e = r.map((e)=>BA(e));
                ep(va, e);
            }
            if (o === NI.Remove) {
                r.forEach((e)=>{
                    s.push(Tp(e));
                });
                const e = r.map((e)=>({
                        ...BA(e),
                        removed: !0
                    }));
                ep(fa, e);
            }
            if ([
                NI.Add,
                NI.List,
                NI.update
            ].includes(o)) {
                const e = r.map((e)=>{
                    const t1 = BA(e);
                    return Object.keys(t1).reduce((e, o)=>("" !== t1[o] && Object.assign(e, {
                            [o]: t1[o]
                        }), e), {});
                });
                if (ep(va, e), s.push(Op(e)), o === NI.update) {
                    const e = r.find((e)=>e.jid === i);
                    if (e && void 0 !== e.bRaiseHand) {
                        const t1 = n.find((e)=>e.jid === i);
                        (null == t1 ? void 0 : t1.bRaiseHand) !== e.bRaiseHand && ep("MEETING_WEBINAR_ATTENDEE_RAISE_HAND", {
                            bRaiseHand: e.bRaiseHand
                        });
                    }
                }
            }
            return Ce(s);
        })),
    epics2: (e)=>ir(e, 7951).pipe(gt((e)=>{
            !1 === e.payload.body.bStarted && ep("ADMIT_ALL_SILENT_USERS_END", e.payload.body.bStarted);
        }), ke((e)=>Ep(e.payload.body.bStarted))),
    epics3: (e)=>ir(e, 7946).pipe(tt((e)=>{
            var t1;
            return [
                "bRaiseHand",
                "feedback"
            ].includes(null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.key) && 0 === e.payload.body.value;
        }), ke((e)=>(ep(ma, {}), "bRaiseHand" === e.payload.body.key ? _p() : Rp())))
}, WA = rr($A), GA = {
    audioEncodeStatus: "initial",
    audioDecodeStatus: "initial",
    videoEncodeStatus: "initial",
    videoDecodeStatus: "initial",
    sharingEncodeStatus: "initial",
    sharingDecodeStatus: "initial",
    assetsPath: "",
    mediaConstraints: void 0,
    fileWithVersion: !1,
    enforceMultipleVideos: !1,
    enforceVirtualBackground: !1,
    enableAudioQos: !0,
    enableVideoQos: !0,
    isAudioBridgeReceiveReady: !1,
    isAudioBridgeSendReady: !1,
    isMediaAgentInitialized: !1,
    disableRenderLimits: !1,
    adaptedABOptionForMediaSDK: ""
}, KA = So({
    [`${xo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.audioDecodeStatus = o;
    }),
    [`${jo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.audioEncodeStatus = o;
    }),
    [`${$o}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.sharingDecodeStatus = o;
    }),
    [`${Ho}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.sharingEncodeStatus = o;
    }),
    [`${Fo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.videoDecodeStatus = o;
    }),
    [`${Bo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.videoEncodeStatus = o;
    }),
    [`${Wo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.mediaConstraints = o.mediaConstraints, e.assetsPath = o.assetsPath, e.fileWithVersion = o.fileWithVersion, e.enforceMultipleVideos = !!o.enforceMultipleVideos, e.enforceVirtualBackground = o.enforceVirtualBackground, e.skipJsMedia = o.skipJsMedia, e.patchJsMedia = o.patchJsMedia, e.alternativeNameForVideoPlayer = o.alternativeNameForVideoPlayer, o.enforceMultipleVideos && "object" == typeof o.enforceMultipleVideos && (e.disableRenderLimits = !!o.enforceMultipleVideos.disableRenderLimits);
    }),
    [`${Go}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { type: r, encryptKey: i, additionalType: n } = o, s = {
            encryptKey: i,
            additionalType: n
        };
        "audio" === r ? e.audioEncrypt = s : "video" === r ? e.videoEncrypt = s : "sharing" === r && (e.sharingEncrypt = s);
    }),
    [`${Ko}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isEnableDecoderInWorklet = o;
    }),
    [`${zo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.patchedMediaSDKStatus = o;
    }),
    [`${qo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.assetsPath = o;
    }),
    [`${Jo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.enableAudioQos = o.audioQos, e.enableVideoQos = o.videoQos;
    }),
    [`${Qo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAudioBridgeReceiveReady = o;
    }),
    [`${Zo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAudioBridgeSendReady = o;
    }),
    [`${Yo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isMediaAgentInitialized = o;
    }),
    [`${Xo}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.adaptedABOptionForMediaSDK = o;
    }),
    [`${er}`]: (e)=>({
            ...GA,
            mediaConstraints: e.mediaConstraints,
            assetsPath: e.assetsPath,
            fileWithVersion: e.fileWithVersion,
            enforceMultipleVideos: e.enforceMultipleVideos,
            disableRenderLimits: e.disableRenderLimits,
            enforceVirtualBackground: e.enforceVirtualBackground,
            alternativeNameForVideoPlayer: e.alternativeNameForVideoPlayer
        })
}, GA), zA = new class {
    constructor(){
        this.state = {
            mediaSDK: void 0,
            mediaSDKInstanceMap: new Map,
            tagName: "video-player",
            renderCountMap: new Map
        }, this.onceMap = new WeakMap, this.subscribers = [];
    }
    get(e) {
        return this.state[e];
    }
    dispatch(e, t1, o) {
        t1 && Object.assign(this.state, t1), e && this.notifySubscribers(e, o);
    }
    subscribe(e) {
        return this.subscribers.push(e), ()=>{
            const t1 = this.subscribers.indexOf(e);
            -1 !== t1 && this.subscribers.splice(t1, 1);
        };
    }
    once(e, t1) {
        this.onceMap.set(t1, {
            event: e,
            unSubscribe: this.subscribe(t1)
        });
    }
    notifySubscribers(e, t1) {
        const o = [];
        this.subscribers.forEach((r)=>{
            r(e, this.state, t1);
            const i = this.onceMap.get(r);
            if (i) {
                const { event: t1, unSubscribe: n } = i;
                t1 === e && (o.push(n), this.onceMap.delete(r));
            }
        }), o.forEach((e)=>e());
    }
};
var qA, JA;
!function(e) {
    e[e.ADD_RENDER_VIDEO = 1] = "ADD_RENDER_VIDEO", e[e.STOP_RENDER_VIDEO = 2] = "STOP_RENDER_VIDEO", e[e.START_SHARING = 23] = "START_SHARING", e[e.STOP_SHARING = 24] = "STOP_SHARING", e[e.SWITCH_CANVAS_FOR_VIDEO_CAPTURE = 25] = "SWITCH_CANVAS_FOR_VIDEO_CAPTURE", e[e.UPDATE_SHARING_DECODE_PARAM = 44] = "UPDATE_SHARING_DECODE_PARAM", e[e.UPDATE_CANVAS_SIZE = 46] = "UPDATE_CANVAS_SIZE", e[e.ZOOM_RENDER = 48] = "ZOOM_RENDER", e[e.REMOVE_EXPIRED_CANVAS = 76] = "REMOVE_EXPIRED_CANVAS", e[e.WEBGL_LOST_REPLACE_CANVAS = 77] = "WEBGL_LOST_REPLACE_CANVAS", e[e.UPDATE_VIDEO_QUALITY = 78] = "UPDATE_VIDEO_QUALITY", e[e.SEND_RENDER_LOG = 79] = "SEND_RENDER_LOG";
}(qA || (qA = {})), function(e) {
    e[e.WEBGL_LOST_IN_MULTI_VIEW = -32] = "WEBGL_LOST_IN_MULTI_VIEW", e[e.MOBILE_CAPTURE_DEVICE_CHANGE = 135] = "MOBILE_CAPTURE_DEVICE_CHANGE";
}(JA || (JA = {}));
const QA = "default-sesssion-key";
var ZA, YA, XA, eC;
function tC(e, t1, o, r, i) {
    const n = document.createElement("canvas");
    n.id = r;
    const s = pC(n, e, t1);
    return i(`VPISC:${window.devicePixelRatio},${s}`), n.style.pointerEvents = "none", n.style.position = "absolute", n.style.left = "0px", n.style.top = "0px", n.style.width = e + "px", n.width = e * hC(n), n.style.height = t1 + "px", n.height = t1 * hC(n), n.ariaHidden = "true", n.style.zIndex = o, n;
}
function oC(e, t1) {
    const o = dC(()=>{
        if (e) {
            pC(e, t1.clientWidth, t1.clientHeight), [
                qA.UPDATE_CANVAS_SIZE,
                qA.UPDATE_SHARING_DECODE_PARAM
            ].forEach((o)=>{
                var r, i;
                null === (i = sC(null === (r = null == t1 ? void 0 : t1.getSessionId) || void 0 === r ? void 0 : r.call(t1))) || void 0 === i || i.Notify_MeidaSDK(o, {
                    width: t1.clientWidth * hC(e),
                    height: t1.clientHeight * hC(e),
                    canvas: e
                });
            }), e.style.width = t1.clientWidth + "px", e.style.height = t1.clientHeight + "px";
            try {
                e.width = t1.clientWidth * hC(e), e.height = t1.clientHeight * hC(e);
            } catch (e) {}
            zA.dispatch("resize", void 0, e.id);
        }
    }, 300), r = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), i = new ResizeObserver(o);
    return r.addEventListener("change", o), i.observe(t1), ()=>{
        !function(e) {
            cC.delete(e);
        }(e), null == i || i.disconnect(), r.removeEventListener("change", o);
    };
}
function rC(e, t1) {
    Object.defineProperties(e, t1.reduce((t1, o)=>(t1[o] = {
            get: ()=>e.getAttribute(o),
            set: (t1)=>{
                t1 ? e.setAttribute(o, t1) : e.removeAttribute(o);
            }
        }, t1), {}));
}
function iC(e, t1) {
    Object.entries(t1).forEach(([t1, o])=>{
        e.getAttribute(t1) || e.setAttribute(t1, o);
    });
}
function nC(e, t1) {
    const o = e.getAttribute(t1);
    return !(!o || "true" !== o);
}
function sC(e = QA) {
    var t1;
    return null === (t1 = zA.get("mediaSDKInstanceMap").get(e)) || void 0 === t1 ? void 0 : t1();
}
function aC() {
    if ("function" == typeof crypto.randomUUID) return crypto.randomUUID();
    let e = (new Date).getTime(), t1 = performance && performance.now && 1e3 * performance.now() || 0;
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (o)=>{
        let r = 16 * Math.random();
        return e > 0 ? (r = (e + r) % 16 | 0, e = Math.floor(e / 16)) : (r = (t1 + r) % 16 | 0, t1 = Math.floor(t1 / 16)), ("x" === o ? r : 3 & r | 8).toString(16);
    });
}
function dC(e, t1) {
    let o;
    return function(...r) {
        clearTimeout(o), o = setTimeout(()=>{
            e(...r);
        }, t1);
    };
}
function uC(e, t1) {
    const o = Object.keys(e), r = Object.keys(t1);
    if (o.length !== r.length) return !1;
    for (const r of o){
        const o = e[r], i = t1[r];
        if ("object" == typeof o && "object" == typeof i) {
            if (!uC(o, i)) return !1;
        } else if (o !== i) return !1;
    }
    return !0;
}
function lC(e) {
    return !e || "0" === e;
}
!function(e) {
    e.Video = "video", e.Share = "share";
}(ZA || (ZA = {})), function(e) {
    e.DEFAULT = "", e.MAIN = "main";
}(YA || (YA = {})), function(e) {
    e.Video_90P = "0", e.Video_180P = "1", e.Video_360P = "2", e.Video_720P = "3", e.Video_1080P = "4";
}(XA || (XA = {})), function(e) {
    e[e.Unknown = 0] = "Unknown", e[e.VideoTag = 1] = "VideoTag", e[e.WebGL = 2] = "WebGL", e[e.WebGL2 = 3] = "WebGL2", e[e.WebGPU = 4] = "WebGPU";
}(eC || (eC = {}));
const cC = new Map;
function pC(e, t1, o) {
    const r = t1 >= 2 * window.screen.width || o >= 2 * window.screen.height ? 1 : window.devicePixelRatio, i = cC.get(e);
    return cC.set(e, r), i && i !== r && zA.dispatch("scale", void 0, e.id), r;
}
function hC(e) {
    return cC.get(e) || window.devicePixelRatio;
}
function mC(e, t1) {
    t1 && (null == e || e.Notify_MeidaSDK(qA.SEND_RENDER_LOG, {
        message: t1
    }));
}
function gC(e, t1) {
    const o = zA.get("renderCountMap"), r = o.get(e) || 0;
    o.set(e, t1 ? r + 1 : r - 1);
}
function vC(e, t1) {
    const { left: o, top: r, bottom: i, right: n, width: s, height: a } = e.getBoundingClientRect(), d = t1.getBoundingClientRect();
    return {
        left: o - d.left,
        top: r - d.top,
        bottom: d.bottom - i,
        right: d.right - n,
        width: s,
        height: a
    };
}
const fC = [];
for(let e = 0; e <= 1; e += .01)fC.push(e);
class yC {
    constructor(e, t1){
        if (this.getRenderParams = t1, this.el = document.createElement("div"), this.position = null, this.id = "", this.srcObject = null, this.removePositionObserve = null, this.viewId = `${zA.get("tagName")}-${aC()}`, this.getSDK = ()=>{
            var e, t1;
            return sC(null === (t1 = null === (e = this.container) || void 0 === e ? void 0 : e.getSessionId) || void 0 === t1 ? void 0 : t1.call(e));
        }, !e) throw new Error(`The ${zA.get("tagName")} must have a ${zA.get("tagName")}-container as its ancestor element.`);
        this.container = e, this.el.style.width = "100%", this.el.style.height = "100%", this.debounceUpdateVideoPosition = dC(this.updateVideoPosition.bind(this), 300);
    }
    getElement() {
        return this.el;
    }
    init() {
        this.removeSubscribe = zA.subscribe((e, t1, o)=>{
            o === this.getCanvas().id && ("resize" === e ? (this.updateVideoPosition(), setTimeout(()=>{
                this.updateVideoPosition();
            }, 300)) : "scale" === e && mC(this.getSDK(), `VPSC:${hC(this.getCanvas())}`));
        });
    }
    getCanvas() {
        return this.container.getCanvas();
    }
    initObservePosition() {
        this.stopObservePosition(), this.removePositionObserve = function(e, t1, o = {}) {
            const { wrapper: r = document.documentElement } = o, i = dC(t1, 300);
            let n, s;
            const a = (o = 1, s = !1)=>{
                n && (n.disconnect(), n = null);
                const { top: d, left: u, width: l, height: c, right: p, bottom: h } = vC(e, r);
                if (!l || !c) return void t1({
                    hide: !0,
                    cross: !1,
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0
                });
                const m = ((e, t1, o, r)=>e < 0 || t1 < 0 || o < 0 || r < 0)(d, h, u, p), g = ((e, t1, o, r, i, n)=>e <= 0 && e + n <= 0 || t1 <= 0 && t1 + n <= 0 || o <= 0 && o + i <= 0 || r <= 0 && r + i <= 0)(d, h, u, p, l, c), v = {
                    root: r,
                    threshold: m ? fC : o
                };
                m || (v.rootMargin = `${-d}px ${-p}px ${-h}px ${-u}px`);
                let f = !0, y = !0;
                s && (y = !1), t1({
                    hide: g,
                    cross: m,
                    top: d,
                    left: u,
                    width: l,
                    height: c,
                    bottom: h,
                    right: p
                }), i({
                    hide: g,
                    cross: m,
                    top: d,
                    left: u,
                    width: l,
                    height: c,
                    bottom: h,
                    right: p
                }, !0), n = new IntersectionObserver(([e])=>{
                    if (0 === e.intersectionRatio) return y ? a(1, !0) : void 0;
                    if (o !== e.intersectionRatio) {
                        if (!f) return a();
                        a(0 === e.intersectionRatio ? 1e-7 : e.intersectionRatio);
                    }
                    1 === e.intersectionRatio && m && a(), f = !1;
                }, v), n.observe(e);
            };
            return a(), s = new ResizeObserver(()=>a()), s.observe(e), ()=>{
                null == n || n.disconnect(), n = null, null == s || s.disconnect(), s = null;
            };
        }(this.el, (e, t1)=>{
            t1 ? setTimeout(()=>{
                this.updateVideoPosition();
            }, 300) : this.debounceUpdateVideoPosition(e);
        }, {
            wrapper: this.container
        });
    }
    stopObservePosition() {
        this.removePositionObserve && (this.removePositionObserve(), this.removePositionObserve = null);
    }
    getCurrentPosition(e) {
        return this.transformRectToPosition(vC(e, this.container));
    }
    transformRectToPosition(e) {
        const { left: t1, width: o, height: r, bottom: i, top: n } = e, s = hC(this.getCanvas());
        return {
            x: t1 * s,
            y: i * s,
            width: o * s,
            height: r * s,
            left: t1 * s,
            bottom: i * s,
            top: n * s
        };
    }
    playVideo(e) {
        this.initObservePosition(), "string" == typeof e ? this.id = e : this.srcObject = e;
        const t1 = this.getCurrentPosition(this.el);
        this.addRender(Object.assign(Object.assign(Object.assign(Object.assign({}, t1), {
            canvas: this.getCanvas(),
            zone: this.viewId,
            userId: Number(this.id),
            ssrc: Number(this.id)
        }), this.getRenderParams()), this.srcObject ? {
            srcObject: this.srcObject
        } : {})), this.position = t1;
    }
    updateVideoPosition(e) {
        if (!this.id && !this.srcObject) return;
        const t1 = this.transformRectToPosition(e || vC(this.el, this.container));
        this.position && uC(t1, this.position) || (this.zoomRender(Object.assign(Object.assign(Object.assign(Object.assign({}, t1), {
            userId: Number(this.id),
            canvas: this.getCanvas(),
            RGBA: this.container.getRGBA(),
            zone: this.viewId
        }), this.getRenderParams()), this.srcObject ? {
            srcObject: this.srcObject
        } : {})), this.position = t1);
    }
    stopVideo() {
        this.stopObservePosition(), (this.id || this.srcObject) && this.position && ((this.id || this.srcObject) && this.stopRender(Object.assign(Object.assign(Object.assign(Object.assign({}, this.position), {
            userId: Number(this.id),
            canvas: this.getCanvas(),
            RGBA: this.container.getRGBA(),
            zone: this.viewId
        }), this.getRenderParams()), this.srcObject ? {
            srcObject: this.srcObject
        } : {})), this.position = null, this.id = "", this.srcObject = null);
    }
    updateVideoQuality(e) {
        var t1;
        this.id && (null === (t1 = this.getSDK()) || void 0 === t1 || t1.Notify_MeidaSDK(qA.UPDATE_VIDEO_QUALITY, {
            userId: this.id,
            videoQuality: e
        }));
    }
    refresh() {
        this.debounceUpdateVideoPosition();
    }
    destroy() {
        var e;
        this.stopVideo(), null === (e = this.removeSubscribe) || void 0 === e || e.call(this);
    }
}
class SC {
    constructor(e){
        this.container = e, this.id = "", this.srcObject = null, this.getSDK = ()=>{
            var e, t1;
            return sC(null === (t1 = null === (e = this.container) || void 0 === e ? void 0 : e.getSessionId) || void 0 === t1 ? void 0 : t1.call(e));
        }, this.el = document.createElement("video"), this.el.style.width = "100%", this.el.style.height = "100%", this.el.setAttribute("autoplay", "true"), this.el.setAttribute("muted", "true"), this.el.setAttribute("playsinline", "true");
    }
    getElement() {
        return this.el;
    }
    init() {}
    playVideo(e) {
        "string" == typeof e ? this.id = e : this.srcObject = e, this.addRender(Object.assign({
            userId: Number(this.id),
            videodom: this.el
        }, this.srcObject ? {
            srcObject: this.srcObject
        } : {}));
    }
    stopVideo() {
        (this.id || this.srcObject) && (this.stopRender(Object.assign({
            userId: Number(this.id),
            videodom: this.el
        }, this.srcObject ? {
            srcObject: this.srcObject
        } : {})), this.id = "", this.srcObject = null);
    }
    updateVideoQuality(e) {}
    destroy() {
        this.stopVideo();
    }
}
class bC extends yC {
    addRender({ width: e, height: t1, x: o, y: r, canvas: i, zone: n, userId: s, left: a, bottom: d, top: u, fillMode: l, videoQuality: c }) {
        var p;
        this.getSDK() && (gC(this.container, !0), function(e) {
            var t1, o;
            const r = zA.get("renderCountMap").get(e) || 0, i = (null === (o = null === (t1 = null === JsMediaSDK_Instance || void 0 === JsMediaSDK_Instance ? void 0 : JsMediaSDK_Instance.util) || void 0 === t1 ? void 0 : t1.getMaxCountRender) || void 0 === o ? void 0 : o.call(t1)) || 25, n = r >= 0 && r <= i, s = zA.get("tagName");
            n || console.error(`In your environment, the maximum number of ${s} that can be accommodated in each ${s}-container is ${i}. The current number has exceeded this limit, which may cause video rendering issues.`);
        }(this.container)), null === (p = this.getSDK()) || void 0 === p || p.Notify_MeidaSDK(qA.ADD_RENDER_VIDEO, {
            width: e,
            height: t1,
            x: o,
            y: r,
            canvas: i,
            zone: n,
            userId: s,
            left: a,
            bottom: d,
            top: u,
            fillMode: l,
            videoQuality: c
        });
    }
    zoomRender({ width: e, height: t1, x: o, y: r, userId: i, canvas: n, RGBA: s, zone: a, left: d, bottom: u, top: l }) {
        var c;
        null === (c = this.getSDK()) || void 0 === c || c.Notify_MeidaSDK(qA.ZOOM_RENDER, {
            width: e,
            height: t1,
            x: o,
            y: r,
            userId: i,
            canvas: n,
            RGBA: s,
            zone: a,
            left: d,
            bottom: u,
            top: l
        });
    }
    stopRender({ width: e, height: t1, x: o, y: r, userId: i, canvas: n, doNotClean: s, RGBA: a, zone: d, left: u, bottom: l, top: c, videoQuality: p }) {
        var h;
        this.getSDK() && gC(this.container, !1), null === (h = this.getSDK()) || void 0 === h || h.Notify_MeidaSDK(qA.STOP_RENDER_VIDEO, {
            width: e,
            height: t1,
            x: o,
            y: r,
            userId: i,
            canvas: n,
            doNotClean: s,
            RGBA: a,
            zone: d,
            left: u,
            bottom: l,
            top: c,
            videoQuality: p
        });
    }
}
class EC extends SC {
    addRender({ userId: e, videodom: t1 }) {
        var o;
        null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(qA.ADD_RENDER_VIDEO, {
            userId: e,
            videodom: t1
        });
    }
    stopRender({ userId: e, videodom: t1 }) {
        var o;
        null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(qA.STOP_RENDER_VIDEO, {
            userId: e,
            videodom: t1
        });
    }
}
class IC extends yC {
    addRender({ width: e, height: t1, userId: o, canvas: r, isFromMainSession: i }) {
        var n;
        null === (n = this.getSDK()) || void 0 === n || n.Notify_MeidaSDK(qA.START_SHARING, {
            width: e,
            height: t1,
            canvas: r,
            ssrc: o,
            isFromMainSession: i
        });
    }
    zoomRender() {}
    stopRender({ canvas: e }) {
        var t1;
        null === (t1 = this.getSDK()) || void 0 === t1 || t1.Notify_MeidaSDK(qA.STOP_SHARING, {
            canvas: e
        });
    }
}
class AC extends SC {
    addRender({ userId: e, videodom: t1 }) {
        var o, r;
        null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(qA.SWITCH_CANVAS_FOR_VIDEO_CAPTURE, [
            t1
        ]), null === (r = this.getSDK()) || void 0 === r || r.Notify_MeidaSDK(qA.ADD_RENDER_VIDEO, {
            userId: e,
            videodom: t1
        });
    }
    stopRender({ userId: e, videodom: t1 }) {
        var o;
        null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(qA.STOP_RENDER_VIDEO, {
            userId: e,
            videodom: t1
        });
    }
}
class CC {
    static VERTEX_SHADER = "\n    attribute vec2 position;\n    varying vec2 texCoord;\n\n    void main() {\n      texCoord = (position + 1.0) * 0.5;\n      // gl_Position = vec4(position, 0.0, 1.0);\n      gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n    }\n  ";
    static FRAGMENT_SHADER = "\n    precision mediump float;\n    varying vec2 texCoord;\n    uniform sampler2D videoTexture;\n\n    void main() {\n      gl_FragColor = texture2D(videoTexture, texCoord);\n    }\n  ";
    constructor(){}
    preview(e, t1, o) {
        const r = t1.getContext("webgl"), i = this.#e(r, CC.VERTEX_SHADER, CC.FRAGMENT_SHADER), n = r.getAttribLocation(i, "position"), s = r.getUniformLocation(i, "videoTexture");
        r.useProgram(i);
        const a = this.#t(r);
        r.bindBuffer(r.ARRAY_BUFFER, a), r.enableVertexAttribArray(n), r.vertexAttribPointer(n, 2, r.FLOAT, !1, 0, 0), this.frame({
            glContext: r,
            program: i,
            positionAttributeLocation: n,
            textureLocation: s,
            positionBuffer: a,
            viewport: o,
            source: e
        });
    }
    frame(e) {
        const t1 = e.glContext;
        e.glContext.clearColor(0, 0, 0, 1), e.glContext.clear(e.glContext.COLOR_BUFFER_BIT), e.glContext.viewport(e.viewport.x, e.viewport.y, e.viewport.w, e.viewport.h), e.glContext.enable(e.glContext.DEPTH_TEST);
        const o = e.glContext.createTexture();
        t1.activeTexture(t1.TEXTURE0), t1.bindTexture(t1.TEXTURE_2D, o), t1.uniform1i(e.textureLocation, 0), t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, e.source), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_S, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_T, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MIN_FILTER, t1.LINEAR), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MAG_FILTER, t1.LINEAR), e.glContext.drawArrays(e.glContext.TRIANGLE_STRIP, 0, 4), requestAnimationFrame(()=>this.frame(e));
    }
    #e(e, t1, o) {
        const r = this.#o(e, e.VERTEX_SHADER, t1), i = this.#o(e, e.FRAGMENT_SHADER, o);
        let n = e.createProgram();
        return e.attachShader(n, r), e.attachShader(n, i), e.linkProgram(n), n;
    }
    #o(e, t1, o) {
        const r = e.createShader(t1);
        return e.shaderSource(r, o), e.compileShader(r), r;
    }
    #t(e) {
        const t1 = e.createBuffer();
        return e.bindBuffer(e.ARRAY_BUFFER, t1), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
            -1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1
        ]), e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, null), t1;
    }
}
class _C {
    static VERTEX_SHADER = "#version 300 es\n    in vec2 position;\n    out vec2 texCoord;\n\n    void main() {\n      texCoord = (position + 1.0) * 0.5;\n      gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n    }\n  ";
    static FRAGMENT_SHADER = "#version 300 es\n    precision mediump float;\n    in vec2 texCoord;\n    uniform sampler2D videoTexture;\n    out vec4 fragColor;\n\n    void main() {\n      fragColor = texture(videoTexture, texCoord);\n    }\n  ";
    constructor(){}
    preview(e, t1, o) {
        const r = t1.getContext("webgl2"), i = this.#e(r, _C.VERTEX_SHADER, _C.FRAGMENT_SHADER), n = r.getAttribLocation(i, "position"), s = r.getUniformLocation(i, "videoTexture");
        r.useProgram(i);
        const a = this.#t(r);
        r.bindBuffer(r.ARRAY_BUFFER, a), r.enableVertexAttribArray(n), r.vertexAttribPointer(n, 2, r.FLOAT, !1, 0, 0), this.frame({
            glContext: r,
            program: i,
            positionAttributeLocation: n,
            textureLocation: s,
            positionBuffer: a,
            viewport: o,
            source: e
        });
    }
    frame(e) {
        const t1 = e.glContext;
        e.glContext.clearColor(0, 0, 0, 1), e.glContext.clear(e.glContext.COLOR_BUFFER_BIT), e.glContext.viewport(e.viewport.x, e.viewport.y, e.viewport.w, e.viewport.h), e.glContext.enable(e.glContext.DEPTH_TEST);
        const o = e.glContext.createTexture();
        t1.activeTexture(t1.TEXTURE0), t1.bindTexture(t1.TEXTURE_2D, o), t1.uniform1i(e.textureLocation, 0), t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, e.source), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_S, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_T, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MIN_FILTER, t1.LINEAR), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MAG_FILTER, t1.LINEAR), e.glContext.drawArrays(e.glContext.TRIANGLE_STRIP, 0, 4), requestAnimationFrame(()=>this.frame(e));
    }
    #e(e, t1, o) {
        const r = this.#o(e, e.VERTEX_SHADER, t1), i = this.#o(e, e.FRAGMENT_SHADER, o);
        let n = e.createProgram();
        return e.attachShader(n, r), e.attachShader(n, i), e.linkProgram(n), n;
    }
    #o(e, t1, o) {
        const r = e.createShader(t1);
        return e.shaderSource(r, o), e.compileShader(r), r;
    }
    #t(e) {
        const t1 = e.createBuffer();
        return e.bindBuffer(e.ARRAY_BUFFER, t1), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
            -1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1
        ]), e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, null), t1;
    }
}
class RC {
    static VERTEX_SHADER = "\n    struct VertexOutput {\n      @builtin(position) Position: vec4<f32>,\n      @location(0) uv: vec2<f32>,\n    }\n\n    @vertex\n    fn vert_main(@builtin(vertex_index) VertexIndex: u32) -> VertexOutput {\n      var pos = array<vec2<f32>, 6>(\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>( 1.0, -1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(-1.0,  1.0)\n      );\n\n      var uv = array<vec2<f32>, 6>(\n        vec2<f32>(1.0, 0.0),\n        vec2<f32>(1.0, 1.0),\n        vec2<f32>(0.0, 1.0),\n        vec2<f32>(1.0, 0.0),\n        vec2<f32>(0.0, 1.0),\n        vec2<f32>(0.0, 0.0)\n      );\n\n      var output : VertexOutput;\n      output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n      output.uv = uv[VertexIndex];\n      return output;\n    }\n  ";
    static FRAG_SHADER_VF = "\n    @group(0) @binding(0) var mySampler: sampler;\n    @group(0) @binding(1) var vfTexture: texture_external;\n\n    @fragment\n    fn frag_main(@location(0) uv : vec2<f32>) -> @location(0) vec4<f32> {\n      var color0: vec4<f32> = textureSampleBaseClampToEdge(vfTexture, mySampler, uv);\n      return color0;\n    }\n  ";
    constructor(){}
    async preview(e, t1, o) {
        if (!e || !t1 || !o) throw new Error("Invalid arguments: source, target, or viewport is missing");
        const r = await navigator.gpu.requestAdapter(), i = await r.requestDevice(), n = navigator.gpu.getPreferredCanvasFormat(), s = t1.getContext("webgpu");
        s.configure({
            device: i,
            format: n,
            alphaMode: "opaque"
        });
        const a = i.createSampler({}), d = i.createRenderPipeline({
            layout: "auto",
            vertex: {
                module: i.createShaderModule({
                    code: RC.VERTEX_SHADER
                }),
                entryPoint: "vert_main"
            },
            fragment: {
                module: i.createShaderModule({
                    code: RC.FRAG_SHADER_VF
                }),
                entryPoint: "frag_main",
                targets: [
                    {
                        format: n
                    }
                ]
            },
            primitive: {
                topology: "triangle-list"
            }
        }), u = {
            device: i,
            context: s,
            pipeline: d,
            sampler: a,
            source: e,
            viewport: o
        };
        this.frame(u);
    }
    frame(e) {
        const t1 = e.device.createCommandEncoder(), o = {
            colorAttachments: [
                {
                    view: e.context.getCurrentTexture().createView(),
                    loadOp: "clear",
                    storeOp: "store"
                }
            ]
        }, r = t1.beginRenderPass(o);
        r.setPipeline(e.pipeline);
        const i = e.device.createBindGroup({
            layout: e.pipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: e.sampler
                },
                {
                    binding: 1,
                    resource: e.device.importExternalTexture({
                        source: e.source
                    })
                }
            ]
        });
        r.setBindGroup(0, i), r.setViewport(e.viewport.x, e.viewport.y, e.viewport.w, e.viewport.h, 0, 1), r.draw(6), r.end(), e.device.queue.submit([
            t1.finish()
        ]), requestAnimationFrame(()=>this.frame(e));
    }
}
class wC {
    constructor(){}
    preview(e, t1, o, r) {
        let i = null;
        1 == e ? o.srcObject = t1 : 2 == e ? (i = new CC, i.preview(t1, o, r)) : 3 == e ? (i = new _C, i.preview(t1, o, r)) : 4 == e && (i = new RC, i.preview(t1, o, r));
    }
    static getInstance() {
        return wC.instance || (wC.instance = new wC), wC.instance;
    }
}
class TC extends yC {
    constructor(){
        super(...arguments), this.rendersProxy = wC.getInstance(), this.videoSource = null;
    }
    createSource(e, t1, o) {
        return function(e, t1, o, r) {
            return new (o || (o = Promise))(function(t1, i) {
                function n(e) {
                    try {
                        a(r.next(e));
                    } catch (e) {
                        i(e);
                    }
                }
                function s(e) {
                    try {
                        a(r.throw(e));
                    } catch (e) {
                        i(e);
                    }
                }
                function a(e) {
                    var r;
                    e.done ? t1(e.value) : (r = e.value, r instanceof o ? r : new o(function(e) {
                        e(r);
                    })).then(n, s);
                }
                a((r = r.apply(e, [])).next());
            });
        }(this, 0, void 0, function*() {
            const r = document.createElement("video");
            return r.width = t1, r.height = o, r.loop = !0, r.autoplay = !0, r.muted = !0, r.srcObject = e, yield r.play(), r;
        });
    }
    addRender(e) {
        e.renderType && e.srcObject && !this.videoSource && (this.videoSource && (this.videoSource = null), this.createSource(e.srcObject, e.width, e.height).then((t1)=>{
            this.videoSource = t1, this.rendersProxy.preview(e.renderType, this.videoSource, e.canvas, {
                x: e.x,
                y: e.renderType === eC.WebGPU ? e.top : e.y,
                w: e.width,
                h: e.height
            });
        }));
    }
    zoomRender(e) {
        e.renderType && this.videoSource && (this.videoSource.width !== e.width && (this.videoSource.width = e.width), this.videoSource.height !== e.height && (this.videoSource.height = e.height));
    }
    stopRender(e) {
        e.renderType && this.videoSource && (this.videoSource.srcObject = null, this.videoSource = null);
    }
}
class OC extends SC {
    constructor(){
        super(...arguments), this.rendersProxy = wC.getInstance();
    }
    addRender(e) {
        e.srcObject && e.videodom && this.rendersProxy.preview(eC.VideoTag, e.srcObject, e.videodom);
    }
    stopRender(e) {
        e.videodom.srcObject = null;
    }
}
const DC = "node-id", PC = "media-type", MC = "video-quality", kC = "share-source", LC = "fill-mode", NC = "stop-no-clean", VC = "refresh-key";
class UC extends HTMLElement {
    static get observedAttributes() {
        return [
            DC,
            PC,
            MC,
            VC
        ];
    }
    constructor(){
        super(), this.container = null, this._srcObject = null, rC(this, UC.customAttributes), this.getRenderParams = this.getParsedParams.bind(this), this.callback = (e, t1)=>{
            e === JA.MOBILE_CAPTURE_DEVICE_CHANGE && t1 === this.getAttribute(DC) && this.initRender();
        };
    }
    initRender() {
        var e, t1, o, r, i;
        if (this.render && this.render.destroy(), null === (e = this.getContainer()) || void 0 === e ? void 0 : e.useInsideRender()) {
            const e = null === (t1 = this.getContainer()) || void 0 === t1 ? void 0 : t1.getInsideRenderType();
            if (e === eC.VideoTag) this.render = new OC(this.getContainer());
            else {
                if (![
                    eC.WebGL,
                    eC.WebGL2,
                    eC.WebGPU
                ].includes(e)) return void console.error("Inside render type error.");
                this.render = new TC(this.getContainer(), this.getRenderParams);
            }
            return this.shadowRoot && (this.shadowRoot.innerHTML = "", this.shadowRoot.appendChild(this.render.getElement())), this.render.init(), void (this.srcObject && this.render.playVideo(this.srcObject));
        }
        const n = this.getAttribute(DC), s = n && (null === (o = this.getCurrentMediaSDK()) || void 0 === o ? void 0 : o.isPreviewVideotag(n));
        let a = 0;
        this.getAttribute(PC) === ZA.Share ? (this.render = new IC(this.getContainer(), this.getRenderParams), a = 2) : (null === (r = this.getCurrentMediaSDK()) || void 0 === r ? void 0 : r.getWebRTCFlag()) ? (this.render = new EC(this.getContainer()), a = 4) : s ? (this.render = new AC(this.getContainer()), a = 1) : (this.render = new bC(this.getContainer(), this.getRenderParams), a = 3), this.getCurrentMediaSDK() && mC(this.getCurrentMediaSDK(), `VPREN:${a}`), this.innerHTML = "", this.appendChild(this.render.getElement()), this.render.init();
        const d = this.getAttribute(DC);
        lC(d) || null === (i = this.render) || void 0 === i || i.playVideo(d);
    }
    get srcObject() {
        return this._srcObject;
    }
    set srcObject(e) {
        var t1, o, r, i;
        !this._srcObject && e ? null === (t1 = this.render) || void 0 === t1 || t1.playVideo(e) : this._srcObject && e ? (null === (o = this.render) || void 0 === o || o.stopVideo(), null === (r = this.render) || void 0 === r || r.playVideo(e)) : this._srcObject && (null === (i = this.render) || void 0 === i || i.stopVideo()), this._srcObject = e;
    }
    getContainer() {
        return this.container || (this.container = this.closest(`${zA.get("tagName")}-container`)), this.container;
    }
    getCurrentMediaSDK() {
        var e, t1;
        return sC(null === (t1 = null === (e = this.getContainer()) || void 0 === e ? void 0 : e.getSessionId) || void 0 === t1 ? void 0 : t1.call(e));
    }
    getParsedParams() {
        var e, t1;
        return {
            fillMode: nC(this, LC),
            doNotClean: nC(this, NC),
            isFromMainSession: "main" === this.getAttribute(kC),
            videoQuality: this.getAttribute(MC),
            renderType: null !== (t1 = null === (e = this.getContainer()) || void 0 === e ? void 0 : e.getInsideRenderType()) && void 0 !== t1 ? t1 : eC.Unknown
        };
    }
    connectedCallback() {
        var e;
        this.style.display = "block", iC(this, UC.defaultValues), this.initRender(), null === (e = this.getCurrentMediaSDK()) || void 0 === e || e.addCallback(this.callback), this.removeSubscribe = zA.subscribe((e, t1, o)=>{
            var r, i, n, s;
            "failover" === e && o === ((null === (i = null === (r = this.getContainer()) || void 0 === r ? void 0 : r.getSessionId) || void 0 === i ? void 0 : i.call(r)) || QA) && (this.initRender(), lC(this.getAttribute(DC)) || null === (n = this.render) || void 0 === n || n.playVideo(this.getAttribute(DC)), this.srcObject && (null === (s = this.render) || void 0 === s || s.playVideo(this.srcObject)));
        });
    }
    disconnectedCallback() {
        var e, t1, o;
        null === (e = this.removeSubscribe) || void 0 === e || e.call(this), null === (t1 = this.render) || void 0 === t1 || t1.destroy(), this.callback && (null === (o = this.getCurrentMediaSDK()) || void 0 === o || o.removeCallback(this.callback));
    }
    attributeChangedCallback(e, t1, o) {
        var r, i, n, s, a;
        if (this.render) switch(e){
            case DC:
                (null === (r = this.getCurrentMediaSDK()) || void 0 === r ? void 0 : r.getWebRTCFlag()) || Boolean(null === (i = this.getCurrentMediaSDK()) || void 0 === i ? void 0 : i.isPreviewVideotag(o)) !== this.render instanceof AC && this.initRender(), lC(t1) && !lC(o) ? this.render.playVideo(o) : lC(t1) || lC(o) ? lC(t1) || this.render.stopVideo() : (this.render.stopVideo(), this.render.playVideo(o));
                break;
            case PC:
                this.initRender();
                break;
            case MC:
                null === (n = this.render) || void 0 === n || n.updateVideoQuality(o);
                break;
            case VC:
                lC(o) || null === (a = null === (s = this.render) || void 0 === s ? void 0 : s.refresh) || void 0 === a || a.call(s);
        }
    }
}
UC.customAttributes = [
    DC,
    PC,
    MC,
    kC,
    LC,
    NC,
    VC
], UC.defaultValues = {
    [DC]: "",
    [PC]: ZA.Video
};
const jC = "session-id", xC = "z-index", BC = "inside-render", FC = "label";
class HC extends HTMLElement {
    static get observedAttributes() {
        return [
            jC,
            xC,
            BC
        ];
    }
    constructor(){
        super(), this.canvasId = "video-player-canvas-" + (this.getAttribute(FC) ? `${this.getAttribute(FC)}-` : "") + aC(), this.needInitCanvas = !1, this.callback = null, rC(this, HC.customAttributes);
        const e = this.attachShadow({
            mode: "open"
        }), t1 = document.createElement("slot");
        this.appendCanvas = (o)=>{
            e.insertBefore(o, t1);
        }, e.appendChild(t1);
    }
    connectedCallback() {
        this.style.display = "block", this.style.position || (this.style.position = "relative"), iC(this, HC.defaultValues), this.needInitCanvas && this.initCanvasEvents(), this.removeSubscribe = zA.subscribe((e, t1, o)=>{
            "failover" === e && o === (this.getSessionId() || QA) && (this.replaceCanvas(), this.initCanvasEvents());
        });
    }
    disconnectedCallback() {
        var e, t1, o, r;
        null === (e = this.removeListener) || void 0 === e || e.call(this), null === (t1 = this.removeSubscribe) || void 0 === t1 || t1.call(this), this.canvas && (null === (o = sC(this.getSessionId())) || void 0 === o || o.Notify_MeidaSDK(qA.REMOVE_EXPIRED_CANVAS, {
            canvasId: this.canvasId
        }), this.canvas.remove(), this.canvas = void 0), this.callback && (null === (r = sC(this.getSessionId())) || void 0 === r || r.removeCallback(this.callback));
    }
    attributeChangedCallback(e, t1, o) {
        e === xC && this.canvas && o && (this.canvas.style.zIndex = o);
    }
    adoptedCallback() {}
    createCanvas() {
        this.getCurrentMediaSDK() && mC(this.getCurrentMediaSDK(), "VPCC"), this.canvas = tC(this.clientWidth, this.clientHeight, this.getAttribute(xC) || "", this.canvasId, (e)=>mC(this.getCurrentMediaSDK(), e)), this.appendCanvas(this.canvas), this.isConnected ? this.initCanvasEvents() : this.needInitCanvas = !0;
    }
    initCanvasEvents() {
        var e;
        this.removeListener = oC(this.canvas, this), this.callback = (e, t1)=>{
            var o, r;
            e === JA.WEBGL_LOST_IN_MULTI_VIEW && t1.replaceCanvas && t1.canvasId === (null === (o = this.canvas) || void 0 === o ? void 0 : o.id) && (this.replaceCanvas(), null === (r = sC(this.getSessionId())) || void 0 === r || r.Notify_MeidaSDK(qA.WEBGL_LOST_REPLACE_CANVAS, {
                canvasId: this.canvasId,
                canvas: this.canvas
            }));
        }, null === (e = this.getCurrentMediaSDK()) || void 0 === e || e.addCallback(this.callback);
    }
    replaceCanvas() {
        var e;
        if (this.getCurrentMediaSDK() && mC(this.getCurrentMediaSDK(), "VPRC"), this.canvas) {
            null === (e = this.removeListener) || void 0 === e || e.call(this);
            const t1 = tC(this.clientWidth, this.clientHeight, this.getAttribute(xC) || "", this.canvasId, (e)=>mC(this.getCurrentMediaSDK(), e));
            this.removeListener = oC(t1, this), this.shadowRoot && this.shadowRoot.replaceChild(t1, this.canvas), this.canvas = t1;
        }
    }
    getCanvas() {
        return this.canvas || this.createCanvas(), this.canvas;
    }
    useInsideRender() {
        return null !== this.getAttribute(BC) && void 0 !== this.getAttribute(BC) && "false" !== this.getAttribute(BC) && "0" !== this.getAttribute(BC);
    }
    getInsideRenderType() {
        return Number(this.getAttribute("inside-render-type"));
    }
    getSessionId() {
        return this.getAttribute(jC) || void 0;
    }
    getCurrentMediaSDK() {
        return sC(this.getSessionId());
    }
    getRGBA() {
        return function(e) {
            let t1 = 0, o = 0, r = 0, i = 0;
            if ("r" === e[0]) if ("a" === e[3]) {
                const n = e.slice(5, -1).split(",").map((e)=>parseInt(e.trim(), 10));
                t1 = n[0], o = n[1], r = n[2], i = n[3];
            } else {
                const i = e.slice(4, -1).split(",").map((e)=>parseInt(e.trim(), 10));
                t1 = i[0], o = i[1], r = i[2];
            }
            else if ("#" === e[0]) {
                let i = e.slice(1);
                3 === i.length && (i = i.split("").map((e)=>e.repeat(2)).join(""));
                const n = parseInt(i, 16);
                t1 = n >> 16 & 255, o = n >> 8 & 255, r = 255 & n;
            }
            return {
                R: t1 / 255,
                G: o / 255,
                B: r / 255,
                A: i
            };
        }(getComputedStyle(this).getPropertyValue("background-color"));
    }
}
function $C(e) {
    const { audio: { isBackgroundNoiseSuppression: t1, originalSound: o, highBitrate: r } } = e, i = {
        currentSelect: Zd.Denoise
    }, n = {
        highfidelity: !1,
        stereo: !1
    };
    if (o) {
        Object.assign(i, {
            currentSelect: Zd.OriginalSound
        });
        const e = {};
        "boolean" == typeof o ? Object.assign(e, n) : Object.assign(e, {
            highfidelity: !!o.hifi,
            stereo: !!o.stereo
        }), Object.assign(i, {
            originalSound: e
        });
    }
    return Object.assign(i, {
        backgroundNoiseSuppression: t1 ? Qd.Zoom : Qd.Browser,
        highBitrate: r
    }), i;
}
function WC(e, t1, o, r) {
    const { meeting: { userId: i }, audio: { localShareAudioUserMutedList: n }, share: { isReceiveSharingFromMainSession: s } } = r;
    return n.filter((e)=>e.userId !== t1).forEach((t1)=>{
        e.setSharingAudioVolume(t1.userId, !0, t1.isFromMainSession);
    }), e.setSharingAudioVolume(t1, o, !!s), t1 === i ? Wh(o) : Fh({
        userId: t1,
        muted: o
    });
}
async function GC(e, t1, o) {
    var r, i;
    const { audio: { audioSsrc: n, activeMicrophone: s, activeSpeaker: a, isAllowToTalk: d, customizeAudioOption: { speakerOnly: u, mute: l, microphoneId: c, speakerId: p }, isUsingMediaPlayback: h, mediaPlaybackFile: m, isHIDEnabled: g, microphoneDevicesList: v, isVerifiedAudioPermissionOnIOSMobile: f, speakerDevicesList: y }, meeting: { svcUrl: S, conId: b, reportDomain: E, isAudioBridgeEnabled: I, userId: A, supportLocalAB: C, abToken: _ } } = t1, R = sh(t1), w = !!u || Gp(R.userRole) && !d, T = null != o ? o : !w;
    gs() && (I || console.warn("Cannot start audio due to the service is not ready."), await Te(Ny(t1, !T)).then((e)=>{
        let [t1, o] = e;
        return t1 && o ? Promise.resolve() : Promise.reject();
    }));
    let O = s, D = a;
    if (void 0 !== c || void 0 !== p) {
        let e = v, t1 = y;
        if (0 === v.length) {
            const { microphones: o, speakers: r } = await Te(Cy());
            e = o, t1 = r;
        }
        c && e.findIndex((e)=>e.deviceId === c) > -1 && (O = c), p && t1.findIndex((e)=>e.deviceId === p) > -1 && (D = p);
    }
    if (h && null != m && m.url) {
        const t1 = $y.getInstance();
        await t1.setAudioElement(m), O = t1.audioElement, void 0 !== m.playback && (e.enablePlayAudioFileLocally(!!m.playback), O.dataset.playback = m.playback ? "1" : "0");
    } else $y.getInstance().stopAudioElement();
    return w && !f && ms.isIOSMobile && await async function() {
        await navigator.mediaDevices.getUserMedia({
            audio: !0
        });
    }(), null === (r = e.joinComputerAudio(n, O, D, T, $C(t1), gs() ? {
        rwgHost: S,
        cid: b,
        nginxHost: E,
        abToken: _,
        supportLocalAB: C,
        useWebRTCOnDesktop: !ms.isAndroidOrIOSBrowser
    } : void 0, g ? {
        microphoneLabel: null === (i = v.find((e)=>e.deviceId === s)) || void 0 === i ? void 0 : i.label,
        defaultMuted: !(null == R || !R.muted)
    } : void 0)) || void 0 === r ? void 0 : r.then(()=>{
        l && (ra.createAgent().mute(A, !0), e.muteAudio()), null != R && R.muted ? e.muteAudio() : e.unmuteAudio();
    });
}
async function KC(e, t1, o) {
    const r = [], { audio: { isJoinComputerAudioBeforeSharingAudio: i, mutedBeforeSharingAudio: n } } = o, s = sh(o);
    return !0 === i && (await GC(e, o), r.push(Hh(void 0)), !1 === n && (r.push(sm(ud.SharingAudio)), t1.mute(s.userId, !1)), r.push(xh(void 0))), r;
}
async function zC(e, t1, o) {
    const { audio: { isSharingAudio: r }, meeting: { userId: i } } = o, n = [];
    if (n.push(WC(e, i, !0, o)), r) {
        await e.leaveSharingAudio(!1), n.push(Gh(!1));
        const r = await KC(e, t1, o);
        n.push(...r), setTimeout(()=>{
            ep(rl, {
                state: "off"
            });
        }, 0);
    }
    return n.push($h(!1)), n;
}
async function qC(e, t1, o) {
    const { audio: { audioSsrc: r, activeMicrophone: i, activeSpeaker: n }, meeting: { svcUrl: s, conId: a, reportDomain: d, supportLocalAB: u, abToken: l } } = o, c = sh(o), p = [];
    if (!ZC()) {
        const t1 = await async function(e, t1) {
            const o = [], r = sh(t1), { audio: { isMicrophoneForbidden: i } } = t1;
            return (null == r ? void 0 : r.audio) === $d.Computer && (o.push(Hh(!0)), o.push(xh(r.muted)), r.muted || e.muteAudio(), await e.leaveComputerAudio(), o.push(Dh(0)), i && o.push(Oh(!1))), o;
        }(e, o);
        p.push(...t1);
    }
    return await e.leaveSharingAudio(!0), await e.joinSharingAudio({
        ssrc: r,
        microphoneDeviceId: i,
        speakerDeviceId: n,
        isCaptureAudio: Gp(c.userRole),
        audioBridge: gs() ? {
            rwgHost: s,
            cid: a,
            nginxHost: d,
            abToken: l,
            supportLocalAB: u,
            useWebRTCOnDesktop: !ms.isAndroidOrIOSBrowser
        } : void 0
    }), p.push($h(!0)), p.push(Gh(!0)), p.push(WC(e, c.userId, !1, o)), p.findIndex((e)=>e.type === `${Hh}` && !0 === e.payload) > -1 && (p.push(nm(dd.SharingAudio)), t1.mute(o.meeting.userId, !0)), setTimeout(()=>{
        ep(rl, {
            state: "on"
        });
    }, 0), p;
}
HC.customAttributes = [], HC.defaultValues = {};
const JC = ()=>{
    if (Ss()) return !0;
    {
        var e;
        let { browser: o } = ms;
        if (o = null === (e = o) || void 0 === e ? void 0 : e.toLocaleLowerCase(), o.indexOf("safari") > -1 && -1 === o.indexOf("ios-safari")) {
            var t1;
            const e = null === (t1 = navigator.userAgent.match(/version\/(\d+\.?\d+)/i)) || void 0 === t1 ? void 0 : t1[1];
            return qr(e || "", "15.2") >= 0 && qr(e || "", "17.1") < 0;
        }
        return !1;
    }
};
function QC(e, t1, o) {
    for(let r = 0; r < o.length && 0 !== t1.length; r++){
        const { userId: i, displayName: n } = o[r];
        if (t1.includes(i)) {
            const o = e.find((e)=>e.userId === i);
            o && (o.displayName = n, t1.splice(t1.indexOf(i), 1));
        }
    }
}
function ZC() {
    return la.isSupportOpenMicWhenShareAudio();
}
function YC(e) {
    return la.isSupportAudioDenoise(e);
}
function XC() {
    return la.isSupportStereoAudio();
}
function e_() {
    var e;
    return "function" == typeof (null === (e = window.navigator.hid) || void 0 === e ? void 0 : e.requestDevice);
}
function t_(e, t1, o) {
    const { audio: { isAllowToTalk: r, customizeAudioOption: i }, media: { audioDecodeStatus: n, audioEncodeStatus: s } } = e;
    return {
        encodeInitStatus: Gp(t1.userRole) && !r || o || null != i && i.speakerOnly || gs() ? "success" : s,
        decodeInitStatus: gs() ? "success" : n
    };
}
function o_(e, t1, o) {
    gs() ? Ny(t1, o).subscribe((t1)=>{
        let [o, r] = t1;
        o && r && e.joinOrLeaveVoip(!0);
    }) : e.joinOrLeaveVoip(!0);
}
const r_ = ra.createAgent(), i_ = Dy(fE(la.getInstance())), n_ = (e)=>!e.muted, s_ = ra.createAgent(), a_ = Dy(fE(la.getInstance())), d_ = ra.createAgent(), u_ = Dy(fE(la.getInstance())), l_ = [
    pd.Canceled,
    pd.CancelFailed
], c_ = {
    asnIds: {
        asn1: {
            userId: 0,
            displayName: null
        },
        asn2: {
            userId: 0,
            displayName: null
        },
        asn3: {
            userId: 0,
            displayName: null
        }
    },
    microphoneDevicesList: [],
    speakerDevicesList: [],
    activeMicrophone: "default",
    activeSpeaker: "default",
    isMicrophoneForbidden: !1,
    audioSsrc: 0,
    bCanUnmute: !1,
    bMutedUponEntry: !1,
    isAllowToTalk: void 0,
    dialout: [],
    crcDevice: [],
    canPlayAudio: !1,
    mutedSource: void 0,
    unmutedSource: void 0,
    isUserGrantCaptureAudio: !1,
    webrtcRestartCount: 0,
    isComputerAudioLoading: !1,
    isUsingMediaPlayback: !1,
    customizeAudioOption: {},
    localShareAudioUserMutedList: [],
    locallyMutedAudioList: [],
    localUserAudioVolumeList: [],
    isStopAllImcomingAudio: !1,
    statistic: {
        encode: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            bandwidth: 0,
            bitrate: 0
        },
        decode: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            bandwidth: 0,
            bitrate: 0
        }
    }
}, p_ = So({
    [`${Eh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.asnIds = {
            ...o
        };
    }),
    [`${Ih}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.bCanUnmute = o;
    }),
    [`${Ah}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { sequence: r, phoneNumber: i } = o;
        -1 === e.dialout.findIndex((e)=>e.sequence === r) && e.dialout.push({
            sequence: r,
            phoneNumber: i,
            returnCode: -1,
            uuid: fS()
        });
    }),
    [`${Ch}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { sequence: r, code: i, nodeId: n } = o, s = e.dialout.find((e)=>e.sequence === r);
        s && (s.returnCode = i, n && (s.phoneNodeId = n));
    }),
    [`${_h}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAllowToTalk = o, e.isAllowToTalkAttendeeConnected = !1;
    }),
    [`${nm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.mutedSource = o;
    }),
    [`${sm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.unmutedSource = o;
    }),
    [`${Rh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.audioSsrc = o;
    }),
    [`${wh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.bMutedUponEntry = o;
    }),
    [`${Th}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isUserGrantCaptureAudio = o;
    }),
    [`${Oh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isMicrophoneForbidden = o;
    }),
    [`${Dh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.webrtcRestartCount = o;
    }),
    [`${Ph}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.microphoneDevicesList = o;
    }),
    [`${Mh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.speakerDevicesList = o;
    }),
    [`${kh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.activeMicrophone = o;
    }),
    [`${Lh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.activeSpeaker = o;
    }),
    [`${Nh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.canPlayAudio = o;
    }),
    [`${Uh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isComputerAudioLoading = o;
    }),
    [`${Yh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        if (o) {
            const { speakerOnly: t1, mute: r, backgroundNoiseSuppression: i, originalSound: n, syncButtonsOnHeadset: s, mediaFile: a, microphoneId: d, speakerId: u, highBitrate: l } = o;
            e.customizeAudioOption.speakerOnly = t1, e.customizeAudioOption.mute = r, e.customizeAudioOption.microphoneId = d, e.customizeAudioOption.speakerId = u, e.isBackgroundNoiseSuppression = !!i, e.isHIDEnabled = !!s, e.originalSound = n, e.highBitrate = !!l, Qr(e.mediaPlaybackFile, a) || (e.mediaPlaybackFile = a, e.isUsingMediaPlayback = !(null == a || !a.url)), r && (e.mutedSource = dd.Inherited);
        }
    }),
    [`${jh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAllowToTalkAttendeeConnected = o;
    }),
    [`${xh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.mutedBeforeSharingAudio = o;
    }),
    [`${Gh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isSharingAudio = o;
    }),
    [`${Wh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isShareAudioMuted = o;
    }),
    [`${Bh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { userId: r, isFromMainSession: i } = o;
        -1 === e.localShareAudioUserMutedList.findIndex((e)=>e.userId === r) && e.localShareAudioUserMutedList.push({
            userId: r,
            isFromMainSession: i,
            muted: !1
        });
    }),
    [`${Fh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.localShareAudioUserMutedList.find((e)=>e.userId === o.userId);
        r && (r.muted = o.muted);
    }),
    [`${Hh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isJoinComputerAudioBeforeSharingAudio = o;
    }),
    [`${$h}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isShareAudioEnabled = o;
    }),
    [`${Kh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { data: { encoding: r, rate: i, ...n } } = o;
        e.statistic.encode = {
            bitrate: i,
            ...n
        };
    }),
    [`${zh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { data: { encoding: r, rate: i, ...n } } = o;
        e.statistic.decode = {
            bitrate: i,
            ...n
        };
    }),
    [`${qh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        -1 === e.locallyMutedAudioList.findIndex((e)=>e === o) && e.locallyMutedAudioList.push(o);
    }),
    [`${Jh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.locallyMutedAudioList.findIndex((e)=>e === o);
        -1 !== r && e.locallyMutedAudioList.splice(r, 1);
    }),
    [`${Qh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.localUserAudioVolumeList.find((e)=>e.userId === o.userId);
        r ? r.volume = o.volume : e.localUserAudioVolumeList.push(o);
    }),
    [`${Zh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.localUserAudioVolumeList.findIndex((e)=>e.userId === o.userId);
        -1 !== r && e.localUserAudioVolumeList.splice(r, 1);
    }),
    [`${Xh}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isBackgroundNoiseSuppression = o;
    }),
    [`${em}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isHIDEnabled = o;
    }),
    [`${tm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.mediaPlaybackFile = o, e.isUsingMediaPlayback = !(null == o || !o.url);
    }),
    [`${om}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isStopAllImcomingAudio = o;
    }),
    [`${rm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isVerifiedAudioPermissionOnIOSMobile = o;
    }),
    [`${im}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAudioBridgeSignalReconnecting = o;
    }),
    [`${am}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.originalSound = o;
    }),
    [`${dm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.leaveAudioSource = o;
    }),
    [`${um}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.secondaryAudioMicrophoneId = o;
    }),
    [`${lm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { sequence: r, ip: i, protocol: n } = o;
        -1 === e.crcDevice.findIndex((e)=>e.sequence === r) && e.crcDevice.push({
            sequence: r,
            ip: i,
            protocol: n,
            transId: 0,
            uuid: fS()
        });
    }),
    [`${cm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { sequence: r, transID: i, result: n } = o, s = e.crcDevice.find((e)=>e.sequence === r);
        s && Object.assign(s, {
            transId: i,
            returnCode: n
        });
    }),
    [`${Vh}`]: (e, t1)=>{
        let { dialout: o, crcDevice: r, locallyMutedAudioList: i, localUserAudioVolumeList: n, customizeAudioOption: s, originalSound: a, highBitrate: d, isHIDEnabled: u, isBackgroundNoiseSuppression: l, isStopAllImcomingAudio: c, mediaPlaybackFile: p, isUsingMediaPlayback: h, isVerifiedAudioPermissionOnIOSMobile: m, activeSpeaker: g, activeMicrophone: v } = e, { payload: f } = t1;
        return f ? {
            ...c_,
            dialout: o,
            crcDevice: r,
            locallyMutedAudioList: i,
            localUserAudioVolumeList: n,
            customizeAudioOption: {
                ...c_.customizeAudioOption,
                speakerOnly: s.speakerOnly
            },
            originalSound: a,
            highBitrate: d,
            isHIDEnabled: u,
            isBackgroundNoiseSuppression: l,
            isStopAllImcomingAudio: c,
            mediaPlaybackFile: p,
            isUsingMediaPlayback: h,
            isVerifiedAudioPermissionOnIOSMobile: m,
            activeSpeaker: g,
            activeMicrophone: v
        } : {
            ...c_
        };
    }
}, c_), h_ = {
    dialEpics0: (e, t1)=>ir(e, 8198).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            const { audio: { dialout: r } } = o, { payload: { seq: i, body: n } } = t1;
            return r.map((e)=>e.sequence).includes(i) || l_.includes(null == n ? void 0 : n.result);
        }), Be((e)=>{
            let [t1, o] = e;
            const { payload: { seq: r, body: { phoneNodeID: i, result: n } } } = t1, s = [
                Ch({
                    code: n,
                    sequence: r,
                    nodeId: i
                })
            ], { audio: { dialout: a } } = o;
            let d = a.find((e)=>e.sequence === r);
            !d && l_.includes(n) && (d = a.find((e)=>[
                    pd.Calling,
                    pd.Ringing,
                    pd.Accepted
                ].includes(e.returnCode)));
            const u = {
                code: n
            };
            if (d && (Object.assign(u, {
                phoneNumber: d.phoneNumber,
                uuid: d.uuid
            }), i && Object.assign(u, {
                userId: i
            })), ep(Ku, u), n === pd.Success) {
                if (ep(zu), i && ch(o).findIndex((e)=>e.userId === i) > -1) {
                    var l;
                    const e = null === (l = o.audio.dialout.find((e)=>e.sequence === r)) || void 0 === l ? void 0 : l.phoneNumber;
                    e && (s.push(Dp({
                        userId: i,
                        key: "phoneNumber",
                        value: e
                    })), ep(ma, [
                        {
                            userId: i,
                            phoneNumber: e
                        }
                    ]));
                }
            } else [
                pd.Canceling,
                pd.Canceled,
                pd.CancelFailed
            ].includes(n) ? n === pd.Canceled ? ep(Ju) : n === pd.CancelFailed && ep(Qu) : -1 === [
                pd.Calling,
                pd.Ringing,
                pd.Accepted,
                pd.Success
            ].indexOf(n) && ep(qu);
            return Ce(s);
        })),
    dialEpics1: (e, t1)=>ir(e, 4120).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            return o.audio.crcDevice.map((e)=>e.sequence).includes(t1.payload.seq);
        }), Be((e)=>{
            let [t1, o] = e;
            const { payload: { seq: r, body: { result: i, transID: n } } } = t1, { audio: { crcDevice: s } } = o, a = [], d = s.find((e)=>e.sequence === r);
            return d && (ep(dl, {
                code: i,
                ip: d.ip,
                protocol: d.protocol,
                uuid: d.uuid
            }), a.push(cm({
                sequence: r,
                transID: n,
                result: i
            }))), i === eu.Success ? ep(ul) : [
                eu.Success,
                eu.Ringing
            ].includes(i) || ep(ll), Ce(a);
        }))
}, m_ = {
    epics0: (e, t1)=>ir(e, 12033).pipe(vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { participants: { allowTalkAttendeesList: r } } = o, i = t1.payload.body;
            let n = {};
            if (i) {
                const e = ch(o), t1 = Object.keys(i).map((e)=>({
                        key: e,
                        userId: i[e]
                    })), s = t1.map((e)=>e.userId);
                QC(t1, s, e), r.length > 0 && s.length > 0 && QC(t1, s, r), n = t1.reduce((e, t1)=>({
                        ...e,
                        [`${t1.key}`]: {
                            userId: t1.userId,
                            displayName: t1.displayName
                        }
                    }), {}), ep(ju, Object.values(n));
            }
            return Eh(n);
        })),
    epics1: (e, t1)=>ir(e, 16135).pipe(vt(t1), gt((e)=>{
            let [t1, o] = e;
            const { payload: { body: { id: r, bLeadershipOn: i } } } = t1, { audio: { bCanUnmute: n } } = o, s = sh(o);
            if (s) {
                const { isHost: e, bCoHost: t1, userId: o, audio: a, muted: d } = s, u = e || t1;
                i && Zr(o, r) && (null !== a && "" !== a && !0 !== d || !u && !n || ep(xu, ad.Spotlight));
            }
        }), dt(ie)),
    epics2: (e, t1)=>ir(e, 12037).pipe(vt(t1), gt((e)=>{
            let [, t1] = e;
            const o = sh(t1);
            null !== (null == o ? void 0 : o.audio) && "" !== (null == o ? void 0 : o.audio) && 1 == (null == o ? void 0 : o.muted) && ep(xu, ad.Unmute);
        }), dt(ie)),
    epics3: (e, t1)=>ir(e, Ps).pipe(tt((e)=>e.payload.body && [
                "bCanUnmute",
                "bMutedAll",
                "bMutedUponEntry"
            ].some((t1)=>void 0 !== e.payload.body[t1])), Be((e)=>{
            const { payload: { body: { bCanUnmute: o, bMutedAll: r, bMutedUponEntry: i } } } = e, n = [];
            if (void 0 !== o && n.push(Ih(e.payload.body.bCanUnmute)), void 0 !== r) {
                const o = sh(t1.value);
                (null == o ? void 0 : o.audio) !== $d.Computer && (null == o ? void 0 : o.audio) !== $d.Phone || 0 != o.muted || e.payload.body.bMutedAll && n.push(nm(dd.PassiveByMuteAll));
            }
            return void 0 !== i && n.push(wh(e.payload.body.bMutedUponEntry)), Ce(n);
        })),
    epics4: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [, t1] = e;
            return t1.socket.zoomSocketStatus === yh.Connected;
        }), Be((e)=>{
            let [o, r] = e;
            const { payload: { body: { update: i } } } = o;
            if (null != i && i.some((e)=>void 0 !== e.audio || void 0 !== e.muted)) {
                const { meeting: { userId: e } } = r, o = i.filter((t1)=>t1.id !== e), n = i.filter((t1)=>t1.id === e);
                if (o && o.forEach((e)=>{
                    ep(Gu, e);
                }), n.length > 0) return Iy(t1).pipe(Be((e)=>{
                    const { audio: { mutedSource: o, unmutedSource: r, isAllowToTalk: i, isShareAudioEnabled: s, isSharingAudio: a, isAudioBridgeSignalReconnecting: d, leaveAudioSource: u, customizeAudioOption: { speakerOnly: l } } } = t1.value, c = e;
                    return Ce(n).pipe(Qy(async (e)=>{
                        const t1 = [];
                        if (e.audio !== c.audio) if ("" === e.audio) ep(Hu, {
                            source: u
                        }), t1.push(dm(void 0));
                        else if (e.audio === $d.Computer) {
                            const e = Gp(c.userRole) && !i || !!l;
                            a && ep(Bu), e && (ep(Bu), ms.isIOSMobile && t1.push(rm(!0))), d && (ep(Bu), t1.push(im(!1)));
                        } else e.audio === $d.Phone && (c.audio === $d.Computer && (await i_.leaveComputerAudio(), t1.push(dm(ld.Pstn)), r_.joinOrLeaveVoip(!1)), ep(Fu));
                        if ("" !== c.audio && e.muted !== c.muted) {
                            if (e.muted !== c.muted) {
                                if (!0 === e.muted) {
                                    if (o !== dd.Inherited) {
                                        const e = null != o ? o : dd.PassiveByMuteOne;
                                        ep($u, {
                                            source: e
                                        });
                                    }
                                    c.audio !== $d.Computer || s && !ZC() || i_.muteAudio();
                                } else if (!1 === e.muted) {
                                    if (r !== ud.Inherited) {
                                        const e = null != r ? r : ud.Passive;
                                        ep(Wu, {
                                            source: e
                                        });
                                    }
                                    c.audio === $d.Computer && i_.unmuteAudio();
                                }
                            }
                            void 0 !== e.muted && t1.push(nm(void 0), sm(void 0));
                        }
                        return t1;
                    }));
                }));
            }
            return ie;
        })),
    epics5: (e, t1)=>ir(e, 12036).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            const r = sh(o), { media: { audioEncodeStatus: i } } = o, { promoterID: n, bAllowTalk: s } = t1.payload.body;
            if ((null == r ? void 0 : r.userId) === n) {
                if (ep(ol, s), s) return "success" !== i && i_.enableAudioEncode(), Ey("audio", i, "success").pipe(Be((e)=>(e && ep(xu, ad.AllowToTalk), ie)), ct(_h(!0)));
                if (r_.mute(n, !0), (null == r ? void 0 : r.audio) === $d.Computer) return i_.leaveComputerAudio(), Qe(300).pipe(gt(async ()=>{
                    (JC() ? Te(ot(ze(document, "click").pipe(it(1)), ze(document, "touchend").pipe(it(1)))) : Promise.resolve(!0)).then(()=>{
                        GC(i_, o, !1);
                    });
                }), dt(ie), ct(_h(!1), nm(dd.Inherited)));
            }
            return ie;
        })),
    epics6: (e)=>ir(e, 8205).pipe(gt((e)=>{
            ep("AUDIO_ALLOW_TO_TALK_RESPONSE", e.payload.body);
        }), dt(ie)),
    epics7: (e, t1)=>sr(e, 24597).pipe(vt(t1), gt((e)=>{
            let [t1, o] = e;
            const r = sh(o);
            (null == r ? void 0 : r.audio) === $d.Phone ? r_.audioDrop(r.userId) : (null == r ? void 0 : r.audio) === $d.Computer && t1.payload.body.bPromote;
        }), dt(ie)),
    epics8: (e, t1)=>ir(e, 12035).pipe(vt(t1), pt((e)=>{
            let [o, r] = e;
            const { meeting: { currentUserAudioBeforeReset: i, isCurrentUserMutedBeforeReset: n, userId: s } } = r, { payload: { body: { ssrc: a } } } = o, d = Iy(t1).pipe(Be((e)=>{
                if (!(i !== $d.Computer || null != e && e.audio)) {
                    const { encodeInitStatus: o, decodeInitStatus: r } = t_(t1.value, e);
                    return Ey("audio", o, r).pipe(tt((e)=>{
                        let [t1, o] = e;
                        return t1 && o;
                    }), gt(()=>{
                        (JC() ? Te(ot(ze(document, "click").pipe(it(1)), ze(document, "touchend").pipe(it(1)))) : Promise.resolve(!0)).then(()=>{
                            o_(r_, t1.value), GC(i_, t1.value);
                        });
                        const { audio: { locallyMutedAudioList: e, localUserAudioVolumeList: o, isStopAllImcomingAudio: r } } = t1.value;
                        e.length > 0 && e.forEach((e)=>{
                            i_.muteOrUnmuteOtherAudio(e, !0);
                        }), o.length > 0 && o.forEach((e)=>{
                            i_.adjustOtherAudioVolume(e.userId, e.volume);
                        }), r && i_.stopAllIncomingAudio(!0);
                    }), st(wn(void 0)));
                }
                return i === $d.Phone && n ? (r_.mute(s, !0), Ce([
                    wn(void 0),
                    Tn(void 0)
                ])) : ie;
            }));
            return ep(nl, a), Ye(_e(Rh(a)), d);
        })),
    epics9: (e, t1)=>ir(e, 7952).pipe(pt((e)=>ip(Fu, 1).pipe(vt(t1), gt((t1)=>{
                let [, o] = t1;
                const { BindStatus: r, nOperatorUserId: i } = e.payload.body, n = o.participants.attendeesList.find((e)=>e.userId === i);
                !0 === r && ep(Zu, {
                    operatorName: null == n ? void 0 : n.displayName,
                    operatorUserId: i,
                    operatorRole: null == n ? void 0 : n.userRole
                });
            }), dt(ie)))),
    epics10: (e, t1)=>dr(e, nd.UserGrantCaptureAudio).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            const r = sh(o);
            var i;
            (i = r, (null == i ? void 0 : i.audio) === $d.Computer ? Promise.resolve() : rp({
                event: pa,
                operations: [
                    tt((e)=>void 0 !== e.audio && "" !== e.audio),
                    it(1)
                ]
            }, (e)=>{
                let { audio: t1 } = e;
                return t1 === $d.Phone || t1 === $d.Computer;
            })).then(()=>{
                ep(Bu);
            });
            const { meeting: { isCurrentUserMutedBeforeReset: n }, audio: { bMutedUponEntry: s, isUserGrantCaptureAudio: a, isAllowToTalk: d, activeMicrophone: u, isUsingMediaPlayback: l } } = o, { payload: { data: c } } = t1, p = [
                Th(!0)
            ];
            if (r) {
                !0 === r.muted && !1 === d && (p.push(nm(dd.Inherited)), r_.mute(r.userId, !0));
                const e = a || r.isHost || d;
                (!0 === n || !e && s) && (p.push(nm(dd.Inherited)), r_.mute(r.userId, !0), n && p.push(Tn(void 0))), !l && c && u !== c && p.push(kh(c));
            }
            return Ce(p);
        })),
    epics11: (e)=>dr(e, nd.UserForbiddedCaptureAudio).pipe(gt(()=>{
            ep(Yu);
        }), st(Oh(!0))),
    epics12: (e)=>dr(e, nd.AudioWebsocketBroken).pipe(gt(()=>{
            ep(Xu);
        }), dt(ie)),
    epics13: (e, t1)=>dr(e, nd.AudioZeroData).pipe(vt(t1), qy((e)=>{
            let [, t1] = e;
            const { audio: { webrtcRestartCount: o, activeMicrophone: r } } = t1;
            if (o < 3) return i_.restoreWebRTC(r), Dh(o + 1);
        })),
    epics14: (e, t1)=>e.pipe(Ot(`${Nh}`), tt((e)=>!1 === e.payload), Be(()=>(ep(el), ot(ze(document, "click").pipe(it(1)), ze(document, "touchend").pipe(it(1))).pipe(gt(()=>{
                o_(r_, t1.value), GC(i_, t1.value);
            }), st(Nh(!0)))))),
    epics15: (e)=>dr(e, [
            nd.JoinComputerAudioComplete,
            nd.JoinSharingAudioComplete,
            nd.LeaveComputerAudioComplete,
            nd.LeaveSharingAudioComplete
        ]).pipe(gt(()=>{
            Oy.completeAudioAction();
        }), dt(ie)),
    epics16: (e, t1)=>dr(e, nd.AudioQosData).pipe(vt(t1), ke((e)=>{
            var t1;
            let [o, r] = e;
            const { meeting: { isWebinar: i }, media: { audioEncodeStatus: n, audioDecodeStatus: s }, participants: { xmppAttendeeList: a, allowTalkAttendeesList: d } } = r, u = sh(r), l = gh(r);
            let c = l.length > 0, p = l.some(n_);
            const h = gs();
            i && (c = c || Boolean(a.length), p = p || d.some(n_));
            const m = ((null == u ? void 0 : u.audio) === $d.Computer || (null == u ? void 0 : u.audio) === $d.Phone) && ("success" === n || h) && !(null != u && u.muted) && c, g = ((null == u ? void 0 : u.audio) === $d.Computer || (null == u ? void 0 : u.audio) === $d.Phone) && ("success" === s || h) && c && p;
            return null !== (t1 = o.payload.data) && void 0 !== t1 && t1.encoding ? m ? (ep(il, o.payload), Kh(o.payload)) : Kh(Ld) : g ? (ep(il, o.payload), zh(o.payload)) : zh(Ld);
        })),
    epics17: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            const { payload: { body: r } } = t1, { audio: { locallyMutedAudioList: i, localUserAudioVolumeList: n } } = o;
            return (i.length > 0 || n.length > 0) && (null == r ? void 0 : r.remove) && r.remove.length > 0;
        }), Be((e)=>{
            let [t1, o] = e;
            const { payload: { body: { remove: r } } } = t1, { audio: { locallyMutedAudioList: i, localUserAudioVolumeList: n } } = o, s = i.concat(n.map((e)=>e.userId)).filter((e)=>-1 !== r.indexOf((t1)=>t1.id === e));
            return s.length > 0 ? (s.forEach((e)=>{
                i_.muteOrUnmuteOtherAudio(e, !1);
            }), Ce(s.map((e)=>[
                    Jh(e),
                    Zh({
                        userId: e
                    })
                ]).flat())) : ie;
        })),
    epics18: (e, t1)=>dr(e, nd.HidStatusMute).pipe(Be((e)=>{
            const { payload: { data: o } } = e, r = t1.value, { meeting: { userId: i }, audio: { isShareAudioEnabled: n, bCanUnmute: s } } = r, a = [];
            if (o) n && !ZC() && a.push(xh(!0)), a.push(nm(dd.Active)), r_.mute(i, !0);
            else if (!n || ZC()) {
                n && a.push(xh(!1));
                const e = sh(r);
                (s || null != e && e.isHost || null != e && e.bCoHost) && (a.push(sm(ud.Active)), r_.mute(i, !1));
            }
            return Ce(a);
        })),
    epics19: (e)=>ir(e, 12040).pipe(gt((e)=>{
            const { payload: { body: { mode: t1 } } } = e;
            i_.setAudioCodecMode(t1);
        }), dt(ie)),
    epics20: (e, t1)=>dr(e, [
            nd.AudioSpeakerSetSuccess,
            nd.JoinComputerAudioComplete,
            nd.AudioSpeakerSetError
        ]).pipe(Be((e)=>{
            const { payload: { data: o, type: r } } = e, { audio: { activeSpeaker: i, activeMicrophone: n, isUsingMediaPlayback: s } } = t1.value, a = [];
            return r === nd.AudioSpeakerSetSuccess && i !== o ? a.push(Lh(o)) : s || r !== nd.JoinComputerAudioComplete || null === o || n === o || a.push(kh(o)), r === nd.AudioSpeakerSetSuccess ? ep(sl, !0) : r === nd.AudioSpeakerSetError && ep(sl, !1), Ce(a);
        })),
    epics21: (e, t1)=>dr(e, nd.AudioLevelIndicator).pipe(tt(()=>{
            const e = sh(t1.value);
            return !!e && e.audio === $d.Computer && !e.muted;
        }), gt((e)=>{
            const { payload: { data: t1 } } = e;
            ep(cl, {
                level: t1.value
            });
        }), Be(()=>ie))
}, g_ = rr(m_, {
    shareAudioEpics0: (e, t1)=>ar(e, Ds).pipe(tt((e)=>{
            const t1 = e.payload.body.update;
            return t1 && t1.length > 0 && t1.findIndex((e)=>void 0 !== e.bShareOn) > -1;
        }), vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { payload: { body: { update: r } } } = t1, { audio: { localShareAudioUserMutedList: i } } = o, n = r.filter((e)=>!0 === e.bShareOn && !0 === e.bShareAudioOn), s = [];
            return n.length > 0 && n.forEach((e)=>{
                -1 === i.findIndex((t1)=>t1.userId === e.id) && s.push(Bh({
                    userId: e.id,
                    isFromMainSession: !!e.bShareToBORooms
                }));
            }), Ce(s);
        })),
    shareAudioEpics1: (e, t1)=>dr(e, nd.SharingDesktopStreamHaveAudio).pipe(tt(()=>!t1.value.audio.secondaryAudioMicrophoneId), pt(()=>ir(e, Ds).pipe(tt((e)=>{
                var o;
                const { payload: { body: r } } = e, { meeting: { userId: i } } = t1.value;
                return (null == r || null === (o = r.update) || void 0 === o ? void 0 : o.findIndex((e)=>e.id === i && !0 === e.bShareOn)) > -1;
            }), it(1), Qy(async ()=>{
                const e = t1.value;
                return await qC(a_, s_, e);
            }), ct($h(!0))))),
    shareAudioEpics2: (e, t1)=>dr(e, nd.SharingDesktopStreamHaveNoAudio).pipe(vt(t1), tt((e)=>{
            var t1;
            let [, o] = e;
            return !0 === (null === (t1 = o.audio) || void 0 === t1 ? void 0 : t1.isShareAudioEnabled);
        }), Qy(async (e)=>{
            let [, t1] = e;
            return await zC(a_, s_, t1);
        })),
    shareAudioEpics3: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [, t1] = e;
            return t1.socket.zoomSocketStatus === yh.Connected && !0 === t1.audio.isSharingAudio;
        }), Be((e)=>{
            var o;
            let [r, i] = e;
            if (null !== (o = r.payload.body.update) && void 0 !== o && o.some((e)=>void 0 !== e.audio || void 0 !== e.muted)) {
                const { meeting: { userId: e } } = i, o = r.payload.body.update.filter((t1)=>t1.id === e);
                return Iy(t1).pipe(Be((e)=>{
                    const t1 = [];
                    return o.findIndex((e)=>e.audio === $d.Computer) > -1 && (null == e ? void 0 : e.audio) !== $d.Computer && !ZC() && (t1.push(Hh(!0)), t1.push(xh(!0))), Ce(t1);
                }));
            }
            return ie;
        })),
    shareAudioEpics4: (e, t1)=>e.pipe(Ot(`${ym}`), Ee(ee), vt(t1), tt((e)=>{
            var t1;
            let [, o] = e;
            return !0 === (null === (t1 = o.audio) || void 0 === t1 ? void 0 : t1.isShareAudioEnabled);
        }), Qy(async (e)=>{
            let [t1, o] = e;
            const { payload: r } = t1, { audio: { isShareAudioMuted: i, isSharingAudio: n } } = o, s = [];
            if (r === fd.End) {
                const e = await zC(a_, s_, o);
                s.push(...e);
            } else if (r === fd.Paused) {
                if (!1 === i && !0 === n) {
                    await a_.leaveSharingAudio(!0), s.push(Gh(!1));
                    const e = await KC(a_, s_, o);
                    s.push(...e), setTimeout(()=>{
                        ep(rl, {
                            state: "off"
                        });
                    }, 0);
                }
            } else if (r === fd.Sharing && !1 === i && !1 === n) {
                const e = await qC(a_, s_, o);
                s.push(...e);
            }
            return s;
        })),
    shareAudioEpics5: (e, t1)=>dr(e, nd.SharingDesktopStreamHaveAudio).pipe(tt(()=>!!t1.value.audio.secondaryAudioMicrophoneId), gt(()=>{
            const { audio: { audioSsrc: e, secondaryAudioMicrophoneId: o }, meeting: { svcUrl: r, conId: i, reportDomain: n, supportLocalAB: s, abToken: a } } = t1.value;
            a_.joinSharingAudio({
                ssrc: e,
                microphoneDeviceId: o,
                speakerDeviceId: null,
                isCaptureAudio: !0,
                audioBridge: gs() ? {
                    rwgHost: r,
                    cid: i,
                    nginxHost: n,
                    abToken: a,
                    supportLocalAB: s,
                    useWebRTCOnDesktop: !ms.isAndroidOrIOSBrowser
                } : void 0
            }), ep(al);
        }), Be(()=>ie))
}, {
    audioBridgEpics0: (e)=>ir(e, 4299).pipe(gt((e)=>{
            const { payload: t1 } = e;
            u_.passThroughRWGMessage(t1);
        }), dt(ie)),
    audioBridgEpics1: (e)=>dr(e, nd.AudioBridgeReconnectStart).pipe(Be(()=>(d_.joinOrLeaveVoip(!1), Ce([
                im(!0),
                dm(ld.Failover)
            ])))),
    audioBridgEpics2: (e, t1)=>dr(e, nd.AudioBridgeReconnectEnd).pipe(gt(()=>{
            o_(d_, t1.value);
        }), dt(ie)),
    audioBridgEpics3: (e)=>ir(e, Ds).pipe(tt((e)=>{
            var t1, o;
            return gs() && ((null === (t1 = e.payload.body.update) || void 0 === t1 ? void 0 : t1.some((e)=>void 0 !== e.muted)) || (null === (o = e.payload.body.remove) || void 0 === o ? void 0 : o.length) > 0);
        }), gt((e)=>{
            const { payload: { body: { update: t1, remove: o } } } = e;
            u_.sendUserAudioStatus({
                update: (t1 || []).filter((e)=>void 0 !== e.muted).map((e)=>({
                        userId: e.id,
                        muted: e.muted
                    })),
                remove: (o || []).map((e)=>({
                        userId: e.id
                    }))
            });
        }), dt(ie)),
    audioBridgEpics4: (e, t1)=>dr(e, nd.NotifyUIFailover).pipe(tt(()=>!t1.value.meeting.isMeetingReset && t1.value.meeting.meetingStatus === Yn.Joined), ke(()=>(ep(ba, {
                reason: qn.Failover
            }), nn(es.NotifyUiFailover)))),
    audioBridgEpics5: (e, t1)=>ur(e, t1).pipe(tt(()=>{
            const { meeting: { isAudioBridgeEnabled: e, abToken: o } } = t1.value;
            return e && gs() && !!o;
        }), gt(()=>{
            const { meeting: { abToken: e, svcUrl: o, reportDomain: r, conId: i, supportLocalAB: n } } = t1.value;
            u_.preInitAudioBridge({
                abToken: e,
                rwgHost: o,
                cid: i,
                nginxHost: r,
                supportLocalAB: n,
                useWebRTCOnDesktop: !ms.isAndroidOrIOSBrowser
            });
        }), dt(ie)),
    audioBridgEpics6: (e, t1)=>ir(e, 16129).pipe(tt((e)=>{
            const { payload: { body: { bVideoOn: o } } } = e, { meeting: { isAudioBridgeEnabled: r } } = t1.value;
            return r && gs() && !!o;
        }), gt((e)=>{
            const { payload: { body: { id: t1 } } } = e;
            u_.changeActiveVideoSsrc(t1);
        }), dt(ie)),
    audioBridgEpics7: (e, t1)=>dr(e, [
            nd.RecoverWebrtcAudio,
            nd.AudioStreamFailed
        ]).pipe(Be(()=>{
            const e = sh(t1.value), o = [];
            return (null == e ? void 0 : e.audio) === $d.Computer && (u_.leaveComputerAudio(), JC() || ms.isIOSMobile ? (d_.joinOrLeaveVoip(!1), o.push(dm(ld.EndedBySystem)), o.push(Dh(0))) : GC(u_, t1.value)), Ce(o);
        })),
    audioBridgEpics8: (e)=>dr(e, [
            nd.AudioBridgeFirstRecvData,
            nd.AudioBridgeCanSendData
        ]).pipe(ke((e)=>{
            const { payload: { type: t1 } } = e;
            return t1 === nd.AudioBridgeFirstRecvData ? (ep(cc), Qo(!0)) : (ep(pc), Zo(!0));
        })),
    audioBridgEpics9: (e, t1)=>e.pipe(Ot(`${cn}`), tt(()=>!!t1.value.meeting.zlkJwtToken), gt(()=>{
            const { meeting: { zlkJwtToken: e } } = t1.value;
            if (e) {
                const { enforce_web_rtc_audio: t1, audio_compatible_mode: o } = ti(e);
                void 0 === t1 && void 0 === o || is.set(as.EnforceWebRTCAudio, 1 === Number(t1) || 1 === Number(o), os.Memory);
            }
        }), dt(ie))
}, h_);
var v_ = Array.isArray;
function f_(e) {
    if (!yS(e)) return !1;
    var t1 = MS(e);
    return "[object Function]" == t1 || "[object GeneratorFunction]" == t1 || "[object AsyncFunction]" == t1 || "[object Proxy]" == t1;
}
var y_, S_ = ES["__core-js_shared__"], b_ = (y_ = /[^.]+$/.exec(S_ && S_.keys && S_.keys.IE_PROTO || "")) ? "Symbol(src)_1." + y_ : "", E_ = Function.prototype.toString;
function I_(e) {
    if (null != e) {
        try {
            return E_.call(e);
        } catch (e) {}
        try {
            return e + "";
        } catch (e) {}
    }
    return "";
}
var A_ = /^\[object .+?Constructor\]$/, C_ = Function.prototype, __ = Object.prototype, R_ = C_.toString, w_ = __.hasOwnProperty, T_ = RegExp("^" + R_.call(w_).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function O_(e, t1) {
    var o = function(e, t1) {
        return null == e ? void 0 : e[t1];
    }(e, t1);
    return function(e) {
        return !(!yS(e) || (t1 = e, b_ && b_ in t1)) && (f_(e) ? T_ : A_).test(I_(e));
        "TURBOPACK unreachable";
        var t1;
    }(o) ? o : void 0;
}
var D_ = O_(ES, "WeakMap"), P_ = /^(?:0|[1-9]\d*)$/;
function M_(e, t1) {
    var o = typeof e;
    return !!(t1 = null == t1 ? 9007199254740991 : t1) && ("number" == o || "symbol" != o && P_.test(e)) && e > -1 && e % 1 == 0 && e < t1;
}
function k_(e, t1) {
    return e === t1 || e != e && t1 != t1;
}
function L_(e) {
    return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991;
}
function N_(e) {
    return null != e && L_(e.length) && !f_(e);
}
var V_ = Object.prototype;
function U_(e) {
    var t1 = e && e.constructor;
    return e === ("function" == typeof t1 && t1.prototype || V_);
}
function j_(e) {
    return kS(e) && "[object Arguments]" == MS(e);
}
var x_ = Object.prototype, B_ = x_.hasOwnProperty, F_ = x_.propertyIsEnumerable, H_ = j_(function() {
    return arguments;
}()) ? j_ : function(e) {
    return kS(e) && B_.call(e, "callee") && !F_.call(e, "callee");
}, $_ = "object" == ("TURBOPACK compile-time value", "undefined") && exports && !exports.nodeType && exports, W_ = $_ && "object" == ("TURBOPACK compile-time value", "undefined") && module && !module.nodeType && module, G_ = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : void 0, K_ = (G_ ? G_.isBuffer : void 0) || function() {
    return !1;
}, z_ = {};
z_["[object Float32Array]"] = z_["[object Float64Array]"] = z_["[object Int8Array]"] = z_["[object Int16Array]"] = z_["[object Int32Array]"] = z_["[object Uint8Array]"] = z_["[object Uint8ClampedArray]"] = z_["[object Uint16Array]"] = z_["[object Uint32Array]"] = !0, z_["[object Arguments]"] = z_["[object Array]"] = z_["[object ArrayBuffer]"] = z_["[object Boolean]"] = z_["[object DataView]"] = z_["[object Date]"] = z_["[object Error]"] = z_["[object Function]"] = z_["[object Map]"] = z_["[object Number]"] = z_["[object Object]"] = z_["[object RegExp]"] = z_["[object Set]"] = z_["[object String]"] = z_["[object WeakMap]"] = !1;
var q_, J_ = "object" == ("TURBOPACK compile-time value", "undefined") && exports && !exports.nodeType && exports, Q_ = J_ && "object" == ("TURBOPACK compile-time value", "undefined") && module && !module.nodeType && module, Z_ = Q_ && Q_.exports === J_ && SS.process, Y_ = function() {
    try {
        return Q_ && Q_.require && Q_.require("util").types || Z_ && Z_.binding && Z_.binding("util");
    } catch (e) {}
}(), X_ = Y_ && Y_.isTypedArray, eR = X_ ? (q_ = X_, function(e) {
    return q_(e);
}) : function(e) {
    return kS(e) && L_(e.length) && !!z_[MS(e)];
}, tR = Object.prototype.hasOwnProperty;
var oR = function(e, t1) {
    return function(o) {
        return e(t1(o));
    };
}(Object.keys, Object), rR = Object.prototype.hasOwnProperty;
function iR(e) {
    if (!U_(e)) return oR(e);
    var t1 = [];
    for(var o in Object(e))rR.call(e, o) && "constructor" != o && t1.push(o);
    return t1;
}
function nR(e) {
    return N_(e) ? function(e) {
        var t1 = v_(e), o = !t1 && H_(e), r = !t1 && !o && K_(e), i = !t1 && !o && !r && eR(e), n = t1 || o || r || i, s = n ? function(e, t1) {
            for(var o = -1, r = Array(e); ++o < e;)r[o] = t1(o);
            return r;
        }(e.length, String) : [], a = s.length;
        for(var d in e)!tR.call(e, d) || n && ("length" == d || r && ("offset" == d || "parent" == d) || i && ("buffer" == d || "byteLength" == d || "byteOffset" == d) || M_(d, a)) || s.push(d);
        return s;
    }(e) : iR(e);
}
var sR = O_(Object, "create"), aR = Object.prototype.hasOwnProperty, dR = Object.prototype.hasOwnProperty;
function uR(e) {
    var t1 = -1, o = null == e ? 0 : e.length;
    for(this.clear(); ++t1 < o;){
        var r = e[t1];
        this.set(r[0], r[1]);
    }
}
function lR(e, t1) {
    for(var o = e.length; o--;)if (k_(e[o][0], t1)) return o;
    return -1;
}
uR.prototype.clear = function() {
    this.__data__ = sR ? sR(null) : {}, this.size = 0;
}, uR.prototype.delete = function(e) {
    var t1 = this.has(e) && delete this.__data__[e];
    return this.size -= t1 ? 1 : 0, t1;
}, uR.prototype.get = function(e) {
    var t1 = this.__data__;
    if (sR) {
        var o = t1[e];
        return "__lodash_hash_undefined__" === o ? void 0 : o;
    }
    return aR.call(t1, e) ? t1[e] : void 0;
}, uR.prototype.has = function(e) {
    var t1 = this.__data__;
    return sR ? void 0 !== t1[e] : dR.call(t1, e);
}, uR.prototype.set = function(e, t1) {
    var o = this.__data__;
    return this.size += this.has(e) ? 0 : 1, o[e] = sR && void 0 === t1 ? "__lodash_hash_undefined__" : t1, this;
};
var cR = Array.prototype.splice;
function pR(e) {
    var t1 = -1, o = null == e ? 0 : e.length;
    for(this.clear(); ++t1 < o;){
        var r = e[t1];
        this.set(r[0], r[1]);
    }
}
pR.prototype.clear = function() {
    this.__data__ = [], this.size = 0;
}, pR.prototype.delete = function(e) {
    var t1 = this.__data__, o = lR(t1, e);
    return !(o < 0 || (o == t1.length - 1 ? t1.pop() : cR.call(t1, o, 1), --this.size, 0));
}, pR.prototype.get = function(e) {
    var t1 = this.__data__, o = lR(t1, e);
    return o < 0 ? void 0 : t1[o][1];
}, pR.prototype.has = function(e) {
    return lR(this.__data__, e) > -1;
}, pR.prototype.set = function(e, t1) {
    var o = this.__data__, r = lR(o, e);
    return r < 0 ? (++this.size, o.push([
        e,
        t1
    ])) : o[r][1] = t1, this;
};
var hR = O_(ES, "Map");
function mR(e, t1) {
    var o, r, i = e.__data__;
    return ("string" == (r = typeof (o = t1)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== o : null === o) ? i["string" == typeof t1 ? "string" : "hash"] : i.map;
}
function gR(e) {
    var t1 = -1, o = null == e ? 0 : e.length;
    for(this.clear(); ++t1 < o;){
        var r = e[t1];
        this.set(r[0], r[1]);
    }
}
function vR(e) {
    var t1 = this.__data__ = new pR(e);
    this.size = t1.size;
}
gR.prototype.clear = function() {
    this.size = 0, this.__data__ = {
        hash: new uR,
        map: new (hR || pR),
        string: new uR
    };
}, gR.prototype.delete = function(e) {
    var t1 = mR(this, e).delete(e);
    return this.size -= t1 ? 1 : 0, t1;
}, gR.prototype.get = function(e) {
    return mR(this, e).get(e);
}, gR.prototype.has = function(e) {
    return mR(this, e).has(e);
}, gR.prototype.set = function(e, t1) {
    var o = mR(this, e), r = o.size;
    return o.set(e, t1), this.size += o.size == r ? 0 : 1, this;
}, vR.prototype.clear = function() {
    this.__data__ = new pR, this.size = 0;
}, vR.prototype.delete = function(e) {
    var t1 = this.__data__, o = t1.delete(e);
    return this.size = t1.size, o;
}, vR.prototype.get = function(e) {
    return this.__data__.get(e);
}, vR.prototype.has = function(e) {
    return this.__data__.has(e);
}, vR.prototype.set = function(e, t1) {
    var o = this.__data__;
    if (o instanceof pR) {
        var r = o.__data__;
        if (!hR || r.length < 199) return r.push([
            e,
            t1
        ]), this.size = ++o.size, this;
        o = this.__data__ = new gR(r);
    }
    return o.set(e, t1), this.size = o.size, this;
};
var fR = Object.prototype.propertyIsEnumerable, yR = Object.getOwnPropertySymbols, SR = yR ? function(e) {
    return null == e ? [] : (e = Object(e), function(e, t1) {
        for(var o = -1, r = null == e ? 0 : e.length, i = 0, n = []; ++o < r;){
            var s = e[o];
            t1(s) && (n[i++] = s);
        }
        return n;
    }(yR(e), function(t1) {
        return fR.call(e, t1);
    }));
} : function() {
    return [];
};
function bR(e) {
    return function(e, t1, o) {
        var r = nR(e);
        return v_(e) ? r : function(e, t1) {
            for(var o = -1, r = t1.length, i = e.length; ++o < r;)e[i + o] = t1[o];
            return e;
        }(r, o(e));
    }(e, 0, SR);
}
var ER = O_(ES, "DataView"), IR = O_(ES, "Promise"), AR = O_(ES, "Set"), CR = "[object Map]", _R = "[object Promise]", RR = "[object Set]", wR = "[object WeakMap]", TR = "[object DataView]", OR = I_(ER), DR = I_(hR), PR = I_(IR), MR = I_(AR), kR = I_(D_), LR = MS;
(ER && LR(new ER(new ArrayBuffer(1))) != TR || hR && LR(new hR) != CR || IR && LR(IR.resolve()) != _R || AR && LR(new AR) != RR || D_ && LR(new D_) != wR) && (LR = function(e) {
    var t1 = MS(e), o = "[object Object]" == t1 ? e.constructor : void 0, r = o ? I_(o) : "";
    if (r) switch(r){
        case OR:
            return TR;
        case DR:
            return CR;
        case PR:
            return _R;
        case MR:
            return RR;
        case kR:
            return wR;
    }
    return t1;
});
var NR = ES.Uint8Array;
function VR(e) {
    var t1 = -1, o = null == e ? 0 : e.length;
    for(this.__data__ = new gR; ++t1 < o;)this.add(e[t1]);
}
function UR(e, t1) {
    for(var o = -1, r = null == e ? 0 : e.length; ++o < r;)if (t1(e[o], o, e)) return !0;
    return !1;
}
function jR(e, t1, o, r, i, n) {
    var s = 1 & o, a = e.length, d = t1.length;
    if (a != d && !(s && d > a)) return !1;
    var u = n.get(e), l = n.get(t1);
    if (u && l) return u == t1 && l == e;
    var c = -1, p = !0, h = 2 & o ? new VR : void 0;
    for(n.set(e, t1), n.set(t1, e); ++c < a;){
        var m = e[c], g = t1[c];
        if (r) var v = s ? r(g, m, c, t1, e, n) : r(m, g, c, e, t1, n);
        if (void 0 !== v) {
            if (v) continue;
            p = !1;
            break;
        }
        if (h) {
            if (!UR(t1, function(e, t1) {
                if (s = t1, !h.has(s) && (m === e || i(m, e, o, r, n))) return h.push(t1);
                var s;
            })) {
                p = !1;
                break;
            }
        } else if (m !== g && !i(m, g, o, r, n)) {
            p = !1;
            break;
        }
    }
    return n.delete(e), n.delete(t1), p;
}
function xR(e) {
    var t1 = -1, o = Array(e.size);
    return e.forEach(function(e, r) {
        o[++t1] = [
            r,
            e
        ];
    }), o;
}
function BR(e) {
    var t1 = -1, o = Array(e.size);
    return e.forEach(function(e) {
        o[++t1] = e;
    }), o;
}
VR.prototype.add = VR.prototype.push = function(e) {
    return this.__data__.set(e, "__lodash_hash_undefined__"), this;
}, VR.prototype.has = function(e) {
    return this.__data__.has(e);
};
var FR = _S ? _S.prototype : void 0, HR = FR ? FR.valueOf : void 0, $R = Object.prototype.hasOwnProperty, WR = "[object Arguments]", GR = "[object Array]", KR = "[object Object]", zR = Object.prototype.hasOwnProperty;
function qR(e, t1, o, r, i) {
    return e === t1 || (null == e || null == t1 || !kS(e) && !kS(t1) ? e != e && t1 != t1 : function(e, t1, o, r, i, n) {
        var s = v_(e), a = v_(t1), d = s ? GR : LR(e), u = a ? GR : LR(t1), l = (d = d == WR ? KR : d) == KR, c = (u = u == WR ? KR : u) == KR, p = d == u;
        if (p && K_(e)) {
            if (!K_(t1)) return !1;
            s = !0, l = !1;
        }
        if (p && !l) return n || (n = new vR), s || eR(e) ? jR(e, t1, o, r, i, n) : function(e, t1, o, r, i, n, s) {
            switch(o){
                case "[object DataView]":
                    if (e.byteLength != t1.byteLength || e.byteOffset != t1.byteOffset) return !1;
                    e = e.buffer, t1 = t1.buffer;
                case "[object ArrayBuffer]":
                    return !(e.byteLength != t1.byteLength || !n(new NR(e), new NR(t1)));
                case "[object Boolean]":
                case "[object Date]":
                case "[object Number]":
                    return k_(+e, +t1);
                case "[object Error]":
                    return e.name == t1.name && e.message == t1.message;
                case "[object RegExp]":
                case "[object String]":
                    return e == t1 + "";
                case "[object Map]":
                    var a = xR;
                case "[object Set]":
                    var d = 1 & r;
                    if (a || (a = BR), e.size != t1.size && !d) return !1;
                    var u = s.get(e);
                    if (u) return u == t1;
                    r |= 2, s.set(e, t1);
                    var l = jR(a(e), a(t1), r, i, n, s);
                    return s.delete(e), l;
                case "[object Symbol]":
                    if (HR) return HR.call(e) == HR.call(t1);
            }
            return !1;
        }(e, t1, d, o, r, i, n);
        if (!(1 & o)) {
            var h = l && zR.call(e, "__wrapped__"), m = c && zR.call(t1, "__wrapped__");
            if (h || m) {
                var g = h ? e.value() : e, v = m ? t1.value() : t1;
                return n || (n = new vR), i(g, v, o, r, n);
            }
        }
        return !!p && (n || (n = new vR), function(e, t1, o, r, i, n) {
            var s = 1 & o, a = bR(e), d = a.length;
            if (d != bR(t1).length && !s) return !1;
            for(var u = d; u--;){
                var l = a[u];
                if (!(s ? l in t1 : $R.call(t1, l))) return !1;
            }
            var c = n.get(e), p = n.get(t1);
            if (c && p) return c == t1 && p == e;
            var h = !0;
            n.set(e, t1), n.set(t1, e);
            for(var m = s; ++u < d;){
                var g = e[l = a[u]], v = t1[l];
                if (r) var f = s ? r(v, g, l, t1, e, n) : r(g, v, l, e, t1, n);
                if (!(void 0 === f ? g === v || i(g, v, o, r, n) : f)) {
                    h = !1;
                    break;
                }
                m || (m = "constructor" == l);
            }
            if (h && !m) {
                var y = e.constructor, S = t1.constructor;
                y == S || !("constructor" in e) || !("constructor" in t1) || "function" == typeof y && y instanceof y && "function" == typeof S && S instanceof S || (h = !1);
            }
            return n.delete(e), n.delete(t1), h;
        }(e, t1, o, r, i, n));
    }(e, t1, o, r, qR, i));
}
var JR = Object.prototype.hasOwnProperty;
const QR = (e)=>4294966272 & e, ZR = (e)=>{
    let t1 = {
        R: 0,
        G: 0,
        B: 0,
        A: 0
    };
    if ("string" == typeof e && e.startsWith("#")) {
        const a = e.slice(1);
        try {
            if (3 === a.length) {
                const e = Array.from(a).map((e)=>e.repeat(2)).map((e)=>parseInt(e, 16));
                t1 = {
                    R: e[0] / 255,
                    G: e[1] / 255,
                    B: e[2] / 255,
                    A: 1
                };
            } else if (6 === a.length || 8 === a.length) {
                var o, r, i, n, s;
                const e = null === (o = a.match(/\S{2}/g)) || void 0 === o ? void 0 : o.map((e)=>parseInt(e, 16));
                t1 = {
                    R: (null !== (r = null == e ? void 0 : e[0]) && void 0 !== r ? r : 0) / 255,
                    G: (null !== (i = null == e ? void 0 : e[1]) && void 0 !== i ? i : 0) / 255,
                    B: (null !== (n = null == e ? void 0 : e[2]) && void 0 !== n ? n : 0) / 255,
                    A: null != e && e[3] ? (null !== (s = null == e ? void 0 : e[3]) && void 0 !== s ? s : 0) / 255 : 1
                };
            }
        } catch (t1) {
            console.warn("error color representation:", e);
        }
    } else "object" == typeof e && (t1 = {
        R: e.R / 255,
        G: e.G / 255,
        B: e.B / 255,
        A: e.A || 1
    });
    return t1;
};
function YR(e) {
    let { captureWidth: t1 = 0, captureHeight: o = 0 } = e || {};
    const { hd: r } = e || {};
    var i, n;
    return 0 !== t1 && 0 !== o || (r && la.isSupportSending720P() ? (t1 = 1280, o = 720) : (t1 = 640, o = 360)), {
        captureWidth: t1,
        captureHeight: o,
        isCustomizedResolution: !(null == e || !e.captureWidth || !e.captureHeight || (i = t1, n = o, Math.abs(Math.floor(i / n * 10) - Math.floor(16 / 9 * 10)) <= 1))
    };
}
function XR(e, t1) {
    return "default" === e || t1.some((t1)=>t1.deviceId === e) || [
        Rd.Environment,
        Rd.User,
        Rd.Left,
        Rd.Right
    ].includes(e);
}
function ew(e, t1) {
    if ("function" == typeof DOMMatrixReadOnly) {
        const o = new DOMMatrixReadOnly(getComputedStyle(e).transform).scale(-1, 1).toString();
        e.style.transform = o, e.dataset.mirrored = t1 ? "1" : "0";
    }
}
function tw(e, t1, o) {
    const r = [], { video: { videoSsrc: i, activeCamera: n } } = t1, { cameraId: s = n, videoElement: a, originalRatio: d, ptz: u, hd: l, fullHd: c, mediaFile: p, fps: h, mirrored: m } = o || {};
    let g;
    if (void 0 !== a) {
        let e = a instanceof HTMLVideoElement ? a : null;
        if ("string" == typeof a) {
            let [t1, o] = [
                document.body,
                a
            ];
            if (a.indexOf(">") > -1) {
                const [e, r] = a.split(">");
                t1 = document.querySelector(e), o = r;
            }
            t1 && (e = t1.querySelector(o));
        }
        if (!e) return [];
        g = e, e.id || (e.id = Xr("__ZOOM_SDK_SELF_VIDEO_@__")), m && "1" !== e.dataset.mirrored && ew(e, m);
    }
    let v = null != h ? h : qd.Default;
    v = Math.max(qd.Min, v), v = Math.min(qd.Max, v);
    const { captureWidth: f, captureHeight: y, isCustomizedResolution: S } = YR(o);
    if (S) e.updateVideoHDValue(!1);
    else {
        e.updateVideoHDValue(!!l || !!c);
        const t1 = !!c && la.isSupportFullHDVideo();
        e.updateVideoFullhdValue(t1);
    }
    let b = Promise.resolve(s);
    if (p && p.url) {
        const e = $y.getInstance();
        b = e.setVideoElement(p).then(()=>e.videoElement);
    } else $y.getInstance().stopVideoElement();
    return b.then((t1)=>{
        e.startCaptureVideo(i, t1, f, y, g, ms.isAndroidOrIOSBrowser && wd.includes(t1), !d && function() {
            var e, t1;
            const { isAndroidOrIOSBrowser: o, isFirefox: r, isSafari: i } = ms;
            return o || !(null !== (e = navigator.mediaDevices) && void 0 !== e && null !== (t1 = e.getSupportedConstraints) && void 0 !== t1 && t1.call(e).aspectRatio) || r || i || Ss();
        }(), u, v);
    }), r.push(Cg({
        cameraId: s,
        captureWidth: f,
        captureHeight: y,
        videoElement: "string" == typeof a ? a : a instanceof HTMLVideoElement ? ni(a) : void 0,
        originalRatio: d,
        ptz: u,
        hd: l,
        fullHd: c,
        mediaFile: p,
        fps: v,
        mirrored: m
    })), r;
}
function ow(e, t1, o) {
    const { max: r, min: i, step: n } = e;
    let s = o / 100 * (r - i);
    n && (s = Math.min(Math.floor(s / n) * n, Math.floor(s)));
    let a = t1 + s;
    return a = Math.min(r, a), a = Math.max(i, a), a;
}
function rw(e, t1) {
    let o = "", r = t1;
    switch(e){
        case Ud.Down:
            r = -t1, o = "tilt";
            break;
        case Ud.Up:
            o = "tilt";
            break;
        case Ud.Left:
            r = -t1, o = "pan";
            break;
        case Ud.Right:
            o = "pan";
            break;
        case Ud.ZoomIn:
            o = "zoom";
            break;
        case Ud.ZoomOut:
            r = -t1, o = "zoom";
    }
    return {
        key: o,
        range: r
    };
}
function iw(e) {
    const t1 = [
        "pan",
        "tilt",
        "zoom"
    ].reduce((t1, o)=>e[o] && 0 !== e[o].value ? {
            ...t1,
            [o]: e[o].value
        } : t1, {});
    return function(e) {
        if (null == e) return !0;
        if (N_(e) && (v_(e) || "string" == typeof e || "function" == typeof e.splice || K_(e) || eR(e) || H_(e))) return !e.length;
        var t1 = LR(e);
        if ("[object Map]" == t1 || "[object Set]" == t1) return !e.size;
        if (U_(e)) return !iR(e).length;
        for(var o in e)if (JR.call(e, o)) return !1;
        return !0;
    }(t1) ? null : t1;
}
function nw(e) {
    return {
        pan: (e & jd.Pan) === jd.Pan,
        tilt: (e & jd.Tilt) === jd.Tilt,
        zoom: (e & jd.Zoom) === jd.Zoom
    };
}
function sw(e) {
    const { isAndroidBrowser: t1, isIOSMobile: o, isFirefox: r, isSupportMediaStreamTrackProcessor: i, isSupportOffscreenCanvas: n } = ms, s = t1 && !r, a = i && n, d = "function" != typeof window.SharedArrayBuffer && s && a;
    return o && "function" == typeof VideoFrame || d || !fs() && a && !e && !wy();
}
function aw(e, t1, o) {
    const { meeting: { userId: r }, video: { isSupportHDVideo: i, renderedVideoList: n, maximumNumbeOfHDSubscriptions: s, receivedVideoMaxQuality: a } } = o, d = e === r;
    let u = t1;
    if (t1 >= yd.Video_720P) if (i) {
        const t1 = n.filter((e)=>e.videoQuality === yd.Video_720P).map((e)=>e.userId), o = null != s ? s : 1;
        t1.length >= o && (t1.includes(e) || d || (console.warn(`Warning: Web Video SDK currently only supports subscribing to ${o} 720p video stream, so quality has been downgraded to 360p`), u = yd.Video_360P));
    } else console.warn("Can not subscribe 720P video stream,will downgrade to 360P stream"), u = yd.Video_360P;
    const l = Math.max(a, yd.Video_360P);
    return [
        u,
        Math.min(u, l)
    ];
}
const dw = ra.createAgent(), uw = fE(la.getInstance());
let lw, cw;
async function pw(e, t1, o) {
    const r = Xr(e), i = document.createElement("img");
    return i.src = t1, i.id = r, i.style.display = "none", ei(t1) && i.setAttribute("crossorigin", ""), await new Promise((e, r)=>{
        i.onload = ()=>{
            o && URL.revokeObjectURL(t1), e("");
        }, i.onerror = ()=>{
            o && URL.revokeObjectURL(t1), r("Cannot load  image.");
        };
    }), {
        imageId: r,
        imgElement: i
    };
}
async function hw(e, t1, o) {
    if (e === _d) return _d;
    {
        let r = e;
        if (t1) {
            const t1 = await function(e) {
                return new Promise((t1, o)=>{
                    try {
                        lw && cw || (lw = document.createElement("canvas"), cw = lw.getContext("2d"));
                        const r = lw, i = cw;
                        if (i) {
                            i.clearRect(0, 0, lw.width, lw.height);
                            const n = new Image;
                            n.src = e, ei(e) && (n.crossOrigin = "");
                            const s = 16 / 9, a = 1280, d = Math.floor(a / s);
                            r.width = a, r.height = d, n.onload = ()=>{
                                const { width: e, height: u } = n, l = u * s;
                                if (l > e) {
                                    const t1 = e, o = Math.floor(e / s), r = 0, l = (u - o) / 2;
                                    null == i || i.drawImage(n, r, l, t1, o, 0, 0, a, d);
                                } else {
                                    const t1 = l, o = u, r = (e - t1) / 2, s = 0;
                                    i.drawImage(n, r, s, t1, o, 0, 0, a, d);
                                }
                                try {
                                    r.toBlob((e)=>{
                                        t1(e);
                                    });
                                } catch (e) {
                                    e instanceof DOMException && e.code === DOMException.SECURITY_ERR && console.error("Image is not from the same origin, add CORS header to solve this issue"), o(e);
                                }
                            }, n.onerror = (e)=>{
                                o("Cannot load  image.");
                            };
                        }
                    } catch (e) {
                        o(e);
                    }
                });
            }(e);
            r = URL.createObjectURL(t1);
        }
        if (r) {
            const { imageId: e, imgElement: i } = await pw("__ZOOM_SDK_VIRTUAL_BACKGROUND_IMAGE_@__", r, !!t1);
            return (null != o ? o : document.body).appendChild(i), e;
        }
    }
    return null;
}
async function mw(e, t1, o) {
    var r;
    const i = null !== (r = o && o.parentNode) && void 0 !== r ? r : document.body, { imageUrl: n, cropped: s, rootWidth: a, rootHeight: d } = e;
    let u = e;
    !t1.video.customizedVideoOption || e.captureWidth && e.captureHeight || (u = t1.video.customizedVideoOption);
    const { captureWidth: l, captureHeight: c } = YR(u), p = document.createElement("div");
    let h;
    p.style.display = "none", h = n ? await hw(n, s, p) : null;
    let m, g = Xr("__ZOOM_SDK_VIRTUAL_BACKGROUND_CANVAS_@__");
    if (o) {
        const t1 = Ry(o);
        t1.id ? g = t1.id : t1.id = g, m = t1;
        try {
            a && o.width !== a && (o.width = a), d && o.height !== d && (o.height = d);
        } catch (e) {
            console.warn("Cannot set the canvas width/height, and pay attention the canvas dimension is different from the setting");
        }
    } else {
        const e = document.createElement("canvas");
        e.width = null != a ? a : 380, e.height = null != d ? d : 214, e.id = g, m = e, p.appendChild(e);
    }
    return null == i || i.appendChild(p), {
        captureWidth: l,
        captureHeight: c,
        imageId: h,
        canvas: m,
        divElement: p
    };
}
async function gw(e, t1, o, r) {
    const i = Array.isArray(e) ? e : e && [
        e
    ];
    if ((null == i ? void 0 : i.length) > 0) {
        lw && cw || (lw = document.createElement("canvas"), cw = lw.getContext("2d"));
        const n = lw, s = cw;
        if (n.width = t1, n.height = o, s) try {
            s.fillStyle = "#fff", s.clearRect(0, 0, t1, o);
            for(let e = 0; e < i.length; e++){
                const t1 = i[e], { type: o, x: r, y: n } = t1;
                if ("rectangle" === o) {
                    const { width: e, height: o } = t1;
                    s.fillRect(r, n, e, o);
                } else if ("square" === o) {
                    const { length: e } = t1;
                    s.fillRect(r, n, e, e);
                } else if ("circle" === o) {
                    const { radius: e } = t1;
                    s.beginPath(), s.arc(r, n, e, 0, 2 * Math.PI), s.fill();
                } else if ("svg" === o) {
                    const { svg: e, width: o, height: i } = t1, a = new Image;
                    a.src = e, ei(e) && (a.crossOrigin = ""), await new Promise((e, t1)=>{
                        a.onload = ()=>{
                            e("");
                        }, a.onerror = ()=>{
                            t1();
                        };
                    });
                    const { width: d, height: u } = a;
                    s.drawImage(a, 0, 0, d, u, r, n, o, i);
                }
            }
            const e = await new Promise((e)=>{
                null == n || n.toBlob((t1)=>{
                    e(t1);
                });
            });
            if (e) {
                const t1 = URL.createObjectURL(e), { imageId: o, imgElement: i } = await pw("__ZOOM_SDK_MASK_CLIP_@__", t1, !0);
                return (null != r ? r : document.body).appendChild(i), o;
            }
        } catch (e) {
            e instanceof DOMException && e.code === DOMException.SECURITY_ERR && console.error("Image is not from the same origin, add CORS header to solve this issue");
        }
    }
    return null;
}
function vw(e, t1) {
    if (e === t1) return !0;
    if (null == e && null == t1) return !0;
    const o = Array.isArray(e) ? [
        ...e
    ] : [
        e
    ], r = Array.isArray(t1) ? [
        ...t1
    ] : [
        t1
    ];
    if (o.length !== r.length) return !1;
    const i = (e, t1)=>e.type < t1.type ? -1 : e.type === t1.type ? 0 : 1;
    o.sort(i), r.sort(i);
    for(let e = 0; e < o.length; e++)if (!Qr(o[e], r[e])) return !1;
    return !0;
}
function fw(e, t1, o, r) {
    const { video: { isCurrentUserStartedVideo: i, virtualBackground: { isVBPreloadReady: n, isVBConfigured: s, imageSrc: a }, backgroundMode: d }, meeting: { isCurrentUserStartVideoBeforeReset: u } } = o;
    return Te(function(e) {
        return void 0 !== e ? Ce([
            e
        ]) : ip(bu, 1).pipe(ke((e)=>e));
    }(n)).then((n)=>n ? r || !s && e.imageUrl !== _d && e.imageUrl ? (async function(e, t1, o, r) {
            const { canvas: i, imageId: n, captureHeight: s, captureWidth: a, divElement: d } = await mw(e, o, r), { cameraId: u } = e, { video: { videoSsrc: l, activeCamera: c } } = o;
            return t1.startVirtualBackgroundSetting(i, n, l, null != u ? u : c, a, s), d;
        })(e, t1, o, r).then((e)=>i ? Sg(!0) : Te(ip(Eu, 1)).then((o)=>{
                var i;
                return r || t1.stopVirtualBackgroundSetting(), o ? (null == e || null === (i = e.parentNode) || void 0 === i || i.removeChild(e), !0) : Promise.reject("Cannot access the virtual background image.");
            })) : a === e.imageUrl && d === Hd.VirtualBackground && !u || async function(e, t1, o) {
            const { imageUrl: r, cropped: i } = e;
            if (r) {
                const e = await hw(r, i);
                e && (o.video.backgroundMode === Hd.Mask && (t1.stopMaskSetting(!0), await Yr(()=>{
                    t1.stopVirtualBackgroundSetting();
                }, 0)), t1.updateVirtualBackgroundImage(e), e !== _d && setTimeout(()=>{
                    pr(e);
                }, 0));
            } else t1.updateVirtualBackgroundImage(null);
        }(e, t1, o) : Promise.reject("Cannot load virtual background model."));
}
function yw(e, t1, o, r) {
    const { video: { mask: { isMaskConfigured: i, imageSrc: n, clip: s }, backgroundMode: a, isCurrentUserStartedVideo: d }, meeting: { isCurrentUserStartVideoBeforeReset: u } } = o;
    return r || !i && e.imageUrl ? (async function(e, t1, o, r) {
        const { canvas: i, imageId: n, captureHeight: s, captureWidth: a, divElement: d } = await mw(e, o, r), { cameraId: u, clip: l, rootWidth: c = 1280, rootHeight: p = 720 } = e, h = l ? await gw(l, c, p, d) : null, { video: { videoSsrc: m, activeCamera: g } } = o;
        return h ? (t1.startMaskSetting(i, n, h, m, null != u ? u : g, c, p, a, s), d) : Promise.reject("Clip is empty");
    })(e, t1, o, r).then((e)=>d ? Ng(!0) : Te(ip(Ou, 1)).then((o)=>{
            var i;
            return r || t1.stopMaskSetting(), o ? (null == e || null === (i = e.parentNode) || void 0 === i || i.removeChild(e), !0) : Promise.reject("Cannot set video mask");
        })) : a === Hd.Mask && e.imageUrl === n && vw(e.clip, s) && !u ? Promise.resolve(!0) : async function(e, t1, o) {
        const { imageUrl: r, cropped: i, clip: n, rootWidth: s, rootHeight: a } = e, { video: { mask: { imageSrc: d, cropped: u, clip: l }, backgroundMode: c } } = o;
        if (r) {
            if (c === Hd.VirtualBackground && (t1.stopVirtualBackgroundSetting(!0), await Yr(()=>{
                t1.stopMaskSetting();
            }, 0)), r !== d || i !== u) {
                const e = await hw(r, i);
                e && (t1.updateMaskBackgroundImage(e), setTimeout(()=>{
                    pr(e);
                }, 0));
            }
            if ((!vw(n, l) || !d) && n && s && a) {
                const e = await gw(n, s, a);
                e && (t1.updateMaskClip(e, s, a), setTimeout(()=>{
                    pr(e);
                }, 0));
            }
        } else t1.updateMaskBackgroundImage(null), t1.updateMaskClip(null, s, a);
    }(e, t1, o);
}
const Sw = ra.createAgent(), bw = fE(la.getInstance()), Ew = ra.createAgent(), Iw = fE(la.getInstance()), Aw = {
    videoSsrc: 0,
    cameraDevicesList: [],
    activeCamera: ms.isAndroidOrIOSBrowser ? Rd.User : "default",
    activeVideoId: 0,
    isCurrentUserStartedVideo: !1,
    spotlightUserList: [],
    isCaptureForbidden: !1,
    isMirrored: !1,
    receivedVideoMaxQuality: navigator.hardwareConcurrency >= 8 ? yd.Video_1080P : yd.Video_360P,
    subscribedVideoList: [],
    renderedVideoList: [],
    ensuredCanvas: [],
    isVideoMuted: !1,
    isCaptureCameraLoading: !1,
    isCameraTaken: !1,
    isUsingMediaPlayback: !1,
    receivedVideoDimension: {
        width: 0,
        height: 0
    },
    capturedVideoDimension: {
        width: 0,
        height: 0
    },
    isFollowHostVideoLayout: !1,
    hostDragLayout: [],
    isSupportHDVideo: !1,
    isFullHDVideoEnabled: !1,
    bCanUnmuteVideo: !1,
    virtualBackground: {
        isVBConfigured: !1,
        isVBPreloadReady: void 0,
        imageSrc: void 0,
        cropped: void 0
    },
    mask: {
        imageSrc: void 0,
        cropped: void 0,
        clip: void 0
    },
    backgroundMode: Hd.Null,
    statistic: {
        encode: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            width: 0,
            height: 0,
            fps: 0,
            bandwidth: 0,
            bitrate: 0
        },
        decode: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            width: 0,
            height: 0,
            fps: 0,
            bandwidth: 0,
            bitrate: 0
        }
    },
    hardwareAcceleration: {
        encode: !1,
        decode: !1
    },
    networkQuality: {},
    ptz: {},
    currentCameraControlStatus: {
        isRequested: !1,
        isInControl: !1,
        isCameraMoving: !1
    },
    farEndCameraControlStatus: {
        controlledUserList: [],
        isControlling: !1
    },
    subscriptionStatus: {
        encode: !1,
        decode: !1,
        detailed: !1
    },
    videoAttachments: {},
    rendererType: Yd.WebGL,
    selfPreviewVideoList: []
}, Cw = So({
    [`${Qm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.videoSsrc = o;
    }),
    [`${Ym}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.cameraDevicesList = o;
    }),
    [`${Xm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.activeCamera;
        if (r in e.ptz) {
            const t1 = e.ptz[r];
            [
                "pan",
                "tilt",
                "zoom"
            ].forEach((e)=>{
                t1[e] && (t1[e].value = 0);
            });
        }
        e.activeCamera = o;
    }),
    [`${Zm}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.activeVideoId = o.userId;
    }),
    [`${eg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isCurrentUserStartedVideo = o;
    }),
    [`${tg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.spotlightUserList = o;
    }),
    [`${og}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isCaptureForbidden = o;
    }),
    [`${rg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.receivedVideoMaxQuality = o;
    }),
    [`${ig}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isVideoMuted = o;
    }),
    [`${ng}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isCaptureCameraLoading = o;
    }),
    [`${sg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isCameraTaken = o;
    }),
    [`${dg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.receivedVideoDimension = o;
    }),
    [`${ug}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.subscribedVideoList.includes(o) || e.subscribedVideoList.push(o);
    }),
    [`${lg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.subscribedVideoList.indexOf(o);
        r >= 0 && e.subscribedVideoList.splice(r, 1);
    }),
    [`${hg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.renderedVideoList.find((e)=>e.userId === o.userId && e.key === o.key && e.canvasId === o.canvasId);
        r ? (void 0 !== o.videoQuality && (r.videoQuality = o.videoQuality), void 0 !== o.aspectRatio && (r.aspectRatio = o.aspectRatio)) : e.renderedVideoList.push({
            ...o
        });
    }),
    [`${mg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.renderedVideoList.findIndex((e)=>e.userId === o.userId && e.key === o.key && e.canvasId === o.canvasId);
        r >= 0 && e.renderedVideoList.splice(r, 1);
    }),
    [`${cg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isFollowHostVideoLayout = o;
    }),
    [`${pg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.hostDragLayout = o;
    }),
    [`${gg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isSupportHDVideo = o;
    }),
    [`${vg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.maximumNumbeOfHDSubscriptions = o;
    }),
    [`${fg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.bCanUnmuteVideo = o;
    }),
    [`${yg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.virtualBackground.isVBPreloadReady = o;
    }),
    [`${Sg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.virtualBackground.isVBConfigured = o;
    }),
    [`${bg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.virtualBackground.imageSrc = o.imageUrl, e.virtualBackground.cropped = o.cropped, e.backgroundMode = Hd.VirtualBackground;
    }),
    [`${Ag}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { encode: r, decode: i } = o;
        void 0 !== r && (e.hardwareAcceleration.encode = r), void 0 !== i && (e.hardwareAcceleration.decode = i);
    }),
    [`${Eg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { data: { encoding: r, rate: i, ...n } } = o;
        e.statistic.encode = {
            bitrate: i,
            ...n
        };
    }),
    [`${Ig}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { data: { encoding: r, rate: i, ...n } } = o;
        e.statistic.decode = {
            bitrate: i,
            ...n
        };
    }),
    [`${Cg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { cameraId: r, captureWidth: i, captureHeight: n, videoElement: s, originalRatio: a, ptz: d, hd: u, fullHd: l, mediaFile: c, fps: p, mirrored: h } = o;
        e.activeCamera = r, e.customizedVideoOption = {
            captureWidth: i,
            captureHeight: n,
            videoElement: s,
            originalRatio: a,
            ptz: d,
            hd: u,
            fullHd: l,
            fps: p
        }, Qr(e.mediaPlaybackFile, c) || (e.mediaPlaybackFile = c, e.isUsingMediaPlayback = !(null == c || !c.url)), void 0 !== h && (e.isMirrored = !!h);
    }),
    [`${_g}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { userId: r, level: i, bwLevel: n, type: s } = o;
        if (Object.prototype.hasOwnProperty.call(e.networkQuality, `${r}`)) e.networkQuality[`${r}`][`${s}`] = {
            level: i,
            bwLevel: n
        };
        else {
            const t1 = {
                [s]: {
                    level: i,
                    bwLevel: n
                }
            };
            Object.assign(e.networkQuality, {
                [`${r}`]: t1
            });
        }
    }),
    [`${Rg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { deviceId: r, ptzRange: i } = o;
        if (Object.prototype.hasOwnProperty.call(e.ptz, r)) {
            const t1 = e.ptz[r];
            t1 && [
                "pan",
                "tilt",
                "zoom"
            ].forEach((e)=>{
                const o = i[e];
                if (o) {
                    var r;
                    const i = null === (r = t1[e]) || void 0 === r ? void 0 : r.capability;
                    i ? Object.assign(i, {
                        ...o
                    }) : t1[e] = {
                        capability: {
                            ...o
                        },
                        value: 0
                    };
                }
            });
        } else Object.assign(e.ptz, {
            [r]: {
                pan: i.pan ? {
                    capability: {
                        ...i.pan
                    },
                    value: 0
                } : null,
                tilt: i.tilt ? {
                    capability: {
                        ...i.tilt
                    },
                    value: 0
                } : null,
                zoom: i.zoom ? {
                    capability: {
                        ...i.zoom
                    },
                    value: 0
                } : null
            }
        });
    }),
    [`${wg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.currentCameraControlStatus.isRequested = o;
    }),
    [`${Tg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { isInControl: r, userId: i } = o;
        e.currentCameraControlStatus.isInControl = r, e.currentCameraControlStatus.controllingUserId = i;
    }),
    [`${Og}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.farEndCameraControlStatus.controlledUserList.includes(o) || e.farEndCameraControlStatus.controlledUserList.push(o);
    }),
    [`${Dg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.farEndCameraControlStatus.controlledUserList.indexOf(o);
        -1 !== r && e.farEndCameraControlStatus.controlledUserList.splice(r, 1);
    }),
    [`${Pg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.currentCameraControlStatus.isCameraMoving = "start" === o.cmd;
    }),
    [`${Mg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { constraints: r, deviceId: i } = o, n = e.ptz[i];
        [
            "pan",
            "tilt",
            "zoom"
        ].forEach((e)=>{
            void 0 !== r[e] && (n[e].value = r[e]);
        });
    }),
    [`${kg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.farEndCameraControlStatus.isControlling = o;
    }),
    [`${Lg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.networkQualityBroadcastTime = o;
    }),
    [`${Ng}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.mask.isMaskConfigured = o;
    }),
    [`${Ug}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { imageUrl: r, cropped: i, rootHeight: n, rootWidth: s, clip: a } = o;
        e.mask.imageSrc = r, e.mask.cropped = i, e.mask.clip = a, e.mask.rootWidth = s, e.mask.rootHeight = n, e.backgroundMode = Hd.Mask;
    }),
    [`${Vg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.backgroundMode = o;
    }),
    [`${jg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.capturedVideoDimension = o;
    }),
    [`${xg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.ensuredCanvas.includes(o) || e.ensuredCanvas.push(o);
    }),
    [`${Bg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.mediaPlaybackFile = o, e.isUsingMediaPlayback = !(null == o || !o.url);
    }),
    [`${Fg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        if (o) {
            const { lastCopy: t1, ...r } = o;
            e.prefetchedVideo = r;
        } else e.prefetchedVideo = o;
    }),
    [`${Hg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        Object.assign(e.subscriptionStatus, o);
    }),
    [`${$g}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isFullHDVideoEnabled = o;
    }),
    [`${Wg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { userId: r, element: i } = o, n = e.videoAttachments[`${r}`];
        if (n) -1 === n.indexOf(i) && n.push(i);
        else {
            const t1 = [];
            t1.push(i), Object.assign(e.videoAttachments, {
                [`${r}`]: t1
            });
        }
    }),
    [`${Gg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { userId: r, element: i } = o, n = e.videoAttachments[`${r}`];
        let s = i;
        Array.isArray(i) || (s = [
            i
        ]), s.forEach((e)=>{
            if (n) {
                const t1 = n.indexOf(e);
                -1 !== t1 && n.splice(t1, 1);
            }
        });
    }),
    [`${Kg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        o && (e.rendererType = Yd.WebGL2);
    }),
    [`${zg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        o && (e.rendererType = Yd.WebGPU);
    }),
    [`${qg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.rendererType = o;
    }),
    [`${Jg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isMirrored = o;
    }),
    [`${Qg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.selfPreviewVideoList.includes(o) || e.selfPreviewVideoList.push(o);
    }),
    [`${Zg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        if (o) {
            const t1 = e.selfPreviewVideoList.indexOf(o);
            t1 >= 0 && e.selfPreviewVideoList.splice(t1, 1);
        } else e.selfPreviewVideoList = [];
    }),
    [`${Yg}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.leadershipUserId = o;
    }),
    [`${ag}`]: (e, t1)=>{
        let { payload: o } = t1;
        const r = {
            cameraDevicesList: e.cameraDevicesList
        };
        return o && Object.assign(r, {
            activeCamera: e.activeCamera,
            customizedVideoOption: e.customizedVideoOption,
            virtualBackground: {
                imageSrc: e.virtualBackground.imageSrc,
                cropped: e.virtualBackground.cropped
            },
            mask: {
                imageSrc: e.mask.imageSrc,
                cropped: e.mask.cropped,
                rootWidth: e.mask.rootWidth,
                rootHeight: e.mask.rootHeight,
                clip: e.mask.clip
            },
            backgroundMode: e.backgroundMode,
            ptz: e.ptz,
            subscriptionStatus: e.subscriptionStatus
        }), {
            ...Aw,
            ...r
        };
    }
}, Aw), _w = {
    cameraPtzEpics0: (e, t1)=>ir(e, 8004).pipe(Be((e)=>{
            const { payload: { body: { nCmd: o, nUserID: r, nReason: i, nButtonID: n } } } = e, s = t1.value, a = ch(s), { video: { currentCameraControlStatus: { isInControl: d, controllingUserId: u }, cameraDevicesList: l, activeCamera: c } } = s, p = a.find((e)=>Zr(e.userId, r)), h = [];
            if (h.push(wg(!0)), o === Vd.Request) {
                const e = {
                    userId: null == p ? void 0 : p.userId,
                    displayName: null == p ? void 0 : p.displayName
                };
                if (d) {
                    const t1 = a.find((e)=>e.userId === u);
                    Object.assign(e, {
                        currentControllingUserId: null == t1 ? void 0 : t1.userId,
                        currentControllingDisplayName: null == t1 ? void 0 : t1.displayName
                    });
                }
                ep(_u, e);
            } else if (o === Vd.Approve) h.push(Og(null == p ? void 0 : p.userId)), ep(Ru, {
                isApproved: !0,
                userId: null == p ? void 0 : p.userId,
                displayName: null == p ? void 0 : p.displayName
            });
            else if (o === Vd.Decline) h.push(Dg(null == p ? void 0 : p.userId)), ep(Ru, {
                isApproved: !1,
                userId: null == p ? void 0 : p.userId,
                displayName: null == p ? void 0 : p.displayName,
                reason: i
            });
            else if (o === Vd.GiveUp) h.push(Tg({
                isInControl: !1,
                userId: 0
            })), ep(wu, {
                isControlled: !1
            });
            else if (o === Vd.StartControl || o === Vd.StopControl) h.push(Pg({
                cmd: o === Vd.StartControl ? "start" : "stop",
                type: n
            }));
            else if (o === Vd.SwitchCamera) {
                const e = l.findIndex((e)=>e.deviceId === c), t1 = e + 1 === l.length ? 0 : e + 1;
                if (t1 !== e) {
                    const e = l[t1].deviceId;
                    Iw.changeCamera(e, wd.includes(e));
                }
            }
            return Ce(h);
        })),
    cameraPtzEpics1: (e, t1)=>ir(e, Ds).pipe(tt((e)=>{
            var t1;
            const { payload: { body: o } } = e;
            return null == o || null === (t1 = o.update) || void 0 === t1 ? void 0 : t1.some((e)=>void 0 !== e.nFECC || void 0 !== e.nFECCExecutive);
        }), gt((e)=>{
            const { payload: { body: { update: o } } } = e, r = o.find((e)=>void 0 !== e.nFECC || void 0 !== e.nFECCExecutive);
            if (r) {
                const { meeting: { userId: e } } = t1.value;
                Zr(r.nFECCExecutive, e) && ep(Tu, {
                    userId: r.id,
                    ptz: nw(r.nFECC)
                });
            }
        }), dt(ie)),
    cameraPtzEpics2: (e, t1)=>ir(e, Ds).pipe(tt((e)=>{
            var o;
            const { payload: { body: r } } = e, { video: { farEndCameraControlStatus: { controlledUserList: i } } } = t1.value;
            return null == r || null === (o = r.remove) || void 0 === o ? void 0 : o.some((e)=>i.includes(e.id));
        }), Be((e)=>{
            var o;
            const { payload: { body: r } } = e, i = [], { video: { farEndCameraControlStatus: { controlledUserList: n } } } = t1.value, s = null == r || null === (o = r.remove) || void 0 === o ? void 0 : o.find((e)=>n.includes(e.id));
            return s && i.push(Dg(s.id)), Ce(i);
        })),
    cameraPtzEpics3: (e, t1)=>e.pipe(Ot(`${Pg}`), pt((e)=>{
            const { payload: { cmd: o, type: r } } = e;
            return "start" === o ? Qe(0, 200).pipe(mt(()=>!!t1.value.video.currentCameraControlStatus.isCameraMoving), Be(()=>{
                const { video: { ptz: e, activeCamera: o } } = t1.value, i = e[o], n = iw(i) || {}, { key: s, range: a } = rw(r, 2);
                return i[s] ? (Object.assign(n, {
                    [s]: ow(i[s].capability, i[s].value, a)
                }), Iw.movePTZCamera(n).then(()=>Mg({
                        deviceId: o,
                        constraints: n
                    }))) : Promise.resolve(void 0);
            }), Be((e)=>"object" == typeof e && void 0 !== e.type ? _e(e) : ie)) : ie;
        })),
    cameraPtzEpics4: (e, t1)=>e.pipe(Ot(`${Xm}`), Be((e)=>{
            const { payload: o } = e, { video: { customizedVideoOption: r, ptz: i } } = t1.value;
            if (null != r && r.ptz) {
                const e = null == i ? void 0 : i[o];
                void 0 !== e && Ew.sendCameraAblity({
                    pan: !!e.pan,
                    tilt: !!e.tilt,
                    zoom: !!e.zoom
                });
            }
            return ie;
        }))
}, Rw = {
    videoCaptureEpics0: (e, t1)=>dr(e, nd.StartVideoCaptureSuccess).pipe(Qy(async (e)=>{
            const { video: { activeCamera: o, ptz: r, isCurrentUserStartedVideo: i, isUsingMediaPlayback: n }, meeting: { userId: s } } = t1.value, { payload: { data: { currentDeviceID: a, PTZRange: d, VideoSelectValue: u, usingFacingMode: l } } } = e, c = [], { cameras: p } = await Te(Cy());
            if (p.length < 1 && !n && (ep(au, {
                reason: "Cannot detect camera devices"
            }), bw.stopCaptureVideo()), XR(o, p) || n) {
                let e = "";
                if (e = l ? Array.isArray(u) && u[0] ? u[0] : u : a, i || Sw.muteAttendeeVideo(s, !1), ep(Du), n) c.push(Xm("default"));
                else if (e && d && c.push(Rg({
                    deviceId: e,
                    ptzRange: d
                })), o !== e && c.push(Xm(e)), Object.prototype.hasOwnProperty.call(r, e)) {
                    const t1 = r[e];
                    if (t1) {
                        const e = iw(t1);
                        e && bw.movePTZCamera(e);
                    }
                }
            } else ep(du, {
                reason: "cannot find target camera"
            }), bw.stopCaptureVideo();
            return c;
        })),
    videoCaptureEpics1: (e, t1)=>ir(e, Ds).pipe(tt((e)=>{
            const { payload: { body: { update: o } } } = e, { meeting: { userId: r } } = t1.value;
            return null == o ? void 0 : o.some((e)=>e.id === r && void 0 !== e.bVideoOn);
        }), ke((e)=>{
            const { payload: { body: { update: o } } } = e, { meeting: { userId: r } } = t1.value, i = o.find((e)=>e.id === r);
            return !0 === i.bVideoOn ? ep(hu) : ep(mu), eg(!!i.bVideoOn);
        })),
    videoCaptureEpics2: (e)=>dr(e, [
            nd.UserForbiddedCaptureVideo,
            nd.UserCameraIsTakenByOtherPrograms,
            nd.VideoWebsocketBroken,
            nd.StopVideoCaptureFailed
        ]).pipe(Be((e)=>{
            const { payload: { type: t1 } } = e, o = [];
            switch(t1){
                case nd.UserForbiddedCaptureVideo:
                    ep(uu), o.push(og(!0));
                    break;
                case nd.UserCameraIsTakenByOtherPrograms:
                    ep(lu, {
                        reason: "User camera is taken by other programs."
                    }), o.push(sg(!0));
                    break;
                case nd.VideoWebsocketBroken:
                    ep(pu, {
                        reason: "Video websocket broken."
                    });
                    break;
                case nd.StopVideoCaptureFailed:
                    ep(mu, {
                        failed: !0,
                        reason: "Unknown."
                    });
            }
            return Ce(o);
        })),
    videoCaptureEpics3: (e, t1)=>dr(e, nd.StopVideoCaptureSuccess).pipe(vt(t1), ke((e)=>{
            let [, t1] = e;
            const { meeting: { userId: o }, video: { isCurrentUserStartedVideo: r } } = t1;
            return r || ep(mu), Sw.muteAttendeeVideo(o, !0), ng(!1);
        })),
    videoCaptureEpics4: (e, t1)=>ir(e, 16133).pipe(vt(t1), tt((e)=>{
            var t1;
            let [o, r] = e;
            return (null == o || null === (t1 = o.payload) || void 0 === t1 || null === (t1 = t1.body) || void 0 === t1 ? void 0 : t1.id) === r.meeting.userId;
        }), qy((e)=>{
            let [t1] = e;
            const { id: o, bVideoMute: r } = t1.payload.body;
            return ep(ru, {
                id: o,
                isVideoMuted: r
            }), !0 === r && bw.stopCaptureVideo(), !1 === r && ep(iu, {
                id: o,
                isVideoMuted: r
            }), ig(r);
        })),
    videoCaptureEpics5: (e, t1)=>ir(e, 16131).pipe(tt((e)=>void 0 !== e.payload.body.ssrc), pt((e)=>{
            const { payload: { body: { ssrc: o } } } = e;
            return ep(Mu, o), Ye(_e(Qm(o)), Iy(t1).pipe(Be((e)=>{
                const { meeting: { isCurrentUserStartVideoBeforeReset: o }, media: { videoEncodeStatus: r } } = t1.value;
                return !0 !== (null == e ? void 0 : e.bVideoOn) && !0 === o ? Ey("video", r, "success").pipe(tt((e)=>{
                    let [t1, o] = e;
                    return t1 && o;
                }), ke(()=>{
                    const e = t1.value, { video: { backgroundMode: o, mask: r, virtualBackground: i, activeCamera: n, customizedVideoOption: s } } = e;
                    let a = Promise.resolve(!0);
                    return o === Hd.VirtualBackground && i.imageSrc ? a = fw({
                        imageUrl: i.imageSrc,
                        cropped: i.cropped
                    }, bw, e) : o === Hd.Mask && r.imageSrc && r.clip && (a = yw({
                        imageUrl: r.imageSrc,
                        cropped: r.cropped,
                        clip: r.clip,
                        rootHeight: r.rootHeight,
                        rootWidth: r.rootWidth
                    }, bw, e)), a.then(()=>{
                        tw(bw, e, {
                            cameraId: n,
                            ...s
                        });
                    }), Pn(void 0);
                })) : ie;
            })));
        })),
    videoCaptureEpics6: (e, t1)=>e.pipe(Ot(`${Ym}`), gt((e)=>{
            const { payload: o } = e, r = t1.value, { meeting: { userId: i } } = r, n = sh(r);
            0 === o.length ? n && !n.bVideoConnect || Sw.connectCamera(i, !1) : null != n && n.bVideoConnect || Sw.connectCamera(i, !0);
        }), dt(ie)),
    videoCaptureEpics7: (e)=>dr(e, nd.InitSuccessVideo).pipe(tt((e)=>!ms.isIPad && ms.isAndroidOrIOSBrowser && e.payload.data === sd.EncodeSuccess), pt(()=>Hy().pipe(gt((e)=>{
                bw.setMobileRotateMode(e);
            }), nt()))),
    videoCaptureEpics8: (e)=>dr(e, nd.StartVideoCaptureSuccess).pipe(tt(()=>!ms.isIPad && ms.isAndroidOrIOSBrowser), gt(()=>{
            bw.setMobileRotateMode(Fy());
        }), dt(ie)),
    videoCaptureEpics9: (e, t1)=>dr(e, nd.VideoStreamFailed).pipe(tt(()=>!!t1.value.video.isCurrentUserStartedVideo && ms.isIOSMobile), gt(()=>{
            bw.stopCaptureVideo();
        }), Be(()=>ie)),
    videoCaptureEpics10: (e)=>ir(e, 24322).pipe(gt((e)=>{
            const { payload: t1 } = e;
            bw.passThroughRWGMessage(t1);
        }), Be(()=>ie))
}, ww = {
    videoRenderEpics0: (e)=>ir(e, 16129).pipe(ke((e)=>{
            const { payload: { body: { id: t1, bVideoOn: o } } } = e, r = QR(t1);
            return ep(ou, {
                bVideoOn: o,
                userId: r
            }), Zm({
                bVideoOn: o,
                userId: r
            });
        })),
    videoRenderEpics1: (e, t1)=>dr(e, nd.VideoDecodeMaxSize).pipe(tt((e)=>{
            var t1;
            return null == e || null === (t1 = e.payload) || void 0 === t1 ? void 0 : t1.data;
        }), ke((e)=>{
            const { size: o } = e.payload.data, { video: { renderedVideoList: r, receivedVideoMaxQuality: i }, meeting: { userId: n } } = t1.value, s = r.filter((e)=>e.videoQuality >= yd.Video_720P && e.userId !== n);
            return i !== o && s.length > 0 && (o >= yd.Video_720P || i >= yd.Video_720P) && s.forEach((e)=>{
                dw.subscribeVideo(e.userId, e.videoQuality, !1);
            }), rg(o);
        })),
    videoRenderEpics2: (e)=>ir(e, 16135).pipe(Be((e)=>{
            const { payload: { body: { bLeadershipOn: t1, id: o } } } = e, r = [], i = [], n = t1 ? QR(o) : 0;
            return t1 && i.push(n), r.push(tg(i), Yg(n)), ot(ip(gu, 1), Qe(2e3).pipe(ke(()=>({
                    leadershipEventOnly: !0
                })))).subscribe((e)=>{
                const { spotlightList: o, leadershipEventOnly: r } = e;
                t1 ? 1 === (null == o ? void 0 : o.length) && i[0] === (null == o ? void 0 : o[0]) || ep(Lu, {
                    spotlightList: o
                }) : (r || 0 === (null == o ? void 0 : o.length)) && ep(Lu, {
                    spotlightList: []
                });
            }), Ce(r);
        })),
    videoRenderEpics3: (e, t1)=>ir(e, 7958).pipe(vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { payload: { body: r } } = t1;
            let i = [];
            r && r.group_list && r.group_list[0] && (i = r.group_list[0].map((e)=>e.id));
            const n = ch(o);
            return n.length > 0 && (i = i.filter((e)=>n.findIndex((t1)=>t1.userId === e) >= 0)), ep(gu, {
                spotlightList: i
            }), tg(i);
        })),
    videoRenderEpics4: (e)=>dr(e, nd.CurrentVideoResolution).pipe(qy((e)=>(ep(nu, e.payload.data), dg(e.payload.data)))),
    videoRenderEpics5: (e)=>dr(e, [
            nd.CurrentVideoResolution,
            nd.CurrentCaptureVideoWidthHeight
        ]).pipe(tt((e)=>!!e.payload.data), ke((e)=>{
            const { payload: { data: t1, type: o } } = e;
            return o === nd.CurrentVideoResolution ? (ep(nu, t1), dg(t1)) : (ep(su, t1), jg(t1));
        })),
    videoRenderEpics6: (e)=>ir(e, Ps).pipe(tt((e)=>{
            const { payload: { body: t1 } } = e;
            return [
                "bFollowHostVideo",
                "VideoHd",
                "bCanUnmuteVideo"
            ].some((e)=>void 0 !== t1[e]);
        }), ke((e)=>{
            const { payload: { body: { bFollowHostVideo: t1, VideoHd: o, bCanUnmuteVideo: r } } } = e;
            if (void 0 !== t1) return ep(vu, {
                bOn: t1
            }), cg(t1);
            if (void 0 !== r) return fg(r);
            {
                const e = 1 === o;
                return uw.updateVideoHDValue(e), uw.enableHardwareAccelerationForVideoEncode(!1), gg(e);
            }
        })),
    videoRenderEpics7: (e, t1)=>ir(e, 7957).pipe(vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { video: { isFollowHostVideoLayout: r } } = o, { payload: { body: i } } = t1, n = i && i.drag_list && i.drag_list.map((e)=>e.id);
            return r && ep(fu, {
                layout: n
            }), pg(n);
        })),
    videoRenderEpics8: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            const { meeting: { userId: r }, video: { subscribedVideoList: i } } = o, n = t1.payload.body.update, s = t1.payload.body.remove;
            return n && n.length > 0 && n.findIndex((e)=>e.id !== r && (void 0 !== e.bVideoOn || e.bHold)) > -1 || s && s.some((e)=>i.includes(e.id));
        }), gt((e)=>{
            let [t1, o] = e;
            const { payload: { body: { remove: r, update: i } } } = t1, { video: { subscribedVideoList: n } } = o, s = lh(o);
            if (r && r.length > 0 && r.filter((e)=>n.includes(e.id)).forEach((e)=>{
                ep(Su, {
                    userId: e.id
                });
            }), i && i.length > 0) {
                const e = i.filter((e)=>void 0 !== e.bVideoOn).filter((e)=>-1 === s.findIndex((t1)=>t1.userId === e.id)), t1 = i.filter((e)=>!0 === e.bHold);
                t1.length > 0 && t1.filter((e)=>n.includes(e.id)).forEach((e)=>{
                    ep(Su, {
                        userId: e.id
                    });
                }), e.forEach((e)=>{
                    e.bVideoOn ? ep(yu, {
                        userId: e.id
                    }) : n.includes(e.id) && ep(Su, {
                        userId: e.id
                    });
                });
            }
        }), dt(ie)),
    videoRenderEpics9: (e, t1)=>dr(e, nd.VideoQosData).pipe(vt(t1), ke((e)=>{
            var t1;
            let [o, r] = e;
            const { video: { isCaptureForbidden: i, isCameraTaken: n }, media: { videoEncodeStatus: s, videoDecodeStatus: a } } = r, d = sh(r), u = gh(r), l = u.length > 0, c = (null == d ? void 0 : d.bVideoOn) && !i && !n, p = u.some((e)=>e.bVideoOn), h = "success" === s && c && l, m = "success" === a && l && p;
            return null !== (t1 = o.payload.data) && void 0 !== t1 && t1.encoding ? h ? (ep(Iu, o.payload), Eg(o.payload)) : Eg(Nd) : m ? (ep(Iu, o.payload), Ig(o.payload)) : Ig(Nd);
        })),
    videoRenderEpics10: (e, t1)=>dr(e, [
            nd.CurrentDecodeVideoQuality,
            nd.CurrentDecodeVideoFps
        ]).pipe(gt((e)=>{
            const { payload: { type: o, data: r } } = e, { video: { subscriptionStatus: i } } = t1.value;
            if (i.detailed) {
                if (o === nd.CurrentDecodeVideoQuality) {
                    const { ssrc: e, width: t1, height: o, quality: i } = r;
                    ep(Au, {
                        userId: e,
                        width: t1,
                        height: o,
                        quality: i
                    });
                } else if (o === nd.CurrentDecodeVideoFps) {
                    const { ssrc: e, fps: t1 } = r;
                    ep(Au, {
                        userId: e,
                        fps: t1
                    });
                }
            }
        }), dt(ie)),
    videoRenderEpics11: (e, t1)=>ur(e, t1).pipe(Be(async ()=>ms.isAndroidOrIOSBrowser ? 1 : await la.isSupportVideoDecodeHardwareAcceleration() ? 4 : 1), ke((e)=>vg(e))),
    videoRenderEpics12: (e, t1)=>dr(e, [
            nd.NetworkQualityChange,
            nd.NetworkQualityChangeAudio
        ]).pipe(tt((e)=>!!e.payload.data), Be((e)=>{
            var o;
            const { payload: { data: { bwLevel: r, isUplink: i, networkLevel: n } } } = e, s = [], { meeting: { userId: a }, video: { networkQuality: d, subscribedVideoList: u, networkQualityBroadcastTime: l } } = t1.value, c = i ? "uplink" : "downlink";
            s.push(_g({
                userId: a,
                level: n,
                bwLevel: r,
                type: c
            }));
            const p = Qr(null === (o = d[`${a}`]) || void 0 === o ? void 0 : o[c], {
                level: n,
                bwLevel: r
            });
            if (!p && -1 !== n) {
                (!i && u.filter((e)=>e !== a).length > 0 || i) && ep(Cu, {
                    userId: a,
                    type: c,
                    level: n
                });
            }
            if (i) {
                const e = performance.now();
                (!p || e - (null != l ? l : 0) > 3e4) && (dw.broadcastUserNetworkQuality({
                    isUplink: i,
                    level: n,
                    bwLevel: r
                }), s.push(Lg(e)));
            }
            return Ce(s);
        })),
    videoRenderEpics13: (e, t1)=>ar(e, 8005).pipe(tt((e)=>{
            var t1;
            return !(null === (t1 = e.payload.body) || void 0 === t1 || !t1.nUserID);
        }), Be((e)=>{
            const { payload: { body: { nLevel: o, nUserID: r } } } = e, { video: { networkQuality: i } } = t1.value, n = i[`${r}`], s = [];
            return n && n.uplink.level === o || (ep(Cu, {
                userId: r,
                level: o,
                type: "uplink"
            }), s.push(_g({
                userId: r,
                level: o,
                type: "uplink"
            }))), Ce(s);
        })),
    videoRenderEpics14: (e, t1)=>ir(e, Ds).pipe(tt((e)=>{
            const { payload: { body: o } } = e, { video: { prefetchedVideo: r } } = t1.value;
            return (null == r ? void 0 : r.userId) && (o.update || o.remove);
        }), Be((e)=>{
            const { payload: { body: o } } = e, r = [], { video: { prefetchedVideo: i } } = t1.value;
            let n = !1;
            return o.remove && (n = -1 !== o.remove.findIndex((e)=>e.id === (null == i ? void 0 : i.userId))), o.update && (n = -1 !== o.update.findIndex((e)=>e.id === (null == i ? void 0 : i.userId) && !1 === e.bVideoOn)), n && i && (i.loaded || uw.cancelPrefetchVideoSsrc(i.userId), dw.unsubscribeVideo(i.userId), r.push(Fg(void 0))), Ce(r);
        })),
    videoRenderEpics15: (e, t1)=>e.pipe(Ot(`${Fg}`), tt((e)=>!!e.payload), gt((e)=>{
            const { payload: { lastCopy: o } } = e, { video: { prefetchedVideo: r } } = t1.value;
            !r || o && o.userId === r.userId || (null != o && o.userId && (o.loaded && uw.cancelPrefetchVideoSsrc(o.userId), dw.unsubscribeVideo(o.userId)), dw.subscribeVideo(r.userId, yd.Video_360P, !1), uw.prefetchVideoSsrc(r.userId));
        }), dt(ie)),
    videoRenderEpics16: (e, t1)=>dr(e, nd.NewActiveSpeakerFirstFrameCallback).pipe(tt(()=>!!t1.value.video.prefetchedVideo), Be((e)=>{
            const { payload: { data: { ssrc: o } } } = e, { video: { prefetchedVideo: r } } = t1.value, i = [];
            return r && (Zr(r.userId, o) ? (i.push(Fg({
                userId: r.userId,
                loaded: !0,
                lastCopy: r
            })), ep(Pu, {
                userId: r.userId
            })) : dw.unsubscribeVideo(r.userId)), Ce(i);
        })),
    videoRenderEpics17: (e, t1)=>ir(e, 16131).pipe(tt((e)=>void 0 !== e.payload.body.ssrc), gt(()=>{
            const { media: { videoDecodeStatus: e, videoEncodeStatus: o } } = t1.value;
            Ey("video", o, e).subscribe((e)=>{
                let [o, r] = e;
                const { video: { subscriptionStatus: i } } = t1.value;
                o && i.encode && uw.subscribeToQos([
                    da.VideoEncode
                ], Td), r && (i.decode && uw.subscribeToQos([
                    da.VideoDecode
                ], Td), i.detailed && uw.enableVideoObserver(!0));
            });
        }), dt(ie)),
    videoRenderEpics18: (e, t1)=>e.pipe(Ot(`${hg}`, `${mg}`), tt(()=>{
            const e = t1.value.video.renderedVideoList.length;
            return [
                0,
                1
            ].includes(e);
        }), gt(()=>{
            const e = t1.value.video.renderedVideoList.length;
            1 === e ? uw.enableVideoObserver(!0, !0) : 0 === e && uw.enableVideoObserver(!1);
        }), dt(ie)),
    videoRenderEpics19: (e, t1)=>dr(e, nd.CurrentDecodeVideoQuality).pipe(Be((e)=>{
            const { payload: { data: o } } = e, { video: { renderedVideoList: r, videoAttachments: i } } = t1.value, n = [], { ssrc: s, width: a, height: d } = o, u = d ? a / d : 0, l = r.filter((e)=>Zr(e.userId, s));
            if (l.some((e)=>e.aspectRatio && Math.abs(e.aspectRatio - u) > .2)) {
                const e = l.filter((e)=>e.canvasId === Md);
                if (e.length > 0) {
                    const e = i[`${s}`];
                    e && e.every((e)=>{
                        if (e) {
                            const { clientWidth: t1, clientHeight: o } = e, r = o ? t1 / o : 0;
                            return Math.abs(r - u) <= .2;
                        }
                        return !0;
                    }) && n.push(hg({
                        userId: s,
                        key: Dd,
                        canvasId: Md,
                        aspectRatio: u
                    }));
                }
                e.length === l.length && 0 !== n.length || ep(ku, {
                    userId: s,
                    aspectRatio: u
                });
            }
            return Ce(n);
        })),
    videoRenderEpics20: (e, t1)=>dr(e, nd.SyncRendererTypeResponse).pipe(Be((e)=>{
            const { payload: { data: { rendererType: o } } } = e, { video: { rendererType: r } } = t1.value, i = [];
            return r !== o && i.push(qg(o)), Ce(i);
        }))
}, Tw = rr(ww, Rw, {
    vbEpics0: (e)=>dr(e, [
            nd.VbModelPreloadingOk,
            nd.VbModelPreloading_3S,
            nd.VbModelPreloading_10S,
            nd.VbSettingParaError
        ]).pipe(Be((e)=>{
            const { payload: { type: t1, data: o } } = e, r = [];
            return [
                nd.VbModelPreloadingOk,
                nd.VbModelPreloading_3S,
                nd.VbModelPreloading_10S
            ].includes(t1) ? (r.push(yg(!0)), ep(bu, !0), t1 === nd.VbModelPreloading_10S && console.warn("Virtual Background is taking longer than expected to load.")) : t1 === nd.VbSettingParaError && (o === Cd.VBModelNotMatch ? (ep(bu, !1), r.push(yg(!1))) : (ep(Eu, !1), r.push(Sg(!1)))), Ce(r);
        })),
    vbEpics1: (e)=>dr(e, nd.StartVideoStreamInVbSettingSuccess).pipe(ke(()=>(ep(Eu, !0), Sg(!0)))),
    vbEpics2: (e)=>dr(e, nd.StartVideoStreamInMaskSettingSuccess).pipe(ke(()=>(ep(Ou, !0), Ng(!0)))),
    vbEpics3: (e)=>dr(e, nd.MaskSettingParaError).pipe(ke(()=>(ep(Ou, !1), Ng(!1))))
}, _w);
class Ow {
    constructor(){
        this.assetsPath = void 0, this.instance = void 0, this.callbackList = void 0, this.mediaWorkersPath = void 0, this.mediaOptions = void 0, this.inProgress = void 0, this.callbackList = [];
    }
    static getInstance() {
        return void 0 === this.agentInstance && (this.agentInstance = new Ow), this.agentInstance;
    }
    init(e, t1) {
        var o, r, i, n, s;
        if (!this.instance && window.JsMediaSDK_Instance) {
            const e = {
                ivObj: {
                    [Es.AUDIO_ENCODE]: void 0,
                    [Es.VIDEO_ENCODE]: void 0,
                    [Es.SHARING_ENCODE]: void 0
                }
            };
            this.instance = new window.JsMediaSDK_Instance(e);
        }
        this.mediaWorkersPath = aa(e, !1), this.onMediaSDKCallback = this.onMediaSDKCallback.bind(this), this.mediaOptions = t1, null === (o = this.instance) || void 0 === o || o.JsMediaSDK_PreLoad(this.mediaWorkersPath, this.onMediaSDKCallback, t1);
        const a = ys(null === (r = this.mediaOptions) || void 0 === r ? void 0 : r.enableMultiDecodeVideoWithoutSAB);
        null === (i = this.instance) || void 0 === i || i.setPropsBeforeInit({
            callback: this.onMediaSDKCallback,
            audioWorkerPath: null === (n = this.mediaWorkersPath) || void 0 === n ? void 0 : n.audioWorkletPath,
            isEnableListenInitEvent: !0
        }), null === (s = this.instance) || void 0 === s || s.initVideoEncode(this.mediaWorkersPath, "", 0, !1, "", 0, a, !1, !1, !0, !0, !1, !0), this.inProgress = !0;
    }
    onMediaSDKCallback(e, t1) {
        this.callbackList.length > 0 && this.callbackList.forEach((o)=>o(e, t1));
    }
    registerCallback(e) {
        this.callbackList.push(e);
    }
    unregisterCallback(e) {
        this.callbackList = this.callbackList.filter((t1)=>t1 !== e);
    }
    async destroy() {
        var e;
        this.callbackList = [], await (null === (e = this.instance) || void 0 === e ? void 0 : e.destroy()), this.instance = null, this.inProgress = !1;
    }
    disconnect() {
        var e, t1;
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(17, {}), null === (t1 = this.instance) || void 0 === t1 || t1.JsMediaSDK_UnInit();
    }
    startVirtualBackgroundSetting(e, t1, o, r, i, n) {
        var s;
        let a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
        null === (s = this.instance) || void 0 === s || s.Notify_MeidaSDK(91, {
            canvas: e,
            bgdom: t1,
            width: i,
            height: n,
            ssid: 0,
            VideoSelectValue: "default" === r ? null : r,
            disableOriginalRatio: a,
            usingFacingMode: [
                "user",
                "environment"
            ].includes(r)
        });
    }
    updateVirtualBackgroundImage(e) {
        var t1;
        null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(92, {
            bgdom: e
        });
    }
    stopVirtualBackgroundSetting() {
        var e;
        let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(93, {
            isSwitch: t1
        });
    }
    startMaskSetting(e, t1, o, r, i, n, s, a, d) {
        var u;
        null === (u = this.instance) || void 0 === u || u.Notify_MeidaSDK(62, {
            canvas: e,
            maskdom: null,
            bgdom: null,
            dx: 0,
            dy: 0,
            dWidth: 170,
            dHeight: 170,
            width: 1280,
            height: 720,
            ssid: 0,
            originWidth: 379,
            originHeight: 213,
            VideoSelectValue: "default" === i ? null : i,
            usingFacingMode: [
                "user",
                "environment"
            ].includes(i)
        });
    }
    stopMaskSetting() {
        var e;
        let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(65, {
            isSwitch: t1
        });
    }
}
Ow.agentInstance = void 0;
const Dw = "PREVIEW_VIDEO_ENCODE_SUCCESS", Pw = "PREVIEW_VIDEO_VB_MODEL_READY";
async function Mw(e, t1, o, r) {
    const { imageUrl: i, cropped: n, deviceId: s } = o, a = Xr("__ZOOM_SDK_PREVIEW_VIRTUAL_BACKGROUND_CANVAS_@__");
    t1.id || (t1.id = a);
    let [d, u] = [
        640,
        360
    ];
    if (la.isSupportSending720P() && (d = 1280, u = 720), i && Py(r)) {
        const o = await hw(i, n);
        return e.startVirtualBackgroundSetting(t1, o, 0, null != s ? s : "default", d, u), o && o !== _d && setTimeout(()=>{
            pr(o);
        }, 0), "vb";
    }
    return e.startMaskSetting(t1, null, null, 0, null != s ? s : "default", 0, 0, 0, 0), "mask";
}
class kw {
    constructor(){
        this.previewMediaAgent = Ow.getInstance(), this.state = void 0, this.eventHandler = (e, t1)=>{
            switch(e){
                case nd.InitSuccessVideo:
                    t1 === sd.EncodeSuccess && (kw.isVideoEncoded = !0, ep(Dw));
                    break;
                case nd.VbModelPreloadingOk:
                case nd.VbModelPreloading_3S:
                case nd.VbModelPreloading_10S:
                    kw.isVBModelReady = !0, ep(Pw, !0);
                    break;
                case nd.VbSettingParaError:
                    t1 === Cd.VBModelNotMatch && (kw.isVBModelReady = !1, ep(Pw, !1));
            }
        };
    }
    static setMediaOption(e) {
        kw.mediaOption = e;
    }
    setup() {
        if (kw.mediaOption) {
            if (la.getInstance().inProgress) return Promise.resolve("");
            if (!Ow.getInstance().inProgress) {
                kw.isVideoEncoded = void 0, kw.isVBModelReady = void 0, this.previewMediaAgent.unregisterCallback(this.eventHandler);
                const { assetsPath: e, enforceMultipleVideos: t1, enforceVirtualBackground: o } = kw.mediaOption, r = {
                    ...Ly(e, t1, o)
                };
                this.previewMediaAgent.init(e, r), this.previewMediaAgent.registerCallback(this.eventHandler);
            }
            return Promise.resolve("");
        }
        return Promise.reject({
            type: Gl,
            reason: "Cannot preview video with virtual background before `client.init` method."
        });
    }
    async startPreview(e, t1) {
        if (la.getInstance().inProgress) {
            var o;
            Mw(la.getInstance(), e, t1, null === (o = kw.mediaOption) || void 0 === o ? void 0 : o.enforceVirtualBackground);
        } else {
            var r;
            let o;
            o = t1.imageUrl ? void 0 !== kw.isVBModelReady ? Ce([
                kw.isVBModelReady
            ]) : ip(Pw, 1).pipe(ke(()=>!0)) : Ce([
                !0
            ]), null === (r = o) || void 0 === r || r.subscribe((o)=>{
                o && (kw.isVideoEncoded ? Ce([
                    !0
                ]) : ip(Dw, 1)).subscribe(()=>{
                    var o;
                    Mw(Ow.getInstance(), e, t1, null === (o = kw.mediaOption) || void 0 === o ? void 0 : o.enforceVirtualBackground).then((o)=>{
                        this.state = {
                            mode: o,
                            canvas: e,
                            vb: t1
                        };
                    });
                });
            });
        }
    }
    async stopPreview() {
        var e;
        la.getInstance().inProgress ? la.getInstance().stopVirtualBackgroundSetting() : "vb" === (null === (e = this.state) || void 0 === e ? void 0 : e.mode) ? Ow.getInstance().stopVirtualBackgroundSetting() : Ow.getInstance().stopMaskSetting();
    }
    async updatePreview(e, t1) {
        const o = la.getInstance().inProgress ? la.getInstance() : Ow.getInstance();
        var r;
        if (e) if ("mask" === (null === (r = this.state) || void 0 === r ? void 0 : r.mode)) {
            var i;
            ms.isChrome ? (await this.stopPreview(), await this.startPreview(this.state.canvas, {
                imageUrl: e,
                cropped: t1,
                deviceId: null === (i = this.state.vb) || void 0 === i ? void 0 : i.deviceId
            })) : console.warn('use the `start` method with the virtual background image parameter instead of using `updateVirtualBackground` to preview the video." ');
        } else {
            const r = await hw(e, t1);
            r && (o.updateVirtualBackgroundImage(r), r !== _d && setTimeout(()=>{
                pr(r);
            }, 0));
        }
        else o.updateVirtualBackgroundImage(null);
    }
}
kw.mediaOption = void 0, kw.isVideoEncoded = void 0, kw.isVBModelReady = void 0;
const { InitSuccessVideo: Lw, InitSuccessAudio: Nw, InitSuccessSharing: Vw, InitFailedVideo: Uw, InitFailedAudio: jw, InitFailedSharing: xw, SharingHealthCheckFailed: Bw, VideoHealthCheckFailed: Fw, AudioHealthCheckFailed: Hw, AudioStreamMuted: $w } = nd, Ww = fE(la.getInstance()), Gw = pE.getInstance(), Kw = Gw.makeLogger([
    "Media Agent"
]), zw = [], qw = {
    epics0: (e, t1)=>e.pipe(Ot(`${cn}`), pt(()=>{
            const { meeting: { isMeetingReset: o } } = t1.value;
            return e.pipe(ht(e.pipe(Ot(`${Io}`), tt((e)=>{
                var t1;
                return !(null !== (t1 = e.payload) && void 0 !== t1 && t1.retry);
            }), it(1))), Ot(`${Sn}`), it(1), Qy((e)=>{
                var r;
                const { logger: i, media: { mediaConstraints: n, assetsPath: s }, meeting: { zlkJwtToken: a, cv: d } } = t1.value, { payload: { disableAqos: u, disableVqos: l } } = e, c = null != i && null !== (r = i.options) && void 0 !== r && r.enable ? pE.getInstance().makeLogger([
                    "MEDIA SDK"
                ]) : void 0;
                return (function(e) {
                    const { media: { patchedMediaSDKStatus: t1 } } = e;
                    return t1 === Jd.Loading ? Te(ip(lc, 1)) : Promise.resolve();
                })(t1.value).then(()=>{
                    const e = [];
                    let t1 = !l;
                    const r = !u;
                    return a && qr(d, "1.3.0") < 0 && (t1 = !1), e.push(Jo({
                        audioQos: r,
                        videoQos: t1
                    })), Ww.init(function(e) {
                        return e ? new Proxy(e, {
                            get: (e, t1)=>"string" == typeof t1 && "error" === t1 ? function() {
                                    try {
                                        var e;
                                        hE.report(arguments.length <= 0 ? void 0 : arguments[0], [
                                            "MEDIA SDK",
                                            ...null !== (e = arguments.length <= 1 ? void 0 : arguments[1]) && void 0 !== e ? e : []
                                        ], "error");
                                    } catch (e) {}
                                } : Reflect.get(e, t1)
                        }) : e;
                    }(c)), e.push(Yo(!0)), o && void 0 !== n && void 0 !== s && e.push(Vo()), e;
                }).catch(()=>[]);
            }));
        })),
    epics1: (e, t1)=>e.pipe(Ot(`${cn}`), tt((e)=>{
            const { payload: { mediaSDKPath: o } } = e, { media: { skipJsMedia: r, patchJsMedia: i, assetsPath: n }, meeting: { isMeetingReset: s } } = t1.value;
            return !r && di(n) && !!i && !!o && !s;
        }), pt((e)=>{
            const { payload: { mediaSDKPath: t1 } } = e, o = oi(t1);
            return Ce(new Promise((e, t1)=>{
                const r = `${o}/${Jn}`;
                "JsMediaSDK_Instance" in window && (window.JsMediaSDK_Instance_backup = window.JsMediaSDK_Instance, delete window.JsMediaSDK_Instance), lr(r, ()=>{
                    "JsMediaSDK_Instance_backup" in window && delete window.JsMediaSDK_Instance_backup, Kw.info(`patched media sdk url:${r}`), e("");
                }, ()=>{
                    "JsMediaSDK_Instance_backup" in window && (window.JsMediaSDK_Instance = window.JsMediaSDK_Instance_backup, delete window.JsMediaSDK_Instance_backup), Kw.error(`cannot load patched media sdk :${r}`), t1();
                });
            })).pipe(Be(()=>(ep(lc), Ce([
                    zo(Jd.Done),
                    qo(o)
                ]))), rt(()=>(ep(lc), Ce([
                    zo(Jd.Done)
                ]))), ct(zo(Jd.Loading)));
        })),
    epics2: (e, t1)=>ur(e, t1).pipe(gt(()=>{
            const { media: { assetsPath: e, mediaConstraints: o, fileWithVersion: r, enforceMultipleVideos: i, enforceVirtualBackground: n, isEnableDecoderInWorklet: s }, meeting: { isAudioBridgeEnabled: a } } = t1.value;
            if (Ww.notifySDKMeetingReady(), e && o) {
                const t1 = {
                    enableDecoderInWorklet: s,
                    enableAudioBridge: a && gs()
                };
                Object.assign(t1, Ly(e, i, n)), Ww.setAssetsAndConstraint(e, o, r, t1);
            }
            Iy(t1).pipe(pt((e)=>Ce(jy.acquire().then(()=>e)))).subscribe((e)=>{
                const { meeting: { svcUrl: o, meetingNumber: r, conId: i, e2eEncrypt: n, userId: s, isWebinar: a, enableWebtransport: d, webtransportPort: u, mediasdkConfig: l }, media: { enableAudioQos: c, enableVideoQos: p, alternativeNameForVideoPlayer: h, adaptedABOptionForMediaSDK: m }, video: { rendererType: g } } = t1.value;
                e && (Ww.connect({
                    svcUrl: o,
                    meetingNumber: r,
                    conId: i,
                    e2eEncrypt: n,
                    isViewOnly: Gp(e.userRole),
                    currentUserId: s,
                    isWebinar: a,
                    enableAudioQos: c,
                    enableVideoQos: p,
                    enableWebtransport: d,
                    webtransportPort: u,
                    rendererType: g,
                    adaptedABOptionForMediaSDK: m,
                    mediasdkConfig: l
                }), function(e) {
                    var t1;
                    let o = "video-player";
                    e.tagName && (o = e.tagName, zA.dispatch("", {
                        tagName: e.tagName
                    }), mC(null === (t1 = e.mediaSDK) || void 0 === t1 ? void 0 : t1.call(e), `VPTN:${o}`));
                    const r = `${o}-container`, i = e.sessionId || aC();
                    zA.get("renderCountMap").clear(), e.mediaSDK && (zA.get("mediaSDKInstanceMap").set(QA, e.mediaSDK), zA.get("mediaSDKInstanceMap").set(i, e.mediaSDK)), e.failover && zA.dispatch("failover", void 0, e.sessionId || QA), customElements.get(r) || customElements.define(r, HC), customElements.get(o) || customElements.define(o, UC);
                }({
                    mediaSDK: ()=>Ww.instance,
                    tagName: h,
                    failover: "1"
                }));
            });
        }), pt(()=>Je((e)=>Ww.registerCallback(e), (e)=>Ww.unregisterCallback(e), (e, t1)=>({
                    type: e,
                    data: t1
                })).pipe(ke((e)=>Uo(e))))),
    epics3: (e)=>dr(e, [
            Lw,
            Nw,
            Vw,
            Uw,
            jw,
            xw
        ]).pipe(Jy((e)=>{
            const { payload: { type: t1, data: o } } = e;
            if (t1 === Nw || t1 === jw) {
                if (o === sd.EncodeSuccess) return ep(Zl), _e(jo("success"));
                if (o === sd.DecodeSuccess) return ep(Yl), _e(xo("success"));
                if (o === sd.EncodeFailed) return ep(rc), _e(jo("failed"));
                if (o === sd.DecodeFailed) return ep(ic), _e(xo("failed"));
            } else if (t1 === Lw || t1 === Uw) {
                if (o === sd.EncodeSuccess) return ep(Xl), _e(Bo("success"));
                if (o === sd.DecodeSuccess) return ep(ec), _e(Fo("success"));
                if (o === sd.EncodeFailed) return ep(nc), _e(Bo("failed"));
                if (o === sd.DecodeFailed) return ep(sc), _e(Fo("failed"));
            } else if (t1 === Vw || t1 === xw) {
                if (o === sd.EncodeSuccess) return ep(tc), _e(Ho("success"));
                if (o === sd.DecodeSuccess) return ep(oc), _e($o("success"));
                if (o === sd.EncodeFailed) return ep(ac), _e(Ho("failed"));
                if (o === sd.DecodeFailed) return ep(dc), _e($o("failed"));
                if (t1 === Vw && void 0 === o) return ep(oc), _e($o("success"));
            }
        })),
    epics4: (e, t1)=>dr(e, [
            Lw,
            Nw
        ]).pipe(pt(()=>"object" == typeof navigator.mediaDevices ? Ye(Cy(), Ye(dr(e, nd.StartVideoCaptureSuccess), ze(navigator.mediaDevices, "devicechange"), dr(e, nd.UserGrantCaptureAudio).pipe(tt(()=>!t1.value.audio.isUserGrantCaptureAudio))).pipe(Be(()=>Cy().pipe(gt(()=>{
                    setTimeout(()=>{
                        ep(uc);
                    }, 50);
                }))))).pipe(vt(t1), Be((e)=>{
                let [t1, o] = e;
                const r = [
                    Ph(t1.microphones),
                    Mh(t1.speakers),
                    Ym(t1.cameras)
                ];
                if (o.audio) {
                    const { audio: { activeMicrophone: e, activeSpeaker: s, microphoneDevicesList: a, speakerDevicesList: d }, video: { cameraDevicesList: u, activeCamera: l } } = o, c = sh(o), { microphones: p, speakers: h, cameras: m } = t1, g = a.filter((e)=>-1 === p.findIndex((t1)=>t1.deviceId === e.deviceId)), v = d.filter((e)=>-1 === h.findIndex((t1)=>t1.deviceId === e.deviceId)), f = u.filter((e)=>-1 === m.findIndex((t1)=>t1.deviceId === e.deviceId));
                    if (g.length > 0) {
                        if (g.some((t1)=>Vy(t1, e, a))) {
                            const e = Uy(p);
                            Ww.changeMicrophone("default", null == e ? void 0 : e.label, !(null == c || !c.muted)), r.push(kh("default"));
                        }
                    } else if ("default" === e) {
                        const e = Uy(a), t1 = Uy(p);
                        a.length > 0 && (null == e ? void 0 : e.label) !== (null == t1 ? void 0 : t1.label) && Ww.changeMicrophone("default", null == t1 ? void 0 : t1.label, !(null == c || !c.muted));
                    }
                    var i, n;
                    v.length > 0 ? v.some((e)=>Vy(e, s, d)) && (Ww.changeSpeaker("default"), r.push(Lh("default"))) : "default" === s && d.length > 0 && (null === (i = Uy(d)) || void 0 === i ? void 0 : i.label) !== (null === (n = Uy(h)) || void 0 === n ? void 0 : n.label) && Ww.changeSpeaker("default"), f.length > 0 && f.some((e)=>Vy(e, l, u)) && (Ww.stopCaptureVideo(), r.push(Xm(ms.isAndroidOrIOSBrowser ? Rd.User : "default")));
                }
                return Ce(r);
            })) : ie)),
    epics5: (e, t1)=>ar(e, Ds).pipe(gt((e)=>{
            const { type: o, payload: { body: r } } = e, i = o === `${Oo}`;
            if (r.add) {
                const e = r.add.map((e)=>({
                        userid: e.id,
                        sn: e.zoomID && Kr(e.zoomID)
                    }));
                if (!i) {
                    const { meeting: { gcmSessinKey: o } } = t1.value;
                    Ww.sendUserNodeList(e, o);
                }
                Ww.updateUserMediaSN({
                    added: e,
                    isFromMainSession: i,
                    iVType: Es.SHARING_DECODE
                }), i && Ww.updateUserMediaSN({
                    added: e,
                    isFromMainSession: i,
                    iVType: Es.AUDIO_DECODE
                });
            }
            if (r.remove && r.remove.length > 0) {
                if (!i) {
                    const { meeting: { gcmSessinKey: e } } = t1.value;
                    Ww.sendUserNodeList(r.remove.map((e)=>({
                            userid: e.id,
                            bremove: !0
                        })), e);
                }
                Ww.updateUserMediaSN({
                    removed: r.remove.map((e)=>e.id),
                    isFromMainSession: i,
                    iVType: Es.SHARING_DECODE
                }), i && Ww.updateUserMediaSN({
                    removed: r.remove.map((e)=>e.id),
                    isFromMainSession: i,
                    iVType: Es.AUDIO_DECODE
                });
            }
        }), dt(ie)),
    epics6: (e)=>dr(e, nd.AesGcmIvResponse).pipe(gt((e)=>{
            const { payload: { data: { workerType: t1, iv: o } } } = e, r = is.get(ns.WebclientIVState);
            if (r) {
                const e = {
                    ...r,
                    [t1]: o
                };
                is.set(ns.WebclientIVState, e, os.SessionStorage);
            }
        }), dt(ie)),
    epics7: (e)=>e.pipe(Ot(`${Co}`), tt((e)=>[
                Ms,
                ks,
                Os
            ].includes(e.payload.evt)), ke((e)=>{
            const { payload: { evt: t1, body: { encryptKey: o, additionalType: r } } } = e;
            return Go({
                type: t1 === Ms ? "audio" : t1 === ks ? "video" : "sharing",
                encryptKey: o,
                additionalType: r
            });
        })),
    epics8: (e)=>e.pipe(Ot(`${Wo}`), gt((e)=>{
            const { payload: t1 } = e;
            kw.setMediaOption({
                assetsPath: t1.assetsPath,
                enforceMultipleVideos: t1.enforceMultipleVideos,
                enforceVirtualBackground: t1.enforceVirtualBackground
            });
        }), dt(ie)),
    epics9: (e)=>e.pipe(Ot(`${on}`, `${tn}`), gt(()=>{
            Ow.getInstance().inProgress && (Ow.getInstance().disconnect(), jy.watch(Ow.getInstance().destroy()));
        }), dt(ie)),
    epics10: (e)=>e.pipe(Ot(`${on}`, `${tn}`), pt(()=>"permissions" in navigator ? [
                "microphone",
                "camera"
            ].map((e)=>{
                navigator.permissions.query({
                    name: e
                }).then((t1)=>{
                    const o = ()=>{
                        ep(hc, {
                            name: e,
                            state: t1.state
                        });
                    };
                    o(), t1.addEventListener("change", o), zw.push(()=>{
                        t1.removeEventListener("change", o);
                    });
                }).catch(()=>{});
            }) : ie), dt(ie)),
    epics11: (e)=>e.pipe(Ot(`${On}`), tt((e)=>e.payload === Yn.Closed), gt(()=>{
            zw.length > 0 && (zw.forEach((e)=>e()), zw.length = 0);
        }), dt(ie)),
    epics12: (e, t1)=>dr(e, [
            Bw,
            Fw,
            Hw,
            Uw,
            jw,
            xw,
            $w
        ]).pipe(Be((o)=>{
            var r, i;
            const { payload: { type: n, data: s } } = o;
            let a, d;
            if (n === $w) {
                const o = "audio";
                let [r, i] = [
                    0,
                    ""
                ];
                s ? (r = tu.MicrophoneMuted, i = "Your mic is muted in system or browser settings. Please open your settings to unmute and adjust the level.") : (r = tu.AudioStreamMuted, i = "Audio was interrupted by the system. Please click anywhere to resume playback.", d = ot(ze(document, "click").pipe(it(1)), ze(document, "touchend").pipe(it(1))).pipe(ht(np())).pipe(ht(dr(e, nd.AudioStreamUnmuted).pipe(it(1))), gt(()=>{
                    !function(e, t1) {
                        const { audio: { activeMicrophone: o, microphoneDevicesList: r } } = t1, i = r.find((e)=>e.deviceId === o), n = sh(t1);
                        e.changeMicrophone(o, null == i ? void 0 : i.label, !(null == n || !n.muted));
                    }(Ww, t1.value);
                }))), a = {
                    message: i,
                    type: o,
                    code: r
                };
            } else if (n === Bw) {
                let [e, t1] = [
                    "",
                    0
                ];
                -129 === s ? (e = "sharing", t1 = tu.SharingStreamFailed) : [
                    -130,
                    -135
                ].includes(s) ? (e = "video", t1 = tu.VideoStreamFailed) : [
                    -131,
                    -136
                ].includes(s) && (e = "audio", t1 = tu.AudioStreamFailed), a = {
                    message: "Oops! Something went wrong. Please close all browsers and rejoin the meeting.",
                    type: e,
                    code: t1
                };
            }
            return Gw.report(`active media failed. reason:${n}; message:${null === (r = a) || void 0 === r ? void 0 : r.message}`, `${null === (i = a) || void 0 === i || null === (i = i.type) || void 0 === i ? void 0 : i.replace(/^./, (e)=>e.toUpperCase())} exception flow`), ep(mc, a), null != d ? d : Ce([]);
        }), Be(()=>ie)),
    epics13: (e)=>ir(e, 4366).pipe(gt((e)=>{
            const { payload: t1 } = e;
            Ww.bypassMediaMessage(t1);
        }), Be(()=>ie))
}, Jw = rr(qw), Qw = {
    meeting: cA,
    socket: LA,
    participants: HA,
    media: KA
}, Zw = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || Rt;
function Yw(e) {
    return function(e) {
        for(var t1 = Object.keys(e), o = {}, r = 0; r < t1.length; r++){
            var i = t1[r];
            "function" == typeof e[i] && (o[i] = e[i]);
        }
        var n, s = Object.keys(o);
        try {
            !function(e) {
                Object.keys(e).forEach(function(t1) {
                    var o = e[t1];
                    if (void 0 === o(void 0, {
                        type: Ct.INIT
                    })) throw new Error(Et(12));
                    if (void 0 === o(void 0, {
                        type: Ct.PROBE_UNKNOWN_ACTION()
                    })) throw new Error(Et(13));
                });
            }(o);
        } catch (e) {
            n = e;
        }
        return function(e, t1) {
            if (void 0 === e && (e = {}), n) throw n;
            for(var r = !1, i = {}, a = 0; a < s.length; a++){
                var d = s[a], u = o[d], l = e[d], c = u(l, t1);
                if (void 0 === c) throw t1 && t1.type, new Error(Et(14));
                i[d] = c, r = r || c !== l;
            }
            return (r = r || s.length !== Object.keys(e).length) ? i : e;
        };
    }({
        ...Qw,
        ...e
    });
}
function Xw(e, t1, o, r, i) {
    var n = {};
    return Object.keys(r).forEach(function(e) {
        n[e] = r[e];
    }), n.enumerable = !!n.enumerable, n.configurable = !!n.configurable, ("value" in n || n.initializer) && (n.writable = !0), n = o.slice().reverse().reduce(function(o, r) {
        return r(e, t1, o) || o;
    }, n), i && void 0 !== n.initializer && (n.value = n.initializer ? n.initializer.call(i) : void 0, n.initializer = void 0), void 0 === n.initializer ? (Object.defineProperty(e, t1, n), null) : n;
}
const eT = Symbol("store"), tT = Symbol("getState"), oT = Symbol("dispatch"), rT = Symbol("additionFeatures"), iT = Symbol("mediaContext");
function nT(e, t1, o) {
    const r = o.value;
    o.value = function() {
        const e = this[eT];
        if (e) {
            const { meeting: { isOnHold: t1, isMeetingReset: o, meetingStatus: r } } = e.getState();
            if (r !== Yn.Joined) return Promise.reject({
                type: Jl,
                reason: "closed"
            });
            if (o) return Promise.reject({
                type: Jl,
                reason: "reconnecting"
            });
            if (t1) return Promise.reject({
                type: Jl,
                reason: "on hold"
            });
        }
        for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
        return r.apply(this, o);
    };
}
function sT(e, t1, o) {
    const r = o.value;
    o.value = function() {
        const e = this[eT];
        if (e) {
            const t1 = e.getState();
            if (!ah(t1)) return Promise.reject({
                type: ql,
                reason: "only host or co-host can do the operation"
            });
        }
        for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
        return r.apply(this, o);
    };
}
function aT(e, t1, o) {
    const r = o.value;
    o.value = function() {
        const e = this[eT];
        if (e) {
            const t1 = e.getState();
            if (!dh(t1)) return Promise.reject({
                type: ql,
                reason: "only host can do the operation"
            });
        }
        for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
        return r.apply(this, o);
    };
}
function dT(e) {
    return function(t1, o, r) {
        const i = r.value;
        r.value = function() {
            const t1 = this[eT];
            if (t1 && void 0 === t1.getState()[e]) return Promise.reject({
                type: Gl,
                reason: `Module:${e} is not enabled`
            });
            for(var o = arguments.length, r = new Array(o), n = 0; n < o; n++)r[n] = arguments[n];
            return i.apply(this, r);
        };
    };
}
function uT(e) {
    return function(t1, o, r) {
        const i = r.value;
        r.value = function() {
            const t1 = this[eT];
            if (t1) {
                const { meeting: { meetingOptions: o } } = t1.getState();
                if (!0 === o[e]) return Promise.reject({
                    type: "OPERATION_LOCKED",
                    reason: `${e} is locked`
                });
            }
            for(var o = arguments.length, r = new Array(o), n = 0; n < o; n++)r[n] = arguments[n];
            return i.apply(this, r);
        };
    };
}
let lT = function(e) {
    return e.Self = "Self", e.Other = "Other", e.Client = "Client", e.Phone = "Phone", e.Attendee = "Attendee", e;
}({});
function cT(e) {
    return function(t1, o, r) {
        const i = r.value;
        r.value = function(t1) {
            const o = this[eT];
            if (o) {
                const r = o.getState(), i = Array.isArray(e) ? e : [
                    e
                ];
                let n = ch(r).find((e)=>e.userId === t1);
                if (i.findIndex((e)=>e === lT.Attendee) > -1 && (n = uh(r).find((e)=>e.userId === t1)), !n) return Promise.reject({
                    type: Ql,
                    reason: "no matching user"
                });
                {
                    const { meeting: { userId: e } } = o.getState();
                    for(let o = 0; o < i.length; o++){
                        const r = i[o];
                        if (r === lT.Other && t1 === e) return Promise.reject({
                            type: Gl,
                            reason: "operation is not applicable to self"
                        });
                        if (r === lT.Self && t1 !== e) return Promise.reject({
                            type: Gl,
                            reason: "operation is only applicable to self "
                        });
                        if (r === lT.Client && $p(n.userType) || r === lT.Phone && !$p(n.userType)) return Promise.reject({
                            types: Gl,
                            reason: "improper target client"
                        });
                    }
                }
            }
            for(var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)n[s - 1] = arguments[s];
            const a = [
                t1,
                ...n
            ];
            return i.apply(this, a);
        };
    };
}
const pT = pE.getInstance();
function hT(e, t1) {
    return function(o, r, i) {
        const n = i.value;
        i.value = function() {
            for(var o = arguments.length, i = new Array(o), s = 0; s < o; s++)i[s] = arguments[s];
            if (pT.checkLaplace()) try {
                var a;
                const o = pT.makeLogger([
                    e
                ]), s = null === (a = t1 ? i.map((e, o)=>t1.includes(o + 1) ? aE(e) : e) : i) || void 0 === a ? void 0 : a.map((e)=>si(e));
                return o.info(`${r},params:${JSON.stringify(s)}`), n.apply(this, i).then((e)=>(o.info(`${r} success`), e)).catch((t1)=>{
                    let o = `${r},params:${JSON.stringify(s)},return failed,`;
                    return "object" == typeof t1 && (o = `${o},${t1.type ? `type:${t1.type},` : ""}${t1.reason ? `reason:${t1.reason}` : ""}`), pT.report(o, `${e} exception flow`, "error"), Promise.reject(t1);
                });
            } catch (e) {}
            return n.apply(this, i);
        };
    };
}
function mT(e, t1, o) {
    return function(r, i, n) {
        const s = n.value;
        n.value = function() {
            for(var r, i, n = arguments.length, a = new Array(n), d = 0; d < n; d++)a[d] = arguments[d];
            const u = a[t1];
            let l = e;
            return Array.isArray(l) || (l = [
                l
            ]), !l.some((e)=>u instanceof e) || o && !o.every((e)=>!!u[e]) ? Promise.reject({
                type: Ql,
                reason: `Expected to accept ${null === (r = l) || void 0 === r ? void 0 : r.map((e)=>e.name).join(" or ")}, but actual it is ${"object" == typeof u && null !== u ? null === (i = Object.getPrototypeOf(u)) || void 0 === i ? void 0 : i.constructor.name : u}`
            }) : s.apply(this, a);
        };
    };
}
class gT {
    constructor(e){
        this[eT] = void 0, this[oT] = void 0, this[tT] = void 0, this[rT] = void 0, this[eT] = e, this[oT] = e.dispatch, this[tT] = e.getState;
    }
}
const vT = [
    "userId",
    "displayName",
    "audio",
    "isHost",
    "avatar",
    "bRaiseHand",
    "bHold",
    "bVideoOn",
    "sharerOn",
    "sharerPause",
    "feedback",
    "bLocalRecord",
    "strPronoun",
    "sdkKey",
    "audioConnectionStatus",
    "caps",
    "bAllowISORecord",
    "bVideoConnect",
    "userIdentity",
    "isSpeakerOnly",
    "bVideoShare",
    "bShareAudioOn",
    "bShareToBORooms",
    "bid",
    {
        from: "bInFailover",
        to: "isInFailover"
    },
    {
        from: "userGUID",
        to: "userGuid"
    },
    {
        from: "bGuest",
        to: "isGuest"
    },
    {
        from: "sharerPause",
        to: "sharePause"
    },
    {
        from: "bCoHost",
        to: (e)=>({
                isCoHost: !!e
            })
    },
    {
        from: "muted",
        to: (e, t1)=>({
                muted: null != t1 && t1.isSpeakerOnly || "" === (null == t1 ? void 0 : t1.audio) ? void 0 : e
            })
    },
    {
        from: "userType",
        to: (e, t1)=>{
            const o = $p(e), r = {
                isPhoneUser: o
            };
            return o && null != t1 && t1.phoneNumber && Object.assign(r, {
                phoneNumber: t1.phoneNumber
            }), r;
        }
    }
];
function fT(e) {
    return vT.reduce((t1, o)=>{
        const r = "string" == typeof o ? o : o.from, i = function(e, t1, o) {
            if ("string" == typeof e) return {
                [`${e}`]: t1
            };
            if ("object" == typeof e && void 0 !== e.from) {
                const { to: r } = e;
                return "string" == typeof r ? {
                    [`${r}`]: t1
                } : r(t1, o);
            }
        }(o, e[r], e);
        return {
            ...t1,
            ...i
        };
    }, {});
}
function yT() {
    const { isSupportAudioWorklet: e, isSupportEssentialAudioAndVideoAbility: t1, isAndroidOrIOSBrowser: o, isSupportSendScreenSharing: r } = ms, i = t1 && e || o, n = t1 && void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaCapabilities, s = "function" == typeof "".replaceAll;
    return {
        audio: s && i,
        video: s && n,
        screen: s && t1 && r
    };
}
const ST = (e)=>{
    let { breakoutRoom: { mainSessionAttendeeList: t1 } } = e;
    return t1;
}, bT = (e)=>{
    let { meeting: { zoomId: t1 } } = e;
    return t1;
}, ET = (e)=>{
    let { breakoutRoom: { isHugeBO: t1 } } = e;
    return t1;
}, IT = Np([
    (e)=>{
        let { breakoutRoom: { controlStatus: t1 } } = e;
        return t1;
    },
    (e)=>{
        let { breakoutRoom: { currentRoom: { status: t1 } } } = e;
        return t1;
    },
    (e)=>{
        let { breakoutRoom: { currentRoom: { boId: t1 } } } = e;
        return t1;
    }
], (e, t1, o)=>!(e !== zp.InProgress && e !== zp.Closing || t1 !== Jp.InRoom && t1 !== Jp.TimeUp || !o)), AT = Np([
    (e)=>{
        let { breakoutRoom: { rooms: t1 } } = e;
        return t1;
    },
    Vp,
    bT,
    ST,
    IT,
    ET
], (e, t1, o, r, i, n)=>{
    const s = e.reduce((e, t1)=>{
        const { attendeeGuidList: o } = t1;
        return e.concat(o);
    }, []);
    return (i ? r : t1).filter((e)=>!e.bHold && !e.isHost && e.zoomID !== o && !e.bid && !s.includes(e.userGUID) && (!n || rS(e.caps)));
}), CT = Np([
    IT,
    ST,
    Vp,
    bT,
    ET
], (e, t1, o, r, i)=>(e ? t1 : o).filter((e)=>!e.bHold && !e.isHost && e.zoomID !== r && !e.bid && (!i || rS(e.caps)))), _T = Np([
    IT,
    ST,
    Vp
], (e, t1, o)=>e ? t1.find((e)=>e.isHost) : o.find((e)=>e.isHost));
var RT, wT, TT, OT;
const DT = ra.createAgent();
let PT = (RT = cT(lT.Other), wT = cT(lT.Other), TT = cT(lT.Other), OT = class extends gT {
    constructor(e){
        super(e), this.modules = void 0, this.useSDK = void 0, this.useSDK = !1, this.modules = new Map;
    }
    initWithSDK(e, t1, o) {
        return this.useSDK = !0, this.init(e, t1, o);
    }
    init(e, t1, o) {
        const { audio: r, video: i } = yT();
        if (!r || !i) return console.error("https://developers.zoom.us/docs/video-sdk/web/browser-support"), Promise.reject({
            type: Gl,
            reason: "Please update to the latest Chrome, Edge, Safari, or Firefox, as your current browser doesn't support audio/video. Retry after the upgrade."
        });
        const { [oT]: n, [eT]: s } = this;
        let a = vr;
        const d = (null == o ? void 0 : o.fileWithVersion) || !1;
        let u = "en-US", l = `${vr}/${Jn}`;
        if (o) {
            const { dependentAssets: e, additionalFeatures: t1, constraints: r, language: i, webEndpoint: n } = o;
            i && (u = i), n && function(e) {
                hr = cr(e, {
                    hostname: !0
                });
            }(n), e === Qn.CDN || e === gr ? (a = gr, l = `${gr}/${Jn}`) : e === Qn.Global || e === vr ? (a = vr, l = `${vr}/${Jn}`) : e === Qn.CN || e === fr ? (a = fr, l = `${fr}/${Jn}`) : e && /^https?:\/\//.test(e) && (a = oi(e), l = d ? `${a}/1501_js_media.min.js` : `${a}/${Jn}`), t1 && Array.isArray(t1) && t1.forEach((e)=>{
                if (this[rT][e] && void 0 === s.getState()[e]) {
                    const { epic: t1, reducer: o, Client: r } = this[rT][e];
                    s.injectReducer(e, o), s.injectEpic(t1);
                    const i = new r(s);
                    this.modules.set(e, i);
                }
            }), null != r && r.audio && void 0 === s.getState().audio && (s.injectReducer("audio", p_), s.injectEpic(g_)), null != r && r.video && void 0 === s.getState().video && (s.injectReducer("video", Cw), s.injectEpic(Tw)), null != r && r.screen && void 0 === s.getState().share && (s.injectReducer("share", DI), s.injectEpic(kI));
        }
        return n(mn({
            apiKey: e,
            signature: t1,
            language: u,
            useSDK: this.useSDK
        })), n(Wo({
            mediaConstraints: o && o.constraints || {},
            assetsPath: a,
            fileWithVersion: d,
            enforceMultipleVideos: null == o ? void 0 : o.enforceMultipleVideos,
            enforceVirtualBackground: null == o ? void 0 : o.enforceVirtualBackground,
            skipJsMedia: null == o ? void 0 : o.skipJsMedia,
            patchJsMedia: null == o ? void 0 : o.patchJsMedia,
            alternativeNameForVideoPlayer: null == o ? void 0 : o.alternativeNameForVideoPlayer
        })), void 0 !== (null == o ? void 0 : o.stayAwake) && n(xn(o.stayAwake)), void 0 !== (null == o ? void 0 : o.quicklyLeaveMeeting) && n($n(o.quicklyLeaveMeeting)), new Promise((e, t1)=>{
            null != o && o.skipJsMedia ? e("") : lr(l, ()=>{
                e("");
            }, ()=>{
                t1({
                    type: Ql,
                    reason: "dependent assets are not accessible"
                });
            });
        });
    }
    on(e, t1) {
        ((e, t1)=>{
            const o = zc[e];
            if (o) {
                const r = Jc.get(e);
                if (r) r.push(t1), Jc.set(e, r);
                else {
                    const r = [
                        t1
                    ];
                    Jc.set(e, r);
                    const i = Ye(...o.map((e)=>{
                        const { event: t1, payload: o } = e;
                        return ze(qc, t1).pipe(ke((e)=>o(e)), Ee(X));
                    })).subscribe((t1)=>{
                        const o = Jc.get(e);
                        o && o.forEach((e)=>{
                            e(t1);
                        });
                    });
                    Qc.push(i);
                }
            }
        })(e, t1);
    }
    off(e, t1) {
        ((e, t1)=>{
            if (zc[e]) {
                const o = Jc.get(e);
                if (Array.isArray(o)) {
                    const r = o.filter((e)=>e !== t1);
                    Jc.set(e, r);
                }
            }
        })(e, t1);
    }
    getFeatureModule(e) {
        return this.modules.get(e);
    }
    leave() {
        const { [tT]: e, [oT]: t1 } = this, { socket: { zoomSocketStatus: o } } = e();
        return o === yh.Connected || o === yh.Connecting ? t1(sn()) : t1(an()), Te(Qe(500).pipe(st("")));
    }
    end() {
        const { [tT]: e, [oT]: t1 } = this;
        return "connected" === e().socket.zoomSocketStatus ? (t1(dn()), Te(Qe(500).pipe(gt(()=>{
            sp();
        }), st("")))) : Promise.resolve("");
    }
    changeName(e, t1) {
        const o = this[eT].getState(), { meeting: { bAllowAttendeeRename: r } } = o, i = sh(o), n = Gp(i.userRole), s = ah(o);
        if (n) return Promise.reject({
            type: ql
        });
        if (t1 && t1 !== (null == i ? void 0 : i.userId)) {
            if (s) {
                const { participants: { attendeesList: r } } = o, i = r.find((e)=>e.userId === t1);
                if (i) return DT.rename(t1, Hr(e), Hr(i.displayName)), Gy({
                    userId: t1,
                    key: "displayName"
                }, (t1)=>t1.displayName === e);
                {
                    const r = uh(o).find((e)=>e.userId === t1);
                    if (r) {
                        const t1 = UI.getInstance();
                        return DT.rename(r.userId, Hr(e), Hr(r.displayName)), t1.rename(r.jid, e), rp(va, (t1)=>{
                            const o = t1.find((e)=>e.jid === r.jid);
                            return o && o.displayName === e;
                        });
                    }
                    return Promise.reject({
                        type: Ql,
                        reason: "no matching user"
                    });
                }
            }
            return Promise.reject({
                type: ql
            });
        }
        return e === i.displayName ? Promise.resolve() : s || r ? (DT.rename(i.userId, Hr(e), Hr(i.displayName)), rp(pa, (t1)=>t1.displayName === e)) : Promise.reject({
            type: ql,
            reason: "host disallow rename themselves"
        });
    }
    makeHost(e) {
        return DT.assignHost(e, !1), Gy({
            userId: e,
            key: "isHost"
        }, (e)=>!0 === e.isHost);
    }
    makeCoHost(e) {
        const t1 = this[eT].getState(), o = ch(t1).find((t1)=>t1.userId === e);
        return !0 === (null == o ? void 0 : o.bCoHost) ? Promise.reject({
            type: Ql,
            reason: `user:[${e}] is already co-host `
        }) : (DT.assignHost(e, !0), Gy({
            userId: e,
            key: "bCoHost"
        }, (e)=>!0 === e.bCoHost));
    }
    revokeCoHost(e) {
        const t1 = this[eT].getState(), o = ch(t1).find((t1)=>t1.userId === e);
        return !1 === (null == o ? void 0 : o.bCoHost) ? Promise.reject({
            type: Ql,
            reason: `user:[${e}] is not a co-host`
        }) : (DT.revokeCoHost(e), Gy({
            userId: e,
            key: "bCoHost"
        }, (e)=>!1 === e.bCoHost));
    }
    reclaimHost() {
        const e = this[tT](), { meeting: { isOriginHost: t1 } } = e, o = sh(e);
        return null != o && o.isHost ? Promise.resolve("") : t1 ? (DT.reclaimHost(o.userId, !1), rp(pa, (e)=>!0 === e.isHost)) : Promise.reject({
            type: ql,
            reason: "You are not the origin host"
        });
    }
    isHost() {
        const e = this[eT].getState(), t1 = sh(e);
        return !!t1 && t1.isHost;
    }
    isCoHost() {
        const e = this[eT].getState(), t1 = sh(e);
        return !!t1 && !!t1.bCoHost;
    }
    isOriginHost() {
        const { meeting: { isOriginHost: e } } = this[tT]();
        return e;
    }
    getCurrentUserInfo() {
        const e = this[eT].getState(), t1 = sh(e);
        if (t1) {
            const o = fT(t1);
            if (e.meeting.isWebinar && Gp(t1.userRole)) {
                const { audio: t1 } = e, r = null == t1 ? void 0 : t1.isAllowToTalk;
                Object.assign(o, {
                    isAllowToTalk: r
                });
            }
            if (e.breakoutRoom && IT(e)) {
                const { breakoutRoom: { currentRoom: { boId: t1 } } } = e;
                Object.assign(o, {
                    bid: t1
                });
            }
            return o;
        }
        return null;
    }
    getParticipantsList() {
        const e = this[eT].getState(), { meeting: { meetingStatus: t1 } } = e, o = sh(e);
        if (t1 === Yn.Joined && o && !o.bHold) {
            var r;
            const t1 = e.breakoutRoom && IT(e) ? null === (r = e.breakoutRoom) || void 0 === r || null === (r = r.currentRoom) || void 0 === r ? void 0 : r.boId : "";
            return ch(e).map((e)=>{
                const o = fT(e);
                return t1 && Object.assign(o, {
                    bid: t1
                }), o;
            });
        }
        return [];
    }
    getAssistantsList() {
        const e = this[eT].getState(), { meeting: { meetingStatus: t1 } } = e, o = sh(e);
        return t1 === Yn.Joined && o ? ph(e).map((e)=>({
                userId: e.userId,
                displayName: e.displayName,
                isNewAst: !0
            })) : [];
    }
    getMeetingHost() {
        var e;
        const t1 = this[tT]();
        let o = hh(t1);
        return o || (null === (e = t1.breakoutRoom) || void 0 === e ? void 0 : e.currentRoom.status) !== Jp.InRoom || (o = t1.breakoutRoom.mainSessionAttendeeList.find((e)=>e.isHost)), void 0 !== o ? fT(o) : null;
    }
    getMeetingInfo() {
        const { meeting: { meetingStatus: e, isOnHold: t1, meetingNumber: o, passWord: r, userName: i, userEmail: n, meetingTopic: s, meetingOptions: a, encType: d, region: u, network: l, topic: c, zlkJwtToken: p, userId: h, lang: m, inviteEmail: g, meetingId: v, participantID: f, h323Password: y, recordingDisclaimer: S, recordingDisclaimerForRecorder: b, wrInfo: E, meetingInfo: I, isNewJoinFlow: A, chatModerationPolicy: C } } = this[tT](), _ = e === Yn.Joined && !t1;
        if (p) return {
            topic: c,
            password: r,
            userName: i,
            isInMeeting: _,
            userId: h,
            meetingId: v
        };
        {
            let e = "";
            return 0 === d ? e = "None" : 1 === d ? e = "AES ECB" : 2 === d && (e = "AES GCM"), {
                meetingNumber: o,
                password: r,
                userName: i,
                userEmail: n,
                inviteEmail: g,
                meetingTopic: s,
                encryptionType: e,
                region: u,
                network: l,
                isInMeeting: _,
                userId: h,
                lang: m,
                webEndpoint: yr(),
                meetingId: v,
                participantId: f,
                telPwd: y,
                recordingInfo: {
                    recordingDisclaimer: S,
                    recordingDisclaimerForRecorder: b,
                    isUserEnableRecordingReminder: null == a ? void 0 : a.isUserEnableRecordingReminder
                },
                wrInfo: Object.assign({}, E, {
                    isNew: A
                }),
                scheduleInfo: I,
                chatModerationPolicy: C
            };
        }
    }
}, Xw(OT.prototype, "end", [
    aT,
    nT
], Object.getOwnPropertyDescriptor(OT.prototype, "end"), OT.prototype), Xw(OT.prototype, "changeName", [
    nT
], Object.getOwnPropertyDescriptor(OT.prototype, "changeName"), OT.prototype), Xw(OT.prototype, "makeHost", [
    RT,
    aT,
    nT
], Object.getOwnPropertyDescriptor(OT.prototype, "makeHost"), OT.prototype), Xw(OT.prototype, "makeCoHost", [
    wT,
    aT,
    nT
], Object.getOwnPropertyDescriptor(OT.prototype, "makeCoHost"), OT.prototype), Xw(OT.prototype, "revokeCoHost", [
    TT,
    aT,
    nT
], Object.getOwnPropertyDescriptor(OT.prototype, "revokeCoHost"), OT.prototype), Xw(OT.prototype, "reclaimHost", [
    nT
], Object.getOwnPropertyDescriptor(OT.prototype, "reclaimHost"), OT.prototype), OT);
const MT = ra.createAgent(), kT = UI.getInstance(), LT = (e, t1, o)=>{
    const r = null == t1 ? void 0 : t1.userId;
    if (null == e || !e.zoomID || null == t1 || !t1.displayName || r === e.userId) return {
        type: Ql,
        reason: "invalid target user"
    };
    const { chat: { chatPrivilege: i, panelistChatPrivilege: n }, meeting: { isWebinar: s } } = o, a = ah(o), d = t1.isHost || t1.bCoHost;
    let u = !1;
    if (!a) {
        if (s) if (Gp(e.userRole)) (i === js.NoAttendee || i === js.AllPanelist && r !== Bs.Panelist || i === js.All && r !== Bs.All && r !== Bs.Panelist) && (u = !0);
        else {
            const e = Gp(null == t1 ? void 0 : t1.userRole);
            (n === xs.Invalid || n === xs.AllPanelist && (e || r === Bs.All)) && (u = !0);
        }
        else (i === js.NoAttendee || i === js.Host && !d || r === Bs.SilentModeUsers || i === js.EveryonePublicly && r !== Bs.All && !d) && (u = !0);
        if (u) return {
            type: ql,
            reason: "Insufficient chat privilege"
        };
    }
    return null;
};
function NT(e, t1) {
    if (t1 === Bs.All) return zs;
    if (t1 === Bs.Panelist) return qs;
    if (t1 === Bs.SilentModeUsers) return Js;
    {
        const { meeting: { isWebinar: o }, participants: { xmppAttendeeList: r, attendeesList: i } } = e;
        return o ? i.find((e)=>e.userId === t1) || r.find((e)=>e.userId === t1) : i.find((e)=>e.userId === t1);
    }
}
function VT(e, t1, o) {
    if (null != o && o.host) return [
        hh(e),
        ...mh(e)
    ].filter((e)=>(null == e ? void 0 : e.userId) !== t1).map((e)=>({
            userId: null == e ? void 0 : e.userId,
            displayName: null == e ? void 0 : e.displayName,
            isHost: null == e ? void 0 : e.isHost,
            isCoHost: null == e ? void 0 : e.bCoHost
        }));
    {
        let r = [
            hh(e),
            ...mh(e),
            ...e.participants.attendeesList.filter((e)=>!(e.bCoHost || e.isHost || e.bHold))
        ];
        if (null != o && o.includeAttendee) {
            const t1 = uh(e).filter((e)=>!$p(e.userType));
            r = [
                ...r,
                ...t1
            ];
        }
        return r.filter((e)=>void 0 !== e && e.userId !== t1).map((e)=>({
                userId: null == e ? void 0 : e.userId,
                displayName: null == e ? void 0 : e.displayName,
                isHost: null == e ? void 0 : e.isHost,
                isCoHost: null == e ? void 0 : e.bCoHost
            }));
    }
}
function UT(e) {
    const { text: t1, destId: o, sn: r, attendeeId: i } = e;
    return ws.beginEncrypt({
        text: t1,
        type: As.RWG_CHAT
    }).then((e)=>{
        MT.chat(e, o, r, i);
    });
}
function jT(e, t1) {
    const { chat: { chatHistory: o } } = t1;
    return o.find((t1)=>{
        var o;
        return (null === (o = t1.file) || void 0 === o || null === (o = o.upload) || void 0 === o ? void 0 : o.uniqueId) === e;
    });
}
function xT(e, t1) {
    const { meeting: { isWebinar: o }, participants: { attendeesList: r } } = t1, { destNodeID: i, senderName: n, attendeeNodeID: s } = e, a = r.find((e)=>e.userId === i), d = e.sn ? e.sn : null == a ? void 0 : a.zoomID, u = n ? $r(n) : null == a ? void 0 : a.displayName;
    let l, c = "";
    if (s === Bs.SilentModeUsers) return {
        sender: {
            name: "Host",
            userId: i
        },
        receiver: {
            name: "Everyone (in Waiting Room)",
            userId: s
        },
        timestamp: (new Date).getTime()
    };
    if (s === Bs.All) c = o ? "All panelists and attendees" : "Everyone";
    else if (s === Bs.Panelist) c = "All panelists";
    else {
        if (o) {
            const e = uh(t1).find((e)=>e.userId === s);
            e && (c = e.displayName);
        }
        if (!c) {
            const e = r.find((e)=>e.userId === s);
            e && (c = e.displayName, l = e.userGUID);
        }
    }
    return {
        sn: d,
        sender: {
            name: u,
            userId: i,
            userGuid: null == a ? void 0 : a.userGUID,
            avatar: null == a ? void 0 : a.avatar
        },
        receiver: {
            name: c,
            userId: s,
            userGuid: l
        },
        timestamp: (new Date).getTime()
    };
}
function BT(e) {
    var t1;
    const [o] = e.split(".").reverse();
    return null !== (t1 = ea[o]) && void 0 !== t1 ? t1 : "";
}
function FT(e, t1) {
    const o = [];
    for(let r = e.length - 1; r >= 0; r--){
        const i = e[r];
        if (!i.file && (!i.id && i.sender.userId === t1.userId && [
            Bs.All,
            Bs.Panelist,
            Bs.IndividualCcPanelist,
            t1.destNodeID
        ].includes(i.receiver.userId) && o.unshift(i), i.id)) break;
    }
    return o.length > 0 ? o[0] : null;
}
const HT = pE.getInstance(), $T = HT.makeLogger([
    "File Transfer"
]);
function WT(e, t1, o) {
    const { name: r, size: i } = e, { meeting: { reportDomain: n, svcUrl: s, conId: a } } = o;
    return `https://${n}${t1}?${new URLSearchParams({
        filename: r,
        filesize: i,
        rwg: s,
        cid: a
    }).toString()}`;
}
function GT(e, t1) {
    return t1.fileObj ? `${e}/zoomfile/download?objkey=${t1.fileObj}&business=meeting` : `${e}/file/${t1.fileID}?business=meeting`;
}
function KT(e, t1) {
    return {
        fileName: e.name,
        fileSize: e.size,
        receiverId: null == t1 ? void 0 : t1.userId,
        receiverGuid: null == t1 ? void 0 : t1.userGuid
    };
}
function zT(e, t1, o) {
    HT.report(`${e}. file name:${aE(t1.name)},file size:${t1.size}, ${"type" in t1 ? `file type:${t1.type}` : ""}, error:${o.name};${o.message}`, [
        "File Transfer"
    ]);
}
function qT(e) {
    var t1, o, r;
    return {
        id: e.id,
        fileName: null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.name,
        fileSize: null === (o = e.file) || void 0 === o ? void 0 : o.size,
        fileUrl: null === (r = e.file) || void 0 === r ? void 0 : r.fileUrl,
        senderId: e.sender.userId,
        senderGuid: e.sender.userGuid
    };
}
function JT(e, t1, o) {
    return new Promise((r, i)=>{
        const n = new FileReader;
        n.readAsArrayBuffer(e.slice(t1, o)), n.onload = (e)=>{
            var t1;
            return r(null === (t1 = e.target) || void 0 === t1 ? void 0 : t1.result);
        }, n.onerror = (e)=>i(e);
    });
}
async function QT(e, t1) {
    let [o, r] = [
        e.size,
        0
    ];
    null != t1 && (o = Math.min(Zs.ChunkSize, e.size - t1), r = t1);
    const i = e.size - r <= Zs.ChunkSize, n = Math.ceil(o / Zs.EncodeBlockSize);
    try {
        return function(e) {
            const t1 = e.reduce((e, t1)=>e + t1.byteLength, 0), o = new Uint8Array(t1);
            let r = 0;
            for (const t1 of e)o.set(new Uint8Array(t1), r), r += t1.byteLength;
            return o;
        }(await Promise.all(Array.from({
            length: i ? Math.max(n - 1, 1) : n
        }, (e, t1)=>({
                start: t1 * Zs.EncodeBlockSize + r,
                end: (i && t1 === n - 2 ? t1 + 2 : t1 + 1) * Zs.EncodeBlockSize + r
            })).map(async (o)=>{
            let { start: r, end: i } = o;
            try {
                const t1 = await JT(e, r, i);
                return t1 ? await ws.beginEncrypt({
                    text: new Uint8Array(t1),
                    type: As.CHAT_FILE
                }) : Promise.reject(null);
            } catch (o) {
                return zT(`encrypt file buffer error. offset:${t1},`, e, o), Promise.reject(o);
            }
        })));
    } catch (e) {
        console.warn(e);
    }
    return null;
}
function ZT(e, t1, o, r) {
    return r.pipe(Ot(`${Ev}`, `${Io}`), tt((r)=>{
        if (r.type === `${Io}`) return !0;
        const { payload: { uniqueId: i, fileName: n, userId: s } } = r;
        return t1 === i && e.name === n && o.userId === s;
    }), it(1), gt((r)=>{
        $T.info(`Cancel file upload. file name:${aE(e.name)},file size:${e.size},receiver id:${o.userId}`), ep(ja, {
            ...KT(e, o),
            progress: 0,
            status: Ys.Cancel,
            retryToken: r.type === `${Ev}` ? t1 : void 0
        });
    }));
}
function YT(e, t1) {
    if (null != e && e.file) {
        const { file: o, receiver: r } = e, { upload: { chunkIndex: i, totalChunks: n, uniqueId: s } } = o;
        return ep(ja, {
            ...KT(t1, r),
            progress: Math.floor((null != i ? i : 0) / (null != n ? n : 1) * 100),
            status: Ys.Fail,
            retryToken: s
        }), Ce([
            bv({
                upload: {
                    status: Ys.Fail,
                    progress: 0,
                    uniqueId: s
                }
            }),
            Iv({
                uniqueId: s,
                file: t1
            })
        ]);
    }
    return ie;
}
function XT(e, t1) {
    return ep(ja, {
        ...KT(e),
        progress: 0,
        status: Ys.Fail
    }), _e(bv({
        upload: {
            status: Ys.Fail,
            progress: 0,
            uniqueId: t1
        }
    }));
}
async function eO(e, t1, o, r) {
    const i = WT(e, "/wc/fileupload", r.value), n = new FormData;
    try {
        const s = await QT(e), a = jT(t1, r.value);
        if (s && a) {
            n.append("file", new File([
                s
            ], e.name));
            const { meeting: { zmk: d } } = r.value, { receiver: u } = a;
            return JI({
                url: i,
                method: "POST",
                headers: {
                    "Zoom-File-Origin": "redirect=support_auth",
                    zmk: d
                },
                crossDomain: ei(i),
                body: n,
                includeUploadProgress: !0
            }).pipe(ht(ZT(e, t1, u, o)), Be((o)=>{
                const { type: i, loaded: n, responseHeaders: s, total: a } = o;
                let d = 0, l = Ys.InProgress;
                const c = {
                    upload: {
                        uniqueId: t1
                    }
                }, p = [];
                if ("upload_loadstart" === i) d = 0;
                else if ("upload_progress" === i) d = Math.floor(n / a * 100 * .9);
                else if ("upload_load" === i) d = 90;
                else if ("download_load" === i) {
                    var h, m;
                    d = 100, l = Ys.Success;
                    const { chat: { fileServerDomain: e } } = r.value, t1 = null === (h = s["zoom-file-id"]) || void 0 === h ? void 0 : h.trim(), o = null === (m = s["zoom-file-obj"]) || void 0 === m ? void 0 : m.trim(), i = GT(e, {
                        fileObj: o
                    });
                    Object.assign(c, {
                        fileID: t1,
                        fileObj: o,
                        fileUrl: i
                    });
                }
                return Object.assign(c.upload, {
                    progress: d,
                    status: l
                }), (d > 0 || "upload_loadstart" === i) && (ep(ja, {
                    ...KT(e, u),
                    progress: d,
                    status: l
                }), p.push(bv(c))), Ce(p);
            }), rt((t1)=>(console.warn(t1), zT("Upload small file error.", e, t1), YT(a, e))));
        }
    } catch (e) {
        console.warn(e);
    }
    return XT(e, t1);
}
const tO = (()=>{
    const e = new by;
    return (t1)=>async function() {
            await e.acquire(), t1(...arguments), setTimeout(()=>{
                e.release();
            }, 3e3);
        };
})(), oO = function(e) {
    const t1 = [
        "chatFileTransfer"
    ];
    return new Proxy(e, {
        get: (e, o)=>"string" == typeof o && t1.includes(o) ? function() {
                return tO(e[o].bind(e))(...arguments);
            } : Reflect.get(e, o)
    });
}(ra.createAgent()), rO = {
    chatHistory: [],
    chatPrivilege: js.All,
    panelistChatPrivilege: xs.AllPanelist,
    isAllowAttendeeChat: !0,
    isFileTransferEnable: !0,
    isEnableFileTransferEncrypted: !0,
    fileTransferFileType: [],
    fileDownloadPromptIgnoreList: [],
    fileTransferSizeLimit: 0,
    fileServerDomain: "",
    failedFileTransfer: {}
}, iO = So({
    [`${hv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.chatHistory.push(o);
    }),
    [`${cv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.chatPrivilege = o;
    }),
    [`${pv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.panelistChatPrivilege = o;
    }),
    [`${gv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isAllowAttendeeChat = o;
    }),
    [`${vv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { destNodeID: r, msgID: i, userId: n } = o, s = FT(e.chatHistory, {
            userId: n,
            destNodeID: r
        });
        s && Object.assign(s, {
            id: i
        });
    }),
    [`${fv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { msgId: r } = o, i = e.chatHistory.findIndex((e)=>e.id === r);
        i >= 0 && e.chatHistory.splice(i, 1);
    }),
    [`${yv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        Object.assign(e, o);
    }),
    [`${Sv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { originFile: r, ...i } = o;
        e.chatHistory.push(i);
    }),
    [`${bv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { upload: r, download: i, originFile: n, ...s } = o;
        if (r) {
            var a;
            const { uniqueId: t1, ...o } = r, i = e.chatHistory.find((e)=>{
                var o;
                return e.file && (null === (o = e.file.upload) || void 0 === o ? void 0 : o.uniqueId) === t1;
            });
            null != i && null !== (a = i.file) && void 0 !== a && a.upload && (Object.assign(i.file.upload, {
                ...o
            }), Object.assign(i.file, {
                ...s
            }), i.file.upload.status === Ys.Success && e.failedFileTransfer[i.file.upload.uniqueId] && delete e.failedFileTransfer[i.file.upload.uniqueId]);
        } else if (i) {
            const { id: t1, fileUrl: o } = s, r = e.chatHistory.find((e)=>{
                var r;
                return e.id === t1 && (null === (r = e.file) || void 0 === r ? void 0 : r.fileUrl) === o;
            });
            null != r && r.file && (r.file.download ? Object.assign(r.file.download, {
                ...i
            }) : Object.assign(r.file, {
                download: i
            }));
        }
    }),
    [`${Ev}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { uniqueId: r, fileName: i, userId: n } = o, s = e.chatHistory.find((e)=>e.file && e.file.name == i && e.file.upload.uniqueId === r && e.file.upload.status === Ys.InProgress && e.receiver.userId === n);
        var a;
        null != s && s.file && Object.assign(null === (a = s.file) || void 0 === a ? void 0 : a.upload, {
            status: Ys.Cancel,
            progress: 0
        });
    }),
    [`${Iv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { uniqueId: r, file: i } = o;
        e.failedFileTransfer[`${r}`] || Object.assign(e.failedFileTransfer, {
            [`${r}`]: i
        });
    }),
    [`${Av}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { fileID: r, msgID: i, senderId: n } = o, s = e.chatHistory.find((e)=>{
            var t1;
            return (null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.fileID) === r && e.sender.userId === n;
        });
        s && Object.assign(s, {
            id: i
        });
    }),
    [`${Cv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { id: r, fileUrl: i } = o, n = e.chatHistory.find((e)=>{
            var t1, o;
            return e.id === r && (null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.fileUrl) === i && (null === (o = e.file) || void 0 === o ? void 0 : o.download.status) === Xs.InProgress;
        });
        var s;
        null != n && n.file && Object.assign(null === (s = n.file) || void 0 === s ? void 0 : s.download, {
            status: Xs.Cancel,
            progress: 0
        });
    }),
    [`${mv}`]: ()=>({
            ...rO
        })
}, rO);
var nO;
const sO = ra.createAgent();
let aO = (nO = class extends gT {
    send(e, t1) {
        if (!e) return Promise.reject({
            type: Ql,
            reason: "Text is empty"
        });
        const { [tT]: o, [oT]: r } = this, i = o(), n = sh(i), s = NT(i, t1), a = LT(n, s, i);
        if (a) return Promise.reject(a);
        const { meeting: { isWebinar: d, encType: u } } = i, l = u === Is.AES_GCM;
        let c = Promise.resolve(), p = !1;
        const h = d && Gp(s.userRole);
        return t1 === Bs.SilentModeUsers ? sO.chat(Hr(e), t1) : d ? h ? 8 & ~s.clientCap ? (c = UT({
            text: e,
            destId: Bs.Panelist,
            sn: null == n ? void 0 : n.zoomID,
            attendeeId: t1
        }).then(()=>(function(e) {
                const { text: t1, jid: o, isGCMEnabled: r } = e;
                return ws.beginEncrypt({
                    text: t1,
                    type: As.XMPP_CHAT
                }).then((e)=>{
                    kT.sendWebinarMseeage(e, o, Bs.IndividualCcPanelist, r);
                });
            })({
                text: e,
                jid: s.jid,
                isGCMEnabled: l
            })), p = !0) : c = UT({
            text: e,
            destId: Bs.IndividualCcPanelist,
            sn: null == n ? void 0 : n.zoomID,
            attendeeId: t1
        }) : s && (c = UT({
            text: e,
            destId: s.userId,
            sn: null == n ? void 0 : n.zoomID
        })) : c = UT({
            text: e,
            destId: s.userId,
            sn: null == n ? void 0 : n.zoomID
        }), c.then(()=>{
            const o = function(e, t1, o, r) {
                const i = (new Date).getTime(), n = performance.now();
                return {
                    message: e,
                    sender: {
                        name: t1.displayName,
                        userId: t1.userId,
                        userGuid: t1.userGUID,
                        avatar: t1.avatar
                    },
                    receiver: {
                        name: null == o ? void 0 : o.displayName,
                        userId: r ? Bs.IndividualCcPanelist : null == o ? void 0 : o.userId,
                        userGuid: null == o ? void 0 : o.userGUID
                    },
                    timestamp: i,
                    highResTimeStampForIdentification: n
                };
            }(e, n, s, h);
            return r(hv(o)), p ? (ep(La, o), o) : new Promise((e, r)=>{
                ip(Va).pipe(Pe(5e3), lt((e)=>o.highResTimeStampForIdentification !== e.identification || !([
                        e.receiverId,
                        Bs.All,
                        Bs.Panelist
                    ].includes(t1) || e.receiverId === Bs.IndividualCcPanelist)), it(1)).subscribe((t1)=>{
                    const { msgId: r } = t1, { highResTimeStampForIdentification: i, ...n } = o, a = {
                        id: r,
                        ...n,
                        ...h && {
                            receiver: {
                                name: null == s ? void 0 : s.displayName,
                                userId: null == s ? void 0 : s.userId
                            }
                        }
                    };
                    ep(La, a), e(a);
                }, ()=>{
                    r({
                        type: zl
                    });
                });
            });
        });
    }
    setPrivilege(e) {
        const t1 = this[tT](), { meeting: { isWebinar: o }, chat: { chatPrivilege: r }, breakoutRoom: i } = t1;
        return r === e ? Promise.resolve("") : (null == i ? void 0 : i.controlStatus) === zp.InProgress && IT(t1) ? Promise.reject({
            type: Gl,
            reason: "Cannot update chat privilege in a subsession"
        }) : !o && !$s.includes(e) || o && !Ws.includes(e) ? Promise.reject({
            type: Ql,
            reason: "invalid privilege value of parameter"
        }) : (sO.setChatPriviledge(e), rp(Na, (t1)=>t1.chatPrivilege === e));
    }
    setPanelistPrivilege(e) {
        const t1 = this[tT](), { chat: { panelistChatPrivilege: o } } = t1, r = Ks[e];
        return o === r ? Promise.resolve("") : Object.values(Gs).includes(e) ? (sO.setPanelistChatPrivilege(e), rp(Na, (e)=>e.panelistChatPrivilege === r)) : Promise.reject({
            type: Ql,
            reason: "Panelist privilege value is invalid"
        });
    }
    deleteMessage(e) {
        const t1 = this[tT](), { chat: { chatHistory: o }, meeting: { meetingOptions: r, userId: i } } = t1;
        if (null != r && r.isEnableDeleteChatMsg) {
            const r = ah(t1), n = o.find((t1)=>t1.id === e);
            if (n) {
                const { sender: t1 } = n;
                if (r) sO.chatCmdReq(e, Fs.Delete);
                else {
                    if (t1.userId !== i) return Promise.reject({
                        type: ql,
                        reason: "can not delete message"
                    });
                    sO.chatCmdReq(e, Fs.Delete);
                }
                return rp(Ua, (t1)=>t1.id === e).then(()=>({
                        id: e
                    }));
            }
            return Promise.reject({
                type: Ql,
                reason: "msgId is wrong"
            });
        }
        return Promise.reject({
            type: Gl,
            reason: "can not delete messages"
        });
    }
    lockChat(e) {
        const t1 = this[tT](), { meeting: { meetingOptions: o } } = t1, r = null != o && o.isPrivateChatEnabled ? js.All : js.EveryonePublicly;
        return this.setPrivilege(e ? js.NoOne : r);
    }
    sendFile(e, t1) {
        if (!e) return Promise.reject({
            type: Ql,
            reason: "File is empty"
        });
        const { [tT]: o, [oT]: r } = this, i = o(), { chat: { isFileTransferEnable: n, fileTransferFileType: s, fileTransferSizeLimit: a, failedFileTransfer: d } } = i;
        if (!n) return Promise.reject({
            type: Gl,
            reason: "Send files via in-session chat is not enabled"
        });
        if ("string" == typeof e) {
            const t1 = jT(e, i);
            if (null != t1 && t1.file && d[e]) {
                const { file: { upload: o, ...i } } = t1, { file: { name: n, upload: { uniqueId: s } }, receiver: { userId: a } } = t1;
                return r(bv({
                    originFile: d[e],
                    ...i,
                    upload: {
                        ...o,
                        status: Ys.InProgress
                    }
                })), Promise.resolve(()=>{
                    r(Ev({
                        uniqueId: s,
                        fileName: n,
                        userId: a
                    }));
                });
            }
            return Promise.reject({
                type: Ql,
                reason: "Retry token is not correct."
            });
        }
        {
            const { name: o } = e;
            if (s.length > 0) {
                const [e] = o.split(".").reverse();
                if (!s.some((t1)=>t1 === e)) return Promise.reject({
                    type: Gl,
                    reason: "File is not in the allow list"
                });
            }
            if (e.size > a) return Promise.reject({
                type: Gl,
                reason: "File size exceeds the maximum limit."
            });
            const n = sh(i), d = NT(i, t1), u = LT(n, d, i);
            if (u) return Promise.reject(u);
            const l = Jr();
            return r(Sv(function(e, t1, o, r) {
                const i = (new Date).getTime();
                return {
                    file: {
                        name: e.name,
                        size: e.size,
                        type: e.type,
                        upload: {
                            progress: 0,
                            uniqueId: t1,
                            totalChunks: 0,
                            chunkIndex: 0
                        }
                    },
                    originFile: e,
                    sender: {
                        name: o.displayName,
                        userId: o.userId,
                        userGuid: o.userGUID,
                        avatar: o.avatar
                    },
                    receiver: {
                        name: null == r ? void 0 : r.displayName,
                        userId: null == r ? void 0 : r.userId,
                        attendeeId: void 0,
                        userGuid: null == r ? void 0 : r.userGUID
                    },
                    timestamp: i
                };
            }(e, l, n, d))), Promise.resolve(()=>{
                r(Iv({
                    uniqueId: l,
                    file: e
                })), r(Ev({
                    uniqueId: l,
                    fileName: o,
                    userId: null == d ? void 0 : d.userId
                }));
            });
        }
    }
    downloadFile(e, t1, o) {
        const { [tT]: r, [oT]: i } = this, { chat: { chatHistory: n } } = r();
        if (!e || !t1) return Promise.reject({
            type: Ql,
            reason: "Invalid message id or file url!"
        });
        const s = n.find((o)=>{
            var r;
            return o.id === e && (null === (r = o.file) || void 0 === r ? void 0 : r.fileUrl) === t1;
        });
        return s ? (i(bv({
            id: e,
            fileUrl: t1,
            download: {
                status: Xs.InProgress,
                progress: 0,
                blob: o
            }
        })), Promise.resolve(()=>i(Cv({
                id: e,
                fileUrl: t1
            })))) : Promise.reject({
            type: Ql,
            reason: "Invalid message id or file url!"
        });
    }
    getPrivilege() {
        const { chat: { chatPrivilege: e, isAllowAttendeeChat: t1 } } = this[tT]();
        return t1 ? e : js.NoAttendee;
    }
    getReceivers() {
        const e = this[tT](), { chat: { chatPrivilege: t1, panelistChatPrivilege: o, isAllowAttendeeChat: r }, meeting: { isWebinar: i } } = e;
        if (!i && !r) return [];
        const n = sh(e), s = ah(e);
        if (n) if (i) if (Gp(n.userRole)) {
            if (!r) return [];
            if (t1 === js.All) return [
                qs,
                zs
            ];
            if (t1 === js.AllPanelist) return [
                qs
            ];
            if (t1 === js.NoOne) return [];
        } else {
            if (s || o === xs.Everyone) {
                const t1 = VT(e, n.userId, {
                    includeAttendee: !0
                });
                return [
                    qs,
                    zs,
                    ...t1
                ];
            }
            if (o === xs.AllPanelist) {
                const t1 = VT(e, n.userId);
                return [
                    qs,
                    ...t1
                ];
            }
        }
        else {
            const o = ah(e);
            if (t1 === js.All || o) {
                const t1 = VT(e, n.userId);
                return [
                    zs,
                    ...t1
                ];
            }
            if (t1 === js.Host) return VT(e, n.userId, {
                host: !0
            });
            if (t1 === js.EveryonePublicly) {
                const t1 = VT(e, n.userId, {
                    host: !0
                });
                return [
                    zs,
                    ...t1
                ];
            }
            if (t1 === js.NoOne) return [];
        }
        return [];
    }
    getHistory() {
        return this[tT]().chat.chatHistory.map((e)=>{
            const { highResTimeStampForIdentification: t1, ...o } = e;
            if (o.file) {
                const { name: e, size: t1, type: r, fileUrl: i, upload: n, download: s } = o.file, a = {
                    name: e,
                    size: t1,
                    type: r,
                    fileUrl: i
                };
                return n && Object.assign(a, {
                    upload: {
                        status: n.status,
                        progress: n.progress
                    }
                }), s && Object.assign(a, {
                    download: {
                        status: s.status,
                        progress: s.progress
                    }
                }), {
                    ...o,
                    file: a
                };
            }
            return o;
        });
    }
    isAllowToDeleteMessages() {
        const e = this[tT](), { meeting: { meetingOptions: t1 } } = e;
        return null == t1 ? void 0 : t1.isEnableDeleteChatMsg;
    }
    isFileTransferEnabled() {
        return this[tT]().chat.isFileTransferEnable;
    }
    getFileTransferSetting() {
        const e = this[tT](), { chat: { fileTransferFileType: t1, fileTransferSizeLimit: o } } = e;
        return {
            typeLimit: (null != t1 ? t1 : []).map((e)=>`.${e}`).join(","),
            sizeLimit: o
        };
    }
}, Xw(nO.prototype, "send", [
    nT
], Object.getOwnPropertyDescriptor(nO.prototype, "send"), nO.prototype), Xw(nO.prototype, "setPrivilege", [
    sT,
    nT
], Object.getOwnPropertyDescriptor(nO.prototype, "setPrivilege"), nO.prototype), Xw(nO.prototype, "setPanelistPrivilege", [
    sT,
    nT,
    function(e, t1, o) {
        const r = o.value;
        o.value = function() {
            const e = this[eT];
            if (e) {
                const { meeting: { isWebinar: t1 } } = e.getState();
                if (!t1) return Promise.reject({
                    type: Jl,
                    reason: "non-webinar"
                });
            }
            for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
            return r.apply(this, o);
        };
    }
], Object.getOwnPropertyDescriptor(nO.prototype, "setPanelistPrivilege"), nO.prototype), Xw(nO.prototype, "deleteMessage", [
    nT
], Object.getOwnPropertyDescriptor(nO.prototype, "deleteMessage"), nO.prototype), Xw(nO.prototype, "lockChat", [
    sT,
    nT
], Object.getOwnPropertyDescriptor(nO.prototype, "lockChat"), nO.prototype), Xw(nO.prototype, "sendFile", [
    nT
], Object.getOwnPropertyDescriptor(nO.prototype, "sendFile"), nO.prototype), Xw(nO.prototype, "downloadFile", [
    nT
], Object.getOwnPropertyDescriptor(nO.prototype, "downloadFile"), nO.prototype), nO);
const dO = {
    epics0: (e, t1)=>sr(e, 24583).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            if (o.meeting.zlkJwtToken) return ie;
            const { payload: { body: { sn: r, senderName: i, senderJid: n, receiver: s, text: a, type: d } } } = t1, u = sh(o), l = uh(o), { meeting: { jid: c, userId: p }, participants: { xmppAttendeeList: h } } = o;
            return ws.beginDecrypt({
                decryptedText: a,
                type: As.XMPP_CHAT,
                zoomId: r
            }).then((e)=>{
                var t1;
                let { message: o } = e, r = null, a = 0, m = "";
                u && Gp(u.userRole) && c === s ? (r = h.find((e)=>e.jid === n), a = p, m = u.displayName) : d === Bs.Panelist && (r = l.find((e)=>e.jid === n), a = Bs.Panelist, m = qs.displayName);
                const g = {
                    message: o,
                    sender: {
                        name: i,
                        userId: (null === (t1 = r) || void 0 === t1 ? void 0 : t1.userId) || 0,
                        avatar: ""
                    },
                    receiver: {
                        name: m,
                        userId: a
                    },
                    timestamp: (new Date).getTime()
                };
                return ep(La, g), hv(g);
            });
        })),
    epics1: (e, t1)=>ir(e, 7944).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { meeting: { bIbDisableChat: r } } = o, { payload: { body: { attendeeNodeID: i, sn: n, destNodeID: s, text: a, senderName: d, msgID: u } } } = t1, l = sh(o);
            if (l) {
                const e = Gp(null == l ? void 0 : l.userRole) && i === l.userId && !u;
                if (!r && !e) {
                    const { sn: e, ...t1 } = xT({
                        destNodeID: s,
                        attendeeNodeID: i,
                        senderName: d,
                        sn: n
                    }, o);
                    return (i === Bs.SilentModeUsers ? Promise.resolve({
                        id: u,
                        message: $r(a),
                        ...t1
                    }) : ws.beginDecrypt({
                        decryptedText: a,
                        zoomId: e,
                        type: As.RWG_CHAT
                    }).then((e)=>{
                        let { message: o } = e;
                        return {
                            id: u,
                            message: o,
                            ...t1
                        };
                    })).then((e)=>(ep(La, e), hv(e)));
                }
            }
            return ie;
        })),
    epics2: (e, t1)=>ir(e, Ps).pipe(tt((e)=>{
            var t1, o;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.chatPriviledge) || void 0 !== (null === (o = e.payload.body) || void 0 === o ? void 0 : o.bAllowAttendeeChat);
        }), vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { payload: { body: { chatPriviledge: r, bAllowAttendeeChat: i } } } = t1, { chat: { chatPrivilege: n } } = o;
            return void 0 !== i ? (ep(Na, !0 === i ? {
                chatPrivilege: n
            } : {
                chatPrivilege: js.NoAttendee
            }), gv(i)) : (ep(Na, {
                chatPrivilege: r
            }), cv(r));
        })),
    epics3: (e)=>ir(e, Ps).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.panelistChatPriviledge);
        }), ke((e)=>{
            const { payload: { body: { panelistChatPriviledge: t1 } } } = e;
            return ep(Na, {
                panelistChatPrivilege: t1
            }), pv(t1);
        })),
    epics4: (e, t1)=>ir(e, 4136).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { payload: { body: { result: r, destNodeID: i, msgID: n, fileID: s } } } = t1, { meeting: { userId: a }, chat: { chatHistory: d } } = o, u = [];
            if (r === Hs.Success) if (s) {
                const e = d.find((e)=>{
                    var t1;
                    return (null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.fileID) === s;
                });
                if (e) {
                    const { file: t1, receiver: o, ...r } = e, { name: i, size: d, type: l, fileUrl: c } = null != t1 ? t1 : {}, { attendeeId: p, ...h } = o;
                    ep(La, {
                        id: n,
                        file: {
                            name: i,
                            size: d,
                            type: l,
                            fileUrl: c,
                            upload: {
                                status: Ys.Complete,
                                progress: 100
                            }
                        },
                        receiver: {
                            ...h
                        },
                        ...r
                    }), u.push(Av({
                        fileID: s,
                        msgID: n,
                        senderId: a
                    }));
                }
            } else {
                const e = FT(d, {
                    userId: a,
                    destNodeID: i
                });
                var l;
                e && (ep(Va, {
                    msgId: n,
                    receiverId: i,
                    identification: null !== (l = e.highResTimeStampForIdentification) && void 0 !== l ? l : 0
                }), u.push(vv({
                    destNodeID: i,
                    msgID: n,
                    userId: a
                })));
            }
            else r !== Hs.Delete && r !== Hs.Block || u.push(fv({
                msgId: n
            }));
            return Ce(u);
        })),
    epics5: (e)=>ir(e, 4238).pipe(Be((e)=>{
            const { payload: { body: { bSuccess: t1, cmd: o, msgID: r } } } = e, i = [];
            return t1 && o === Fs.Delete && (i.push(fv({
                msgId: r
            })), ep(Ua, {
                id: r
            })), Ce(i);
        })),
    epics6: (e)=>ir(e, 7960).pipe(Be((e)=>{
            const { payload: { body: { cmd: t1, msgID: o } } } = e, r = [];
            return t1 === Fs.Delete && (r.push(fv({
                msgId: o
            })), ep(Ua, {
                id: o
            })), Ce(r);
        }))
}, uO = rr(dO, {
    chatFileEpics0: (e)=>e.pipe(Ot(`${cn}`), ke((e)=>{
            var t1, o, r;
            const { payload: { fileTransfer: i, fileServerDomain: n } } = e;
            return yv({
                isFileTransferEnable: null == i ? void 0 : i.isEnable,
                isEnableFileTransferEncrypted: null == i ? void 0 : i.isEnableFileTransferEncrypted,
                fileTransferFileType: (null !== (t1 = null == i ? void 0 : i.fileType) && void 0 !== t1 ? t1 : "").replace(/\./g, "").split(",").filter(Boolean),
                fileTransferSizeLimit: 1024 * (null !== (o = null == i ? void 0 : i.sizeLimit) && void 0 !== o ? o : 0) * 1024 || Zs.MaxSize,
                fileDownloadPromptIgnoreList: (null !== (r = null == i ? void 0 : i.fileDownloadPromptIgnoreList) && void 0 !== r ? r : "").replace(/\./g, "").split(","),
                fileServerDomain: `https://${n}`
            });
        })),
    chatFileEpics1: (e, t1)=>e.pipe(Ot(`${Sv}`), Be(async (o)=>{
            const { payload: { originFile: r, file: { upload: { uniqueId: i } } } } = o;
            return r.size > Zs.ChunkSize ? await async function(e, t1, o, r) {
                const i = WT(e, "/wc/multiupload/init", r.value), n = await async function(e) {
                    const t1 = Math.ceil(e.size / Zs.ReaderChunkSize);
                    return (await Promise.all(Array.from({
                        length: t1
                    }, (e, t1)=>({
                            start: t1 * Zs.ReaderChunkSize,
                            end: (t1 + 1) * Zs.ReaderChunkSize
                        })).map(async (t1)=>{
                        let { start: o, end: r } = t1;
                        try {
                            const t1 = await JT(e, o, r);
                            return ri(await window.crypto.subtle.digest("SHA-256", t1));
                        } catch (t1) {
                            return zT("calculate file hash error.", e, t1), Promise.reject(t1);
                        }
                    }))).join("");
                }(e), { meeting: { zmk: s, meetingId: a } } = r.value, d = jT(t1, r.value);
                if (n && d) {
                    const { receiver: r } = d, u = {
                        fileName: e.name,
                        length: e.size,
                        channelType: 4,
                        digest: n,
                        shareJid: a
                    };
                    return JI({
                        url: i,
                        method: "POST",
                        headers: {
                            "Zoom-File-Origin": "redirect=support_auth",
                            zmk: s
                        },
                        crossDomain: ei(i),
                        body: u
                    }).pipe(ht(ZT(e, t1, r, o)), ke((o)=>{
                        var r;
                        const { responseHeaders: i, response: n } = o, s = null === (r = i["x-zm-trackingid"]) || void 0 === r ? void 0 : r.trim(), { uploadid: a, path: d, metadata: u } = n, l = Math.ceil(e.size / Zs.ChunkSize);
                        return bv({
                            originFile: e,
                            upload: {
                                uniqueId: t1,
                                status: Ys.InProgress,
                                progress: 0,
                                chunkIndex: 0,
                                totalChunks: l,
                                uploadid: a,
                                trackingId: s,
                                path: d,
                                metadata: u
                            }
                        });
                    }), rt((t1)=>(console.warn(t1), zT("Upload file meta error.", e, t1), YT(d, e))), ct(bv({
                        upload: {
                            uniqueId: t1,
                            status: Ys.Init
                        }
                    })));
                }
                return XT(e, t1);
            }(r, i, e, t1) : await eO(r, i, e, t1);
        }), Be((e)=>e)),
    chatFileEpics2: (e, t1)=>e.pipe(Ot(`${bv}`), tt((e)=>{
            var t1;
            return (null === (t1 = e.payload.upload) || void 0 === t1 ? void 0 : t1.status) === Ys.Success;
        }), Qy(async (e)=>{
            const { payload: { upload: { uniqueId: o } } } = e, { chat: { isEnableFileTransferEncrypted: r, chatHistory: i } } = t1.value, n = i.find((e)=>{
                var t1;
                return (null === (t1 = e.file) || void 0 === t1 || null === (t1 = t1.upload) || void 0 === t1 ? void 0 : t1.uniqueId) === o;
            }), s = [];
            if (n && n.file) {
                const { file: { name: e, size: t1, fileObj: i, fileID: a, type: d }, receiver: { userId: u, attendeeId: l } } = n;
                let [c, p] = [
                    "",
                    ""
                ];
                if (r) {
                    const [o, r] = await Promise.all([
                        e,
                        `${t1}`
                    ].map((e)=>ws.beginEncrypt({
                            text: e,
                            type: As.RWG_CHAT
                        })));
                    [c, p] = [
                        o,
                        r
                    ];
                } else [c, p] = [
                    e,
                    `${t1}`
                ].map((e)=>Hr(e));
                await oO.chatFileTransfer({
                    fileID: a,
                    fileSize: p,
                    fileName: c,
                    fileObj: i,
                    type: d,
                    destNodeID: u,
                    attendeeNodeID: l
                }), s.push(bv({
                    upload: {
                        uniqueId: o,
                        status: Ys.Complete
                    }
                }));
            }
            return s;
        })),
    chatFileEpics3: (e, t1)=>e.pipe(Ot(`${bv}`), tt((e)=>{
            const { payload: { upload: t1, originFile: o } } = e;
            return !!t1 && !!t1.uniqueId && t1.status === Ys.InProgress && (null == o ? void 0 : o.size) <= Zs.ChunkSize && 0 === t1.totalChunks;
        }), Be(async (o)=>{
            const { payload: { originFile: r, upload: { uniqueId: i } } } = o;
            return await eO(r, i, e, t1);
        }), Be((e)=>e)),
    chatFileEpics4: (e, t1)=>e.pipe(Ot(`${bv}`), tt((e)=>{
            const { payload: { upload: t1 } } = e;
            return !!t1 && !!t1.uniqueId && t1.totalChunks > 0 && t1.chunkIndex !== t1.totalChunks;
        }), Be(async (o)=>{
            const { payload: { originFile: r, upload: { uniqueId: i } } } = o;
            return await async function(e, t1, o, r) {
                const i = jT(t1, r.value);
                if (null != i && i.file) {
                    const { file: { upload: { chunkIndex: n, totalChunks: s, uploadid: a, path: d, trackingId: u, etags: l }, size: c }, receiver: p } = i, h = n * Zs.ChunkSize, m = await QT(e, h);
                    if (m) {
                        const { chat: { fileServerDomain: h }, meeting: { zmk: g } } = r.value, v = `${h}/upload/parts?${new URLSearchParams({
                            uploadid: a,
                            partNumber: n + 1
                        }).toString()}`, f = new FormData, y = new File([
                            m
                        ], e.name);
                        return f.append("file", y), JI({
                            url: v,
                            method: "POST",
                            headers: {
                                "Zoom-File-Size": y.size,
                                "Zoom-File-Path": d,
                                "x-zm-trackingid": u,
                                "Zoom-File-Origin": "redirect=support_auth",
                                zmk: g
                            },
                            crossDomain: ei(v),
                            body: f,
                            includeUploadProgress: !0
                        }).pipe(ht(ZT(e, t1, p, o)), Be((o)=>{
                            var i;
                            const { type: a, loaded: d, total: u, responseHeaders: h } = o;
                            let m = 0;
                            const g = {
                                upload: {
                                    uniqueId: t1,
                                    status: Ys.InProgress
                                }
                            }, v = [], f = jT(t1, r.value), y = null == f || null === (i = f.file) || void 0 === i ? void 0 : i.upload.progress;
                            if ("upload_loadstart" === a) m = y || Math.floor(n / s * 100);
                            else if ("upload_progress" === a) m = Math.floor((n * Zs.ChunkSize + .9 * d) / c * 100);
                            else if ("upload_load" === a) m = Math.floor((n * Zs.ChunkSize + .9 * u) / c * 100);
                            else if ("download_load" === a) {
                                m = y || Math.floor((n + 1) / s * 100);
                                const t1 = h["x-zm-etag"].trim(), o = l ? {
                                    ...l,
                                    [`${n + 1}`]: t1
                                } : {
                                    [`${n + 1}`]: t1
                                };
                                Object.assign(g.upload, {
                                    etags: o,
                                    chunkIndex: n + 1,
                                    totalChunks: s
                                }), Object.assign(g, {
                                    originFile: e
                                });
                            }
                            return (m > 0 || "upload_loadstart" === a) && (Object.assign(g.upload, {
                                progress: m
                            }), ep(ja, {
                                ...KT(e, p),
                                progress: m,
                                status: Ys.InProgress
                            }), v.push(bv(g))), Ce(v);
                        }), rt((t1)=>(console.warn(t1), zT(`Upload file chunk error. chunk:${n},total chunks:${s},uploadid:${a},trackingId:${u}`, e, t1), YT(i, e))));
                    }
                }
                return XT(e, t1);
            }(r, i, e, t1);
        }), Be((e)=>e)),
    chatFileEpics5: (e, t1)=>e.pipe(Ot(`${bv}`), tt((e)=>{
            const { payload: { upload: t1 } } = e;
            return !!t1 && !!t1.uniqueId && t1.totalChunks > 0 && t1.chunkIndex == t1.totalChunks;
        }), Be((o)=>{
            const { payload: { originFile: r, upload: { uniqueId: i } } } = o;
            return function(e, t1, o, r) {
                const { chat: { fileServerDomain: i }, meeting: { zmk: n } } = r.value, s = jT(t1, r.value);
                if (null != s && s.file) {
                    const { file: { upload: { uploadid: a, metadata: d, etags: u, trackingId: l } }, receiver: c } = s, p = `${i}/upload/complete?uploadid=${a}`;
                    return JI({
                        url: p,
                        method: "POST",
                        headers: {
                            "x-zm-trackingid": l,
                            "Zoom-File-Origin": "redirect=support_auth",
                            zmk: n
                        },
                        crossDomain: ei(p),
                        body: {
                            metadata: d,
                            etags: u
                        }
                    }).pipe(ht(ZT(e, t1, c, o)), ke((o)=>{
                        var i, n;
                        const { chat: { fileServerDomain: s } } = r.value, { responseHeaders: a } = o, d = null === (i = a["zoom-file-id"]) || void 0 === i ? void 0 : i.trim(), u = null === (n = a["zoom-file-obj"]) || void 0 === n ? void 0 : n.trim(), l = `${s}/zoomfile/download?objkey=${u}&business=meeting`;
                        return ep(ja, {
                            ...KT(e, c),
                            progress: 100,
                            status: Ys.Success
                        }), bv({
                            fileID: d,
                            fileObj: u,
                            fileUrl: l,
                            upload: {
                                uniqueId: t1,
                                progress: 100,
                                status: Ys.Success
                            }
                        });
                    }), rt((t1)=>(console.warn(t1), zT(`Upload chunks checksum error.uploadid${a},trackingId${l}`, e, t1), YT(s, e))));
                }
                return XT(e, t1);
            }(r, i, e, t1);
        })),
    chatFileEpics6: (e, t1)=>ir(e, 4308).pipe(Qy(async (e)=>{
            const { payload: { body: { attendeeNodeID: o, destNodeID: r, fileID: i, fileName: n, fileObj: s, fileSize: a, fileType: d, msgID: u, senderName: l } } } = e, { meeting: { bIbDisableChat: c }, chat: { fileServerDomain: p, isEnableFileTransferEncrypted: h } } = t1.value, m = [];
            if (!c) {
                const e = GT(p, {
                    fileObj: s,
                    fileID: i
                });
                if (d === Qs.Local) {
                    const { sn: d, ...c } = xT({
                        destNodeID: r,
                        attendeeNodeID: o,
                        senderName: l
                    }, t1.value);
                    let [p, g] = [
                        "",
                        0
                    ];
                    if (h) {
                        const [e, t1] = await Promise.all([
                            n,
                            a
                        ].map((e)=>ws.beginDecrypt({
                                decryptedText: e,
                                zoomId: d,
                                type: As.RWG_CHAT
                            })));
                        p = e.message, g = Number(t1.message);
                    } else p = $r(n), g = Number($r(a));
                    const v = {
                        id: u,
                        file: {
                            name: p,
                            size: g,
                            fileUrl: e
                        },
                        ...c
                    };
                    m.push(hv({
                        ...v,
                        file: {
                            ...v.file,
                            fileID: i,
                            fileObj: s
                        }
                    })), setTimeout(()=>{
                        ep(La, v);
                    }, 0);
                }
            }
            return m;
        })),
    chatFileEpics7: (e, t1)=>e.pipe(Ot(`${bv}`), tt((e)=>{
            var t1, o;
            const { payload: r } = e;
            return r.id && r.fileUrl && (null === (t1 = r.download) || void 0 === t1 ? void 0 : t1.status) === Xs.InProgress && 0 === (null === (o = r.download) || void 0 === o ? void 0 : o.progress);
        }), Be((o)=>(function(e, t1, o) {
                var r;
                const { chat: { chatHistory: i }, meeting: { zmk: n }, participants: { attendeesList: s } } = o.value, a = i.find((t1)=>t1.id === e);
                if (null != a && null !== (r = a.file) && void 0 !== r && r.fileUrl) {
                    const { file: { fileUrl: o } } = a;
                    return JI({
                        url: o,
                        method: "GET",
                        headers: {
                            "Zoom-File-Origin": "redirect=support_auth",
                            zmk: n
                        },
                        crossDomain: ei(o),
                        responseType: "arraybuffer",
                        includeDownloadProgress: !0
                    }).pipe(ht(function(e, t1) {
                        return t1.pipe(Ot(`${Cv}`, `${Io}`), tt((t1)=>{
                            if (t1.type === `${Io}`) return !0;
                            const { payload: { id: o } } = t1;
                            return e.id === o;
                        }), it(1), gt(()=>{
                            var t1, o, r;
                            $T.info(`Cancel file download. file name:${aE(null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.name)},file size:${null === (o = e.file) || void 0 === o ? void 0 : o.size},sender id:${null === (r = e.sender) || void 0 === r ? void 0 : r.userId}`), ep(xa, {
                                ...qT(e),
                                progress: 0,
                                status: Xs.Cancel
                            });
                        }));
                    }(a, t1)), Qy(async (t1)=>{
                        const { type: o, loaded: r, total: i } = t1, n = [], d = {
                            ...qT(a),
                            progress: 0,
                            status: Xs.InProgress
                        };
                        if ("download_loadstart" === o && Object.assign(d, {
                            progress: 0
                        }), "download_progress" === o) {
                            var u;
                            const t1 = Math.floor(r / i * 100);
                            n.push(bv({
                                id: e,
                                fileUrl: null === (u = a.file) || void 0 === u ? void 0 : u.fileUrl,
                                download: {
                                    progress: t1
                                }
                            })), Object.assign(d, {
                                progress: t1
                            });
                        } else if ("download_load" === o) {
                            var l, c, p;
                            const o = 100, r = Xs.Success;
                            Object.assign(d, {
                                progress: o,
                                status: r
                            }), n.push(bv({
                                id: e,
                                fileUrl: null === (l = a.file) || void 0 === l ? void 0 : l.fileUrl,
                                download: {
                                    progress: o,
                                    status: r
                                }
                            }));
                            const i = null === (c = s.find((e)=>e.userId === a.sender.userId)) || void 0 === c ? void 0 : c.zoomID, u = await async function(e, t1, o) {
                                const r = Math.ceil(e.byteLength / Zs.DecodeBlockSize);
                                try {
                                    const i = await Promise.all(Array.from({
                                        length: Math.max(r - 1, 1)
                                    }, (e, t1)=>({
                                            start: t1 * Zs.DecodeBlockSize,
                                            end: (t1 === r - 2 ? t1 + 2 : t1 + 1) * Zs.DecodeBlockSize
                                        })).map(async (r)=>{
                                        let { start: i, end: n } = r;
                                        try {
                                            const t1 = e.slice(i, n), { message: r } = await ws.beginDecrypt({
                                                decryptedText: t1,
                                                zoomId: o,
                                                type: As.CHAT_FILE
                                            });
                                            return r;
                                        } catch (o) {
                                            return zT("decrypt file buffer error.", {
                                                name: t1,
                                                size: e.byteLength
                                            }, o), Promise.reject(o);
                                        }
                                    }));
                                    return new Blob(i, {
                                        type: BT(t1)
                                    });
                                } catch (e) {
                                    return null;
                                }
                            }(t1.response, null === (p = a.file) || void 0 === p ? void 0 : p.name, i);
                            var h, m;
                            u && (null !== (h = a.file) && void 0 !== h && h.download.blob ? Object.assign(d, {
                                fileBlob: u
                            }) : function(e, t1) {
                                const o = document.createElement("a"), r = window.URL.createObjectURL(e);
                                o.href = r, o.download = t1, o.click(), window.URL.revokeObjectURL(r);
                            }(u, null === (m = a.file) || void 0 === m ? void 0 : m.name));
                        }
                        return (d.progress > 0 || "download_loadstart" === o) && ep(xa, d), n;
                    }), rt((t1)=>(console.warn(t1), zT(`download file error. file url:${o}`, {
                            name: void 0,
                            size: void 0
                        }, t1), ep(xa, {
                            ...qT(a),
                            progress: 0,
                            status: Xs.Fail
                        }), _e(bv({
                            id: e,
                            fileUrl: o,
                            download: {
                                status: Xs.Fail,
                                progress: 0
                            }
                        })))));
                }
                return ie;
            })(o.payload.id, e, t1)))
});
function lO(e, t1) {
    var o, r, i;
    const { meeting: { isMeetingReset: n, meetingId: s, meetingNumber: a, userName: d, userEmail: u, tid: l, userId: c, userGUID: p }, breakoutRoom: h } = e;
    let m = "";
    var g;
    return m = n ? null != h && null !== (g = h.currentRoom) && void 0 !== g && g.boConfId ? "join breakout room" : "meeting failover" : "join meeting", {
        label: m,
        payload: {
            meetingId: null !== (o = null == t1 ? void 0 : t1.meetingId) && void 0 !== o ? o : s,
            tid: l,
            userId: null !== (r = null == t1 ? void 0 : t1.userId) && void 0 !== r ? r : c,
            userGUID: null !== (i = null == t1 ? void 0 : t1.userGUID) && void 0 !== i ? i : p,
            meetingNumber: aE(a),
            userName: aE(d),
            userEmail: aE(u)
        }
    };
}
function cO(e, t1, o) {
    return T(pt((r)=>{
        let i = !1;
        try {
            var n, s;
            const { logger: { options: e }, meeting: { logConfig: o } } = t1.value;
            i = null !== (n = null == e ? void 0 : e.enable) && void 0 !== n ? n : null === (s = JSON.parse(o || "{}")) || void 0 === s ? void 0 : s.enable;
        } catch (e) {}
        try {
            if (i) {
                const { logger: { isLaplaceInitialized: i } } = t1.value;
                if (!i) return e.pipe(Ot(`${uy}`), it(1), Be((e)=>(e.payload && o(r), ie)));
                o(r);
            }
        } catch (e) {
            console.warn(e);
        }
        return ie;
    }));
}
function pO(e, t1, o, r) {
    return dr(e, o).pipe(cO(e, t1, r));
}
function hO(e, t1, o, r) {
    return ir(e, o).pipe(cO(e, t1, r));
}
function mO(e) {
    var t1, o;
    const { audio: { activeMicrophone: r, activeSpeaker: i, microphoneDevicesList: n, speakerDevicesList: s } } = e;
    return `microphone: [${r} - ${null == n || null === (t1 = n.find((e)=>e.deviceId === r)) || void 0 === t1 ? void 0 : t1.label}]; speaker: [${i} - ${null == s || null === (o = s.find((e)=>e.deviceId === i)) || void 0 === o ? void 0 : o.label}]`;
}
function gO(e) {
    var t1;
    const { video: { activeCamera: o, cameraDevicesList: r } } = e;
    return `camera: [${o} - ${null == r || null === (t1 = r.find((e)=>e.deviceId === o)) || void 0 === t1 ? void 0 : t1.label}]`;
}
function vO(e, t1) {
    return void 0 !== t1 ? ` ,${e}:${t1}` : "";
}
const { InitSuccessAudio: fO, InitFailedAudio: yO, InitSuccessVideo: SO, InitFailedVideo: bO, InitSuccessSharing: EO, InitFailedSharing: IO } = nd, { DecodeSuccess: AO, DecodeFailed: CO, EncodeSuccess: _O, EncodeFailed: RO } = sd, wO = {
    [`${fO}`]: {
        name: "Audio",
        isException: !1
    },
    [`${yO}`]: {
        name: "Audio",
        isException: !0
    },
    [`${SO}`]: {
        name: "Video",
        isException: !1
    },
    [`${bO}`]: {
        name: "Video",
        isException: !0
    },
    [`${EO}`]: {
        name: "Sharing",
        isException: !1
    },
    [`${IO}`]: {
        name: "Sharing",
        isException: !0
    }
};
function TO(e) {
    const t1 = (null != e ? e : "").split("-");
    return [
        ...new Set(t1)
    ].map((e)=>({
            reason: e,
            count: t1.filter((t1)=>e === t1).length
        }));
}
const OO = pE.getInstance(), DO = ()=>{
    if ("connection" in navigator) {
        const { effectiveType: e, rtt: t1, downlink: o } = navigator.connection;
        OO.makeLogger([
            "Network Connection Type"
        ]).info(`Network connection. ect:${e},rtt:${t1},downlink:${o}`);
    }
}, PO = pE.getInstance().makeLogger([
    "Remote Control"
]), MO = fE(la.getInstance()), kO = [
    {
        event: nd.AudioBridgeReconnectStart,
        message: nE.AudioBridgeReconnectStart,
        logType: "info",
        additionalTags: [
            "Audio Join Flow"
        ]
    },
    {
        event: nd.AudioBridgeReconnectEnd,
        message: nE.AudioBridgeReconnectEnd,
        logType: "info",
        additionalTags: [
            "Audio Join Flow"
        ]
    },
    {
        event: nd.UserGrantCaptureAudio,
        message: (e)=>`${nE.DeviceAudioStreamCaptured},${mO(e)}`,
        logType: "info",
        additionalTags: [
            "Audio Capture Flow"
        ]
    },
    {
        event: nd.JoinComputerAudioComplete,
        message: nE.AudioJoinComplete,
        logType: "info",
        additionalTags: [
            "Audio Join Flow"
        ]
    },
    {
        event: nd.LeaveComputerAudioComplete,
        message: nE.AudioLeaveComplete,
        logType: "info",
        additionalTags: [
            "Audio Join Flow"
        ]
    },
    {
        event: nd.JoinSharingAudioComplete,
        message: nE.SharingAudioStartComplete,
        logType: "info",
        additionalTags: [
            "Audio Sharing Flow"
        ]
    },
    {
        event: nd.LeaveSharingAudioComplete,
        message: nE.SharingAudioStopComplete,
        logType: "info",
        additionalTags: [
            "Audio Sharing Flow"
        ]
    }
], LO = [
    {
        event: nd.StartVideoCaptureSuccess,
        message: (e)=>`${sE.StartCaptureVideoSuccess}, ${gO(e)}`,
        logType: "info",
        additionalTags: [
            "Video Join Flow"
        ]
    },
    {
        event: nd.StopVideoCaptureSuccess,
        message: sE.StopCaptureVideoSuccess,
        logType: "info",
        additionalTags: [
            "Video Join Flow"
        ]
    },
    {
        event: nd.StartVideoStreamInVbSettingSuccess,
        message: sE.VBSettingSuccess,
        logType: "info",
        additionalTags: [
            "Video VB Flow"
        ]
    },
    {
        event: nd.VbModelPreloadingOk,
        message: sE.VBPreloadSuccess,
        logType: "info",
        additionalTags: [
            "Video VB Flow"
        ]
    },
    {
        event: nd.VbModelPreloading_3S,
        message: sE.VBPreloading3S,
        logType: "warn",
        additionalTags: [
            "Video VB Flow"
        ]
    },
    {
        event: nd.VbModelPreloading_10S,
        message: sE.VBPreloading10S,
        logType: "warn",
        additionalTags: [
            "Video VB Flow"
        ]
    },
    {
        event: nd.VbSettingParaError,
        message: sE.VBSettingFailed,
        logType: "error",
        additionalTags: [
            "Video VB Flow"
        ]
    }
], NO = kO.map((e)=>({
        ...e,
        tag: "Audio"
    })).concat(LO.map((e)=>({
        ...e,
        tag: "Video"
    }))), VO = pE.getInstance(), { InitSuccessVideo: UO, InitSuccessAudio: jO, InitSuccessSharing: xO, InitFailedVideo: BO, InitFailedAudio: FO, InitFailedSharing: HO, RecoverWebrtcAudio: $O, AudioBridgeFirstRecvData: WO, AudioBridgeCanSendData: GO, UserForbiddedCaptureAudio: KO, AudioWebsocketBroken: zO, AudioZeroData: qO, UserForbiddedCaptureVideo: JO, UserCameraIsTakenByOtherPrograms: QO, VideoWebsocketBroken: ZO, StopVideoCaptureFailed: YO, DesktopSharingPermissionDenied: XO, DesktopSharingSystemError: eD, AudioSpeakerSetError: tD, VbSettingParaError: oD, MaskSettingParaError: rD, WebglLostInMultiView: iD, VideoStreamFailed: nD, AudioStreamFailed: sD, NotifyUIFailover: aD } = nd, dD = pE.getInstance(), uD = {
    options: void 0,
    isLaplaceInitialized: !1
}, lD = So({
    [`${dy}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.options = o;
    }),
    [`${uy}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isLaplaceInitialized = o;
    }),
    [`${ly}`]: (e, t1)=>{
        let { options: o } = e, { payload: r } = t1;
        return r ? {
            ...uD,
            options: o
        } : {
            ...uD
        };
    }
}, uD), cD = {
    mlEpics0: (e, t1)=>dr(e, [
            UO,
            jO,
            xO,
            BO,
            FO,
            HO
        ]).pipe(cO(e, t1, (e)=>{
            const { payload: { type: o, data: r } } = e, { meeting: { userId: i } } = t1.value, n = function(e, t1) {
                const o = wO[`${e}`];
                if (o) {
                    const { name: e, isException: r } = o, i = [
                        e,
                        `${e} Init Flow`
                    ];
                    r && i.push(`${e} exception flow`);
                    let n = "";
                    return [
                        AO,
                        CO
                    ].includes(t1) && (n = `${n} decode`.trim()), [
                        _O,
                        RO
                    ].includes(t1) && (n = `${n} encode`.trim()), [
                        _O,
                        AO
                    ].includes(t1) && (n = `${n} success`.trim()), [
                        CO,
                        RO
                    ].includes(t1) && (n = `${n} failed`.trim()), {
                        message: `init ${e.toLowerCase()} ${n}`,
                        tags: i,
                        isException: r
                    };
                }
                return null;
            }(o, r);
            if (n) {
                const { message: e, tags: t1, isException: o } = n;
                o ? VO.report(`${e}. userId:${i}`, t1) : VO.makeLogger(t1).info(e);
            }
        })),
    mlEpics1: (e, t1)=>pO(e, t1, NO.map((e)=>e.event), (e)=>{
            const { payload: { type: o } } = e, r = NO.find((e)=>e.event === o);
            if (r) {
                const { message: e, logType: o, additionalTags: i, tag: n } = r;
                let s = e;
                "function" == typeof e ? window.setTimeout(()=>{
                    s = e(t1.value), VO.makeLogger([
                        n
                    ])[o](s, i);
                }, 0) : s && VO.makeLogger([
                    n
                ])[o](s, i);
            }
        }),
    mlEpics2: (e, t1)=>e.pipe(Ot(`${Nh}`), tt((e)=>!e.payload), cO(e, t1, ()=>{
            VO.makeLogger([
                "Audio"
            ]).warn(`Auto play audio failed,${mO(t1.value)}`);
        })),
    mlEpics3: (e, t1)=>pO(e, t1, $O, ()=>{
            VO.report("Audio bridge, recover audio failed, need to rejoin the audio", [
                "Audio exception flow"
            ]);
        }),
    mlEpics4: (e, t1)=>pO(e, t1, [
            WO,
            GO
        ], (e)=>{
            const { payload: { type: t1 } } = e;
            VO.makeLogger([
                "Audio"
            ]).log("Audio bridge connection: " + (t1 === WO ? "first receive data" : "can send data"));
        }),
    mlEpics5: (e, t1)=>pO(e, t1, aD, (e)=>{
            VO.report(`Audio bridge, notify ui failover, subreason:${e.payload.data}`, [
                "Audio exception flow"
            ]);
        }),
    mlEpics6: (e, t1)=>pO(e, t1, [
            KO,
            zO,
            qO,
            tD,
            sD
        ], (e)=>{
            const { payload: { type: o } } = e;
            let r = `Audio error case:${o}`;
            o === KO ? r = "Audio capture is forbidden by the user" : o === qO ? t1.value.audio.webrtcRestartCount < 3 && (r = "audio capture zero data, auto failover") : o === tD ? r = "audio change speaker error" : o === sD && (r = "audio stream ended or muted, stop capture audio"), VO.report(`${r},${mO(t1.value)}`, [
                "Audio exception flow"
            ]);
        }),
    mlEpics7: (e, t1)=>pO(e, t1, [
            JO,
            QO,
            ZO,
            YO,
            nD
        ], (e)=>{
            const { payload: { type: o, data: r } } = e;
            let i = `Video error case:${o}`;
            if (o === JO) i = "Video capture is forbidden by the user" + (r ? ` (error name:${null == r ? void 0 : r.name};error message:${null == r ? void 0 : r.message})` : "");
            else if (o === QO) i = "Camera is taken by other programs" + (r ? ` (error name:${null == r ? void 0 : r.name};error message:${null == r ? void 0 : r.message})` : "");
            else if (o === oD) {
                var n;
                i = `VB setting error, param:${JSON.stringify(null !== (n = t1.value.video.virtualBackground) && void 0 !== n ? n : {})}`;
            } else if (o === rD) {
                var s;
                i = `Mask setting error, param:${JSON.stringify(null !== (s = t1.value.video.mask) && void 0 !== s ? s : {})}`;
            } else o === nD && (i = `Video stream ended or muted, if it is on iOS platform, will stop capture video.platform:${ms.browser}`);
            VO.report(`${i},${gO(t1.value)}`, [
                "Video exception flow"
            ]);
        }),
    mlEpics8: (e, t1)=>pO(e, t1, [
            XO,
            eD
        ], (e)=>{
            const { payload: { type: t1 } } = e;
            let o = "";
            t1 === eD ? ms.isMacOS && (o = "Need to allow screen recording access in system setting on MacOS") : o = "Need to allow the permission request", VO.report(`${o}`, [
                "Sharing exception flow"
            ]);
        }),
    mlEpics9: (e, t1)=>pO(e, t1, iD, (e)=>{
            const { payload: { data: o } } = e, { video: { renderedVideoList: r } } = t1.value;
            if (null != o && o.canvasId) {
                const e = r.filter((e)=>e.canvasId === o.canvasId);
                VO.report(`WebGl Context lost, canvas ID:${o.canvasId}, affected video node Ids:${e.map((e)=>e.userId).join(",")}`, [
                    "Video exception flow"
                ]);
            }
        }),
    mlEpics10: (e, t1)=>ze(document, "visibilitychange").pipe(cO(e, t1, ()=>{
            VO.makeLogger([
                "Video"
            ]).log(`Page visibility ${document.visibilityState} `), setTimeout(()=>{
                const e = "visible" !== document.visibilityState, { video: { subscribedVideoList: o }, meeting: { userId: r } } = t1.value, i = o.filter((e)=>e !== r).length > 0;
                e && i && (ra.createAgent().sendRWGConnectionPerformance("VCSV"), VO.makeLogger([
                    "Video"
                ]).warn("Still subscribing videos after switching to background"));
            }, 1e3);
        })),
    mlEpics11: (e)=>dr(e, nd.InitSuccessVideo).pipe(tt((e)=>e.payload.data === sd.EncodeSuccess && ms.isAndroidOrIOSBrowser), pt(()=>{
            const e = VO.makeLogger([
                "Video"
            ]);
            return e.info("Screen orientation: " + (Fy() ? "landscape" : "portrait")), Hy().pipe(gt((t1)=>{
                e.info("Screen orientation changes, current orientation: " + (t1 ? "landscape" : "portrait"));
            }), nt());
        }))
}, pD = {
    rmclEpics0: (e, t1)=>e.pipe(Ot(`${Km}`), cO(e, t1, (e)=>{
            const { payload: { isRemoteControlEnabled: t1, isEnableAutoDeleteRcApp: o } } = e;
            PO.log(`isRemoteControlEnabled:${t1},auto delete:${o}`);
        })),
    rmclEpics1: (e, t1)=>e.pipe(Ot(`${Hm}`), tt((e)=>!!e.payload), cO(e, t1, (e)=>{
            PO.log(`Launch Remote control app, scheme:${e.payload}`);
        })),
    rmclEpics2: (e, t1)=>e.pipe(Ot(`${Nm}`), tt((e)=>!!e.payload), cO(e, t1, (e)=>{
            PO.log(`Remote control session starts, controlling ssrc:${e.payload}`);
        })),
    rmclEpics3: (e, t1)=>hO(e, t1, 16430, ()=>{
            PO.log("Remote control app connected to rwg.");
        }),
    rmclEpics4: (e, t1)=>hO(e, t1, Us, ()=>{
            PO.log("Remote control app disconnected to rwg.");
        }),
    rmclEpics5: (e, t1)=>hO(e, t1, Us, (e)=>{
            const { share: { status: o, isRemoteControlEnabled: r } } = t1.value;
            r && o !== fd.End && e.payload.body.bOn && PO.log(`Remote control sharing device info.${JSON.stringify(MO.getShareStreamInfo())}`);
        }),
    rmclEpics6: (e, t1)=>pO(e, t1, nd.CurrentDesktopSharingWidthHeight, ()=>{
            const { share: { isRemoteControlEnabled: e } } = t1.value;
            e && PO.log(`Remote control sharing device info changes.${JSON.stringify(MO.getShareStreamInfo())}`);
        }),
    rmclEpics7: (e, t1)=>pO(e, t1, nd.SendRemoteControlQrCode, (e)=>{
            const { share: { status: o } } = t1.value, { payload: { data: r } } = e;
            PO.log(`Remote control QR code result. sharing status:${o}, result${JSON.stringify(r)}`);
        })
}, hD = {
    epics0: (e, t1)=>e.pipe(Ot(`${cn}`), Be(async (e)=>{
            const { meeting: { logConfig: o, logEncryptionPubKey: r, zlkJwtToken: i, accountId: n, enableAutoLog: s, collectionToggleEnable: a, zsk: d }, logger: { options: u } } = t1.value;
            let l = u || {};
            if (o) try {
                const { enable: e, enableReport: t1 } = JSON.parse(o);
                l = {
                    ...l,
                    enable: e,
                    enableReport: t1
                };
            } catch (e) {}
            if (i) {
                const { telemetry_tracking_id: t1 } = ti(i), { payload: { meetingId: o } } = e, r = null != t1 ? t1 : o;
                l = {
                    ...l,
                    enable: !0,
                    enableReport: !0,
                    trackingId: r
                };
            } else {
                let e = !1;
                e = d && void 0 !== a ? !(s && a) : !s, is.set(as.DisableAutoReportLogs, e, os.Memory);
            }
            return OO.init({
                ...l,
                logConfig: o,
                logEncryptionPubKey: r,
                accountId: n
            }).then(()=>[
                    uy(!0),
                    dy(l)
                ]).catch(()=>[
                    uy(!1)
                ]);
        }), Be((e)=>Ce(e))),
    epics1: (e, t1)=>hO(e, t1, Ls, (e)=>{
            var o, r, i, n;
            const { payload: { body: s } } = e;
            if (s && s.res === ui.Success) {
                OO.makeLogger([
                    "A/V Performance Info"
                ]).info(`CPU cores:${navigator.hardwareConcurrency}, SharedArrayBuffer:${!!ms.isSupportSharedArrayBuffer}, browser:${ms.browser} ${ms.browserVersion}, OS:${ms.os} ${ms.osVersion}${vO("wow64", ms.wow64)}${vO("GPU", ms.gpu)}${vO("architecture", ms.architecture)}${vO("bitness", ms.bitness)}${vO("model", ms.model)}${is.get(as.EnforceWebRTCAudio) ? "; Enforce WebTRC audio" : ""}`, [
                    "CPU_CORES"
                ]);
                const { media: { enforceMultipleVideos: e, enforceVirtualBackground: o, assetsPath: r, disableRenderLimits: i }, meeting: { stayAwake: n, quicklyLeave: s } } = t1.value;
                OO.makeLogger([
                    "Init Option"
                ]).info(`Init option:${JSON.stringify({
                    enforceMultipleVideos: e,
                    disableRenderLimits: i,
                    enforceVirtualBackground: o,
                    assetsPath: r,
                    stayAwake: n,
                    leaveOnPageUnload: s
                })}`), "connection" in navigator && (DO(), navigator.connection.addEventListener("change", DO));
            } else OO.report(`join meeting failed, error:${JSON.stringify(gi(null == s ? void 0 : s.res))}, rwg error code:${null == s ? void 0 : s.res}, rwg conID:${null == s ? void 0 : s.conID}, error message:${null == s ? void 0 : s.error_desc}, rwg url:${null == s ? void 0 : s.svcUrl},mid:${t1.value.meeting.meetingId}`, "JOIN_MEETING_FAILED", "error");
            const { meeting: { meetingInfoTimestamp: a, pingRWCTimestamp: d, tid: u, meetingId: l, topic: c, accountId: p, cv: h }, socket: { rwgServerList: m, retryCount: g }, video: { rendererType: v }, media: { patchJsMedia: f, assetsPath: y } } = t1.value;
            let S = [
                "conID",
                "confID",
                "mmrFeature",
                "mmrFeatureEx",
                "reportDomain",
                "res",
                "role",
                "svcUrl",
                "userID"
            ].reduce((e, t1)=>void 0 !== s[t1] ? {
                    ...e,
                    [`${t1}`]: s[t1]
                } : e, {});
            S = [
                "jid",
                "mn",
                "participantID",
                "zoomID"
            ].reduce((e, t1)=>void 0 !== s[t1] ? {
                    ...e,
                    [`${t1}`]: aE(s[t1])
                } : e, S), S.response = S.res, delete S.res;
            const b = [
                "connection_info_map"
            ];
            let E;
            if (s.res === ui.Success && b.push("Command Socket Event", "User Info Map"), u) {
                const e = u.match(/clid=(\S+);/);
                e && e.length > 1 && (E = e[1]);
            }
            const I = Math.floor(performance.now() - a), A = Math.floor(performance.now() - d), C = ra.createAgent();
            OO.report(JSON.stringify({
                ...S,
                tid: u,
                mid: l,
                userRegion: E,
                rwgUrl: m.length > 0 ? null === (o = m[g]) || void 0 === o ? void 0 : o.rwg : void 0,
                hardwareConcurrency: navigator.hardwareConcurrency,
                sharedArrayBuffer: ms.isSupportSharedArrayBuffer,
                browserVersion: `${ms.browser} ${ms.browserVersion}`,
                osVersion: `${ms.os} ${ms.osVersion}`,
                gpu: ms.gpu,
                architecture: ms.architecture,
                model: ms.model,
                bitness: ms.bitness,
                totalDurationOfJoining: I,
                durationOfRWG: A,
                rendererType: v,
                sdkVersion: h,
                mediaSdkVersion: null === (r = window.JsMediaSDK_Instance) || void 0 === r ? void 0 : r.version,
                topic: c ? aE(c) : void 0,
                accountId: p ? aE(p) : void 0,
                patchJSMediaSDK: f,
                dependentAssets: y,
                webRtcAudio: gs(),
                crossOriginIsolated: !!window.crossOriginIsolated,
                isRlbTP: null === (i = C.websocket) || void 0 === i ? void 0 : i.isRlb
            }), b, "info"), C.sendRWGConnectionPerformance(`WCL_M, conId: ${null == s ? void 0 : s.conID}, trackingId: ${null === (n = t1.value.logger) || void 0 === n || null === (n = n.options) || void 0 === n ? void 0 : n.trackingId}, JOINFS(${I}), JOINFRWC(${A})`);
        }),
    epics2: (e, t1)=>e.pipe(Ot(`${rn}`), vt(t1), tt((e)=>{
            let [, t1] = e;
            return void 0 === t1.meeting.encryptedRWC && (void 0 === t1.meeting.encryptedGEORWC || 0 === t1.meeting.encryptedGEORWC.length);
        }), cO(e, t1, ()=>{
            const { label: e, payload: o } = lO(t1.value);
            OO.report(`${e} ${JSON.stringify(o)}`, [
                "Join Meeting Flow",
                "Ping RWC Domain Empty"
            ], "error");
        })),
    epics3: (e, t1)=>e.pipe(Ot(`${nn}`), tt((e)=>e.payload === es.OnError || e.payload === es.Disconnect || e.payload === es.NoHeartbeat), cO(e, t1, (e)=>{
            const { payload: o } = e, { socket: { rwgServerList: r, retryCount: i } } = t1.value, { payload: n } = lO(t1.value);
            OO.report(`websocket unexpected disconnected,${JSON.stringify({
                code: o,
                rwgHost: r[i],
                ...n
            })}`, [
                "Join Meeting Flow",
                "RWG Disconnect"
            ]);
        })),
    epics4: (e, t1)=>e.pipe(Ot(`${Hn}`), cO(e, t1, (e)=>{
            const { payload: { reason: o, count: r, interval: i, sequence: n, userId: s, userGUID: a, meetingId: d } } = e, { payload: u } = lO(t1.value, {
                meetingId: d,
                userId: s,
                userGUID: a
            });
            OO.report(`meeting failover,${JSON.stringify({
                reason: o,
                count: r,
                interval: i,
                sequence: n,
                detailed: TO(n),
                ...u
            })}`, [
                "Join Meeting Flow",
                "Failover"
            ]), "connection" in navigator && navigator.connection.removeEventListener("change", DO);
        })),
    epics5: (e, t1)=>e.pipe(Ot(`${Do}`), tt((e)=>e.payload.status === yh.Connecting), cO(e, t1, (e)=>{
            const { payload: { rwgUrl: o } } = e;
            let r = o.replace(/(\d+)\?/, `${aE("$1")}?`);
            r = [
                "email",
                "zoomid",
                "participantID",
                "dn2",
                "customer_key",
                "mpwd",
                "topic"
            ].reduce((e, t1)=>e.indexOf(t1) > -1 ? e.replace(new RegExp(`${t1}=([^&]+)`, "g"), `${t1}=${aE("$1")}`) : e, r);
            const { payload: i } = lO(t1.value);
            OO.makeLogger([
                "Join Meeting Flow"
            ]).info(`RWG URL,${JSON.stringify({
                rwgUrl: r,
                ...i
            })}`, [
                "RWG Url"
            ]);
        })),
    epics6: (e, t1)=>e.pipe(Ot(`${Io}`), tt((e)=>{
            const { payload: o } = e;
            return o ? o.retry : t1.value.meeting.meetingStatus === Yn.Initial;
        }), cO(e, t1, ()=>{
            const { meeting: { meetingStatus: e }, socket: { rwgServerList: o, retryCount: r } } = t1.value;
            if (e !== Yn.Joined) {
                const { payload: e } = lO(t1.value), i = (null == o ? void 0 : o.length) > 0 ? o[r] : void 0;
                OO.report(JSON.stringify({
                    ...e,
                    rwc: null == i ? void 0 : i.rwc,
                    rwg: null == i ? void 0 : i.rwg
                }), [
                    "UNAVAILABLE_RWG"
                ]);
            }
        })),
    epics7: (e, t1)=>hO(e, t1, 1, (e)=>{
            const { payload: { body: o } } = e;
            OO.report(`join meeting failed, version blocked. Current version:${t1.value.meeting.cv},upgrade version:${null == o ? void 0 : o.upgradeVersion}`, "JOIN_MEETING_FAILED", "error");
        }),
    epics8: (e, t1)=>hO(e, t1, 2, ()=>{
            OO.report(`join meeting with low version of SDK. Current version:${t1.value.meeting.cv}.`, "Join Meeting Flow", "warn");
        }),
    epics9: (e, t1)=>e.pipe(Ot(`${tn}`, `${on}`), pt(()=>ip(Sa, 1).pipe(gt((e)=>{
                try {
                    const { payload: o } = lO(t1.value);
                    OO.report(`Connection change with join meeting failed. payload:${JSON.stringify(e)}. meeting info:${JSON.stringify(o)}`, "JOIN_MEETING_FAILED", "error");
                } catch (e) {}
            }), Be(()=>ie))))
}, mD = rr(hD, pD, cD), gD = ra.createAgent(), vD = {
    cmrStatus: za.Stop,
    recordingEnable: !1,
    recordingIsoEnable: !1,
    allowStopAutoRecording: !1,
    automaticCloudRecordingEnable: !1,
    isZoomIQ: !1,
    zoomIQChanging: !1,
    localStatus: qa.Stop,
    supportLocalRecording: Ja.None,
    localGrantPermissionOption: Qa.None,
    localPermissionUserList: []
}, fD = So({
    [`${pf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.cmrStatus = o;
    }),
    [`${hf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.recordingEnable = o;
    }),
    [`${mf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.recordingIsoEnable = o;
    }),
    [`${gf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.allowStopAutoRecording = o;
    }),
    [`${vf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.automaticCloudRecordingEnable = o;
    }),
    [`${ff}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isZoomIQ = o;
    }),
    [`${yf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.zoomIQChanging = o;
    }),
    [`${Sf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.localStatus = o;
    }),
    [`${bf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.supportLocalRecording = o;
    }),
    [`${Ef}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.localGrantPermissionOption = o;
    }),
    [`${If}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.localPermissionUserList = o;
    }),
    [`${Af}`]: ()=>({
            ...vD
        })
}, vD);
var yD, SD, bD, ED, ID, AD, CD, _D, RD;
const wD = ra.createAgent(), TD = hT("Recording");
let OD = (yD = dT("recording"), SD = dT("recording"), bD = dT("recording"), ED = dT("recording"), ID = dT("recording"), AD = dT("recording"), CD = dT("recording"), _D = dT("recording"), RD = class extends gT {
    startRecording() {
        const e = this[tT](), { meeting: { bIbDisableRecording: t1, recordingEnable: o }, recording: { cmrStatus: r } } = e;
        return t1 ? Promise.reject({
            type: Gl,
            reason: "Rejected by Information Barrier"
        }) : o ? r === za.Start ? Promise.resolve("") : (wD.recordMeeting(!0, !1), rp(Za, (e)=>e.cmrServerStatus === za.Start)) : Promise.reject({
            type: Gl,
            reason: "The account of the meeting disabled the cloud recording"
        });
    }
    pauseRecording() {
        const e = this[tT](), { recording: { cmrStatus: t1, allowStopAutoRecording: o } } = e;
        return t1 === za.Pause ? Promise.resolve("") : t1 !== za.Start ? Promise.reject({
            type: Gl,
            reason: "Recording is not started"
        }) : o ? (wD.recordMeeting(!1, !0), rp(Za, (e)=>e.cmrServerStatus === za.Pause)) : Promise.reject({
            type: Gl,
            reason: "Cannot pause cloud recording due to web setting config"
        });
    }
    stopRecording() {
        const e = this[tT](), { recording: { cmrStatus: t1, allowStopAutoRecording: o } } = e;
        return t1 === za.Stop ? Promise.resolve("") : o ? (wD.recordMeeting(!1, !1), rp(Za, (e)=>e.cmrServerStatus === za.Stop)) : Promise.reject({
            type: Gl,
            reason: "Cannot stop cloud recording due to web setting config"
        });
    }
    accept() {
        const e = this[tT](), { recording: { cmrStatus: t1, recordingIsoEnable: o } } = e, r = sh(e);
        return o ? t1 !== za.Start && t1 !== za.Pause ? Promise.reject({
            type: Gl,
            reason: "Recording is not started"
        }) : null != r && r.bAllowISORecord ? Promise.resolve("You accepted ISO recording") : (wD.allowSelfRecord(!0), rp(Ya, (e)=>(null == e ? void 0 : e.userId) === (null == r ? void 0 : r.userId) && (null == e ? void 0 : e.status) === Ka.Accept)) : Promise.reject({
            type: Gl,
            reason: "ISO Recording is not enabled"
        });
    }
    decline() {
        const e = this[tT](), { recording: { cmrStatus: t1, recordingIsoEnable: o } } = e, r = sh(e);
        return o ? t1 !== za.Start && t1 !== za.Pause ? Promise.reject({
            type: Gl,
            reason: "Recording is not started"
        }) : !0 === (null == r ? void 0 : r.bAllowISORecord) ? Promise.reject({
            type: Gl,
            reason: "You had accept ISO recording, cant change it"
        }) : (wD.allowSelfRecord(!1), Promise.resolve("")) : Promise.reject({
            type: Gl,
            reason: "ISO Recording is not enabled"
        });
    }
    getRecordingStatus() {
        const e = this[tT](), { recording: { cmrStatus: t1 } } = e, o = vh(e);
        return t1 === za.Start ? Ka.Recording : t1 === za.Pause ? Ka.Paused : o ? Ka.Recording : Ka.Stopped;
    }
    isRecordingEnabled() {
        const e = this[tT](), { recording: { recordingEnable: t1 } } = e;
        return t1;
    }
    isAllowedToStopAutoRecording() {
        const e = this[tT](), { recording: { allowStopAutoRecording: t1 } } = e;
        return t1;
    }
    isAutomaticCloudRecordingEnabled() {
        const e = this[tT](), { recording: { automaticCloudRecordingEnable: t1 } } = e;
        return t1;
    }
    enableRecordingWithIQ(e) {
        const { [tT]: t1, [oT]: o } = this, r = t1(), { recording: { isZoomIQ: i, zoomIQChanging: n }, meeting: { meetingOptions: s } } = t1();
        return s.isEnableKiwiRecording ? ah(r) ? n ? Promise.reject({
            type: Gl,
            reason: "We are changing, please wait"
        }) : e === i ? Promise.reject({
            type: Gl,
            reason: `You have ${e ? "enable" : "disable"} Zoom IQ, don't need change`
        }) : (o(yf(!n)), o(ff(!i)), wD.enableZoomIQRecord(e), rp(od, (e)=>null == e ? void 0 : e.success)) : Promise.reject({
            type: Gl,
            reason: "Only Host or co-host can enable/disable Zoom IQ"
        }) : Promise.reject({
            type: Gl,
            reason: "You not have zoom IQ license or not enable zoom IQ, please check and retry"
        });
    }
    isSupportLocalRecording() {
        const e = this[tT](), { meeting: { meetingOptions: t1, isWebinar: o }, breakoutRoom: r } = e;
        if ((null == r ? void 0 : r.currentRoom.status) === Jp.InRoom) return !1;
        const i = sh(e);
        return (!o || !Gp(i.userRole)) && (null == t1 ? void 0 : t1.isLocalRecordingEnabled);
    }
    isSupportLocalRecordingPermission() {
        const e = this[tT](), { recording: { supportLocalRecording: t1 } } = e;
        if (!this.isSupportLocalRecording()) return !1;
        const o = sh(e);
        return !(null == o || !o.isHost) || t1 === Ja.Allow;
    }
    askLocalRecordingPermission() {
        const { [tT]: e } = this, { recording: { supportLocalRecording: t1 } } = e();
        return this.isSupportLocalRecording() ? t1 === Ja.None ? (wD.localRecordingRequestPermission(), Promise.resolve("")) : t1 === Ja.Allow ? Promise.resolve("") : Promise.reject("permission is denied") : Promise.reject("not support");
    }
    startLocalRecording(e) {
        const { [tT]: t1, [oT]: o } = this, r = t1(), { recording: { localStatus: i, supportLocalRecording: n }, meeting: { userId: s } } = r;
        if (!(e in qa)) return Promise.reject({
            type: Gl,
            reason: "not support you parameter, only support type are 0(stop)/1(start)/2(pause)."
        });
        if (!this.isSupportLocalRecording()) return Promise.reject({
            type: Gl,
            reason: "not support local recording"
        });
        if (e === i) return Promise.resolve(`you currently status is ${i}, do nothing`);
        const a = sh(r);
        return n === Ja.Allow || null != a && a.isHost ? (wD.localRecordingMeeting(e), rp(Xa, (t1)=>(null == t1 ? void 0 : t1.userId) === s && (o(Sf(t1.bLocalRecord)), t1.bLocalRecord === e), 1e3)) : Promise.reject({
            type: Gl,
            reason: "you not have local recording permission, please use askLocalRecordingPermission request it first"
        });
    }
    isSupportLocalRecordingGrantPermission() {
        const e = this[tT]();
        if (!this.isSupportLocalRecording()) return !1;
        const t1 = sh(e);
        return !(null == t1 || !t1.isHost) && !!iS(t1.caps);
    }
    grantLocalRecordingPermission(e, t1, o) {
        const { [tT]: r, [oT]: i } = this, n = r(), { recording: { localPermissionUserList: s } } = n;
        if (!this.isSupportLocalRecording()) return Promise.resolve(!1);
        const a = sh(n);
        if (!iS(a.caps)) return Promise.reject({
            type: Gl,
            reason: "you can not grant permission"
        });
        let d = !1;
        if (o && (d = !0), s.filter((t1)=>t1 === e).length > 0) {
            if (t1 === Ja.Allow) wD.localRecordingGrantPermission(e, !0, d);
            else {
                if (t1 !== Ja.Deny) return Promise.reject({
                    type: Gl,
                    reason: "only support DENY(1)/ALLOW(2)"
                });
                wD.localRecordingGrantPermission(e, !1, d);
            }
            return i(If(s.filter((t1)=>t1 !== e))), ep(ed, {
                type: "answer",
                value: t1 === Ja.Allow
            }), Promise.resolve(!1);
        }
        return t1 !== Ja.Deny ? Promise.reject({
            type: Gl,
            reason: "Direct grant only support DENY(1)"
        }) : (wD.hostGrantPermission(e, !1), rp(ed, (o)=>(null == o ? void 0 : o.value) === e && (t1 === Ja.Allow ? (i(If([
                ...s,
                e
            ])), !0 === (null == o ? void 0 : o.canRecord)) : (i(If(s.filter((t1)=>t1 !== e))), !1 === (null == o ? void 0 : o.canRecord))), 1e3));
    }
    getLocalRecordingPermissionUserList() {
        const e = this[tT](), { recording: { localPermissionUserList: t1 } } = e;
        if (!this.isSupportLocalRecording()) return [];
        const o = sh(e);
        return iS(o.caps) ? t1 : Promise.reject({
            type: Gl,
            reason: "you can not grant permission"
        });
    }
    getLocalRecordingPermissionOperation() {
        const e = this[tT](), { recording: { localGrantPermissionOption: t1 } } = e;
        if (!this.isSupportLocalRecording()) return null;
        const o = sh(e);
        return iS(o.caps) ? t1 : null;
    }
}, Xw(RD.prototype, "startRecording", [
    sT,
    nT,
    yD,
    TD
], Object.getOwnPropertyDescriptor(RD.prototype, "startRecording"), RD.prototype), Xw(RD.prototype, "pauseRecording", [
    sT,
    nT,
    SD,
    TD
], Object.getOwnPropertyDescriptor(RD.prototype, "pauseRecording"), RD.prototype), Xw(RD.prototype, "stopRecording", [
    sT,
    nT,
    bD,
    TD
], Object.getOwnPropertyDescriptor(RD.prototype, "stopRecording"), RD.prototype), Xw(RD.prototype, "accept", [
    nT,
    ED,
    TD
], Object.getOwnPropertyDescriptor(RD.prototype, "accept"), RD.prototype), Xw(RD.prototype, "decline", [
    nT,
    ID,
    TD
], Object.getOwnPropertyDescriptor(RD.prototype, "decline"), RD.prototype), Xw(RD.prototype, "askLocalRecordingPermission", [
    nT,
    AD
], Object.getOwnPropertyDescriptor(RD.prototype, "askLocalRecordingPermission"), RD.prototype), Xw(RD.prototype, "startLocalRecording", [
    nT,
    CD
], Object.getOwnPropertyDescriptor(RD.prototype, "startLocalRecording"), RD.prototype), Xw(RD.prototype, "grantLocalRecordingPermission", [
    nT,
    aT,
    _D
], Object.getOwnPropertyDescriptor(RD.prototype, "grantLocalRecordingPermission"), RD.prototype), RD);
const DD = {
    moduleEpics0: (e)=>e.pipe(Ot(`${cn}`), ke((e)=>{
            const { payload: { recordingEnable: t1 } } = e;
            return hf(t1);
        })),
    moduleEpics1: (e, t1)=>ir(e, Ps).pipe(tt((e)=>{
            var t1, o, r;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.cmrServerStatus) || void 0 !== (null === (o = e.payload.body) || void 0 === o ? void 0 : o.disAllowClientStopAutoCmr) || void 0 !== (null === (r = e.payload.body) || void 0 === r ? void 0 : r.enableAutomicRecordingCloud);
        }), vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { cmrServerStatus: r, disAllowClientStopAutoCmr: i, enableAutomicRecordingCloud: n } = t1.payload.body, s = [];
            return void 0 !== r && (r !== za.Init && (ep(Za, {
                cmrServerStatus: r
            }), o.recording.recordingIsoEnable && r === za.Start && ep(Ya, {
                status: Ka.Ask
            })), s.push(pf(r))), void 0 !== i && s.push(gf(!i)), void 0 !== n && s.push(vf(n)), Ce(s);
        })),
    moduleEpics2: (e)=>ir(e, Ps).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.bCmrIsoEnble);
        }), ke((e)=>{
            const { bCmrIsoEnble: t1 } = e.payload.body;
            return mf(t1);
        })),
    moduleEpics3: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [t1] = e;
            const { payload: { body: { update: o, add: r } } } = t1;
            return (null == o ? void 0 : o.some((e)=>void 0 !== e.bLocalRecordStatus || void 0 !== e.canRecord)) || (null == r ? void 0 : r.some((e)=>void 0 !== e.bLocalRecordStatus || void 0 !== e.canRecord));
        }), Be((e)=>{
            let [t1, o] = e;
            const { payload: { body: { update: r, add: i } } } = t1, { meeting: { userId: n, isHost: s }, recording: { supportLocalRecording: a }, participants: { attendeesList: d } } = o, u = [];
            return null == r || r.concat(i || []).filter((e)=>void 0 !== e.bLocalRecordStatus || void 0 !== e.canRecord).forEach((e)=>{
                if (void 0 !== e.canRecord) {
                    const t1 = Boolean(e.canRecord);
                    if (n === e.id || s) {
                        const o = d.find((e)=>e.userId === n);
                        !t1 && null != o && o.bLocalRecord && (ep(ed, {
                            type: "revoke",
                            value: e.id,
                            canRecord: t1
                        }), gD.localRecordingMeeting(qa.Stop)), !t1 || null != o && o.bLocalRecord || ep(ed, {
                            type: "grant",
                            value: e.id,
                            canRecord: t1
                        });
                    }
                    n === e.id && ((a !== Ja.None || t1) && u.push(bf(t1 ? Ja.Allow : Ja.Deny)), t1 || u.push(Sf(qa.Stop)));
                } else ep(Xa, {
                    userId: e.id,
                    bLocalRecord: e.bLocalRecordStatus
                });
            }), Ce(u);
        })),
    moduleEpics4: (e, t1)=>ir(e, Ds).pipe(ke((e)=>jA(e.payload.body)), vt(t1), Be((e)=>{
            let [t1, o] = e;
            const r = [], { recording: { localPermissionUserList: i } } = o;
            return t1.remove && t1.remove.forEach((e)=>{
                i.filter((t1)=>t1 === (null == e ? void 0 : e.userId)) && (r.push(If(i.filter((t1)=>t1 !== (null == e ? void 0 : e.userId)))), ep(ed, {
                    type: "remove",
                    value: null == e ? void 0 : e.userId
                }));
            }), Ce(r);
        })),
    moduleEpics5: (e)=>ir(e, Ds).pipe(tt((e)=>{
            const { payload: { body: { update: t1 } } } = e;
            return null == t1 ? void 0 : t1.some((e)=>void 0 !== e.bAllowISORecord);
        }), gt((e)=>{
            const { payload: { body: { update: t1 } } } = e;
            t1.filter((e)=>void 0 !== e.bAllowISORecord).forEach((e)=>{
                ep(Ya, {
                    userId: e.id,
                    status: e.bAllowISORecord ? Ka.Accept : Ka.Decline
                });
            });
        }), dt(ie)),
    moduleEpics6: (e)=>ir(e, Ps).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.SalesRecordingAnalytics);
        }), ke((e)=>{
            const { SalesRecordingAnalytics: t1 } = e.payload.body;
            return ep(td, {
                isZoomIQ: t1
            }), ff(t1);
        })),
    moduleEpics7: (e, t1)=>ir(e, 4319).pipe(vt(t1), tt((e)=>{
            var t1;
            let [o] = e;
            return void 0 !== (null === (t1 = o.payload.body) || void 0 === t1 ? void 0 : t1.success);
        }), Be((e)=>{
            let [t1, o] = e;
            const r = [], { success: i } = t1.payload.body, { recording: { zoomIQChanging: n } } = o;
            return ep(od, {
                success: i
            }), i && r.push(yf(!n)), Ce(r);
        })),
    moduleEpics8: (e, t1)=>ir(e, 4344).pipe(vt(t1), tt((e)=>{
            var t1;
            let [o] = e;
            return void 0 !== (null === (t1 = o.payload.body) || void 0 === t1 ? void 0 : t1.cmdType);
        }), Be((e)=>{
            var t1;
            let [o, r] = e;
            const i = [], { cmdType: n } = o.payload.body, { recording: { localPermissionUserList: s }, meeting: { isHost: a } } = r;
            var d, u, l, c;
            ("permission_req_option" === n && (ep(ed, {
                type: "option",
                value: null === (d = o.payload.body) || void 0 === d ? void 0 : d.option
            }), i.push(Ef(null === (u = o.payload.body) || void 0 === u ? void 0 : u.option))), "request_permission" === n && null !== (t1 = o.payload.body) && void 0 !== t1 && t1.userId) && (a && ep(ed, {
                type: "request",
                value: null === (c = o.payload.body) || void 0 === c ? void 0 : c.userId
            }), i.push(If([
                ...s,
                null === (l = o.payload.body) || void 0 === l ? void 0 : l.userId
            ])));
            return "permission_request_answer" === n && (ep(ed, {
                type: "answer",
                value: o.payload.body.agreed
            }), i.push(bf(o.payload.body.agreed ? Ja.Allow : Ja.Deny))), Ce(i);
        }))
}, PD = rr(DD);
let MD = function(e) {
    return e[e.All = 1] = "All", e[e.Private = 2] = "Private", e;
}({}), kD = function(e) {
    return e.SUCCESS = "success", e;
}({}), LD = function(e) {
    return e.CustomizedKey = "__zoom_internal_message_customized_key__@@", e.SpeakerOnly = "__zoom_internal_message_speaker_only__@@", e;
}({});
const ND = UI.getInstance(), VD = (e, t1, o)=>{
    const { meeting: { encType: r } } = o, i = t1, n = Wr(e), s = i ? MD.Private : MD.All;
    return r === Is.AES_GCM ? ws.beginEncrypt({
        text: n,
        type: As.XMPP_CHAT
    }).then((e)=>{
        ND.sendWebinarMseeage(e, i, s, !0);
    }) : ND.sendWebinarMseeage(n, i, s, !1);
};
function UD(e, t1) {
    const { cmd: { jids: o } } = t1;
    return Object.prototype.hasOwnProperty.call(o, e) ? Promise.resolve() : Te(ip(va).pipe(lt((t1)=>-1 === t1.findIndex((t1)=>Number(t1.userId) === e)), it(1), Ee(ee)));
}
function jD(e) {
    const { cmd: { connectionStatus: t1 } } = e;
    return t1 === kD.SUCCESS ? Promise.resolve(!0) : Te(ip($a, 1)).then((e)=>e === Zn.Connected || Promise.reject({
            type: Gl,
            reason: "Cannot establish the command channel"
        }));
}
function xD(e, t1) {
    for (const [o, r] of Object.entries(e))if (r.jid === t1) return o;
}
const BD = {
    connectionStatus: "initial",
    jids: {}
}, FD = So({
    [`${wf}`]: ()=>({
            ...BD
        }),
    [`${Cf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { data: r, attendees: i } = o;
        r.forEach((t1)=>{
            const { jid: o, node: r } = t1;
            if (!e.jids[r] || e.jids[r].jid !== o) {
                const t1 = i.find((e)=>e.userId === Number(r));
                e.jids[r] = {
                    jid: o,
                    userGuid: null == t1 ? void 0 : t1.userGUID
                };
            }
        });
    }),
    [`${_f}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        o.forEach((t1)=>{
            const { jid: o } = t1, r = xD(e.jids, o);
            r && delete e.jids[r];
        });
    }),
    [`${Rf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.connectionStatus = o;
    })
}, BD);
var HD;
let $D = (HD = class extends gT {
    send(e, t1) {
        if (!e) return Promise.reject({
            type: Ql,
            reason: "Text is empty"
        });
        if ("string" != typeof e) return Promise.reject({
            type: Ql,
            reason: "Text is not a string"
        });
        if (e.length > 512) return Promise.reject({
            type: Ql,
            reason: "Text exceeds the max length(512)."
        });
        const { [tT]: o } = this, r = o(), { socket: { xmppSocketStatus: i }, meeting: { userId: n } } = r;
        return i !== yh.Connected ? Promise.reject({
            type: Jl,
            reason: "Command channel is not ready"
        }) : jD(r).then(()=>t1 ? -1 !== ch(o()).findIndex((e)=>e.userId === t1) ? UD(t1, r).then(()=>{
                const { cmd: { jids: r } } = o();
                return r[t1] ? (VD(e, r[t1].jid, o()), {
                    timestamp: (new Date).getTime(),
                    text: e,
                    receiverId: t1,
                    senderId: n
                }) : Promise.reject({
                    type: Kl
                });
            }).catch(()=>{}) : Promise.reject({
                type: Ql,
                reason: "Cannot find the user"
            }) : (VD(e, "", r), {
                timestamp: (new Date).getTime(),
                text: e,
                receiverId: 0,
                senderId: n
            })).catch(()=>{});
    }
    getJids() {
        const { [tT]: e } = this, t1 = e(), { cmd: { jids: o } } = t1;
        return o;
    }
}, Xw(HD.prototype, "send", [
    nT
], Object.getOwnPropertyDescriptor(HD.prototype, "send"), HD.prototype), HD);
const WD = {
    extraEpics0: (e, t1)=>e.pipe(Ot(`${Yh}`), pt((e)=>{
            const { payload: { speakerOnly: o } } = e, r = sh(t1.value);
            return (void 0 !== (null == r ? void 0 : r.audio) ? Ce([
                r.audio
            ]) : ip(pa).pipe(tt((e)=>void 0 !== e.audio), it(1))).pipe(gt(()=>{
                jD(t1.value).then(()=>{
                    VD(`${LD.SpeakerOnly}${o ? 1 : 0}`, "", t1.value);
                });
            }), dt(ie));
        })),
    extraEpics1: (e, t1)=>ir(e, Ds).pipe(tt((e)=>{
            var o;
            const { payload: { body: r } } = e;
            return !!r.add && !(null === (o = t1.value.audio) || void 0 === o || null === (o = o.customizeAudioOption) || void 0 === o || !o.speakerOnly);
        }), Ee(ee), gt(async (e)=>{
            const { payload: { body: { add: o } } } = e, r = t1.value, { meeting: { userId: i } } = r;
            for(let e = 0; e < o.length; e++){
                const { id: r } = o[e];
                if (r !== i) {
                    await UD(r, t1.value);
                    const { cmd: { jids: e }, participants: { attendeesList: o } } = t1.value;
                    e[r] && setTimeout(()=>{
                        VD(`${LD.SpeakerOnly}1`, e[r].jid, t1.value);
                    }, Math.floor(Math.random() * Math.log10(o.length) * 1e3));
                }
            }
        }), dt(ie))
}, GD = {
    epics0: (e, t1)=>sr(e, 24577).pipe(vt(t1), ke((e)=>{
            let [t1] = e;
            const { payload: { body: { status: o } } } = t1;
            return o === kD.SUCCESS && ep($a, Zn.Connected), Rf(o);
        })),
    epics1: (e, t1)=>sr(e, 24583).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { meeting: { userId: r, encType: i }, cmd: { jids: n } } = o, { payload: { body: { senderName: s, senderJid: a, text: d, type: u, receiver: l, msgid: c, sn: p } } } = t1, h = xD(n, l), m = i === Is.AES_GCM, g = xD(n, a), v = (new Date).getTime();
            let f = Promise.resolve({
                message: d
            });
            return m && (f = ws.beginDecrypt({
                decryptedText: d,
                type: As.XMPP_CHAT,
                zoomId: p
            })), f.then((e)=>{
                let { message: t1 } = e;
                if (u === MD.Private && Number(h) === r || u === MD.All) {
                    const e = $r(t1);
                    if (null != e && e.startsWith(LD.SpeakerOnly)) {
                        const t1 = e.substring(LD.SpeakerOnly.length), o = 1 === Number(t1);
                        return Dp({
                            userId: Number(g),
                            key: "isSpeakerOnly",
                            value: o
                        });
                    }
                    {
                        var o;
                        const t1 = g && (null === (o = n[g]) || void 0 === o ? void 0 : o.userGuid);
                        ep(Ha, {
                            senderId: g,
                            senderName: s,
                            senderGuid: t1,
                            text: e,
                            timestamp: v,
                            msgid: c
                        });
                    }
                }
                return "";
            });
        }), tt((e)=>"object" == typeof e && null !== e && void 0 !== e.type), gt((e)=>{
            const { payload: { userId: t1, key: o, value: r } } = e;
            ep(ma, [
                {
                    userId: t1,
                    [`${o}`]: r
                }
            ]);
        })),
    epics2: (e, t1)=>sr(e, 24595).pipe(Be((e)=>{
            const { payload: { body: { action: o, data: r } } } = e, i = [];
            if ([
                NI.List,
                NI.Add,
                NI.update
            ].includes(o) && r) {
                const { breakoutRoom: e, participants: { attendeesList: o } } = t1.value, n = (null == e ? void 0 : e.currentRoom.status) === Jp.InRoom ? o.concat(e.mainSessionAttendeeList) : o;
                i.push(Cf({
                    data: r,
                    attendees: n
                }));
            }
            return o === NI.Remove && r && i.push(_f(r)), Ce(i);
        }))
}, KD = rr(GD, WD), zD = (e, t1, o, r)=>{
    const { getState: i, dispatch: n } = o, s = i(), { participants: { attendeesList: a }, audio: { localShareAudioUserMutedList: d }, share: { isReceiveSharingFromMainSession: u }, breakoutRoom: l } = s, c = (u ? null == l ? void 0 : l.mainSessionAttendeeList : a).find((t1)=>t1.userId == e);
    if (c) {
        if (c.bShareAudioOn) {
            const o = d.find((t1)=>t1.userId === e);
            return o && o.muted === !t1 && n(WC(r, e, t1, s)), Promise.resolve("");
        }
        return Promise.reject({
            type: Gl,
            reason: `Cannot ${t1 ? "mute" : "unmute"} share audio when the user's share audio is not enable.`
        });
    }
    return Promise.reject({
        type: Ql,
        reason: "Cannot find the user"
    });
}, qD = (e, t1)=>{
    const { store: { getState: o }, rwgAgent: r } = e, { share: { sharePrivilege: i } } = o();
    return i === t1 ? Promise.resolve("") : Object.values(vd).includes(t1) ? (r.lockSharing(t1), xy("lockShare", t1)) : Promise.reject({
        type: Ql
    });
}, JD = Np([
    ch
], (e)=>e.filter((e)=>e.bVideoOn)), QD = Np([
    JD
], (e)=>e.filter((e)=>(e.caps & tS) === tS)), ZD = (e, t1)=>{
    const o = e.store.getState(), r = dS(o).find((e)=>e.userId === t1);
    if (r) {
        const { caps: e } = r;
        return ((e)=>!(512 & ~e))(e);
    }
    return !1;
};
var YD, XD, eP, tP, oP, rP, iP, nP, sP, aP, dP, uP, lP, cP, pP, hP, mP, gP, vP, fP, yP, SP, bP, EP, IP, AP, CP, _P, RP, wP, TP, OP, DP, PP, MP, kP, LP, NP, VP, UP, jP, xP, BP, FP, HP, $P, WP, GP, KP, zP, qP, JP, QP, ZP, YP, XP, eM, tM, oM, rM, iM, nM, sM, aM, dM, uM, lM, cM, pM, hM, mM, gM, vM, fM, yM, SM, bM, EM, IM, AM, CM, _M, RM;
const wM = hT("Audio"), TM = hT("Video"), OM = hT("Sharing"), DM = hT("CameraControl"), PM = hT("Remote Control"), MM = mT(HTMLCanvasElement, 0), kM = mT([
    HTMLCanvasElement,
    HTMLVideoElement
], 0), LM = mT(HTMLCanvasElement, 0, [
    "id"
]), NM = mT([
    HTMLCanvasElement,
    HTMLVideoElement
], 0, [
    "id"
]);
let VM = (YD = dT("audio"), XD = dT("audio"), eP = dT("audio"), tP = dT("audio"), oP = dT("audio"), rP = hT("Audio", [
    1,
    2,
    3
]), iP = dT("audio"), nP = hT("Audio", [
    1,
    2
]), sP = dT("audio"), aP = dT("audio"), dP = dT("audio"), uP = dT("audio"), lP = dT("share"), cP = dT("audio"), pP = dT("share"), hP = dT("audio"), mP = dT("audio"), gP = dT("audio"), vP = dT("audio"), fP = dT("audio"), yP = dT("audio"), SP = hT("Audio", [
    1,
    2
]), bP = dT("audio"), EP = hT("Audio", [
    1,
    2
]), IP = dT("audio"), AP = dT("audio"), CP = dT("audio"), _P = dT("video"), RP = dT("video"), wP = dT("video"), TP = dT("video"), OP = dT("video"), DP = dT("video"), PP = dT("video"), MP = dT("video"), kP = dT("video"), LP = dT("video"), NP = dT("video"), VP = dT("video"), UP = dT("video"), jP = dT("video"), xP = dT("video"), BP = dT("video"), FP = dT("video"), HP = dT("video"), $P = dT("video"), WP = dT("video"), GP = dT("video"), KP = dT("video"), zP = dT("video"), qP = dT("video"), JP = dT("video"), QP = dT("video"), ZP = dT("video"), YP = dT("video"), XP = dT("video"), eM = dT("share"), tM = dT("share"), oM = dT("share"), rM = dT("share"), iM = dT("share"), nM = dT("share"), sM = dT("share"), aM = dT("share"), dM = uT("isShareOptionLocked"), uM = uT("isShareOptionLocked"), lM = dT("share"), cM = dT("share"), pM = dT("share"), hM = dT("share"), mM = dT("share"), gM = dT("share"), vM = dT("share"), fM = dT("share"), yM = dT("share"), SM = dT("share"), bM = dT("share"), EM = dT("share"), IM = dT("share"), AM = dT("share"), CM = dT("share"), _M = dT("share"), RM = class extends gT {
    constructor(e){
        super(e), this[iT] = void 0, this[eT].dispatch(Vo()), this[iT] = {
            store: e,
            mediaAgent: Dy(fE(la.getInstance())),
            rwgAgent: ra.createAgent()
        };
    }
    startAudio(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), a = sh(s);
            if ((null == a ? void 0 : a.audio) === $d.Computer) return Promise.resolve("");
            if ((null == a ? void 0 : a.audio) === $d.Phone) return Promise.reject({
                type: Gl,
                reason: "joined by phone"
            });
            {
                const { audio: { isAllowToTalk: e, isComputerAudioLoading: d, canPlayAudio: u, customizeAudioOption: { speakerOnly: l } }, media: { audioDecodeStatus: c, audioEncodeStatus: p } } = s;
                if (d) return Promise.reject({
                    type: Gl,
                    reason: "Computer audio has been loading, please wait."
                });
                const h = function(e) {
                    const t1 = e ? {
                        ...e
                    } : void 0;
                    if (YC(gs()) || !0 !== (null == t1 ? void 0 : t1.backgroundNoiseSuppression) || (console.warn("Background noise suppression requires SharedArrayBuffer and is only supported on desktop browser"), Object.assign(t1, {
                        backgroundNoiseSuppression: void 0
                    })), void 0 !== (null == t1 ? void 0 : t1.originalSound)) {
                        t1.backgroundNoiseSuppression && t1.originalSound && (console.warn("Enabling original sound will disable background noise suppression."), Object.assign(t1, {
                            backgroundNoiseSuppression: !1
                        }));
                        const { originalSound: e } = t1;
                        "object" == typeof e && e.stereo && !XC() && (console.warn("Cannot enable stereo audio on current platform due to the browser limitation"), Object.assign(e, {
                            stereo: !1
                        }));
                    }
                    return e_() || !0 !== (null == t1 ? void 0 : t1.syncButtonsOnHeadset) || (console.warn("Sync buttons on headset is not supported on the current platform"), Object.assign(t1, {
                        syncButtonsOnHeadset: void 0
                    })), null != t1 && t1.mediaFile && !la.isSupportMediaPlaybackAsVideoInput() && (console.warn("Cannot use media file as audio input due to the browser limitation"), Object.assign(t1, {
                        mediaFile: void 0
                    })), t1;
                }(t1);
                r(Yh(null != h ? h : {}));
                const { speakerOnly: m, autoStartAudioInSafari: g } = h || {};
                if (!!l != !!m && r(Dp({
                    userId: s.meeting.userId,
                    key: "isSpeakerOnly",
                    value: !!m
                })), !a) return Promise.reject({
                    type: Gl,
                    reason: "Please call `startAudio` method after the `join` has been resolved"
                });
                {
                    const t1 = Gp(a.userRole) && !e || m, { encodeInitStatus: d, decodeInitStatus: l } = t_(s, a, m);
                    if (JC() && ("success" !== l || "success" !== d)) return Promise.reject({
                        type: Gl,
                        reason: "It is required to wait for the audio encoding and decoding to be ready before calling `startAudio` method"
                    });
                    r(Uh(!0)), Ey("audio", d, l).subscribe((s)=>{
                        let [d, l] = s;
                        if (d && l) {
                            let s = u || (JC() || ms.isIOSMobile) && !g ? Promise.resolve() : function() {
                                const e = URL.createObjectURL(hd), t1 = new Audio(e);
                                t1.muted = !1;
                                const o = Yr(()=>Promise.reject(), 3e3), r = ms.isIOSMobile ? new Promise((e, o)=>{
                                    var r;
                                    t1.addEventListener("canplaythrough", ()=>{
                                        t1.play().then(()=>{
                                            e(!0);
                                        }).catch((e)=>{
                                            o(e);
                                        });
                                    }), null === (r = t1.load) || void 0 === r || r.call(t1);
                                }) : t1.play();
                                return Promise.race([
                                    r,
                                    o
                                ]).finally(()=>{
                                    URL.revokeObjectURL(e);
                                });
                            }();
                            void 0 === s && (s = Promise.resolve()), s.then(()=>Ay("audio", o())).then(()=>{
                                const s = o(), { audio: { isSharingAudio: d } } = s;
                                o_(i, s, t1), d && !ZC() || GC(n, s, !t1), Gp(a.userRole) && e && r(jh(!0)), r(Nh(!0));
                            }).catch(()=>{
                                r(Nh(!1)), r(Uh(!1));
                            });
                        } else r(Uh(!1));
                    });
                }
                return "failed" === p || "failed" === c ? (r(Uh(!1)), Promise.reject({
                    type: Kl,
                    reason: "audio encode or decode error"
                })) : new Promise((e, t1)=>{
                    ot(ip(hl.JoinComputerAudio.success, 1), Ye(...hl.JoinComputerAudio.fail.map((e)=>ip(e, 1).pipe(Be(()=>Re({
                                type: ql,
                                reason: e
                            }))))), Qe(45e3).pipe(Be(()=>Re({
                            type: zl
                        })))).subscribe({
                        next: ()=>{
                            r(Uh(!1)), e("");
                        },
                        error: (e)=>{
                            la.getInstance().leaveComputerAudio();
                            const n = sh(o());
                            (null == n ? void 0 : n.audio) !== $d.Phone && (r(dm(ld.MicrophoneError)), i.joinOrLeaveVoip(!1)), r(Uh(!1)), t1(e);
                        }
                    });
                });
            }
        })(this[iT], e);
    }
    stopAudio() {
        return (async (e)=>{
            const { store: { getState: t1, dispatch: o }, mediaAgent: r, rwgAgent: i } = e, n = t1(), { audio: { isComputerAudioLoading: s, isShareAudioEnabled: a, isSharingAudio: d, isUsingMediaPlayback: u, customizeAudioOption: { speakerOnly: l } } } = n, c = sh(n);
            if (s) return Promise.reject({
                type: Gl,
                reason: "Computer audio has not finished joining, please wait."
            });
            if (a) {
                if (d && !ZC()) return Promise.reject({
                    type: Gl,
                    reason: "Cannot stop audio during sharing with audio"
                });
                o(Hh(void 0)), o(xh(void 0));
            }
            return (null == c ? void 0 : c.audio) === $d.Computer ? (o(dm(ld.Active)), await r.leaveComputerAudio(), i.joinOrLeaveVoip(!1), l && o(Dp({
                userId: n.meeting.userId,
                key: "isSpeakerOnly",
                value: void 0
            })), u && $y.getInstance().stopAudioElement(), o(Dh(0)), rp(Hu)) : Promise.resolve("");
        })(this[iT]);
    }
    muteAudio(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), a = sh(s);
            if (null == t1 || t1 === (null == a ? void 0 : a.userId)) return "" === (null == a ? void 0 : a.audio) || null === (null == a ? void 0 : a.audio) ? Promise.reject({
                type: Gl,
                reason: "no audio joined"
            }) : !0 === (null == a ? void 0 : a.muted) ? Promise.resolve("") : (r(nm(dd.Active)), i.mute(a.userId, !0), n.muteAudio(), s.audio.isShareAudioEnabled && !ZC() && r(xh(!0)), rp($u).then(()=>""));
            if (ah(s)) {
                const { participants: { allowTalkAttendeesList: e, attendeesList: o } } = s, r = e.concat(o).find((e)=>e.userId === t1);
                return r ? "" === r.audio || null === r ? Promise.reject({
                    type: Gl,
                    reason: "no audio joined"
                }) : !1 === r.muted ? (i.mute(t1, !0), rp(Gu, (e)=>e.id === t1 && 1 == e.muted)) : Promise.resolve("") : Promise.reject({
                    type: Ql,
                    reason: "no matching user"
                });
            }
            return Promise.reject({
                type: ql
            });
        })(this[iT], e);
    }
    unmuteAudio(e) {
        return (async (e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), a = sh(s);
            if (void 0 === t1 || t1 === (null == a ? void 0 : a.userId)) {
                if ("" === (null == a ? void 0 : a.audio) || null === (null == a ? void 0 : a.audio)) return Promise.reject({
                    type: Gl,
                    reason: "no audio joined"
                });
                if (!1 === (null == a ? void 0 : a.muted)) return Promise.resolve("");
                if (s.audio.isShareAudioEnabled && !ZC()) {
                    if (s.audio.isSharingAudio) return Promise.reject({
                        type: Gl,
                        reason: "Cannot unmute audio during sharing with audio"
                    });
                    r(xh(!1));
                }
                if (s.audio.bCanUnmute || null != a && a.isHost || null != a && a.bCoHost) {
                    if (Gp(a.userRole)) {
                        const { audio: { isAllowToTalk: e, isAllowToTalkAttendeeConnected: t1 } } = s;
                        e ? t1 || (await n.leaveComputerAudio(), await GC(n, s, !0), r(jh(!0))) : Promise.reject({
                            type: Gl,
                            reason: "Webinar attendee cannot unmute self audio."
                        });
                    }
                    return r(sm(ud.Active)), i.mute(a.userId, !1), n.unmuteAudio(), rp(Wu).then(()=>"");
                }
                return Promise.reject({
                    type: ql,
                    reason: "host not allow unmute themselves"
                });
            }
            if (ah(s)) {
                const { participants: { allowTalkAttendeesList: e, attendeesList: o } } = s, r = e.concat(o).find((e)=>e.userId === t1);
                return r ? "" === r.audio || null === r ? Promise.reject({
                    type: Gl,
                    reason: "no audio joined"
                }) : (!0 === r.muted && i.mute(t1, !1), Promise.resolve("")) : Promise.reject({
                    type: Ql,
                    reason: "no matching user"
                });
            }
            return Promise.reject({
                type: ql
            });
        })(this[iT], e);
    }
    dialOut(e, t1, o, r) {
        return ((e, t1, o, r, i)=>{
            const { store: { getState: n, dispatch: s }, rwgAgent: a } = e, d = n(), { meeting: { callOutCountry: u, isSupportCallOut: l } } = d;
            if (l && Array.isArray(u) && u.findIndex((e)=>e.code === t1) > -1) {
                const { seq: e } = a.audioDialout(t1 + o, r, !(null == i || !i.callMe), !(null == i || !i.pressingOne), !(null == i || !i.greeting));
                return s(Ah({
                    sequence: e,
                    phoneNumber: t1 + o
                })), op(hl.JoinAudioByCallMe);
            }
            return Promise.reject({
                type: Ql,
                reason: "no matching country code"
            });
        })(this[iT], e, t1, o, r);
    }
    cancelDialOut(e, t1, o) {
        return ((e, t1, o, r)=>{
            const { rwgAgent: i } = e;
            return i.audioCancelDialout(t1 + o, !(null == r || !r.callMe)), op(hl.cancelDialOut);
        })(this[iT], e, t1, o);
    }
    hangup() {
        return ((e)=>{
            const { store: { getState: t1 }, rwgAgent: o } = e, r = t1(), i = sh(r);
            return (null == i ? void 0 : i.audio) === $d.Phone && null !== i.userId ? (o.audioDrop(i.userId), op(hl.hangup)) : Promise.reject({
                type: Gl,
                reason: "not joined audio by phone"
            });
        })(this[iT]);
    }
    switchMicrophone(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { audio: { microphoneDevicesList: s, activeMicrophone: a, mediaPlaybackFile: d, isUsingMediaPlayback: u } } = n, l = s.find((e)=>e.deviceId === t1);
            if ("default" === t1 || "string" != typeof t1 || l) {
                const e = sh(n);
                if ((null == e ? void 0 : e.audio) === $d.Computer) {
                    let o = !1;
                    if ("string" == typeof t1) t1 !== a && (i.changeMicrophone(t1, null == l ? void 0 : l.label, !(null == e || !e.muted)), r(tm(void 0)), $y.getInstance().stopAudioElement(), o = !0);
                    else if (t1 && (!u || (null == d ? void 0 : d.url) !== t1.url)) {
                        const n = $y.getInstance();
                        n.setAudioElement(t1).then(()=>{
                            void 0 !== t1.playback && (i.enablePlayAudioFileLocally(!!t1.playback), n.audioElement.dataset.playback = t1.playback ? "1" : "0"), i.changeMicrophone(n.audioElement, void 0, !(null == e || !e.muted)), r(tm(t1));
                        }), o = !0;
                    }
                    if (o) return op(hl.JoinComputerAudio);
                } else "string" == typeof t1 && r(kh(t1));
                return Promise.resolve("");
            }
            return Promise.reject({
                type: tl
            });
        })(this[iT], e);
    }
    switchSpeaker(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { audio: { speakerDevicesList: n, activeSpeaker: s } } = o();
            if ("default" !== t1 && -1 == n.findIndex((e)=>e.deviceId === t1)) return Promise.reject({
                type: tl
            });
            var a;
            if ((null === (a = sh(o())) || void 0 === a ? void 0 : a.audio) === $d.Computer) {
                if (t1 !== s) return i.changeSpeaker(t1), rp(sl, (e)=>e);
            } else r(Lh(t1));
            return Promise.resolve("");
        })(this[iT], e);
    }
    muteShareAudio(e) {
        return ((e, t1)=>{
            const { mediaAgent: o, rwgAgent: r, store: { getState: i, dispatch: n } } = e, s = i(), { meeting: { userId: a } } = s;
            if (t1 && t1 !== a) return zD(t1, !0, e.store, o);
            {
                const { audio: { isSharingAudio: e, isShareAudioEnabled: t1, isShareAudioMuted: i } } = s;
                if (!t1) return Promise.reject({
                    type: Gl,
                    reason: "Cannot mute sharing audio when sharing audio is not enable"
                });
                if (i) return Promise.resolve("");
                {
                    r.muteShareAudio(!0);
                    let t1 = Promise.resolve();
                    var d;
                    return e && (t1 = null === (d = o.leaveSharingAudio(!0)) || void 0 === d ? void 0 : d.then(()=>KC(o, r, s).then((e)=>{
                            e.forEach((e)=>n(e));
                        }))), WC(o, a, !0, s), Promise.all([
                        rp({
                            event: pa,
                            operations: [
                                tt((e)=>void 0 !== e.bShareAudioOn),
                                it(1)
                            ]
                        }, (e)=>!1 === e.bShareAudioOn),
                        t1
                    ]).then(()=>(n(Wh(!0)), e && (n(Gh(!1)), ep(rl, {
                            state: "off"
                        })), ""));
                }
            }
        })(this[iT], e);
    }
    unmuteShareAudio(e) {
        return ((e, t1)=>{
            const { mediaAgent: o, rwgAgent: r, store: { getState: i, dispatch: n } } = e, s = i(), { meeting: { userId: a } } = s;
            if (t1 && t1 !== a) return zD(t1, !1, e.store, o);
            {
                const { audio: { isSharingAudio: e, isShareAudioEnabled: t1, isShareAudioMuted: i }, share: { status: d } } = s;
                if (!t1) return Promise.reject({
                    type: Gl,
                    reason: "Cannot unmute sharing audio when sharing audio is not enable"
                });
                if (!1 === i) return Promise.resolve("");
                {
                    r.muteShareAudio(!1);
                    let t1 = Promise.resolve();
                    return !1 === e && d === fd.Sharing && (t1 = qC(o, r, s).then((e)=>{
                        e.forEach((e)=>n(e));
                    })), WC(o, a, !1, s), Promise.all([
                        rp({
                            event: pa,
                            operations: [
                                tt((e)=>void 0 !== e.bShareAudioOn),
                                it(1)
                            ]
                        }, (e)=>!0 === e.bShareAudioOn),
                        t1
                    ]).then(()=>(n(Wh(!1)), !1 === e && d === fd.Sharing && (n(Gh(!0)), ep(rl, {
                            state: "on"
                        })), ""));
                }
            }
        })(this[iT], e);
    }
    subscribeAudioStatisticData(e) {
        return (async (e, t1)=>{
            const { mediaAgent: o, store: { getState: r } } = e, i = r(), n = sh(i), s = !t1 || t1.decode, a = !t1 || t1.encode;
            if (!n) return Promise.reject({
                type: Gl,
                reason: "Call this function after the 'join' method resolved."
            });
            {
                var d;
                const { encodeInitStatus: e, decodeInitStatus: t1 } = t_(i, n);
                (gs() ? Ny(i, !(null !== (d = i.audio.customizeAudioOption) && void 0 !== d && d.speakerOnly)) : Ey("audio", e, t1)).subscribe((e)=>{
                    let [t1, r] = e;
                    t1 && r && (s && o.subscribeToQos([
                        da.AudioDecode
                    ], Td), a && o.subscribeToQos([
                        da.AudioEncode
                    ], Td));
                });
            }
            return "";
        })(this[iT], e);
    }
    unsubscribeAudioStatisticData(e) {
        return (async (e, t1)=>{
            const { mediaAgent: o, store: { dispatch: r } } = e, i = !t1 || t1.decode, n = !t1 || t1.encode;
            return i && (o.unsubscribeFromQos([
                da.AudioDecode
            ]), r(Kh(Ld))), n && (o.unsubscribeFromQos([
                da.AudioEncode
            ]), r(zh(Ld))), null;
        })(this[iT], e);
    }
    enableBackgroundNoiseSuppression(e) {
        return ((e, t1)=>{
            const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { audio: { isBackgroundNoiseSuppression: n, originalSound: s } } = r();
            let a = t1;
            return a === !!n || (a && !YC(gs()) ? (console.warn("Background noise suppression requires SharedArrayBuffer and is only supported on desktop browser"), a = !1) : (a && s && (console.warn("Enabling noise suppression will disable original sound."), i(am(!1))), i(Xh(a)), o.changeAudioProfile($C(r())))), Promise.resolve("");
        })(this[iT], e);
    }
    enableSyncButtonsOnHeadset(e) {
        return ((e, t1)=>{
            const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, n = r(), { audio: { isHIDEnabled: s, microphoneDevicesList: a, activeMicrophone: d } } = n;
            if (t1 === !!s) return Promise.resolve("");
            {
                const e = sh(n);
                var u;
                return e ? (t1 && !e_() ? console.warn("Sync buttons on headset is not supported on the current platform") : (o.enableSyncButtonsOnHeadset(t1, null === (u = a.find((e)=>e.deviceId === d)) || void 0 === u ? void 0 : u.label, e.muted), i(em(t1))), Promise.resolve("")) : Promise.reject({
                    type: Gl,
                    reason: "Please call `enableSyncButtonsOnHeadset` method after the `join` has been resolved"
                });
            }
        })(this[iT], e);
    }
    enableOriginalSound(e) {
        return ((e, t1)=>{
            const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { audio: { isBackgroundNoiseSuppression: n, originalSound: s } } = r(), a = t1;
            return a === s || "object" == typeof t1 && Qr(t1, s) || ("object" != typeof a || !0 !== (null == a ? void 0 : a.stereo) || XC() || (console.warn("Cannot enable stereo audio on current platform due to the browser limitation"), a.stereo = !1), n && a && (console.warn("Enabling original sound will disable background noise suppression."), i(Xh(!1))), i(am(a)), o.changeAudioProfile($C(r()))), Promise.resolve("");
        })(this[iT], e);
    }
    callCRCDevice(e, t1) {
        return ((e, t1, o)=>{
            const { rwgAgent: r, store: { dispatch: i, getState: n } } = e, { seq: s } = r.inviteCRCDevice(t1, o);
            return i(lm({
                sequence: s,
                ip: t1,
                protocol: o
            })), op(hl.crcCallOut).then(()=>{
                var e;
                const { audio: { crcDevice: r } } = n();
                return null === (e = r.find((e)=>e.ip === t1 && e.protocol === o && e.sequence === s)) || void 0 === e ? void 0 : e.uuid;
            });
        })(this[iT], e, t1);
    }
    cancelCallCRCDevice(e, t1) {
        return ((e, t1, o)=>{
            const { rwgAgent: r, store: { getState: i } } = e, { audio: { crcDevice: n } } = i(), s = n.find((e)=>e.ip === t1 && e.protocol === o);
            return s && s.returnCode === eu.Ringing ? (r.cancelInviteCRCDevice(s.transId), Promise.resolve("")) : Promise.reject({
                type: Gl,
                reason: "Cannot cancel call out "
            });
        })(this[iT], e, t1);
    }
    muteAllAudio() {
        return ((e)=>{
            const { rwgAgent: t1 } = e;
            return t1.audioMuteAll(!0), xy("bMutedAll", !0);
        })(this[iT]);
    }
    unmuteAllAudio() {
        return ((e)=>{
            const { rwgAgent: t1 } = e;
            return t1.audioMuteAll(!1), xy("bMutedAll", !1);
        })(this[iT]);
    }
    muteAudioUponEntry() {
        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        return function(e) {
            let t1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            const { store: { getState: o }, rwgAgent: r } = e, { audio: { bMutedUponEntry: i } } = o();
            return i === t1 ? Promise.resolve("") : (r.setMuteOnEntry(t1), xy("bMutedUponEntry", t1));
        }(this[iT], e);
    }
    getMicList() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const o = t1();
            return o.audio ? [
                ...o.audio.microphoneDevicesList
            ] : [];
        })(this[iT]);
    }
    getSpeakerList() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const o = t1();
            return o.audio ? [
                ...o.audio.speakerDevicesList
            ] : [];
        })(this[iT]);
    }
    getAudioState(e) {
        return ((e, t1)=>{
            let { store: { getState: o } } = e;
            const r = o(), { meeting: { isWebinar: i } } = r;
            let n = null;
            return null == t1 ? n = sh(r) : (n = r.participants.attendeesList.find((e)=>e.userId === t1), i && !n && (n = r.participants.xmppAttendeeList.find((e)=>e.userId === t1))), n ? n.audio : null;
        })(this[iT], e);
    }
    isAudioMuted(e) {
        return ((e, t1)=>{
            let { store: { getState: o } } = e;
            const r = o(), { meeting: { isWebinar: i } } = r;
            let n = null;
            return void 0 === t1 ? n = sh(r) : (n = r.participants.attendeesList.find((e)=>e.userId === t1), i && !n && (n = r.participants.xmppAttendeeList.find((e)=>e.userId === t1))), !!n && !!n.muted;
        })(this[iT], e);
    }
    getActiveMicrophone() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const o = t1();
            return o.audio ? o.audio.activeMicrophone : null;
        })(this[iT]);
    }
    getActiveSpeaker() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const o = t1();
            return o.audio ? o.audio.activeSpeaker : null;
        })(this[iT]);
    }
    isSupportCallOut() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { meeting: { isSupportCallOut: o, callOutCountry: r } } = t1();
            return o && Array.isArray(r) && (null == r ? void 0 : r.length) > 0;
        })(this[iT]);
    }
    getDialOutStatus() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { audio: o } = t1();
            return null == o ? void 0 : o.dialout[o.dialout.length - 1].returnCode;
        })(this[iT]);
    }
    getDialOutCountries() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { meeting: { callOutCountry: o } } = t1();
            return Array.isArray(o) ? o : [];
        })(this[iT]);
    }
    getShareAudioStatus() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { audio: { isShareAudioEnabled: o, isShareAudioMuted: r, isSharingAudio: i } } = t1();
            return {
                isShareAudioEnabled: o,
                isShareAudioMuted: r,
                isSharingAudio: i
            };
        })(this[iT]);
    }
    isOthersShareAudioMutedLocally(e) {
        return ((e, t1)=>{
            var o;
            let { store: { getState: r } } = e;
            const { audio: { localShareAudioUserMutedList: i } } = r();
            return null === (o = i.find((e)=>e.userId === t1)) || void 0 === o ? void 0 : o.muted;
        })(this[iT], e);
    }
    getAudioStatisticData() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { audio: { statistic: o } } = t1();
            return {
                ...o
            };
        })(this[iT]);
    }
    getDialInInfo() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { meeting: { meetingNumber: o, tollNumbers: r, participantID: i, h323Password: n } } = t1();
            return void 0 === r ? null : {
                meetingId: o,
                participantId: i,
                password: n || "",
                tollNumbers: r.map((e)=>({
                        ...e
                    }))
            };
        })(this[iT]);
    }
    isSupportMicrophoneAndShareAudioSimultaneously() {
        return ZC();
    }
    getAudioMediaPlaybackController() {
        return ((e)=>{
            let { store: { getState: t1 }, mediaAgent: o } = e;
            const r = t1(), { audio: { isUsingMediaPlayback: i } } = r;
            if (i) {
                const { audioElement: e } = $y.getInstance();
                return By(e, "audio", r, o);
            }
            return null;
        })(this[iT]);
    }
    startVideo(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { media: { videoDecodeStatus: s, videoEncodeStatus: a, enforceVirtualBackground: d }, video: { isCaptureCameraLoading: u, isCurrentUserStartedVideo: l, isVideoMuted: c } } = n, p = t1 ? {
                ...t1
            } : void 0;
            if (l) return Promise.reject({
                type: Gl,
                reason: "Video is started"
            });
            if (u) return Promise.reject({
                type: Gl,
                reason: "Camera is starting,please wait."
            });
            if (c && !ah(n)) return Promise.reject({
                type: Gl,
                reason: "Video is muted by the host"
            });
            if (sw(d)) if ((null == p ? void 0 : p.videoElement) instanceof HTMLVideoElement) console.warn('The "videoElement" option will be removed in version 2.x. Please use the "attachVideo" or "renderVideo" method to render the self-view.');
            else {
                console.warn('Rendering self-view on Chromium browser, Android browser without SharedArrayBuffer or iOS browser requires video tag, Please use "attachVideo" or pass a video element instead of a canvas element in the "renderVideo" method');
                let e = document.body.querySelector(`#${kd}`);
                if (!e) {
                    e = document.createElement("video");
                    const t1 = ms.isSafari || ms.isIOSMobile ? "position:fixed;top:-10000px;left:-10000px" : "display:none";
                    e.setAttribute("style", t1), e.muted = !0, e.playsInline = !0, e.autoplay = !0, e.id = kd, document.body.appendChild(e);
                }
                p && Object.assign(p, {
                    videoElement: e
                });
            }
            return !Py(d) && null != p && p.virtualBackground ? Promise.reject({
                type: Ql,
                reason: "Virtual background only compatible with Chrome and Edge with SharedArrayBuffer enabled."
            }) : (r(ng(!0)), Ey("video", a, s).subscribe((e)=>{
                let [t1] = e;
                if (t1) {
                    const e = o(), { video: { activeCamera: t1, isSupportHDVideo: n, virtualBackground: { imageSrc: s }, mask: { imageSrc: a } } } = e, { cameraId: d = t1, captureWidth: u = 0, captureHeight: l = 0, mirrored: c, hd: h, fullHd: m, virtualBackground: g, mask: v } = p || {};
                    c && i.mirrorVideo(c), (h || m) && (console.log("HD support is currently limited, and comes with a number of restrictions and limitations. Please visit https://developers.zoom.us/docs/video-sdk/web/video/#720p-video for more details"), n && la.isCompatibleHardwareForEncode() && la.isSupportVideoEncodeHardwareAcceleration().then((e)=>{
                        e && (i.enableHardwareAccelerationForVideoEncode(!0), r(Ag({
                            encode: e
                        })));
                    }), n || console.warn("Cannot capture HD video due to either account restriction and/or hardware limitation"));
                    const f = g || void 0 === g && !!s && void 0 === v, y = v || void 0 === v && !!a;
                    let S = Promise.resolve({});
                    if (f) {
                        const t1 = g || {
                            imageUrl: void 0,
                            cropped: void 0
                        };
                        S = fw({
                            ...t1,
                            captureWidth: u,
                            captureHeight: l,
                            cameraId: d,
                            hd: h
                        }, i, e).then(()=>t1);
                    } else if (y) {
                        const t1 = v || {
                            imageUrl: void 0,
                            cropped: void 0,
                            clip: void 0,
                            rootWidth: void 0,
                            rootHeight: void 0
                        };
                        t1.rootWidth || Object.assign(t1, {
                            rootWidth: 1280
                        }), t1.rootHeight || Object.assign(t1, {
                            rootHeight: 720
                        }), S = yw({
                            ...t1,
                            captureWidth: u,
                            captureHeight: l,
                            cameraId: d,
                            hd: h
                        }, i, e).then(()=>t1);
                    }
                    null != p && p.mediaFile && !la.isSupportMediaPlaybackAsVideoInput() && (console.warn("Cannot use media file as video input due to the browser limitation."), Object.assign(p, {
                        mediaFile: void 0
                    })), S.then((e)=>Ay("video", o()).then(()=>e)).then((t1)=>{
                        tw(i, e, p).forEach((e)=>{
                            r(e);
                        }), f ? r(bg(t1)) : y && r(Ug(t1));
                    }).catch((e)=>{
                        r(ng(!1)), ep(cu, {
                            reason: e
                        });
                    });
                } else r(ng(!1));
            }), op(Nu.startCaptureVideo).then(()=>{
                r(sg(!1)), r(og(!1));
            }).finally(()=>{
                r(ng(!1));
            }));
        })(this[iT], e);
    }
    stopVideo() {
        return ((e)=>{
            const { store: { getState: t1 }, mediaAgent: o } = e, { video: { isCaptureCameraLoading: r, isCurrentUserStartedVideo: i, isUsingMediaPlayback: n } } = t1();
            return r ? Promise.reject({
                type: Gl,
                reason: "Camera is starting,please wait."
            }) : i ? (o.stopCaptureVideo(), n && $y.getInstance().stopVideoElement(), rp(mu, (e)=>!0 !== (null == e ? void 0 : e.failed))) : Promise.reject({
                type: Gl,
                reason: "camera is closed"
            });
        })(this[iT]);
    }
    switchCamera(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { video: { cameraDevicesList: s, isCurrentUserStartedVideo: a, virtualBackground: d, mask: u, mediaPlaybackFile: l, isUsingMediaPlayback: c, customizedVideoOption: p } } = n;
            if ("string" == typeof t1 && !XR(t1, s)) return Promise.reject({
                type: Ql,
                reason: "Cannot find cameraDeviceId in camera devices list."
            });
            if (a || null != d && d.isVBConfigured || u.isMaskConfigured) {
                if ("string" == typeof t1) {
                    const { captureWidth: e, captureHeight: o } = YR(p);
                    i.changeCamera(t1, wd.includes(t1), {
                        width: e,
                        height: o
                    }), r(Bg(void 0)), $y.getInstance().stopVideoElement();
                } else if (t1 && (!c || (null == l ? void 0 : l.url) !== t1.url)) {
                    const e = $y.getInstance();
                    e.setVideoElement(t1).then(()=>{
                        i.changeCamera(e.videoElement), r(Bg(t1));
                    });
                }
                return op(Nu.switchCameraVideo).then(()=>{
                    r(sg(!1)), r(og(!1));
                }).catch((e)=>(i.stopCaptureVideo(), Promise.reject(e)));
            }
            return Promise.resolve();
        })(this[iT], e);
    }
    renderVideo(e, t1, o, r, i, n, s, a, d) {
        return ((e, t1, o, r, i, n, s, a, d, u)=>{
            const { store: { getState: l, dispatch: c }, mediaAgent: p, rwgAgent: h } = e, m = l(), { meeting: { userId: g }, media: { enforceMultipleVideos: v, enforceVirtualBackground: f, disableRenderLimits: y }, video: { subscribedVideoList: S, renderedVideoList: b } } = m, E = ys(!!v, y), I = sw(f) && o === g;
            if (t1 instanceof HTMLCanvasElement && !S.includes(o) && S.length >= E && new Set(b.map((e)=>e.canvasId)).has(t1.id)) return Promise.reject({
                type: Gl,
                reason: `subscribe video counts greater than maximum size (${E})`
            });
            if (-1 === JD(m).findIndex((e)=>e.userId === o)) return Promise.reject({
                type: Ql,
                reason: "user is not send video"
            });
            if (t1.id || (t1.id = Xr("__ZOOM_SDK_VIDEO_CANVAS_@__")), I) {
                if (t1 instanceof HTMLVideoElement) {
                    t1.playsInline = !0, t1.muted = !0, t1.autoplay = !0, ms.isIOSMobile && (p.switchCanvasForVideoCapture(t1), c(Zg())), p.renderVideo(t1, o, d || Dd, r, i, n, s, a, !0, u || "", !1), c(ug(o)), c(Qg(t1.id));
                    const e = document.querySelector(`#${kd}`);
                    return e && e.remove(), Promise.resolve("");
                }
                return Promise.reject({
                    type: Ql,
                    reason: "You must use a <video> element to render self video for Chromium browser, Android browser without SharedArrayBuffer or iOS browser "
                });
            }
            const A = !!u, { media: { videoDecodeStatus: C } } = m;
            return Ey("video", "success", C).subscribe(async (e)=>{
                let [m, v] = e;
                if (v) {
                    const { video: { ensuredCanvas: e, renderedVideoList: m } } = l();
                    let v = t1;
                    e.includes(t1.id) || (v = Ry(t1), c(xg(t1.id)));
                    const f = o === g, [y, b] = aw(o, a, l()), E = d || Dd, I = await async function(e, t1) {
                        const { video: { prefetchedVideo: o } } = t1;
                        return (null == o ? void 0 : o.userId) !== e || o.loaded ? "" : Te(ot(ip(Pu, 1), Qe(1e3).pipe(st(""))));
                    }(o, l());
                    m.some((e)=>e.userId === o && e.key === E && e.canvasId === v.id) || p.renderVideo(v, o, E, r, i, n, s, b, f, u || "", A), o !== g && h.subscribeVideo(o, b, !1), S.includes(o) || c(ug(o)), I && c(Fg(void 0)), c(hg({
                        userId: o,
                        key: E,
                        canvasId: v.id,
                        videoQuality: y,
                        aspectRatio: i ? r / i : 0
                    }));
                }
            }), "failed" === C ? Promise.reject({
                type: Kl,
                reason: "Video  decode status is failed"
            }) : Promise.resolve("");
        })(this[iT], e, t1, o, r, i, n, s, a, d);
    }
    stopRenderVideo(e, t1, o, r) {
        let i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = arguments.length > 5 ? arguments[5] : void 0;
        return function(e, t1, o, r, i) {
            let n = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], s = arguments.length > 6 ? arguments[6] : void 0;
            const { store: { getState: a, dispatch: d }, mediaAgent: u, rwgAgent: l } = e, c = a(), { video: { subscribedVideoList: p, renderedVideoList: h }, meeting: { userId: m }, media: { enforceVirtualBackground: g } } = c;
            if (p.includes(o)) {
                const e = r || Dd;
                if (sw(g) && o === m && t1 instanceof HTMLVideoElement) return t1.pause(), d(lg(o)), d(Zg(t1.id)), Promise.resolve("");
                if (h.find((r)=>r.userId === o && r.key === e && r.canvasId === t1.id) && (u.stopRenderVideo(t1.id, o, e, ZR(i), n), 1 == h.filter((e)=>e.userId === o).length && (o !== m && l.unsubscribeVideo(o), d(lg(o))), d(mg({
                    userId: o,
                    key: e,
                    canvasId: t1.id
                }))), s && m !== s) {
                    const { video: { subscribedVideoList: e, prefetchedVideo: t1 } } = a();
                    JD(c).find((e)=>e.userId === s) && !e.includes(s) && (null == t1 ? void 0 : t1.userId) !== s && d(Fg({
                        userId: s,
                        lastCopy: t1
                    }));
                }
            }
            return Promise.resolve("");
        }(this[iT], e, t1, o, r, i, n);
    }
    updateVideoCanvasDimension(e, t1, o) {
        return ((e, t1, o, r)=>{
            const { mediaAgent: i } = e;
            return o >= 0 && r >= 0 && i.updateRenderedVideoCanvasDimension(t1, o, r), Promise.resolve("");
        })(this[iT], e, t1, o);
    }
    adjustRenderedVideoPosition(e, t1, o, r, i, n, s) {
        return ((e, t1, o, r, i, n, s, a)=>{
            const { store: { getState: d, dispatch: u }, mediaAgent: l } = e, { video: { subscribedVideoList: c } } = d();
            if (c.includes(o)) {
                if (t1 instanceof HTMLVideoElement) return Promise.resolve("");
                const e = a || Dd;
                l.adjustRenderedVideoPosition(t1.id, o, e, n, s, r, i, ZR("#000")), u(hg({
                    userId: o,
                    key: e,
                    canvasId: t1.id,
                    aspectRatio: i ? r / i : 0
                }));
            } else console.warn("Cannot adjust the size or position of the video as the video has not been rendered yet.");
            return Promise.resolve("");
        })(this[iT], e, t1, o, r, i, n, s);
    }
    clearVideoCanvas(e, t1) {
        return ((e, t1, o)=>{
            const { mediaAgent: r } = e;
            return r.clearVideoCanvas(t1.id, ZR(o)), Promise.resolve("");
        })(this[iT], e, t1);
    }
    mirrorVideo(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { media: { enforceVirtualBackground: n }, video: { isCurrentUserStartedVideo: s, virtualBackground: a, selfPreviewVideoList: d, customizedVideoOption: u, videoAttachments: l, isMirrored: c }, meeting: { userId: p } } = o();
            if (c === t1) return Promise.resolve("");
            if (s || null != a && a.isVBConfigured) {
                if (sw(n)) {
                    const e = [];
                    d.length > 0 && d.forEach((t1)=>{
                        e.push(document.getElementById(t1));
                    }), null != u && u.videoElement && e.push(document.querySelector(null == u ? void 0 : u.videoElement)), l && l[`${p}`] && l[`${p}`].forEach((t1)=>{
                        var o;
                        e.push(null == t1 || null === (o = t1.render) || void 0 === o ? void 0 : o.el);
                    }), e.filter((e)=>!!e).forEach((e)=>{
                        e && ew(e, t1);
                    });
                } else i.mirrorVideo(t1);
                r(Jg(t1));
            }
            return Promise.resolve("");
        })(this[iT], e);
    }
    enableHardwareAcceleration(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { video: { isSupportHDVideo: n } } = o();
            if ("boolean" == typeof t1 || void 0 !== t1.decode) {
                const e = "boolean" == typeof t1 ? t1 : !!t1.decode;
                return e ? la.isSupportVideoDecodeHardwareAcceleration().then((e)=>(e && i.enableHardwareAccelerationForVideoDecode(e), r(Ag({
                        decode: e
                    })), e)) : (i.enableHardwareAccelerationForVideoDecode(e), r(Ag({
                    decode: e
                })), Promise.resolve(!0));
            }
            if ("boolean" == typeof t1 || void 0 !== t1.encode) {
                const e = "boolean" == typeof t1 ? t1 : !!t1.encode;
                if (n) {
                    if (!e) return i.enableHardwareAccelerationForVideoEncode(!1), r(Ag({
                        encode: !1
                    })), Promise.resolve(!0);
                    if (la.isCompatibleHardwareForEncode()) return la.isSupportVideoEncodeHardwareAcceleration().then((e)=>(e && i.enableHardwareAccelerationForVideoEncode(e), r(Ag({
                            encode: e
                        })), e));
                    console.warn("Can not turn on hardware acceleration with your graphic card due to the technical limitation");
                } else "boolean" != typeof t1 && null != t1 && t1.encode && console.warn("Can not use the hardware acceleration for video encoding due to the account restriction");
            }
            return Promise.resolve(!1);
        })(this[iT], e);
    }
    subscribeVideoStatisticData(e) {
        return (async (e, t1)=>{
            const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { media: { videoDecodeStatus: n, videoEncodeStatus: s }, video: { subscriptionStatus: a } } = r(), d = !t1 || t1.decode, u = !t1 || t1.encode;
            return Ey("video", s, n).subscribe((e)=>{
                let [r, n] = e;
                const s = {};
                d && n && !a.decode && (o.subscribeToQos([
                    da.VideoDecode
                ], Td), Object.assign(s, {
                    decode: !0
                })), u && r && !a.encode && (o.subscribeToQos([
                    da.VideoEncode
                ], Td), Object.assign(s, {
                    encode: !0
                })), null != t1 && t1.detailed && n && !a.detailed && (o.enableVideoObserver(!0), Object.assign(s, {
                    detailed: !0
                })), i(Hg(s));
            }), null;
        })(this[iT], e);
    }
    unsubscribeVideoStatisticData(e) {
        return (async (e, t1)=>{
            const { mediaAgent: o, store: { dispatch: r } } = e, i = !t1 || t1.decode, n = !t1 || t1.encode, s = {};
            return i && (o.unsubscribeFromQos([
                da.VideoDecode
            ]), r(Eg(Nd)), Object.assign(s, {
                decode: !1
            })), n && (o.unsubscribeFromQos([
                da.VideoEncode
            ]), r(Ig(Nd)), Object.assign(s, {
                encode: !1
            })), null != t1 && t1.detailed && (o.enableVideoObserver(!1), Object.assign(s, {
                detailed: !1
            })), r(Hg(s)), null;
        })(this[iT], e);
    }
    previewVirtualBackground(e, t1, o, r) {
        return ((e, t1, o, r, i)=>{
            const { store: { getState: n, dispatch: s }, mediaAgent: a } = e, d = n();
            return fw({
                imageUrl: o,
                cropped: r,
                cameraId: i
            }, a, d, t1).then((e)=>("object" == typeof e && null != e && e.type && s(e), s(bg({
                    imageUrl: o,
                    cropped: r
                })), !0)).catch((e)=>Promise.reject({
                    type: Gl,
                    reason: e
                }));
        })(this[iT], e, t1, o, r);
    }
    updateVirtualBackgroundImage(e, t1) {
        return ((e, t1, o)=>{
            const { store: { getState: r, dispatch: i }, mediaAgent: n } = e, s = r(), { video: { virtualBackground: { imageSrc: a, cropped: d }, backgroundMode: u } } = s;
            return t1 === a && o === d ? Promise.resolve(!0) : u === Hd.Mask ? Promise.reject({
                type: Gl,
                reason: "Cannot update virtual background in the mask mode"
            }) : fw({
                imageUrl: t1,
                cropped: o
            }, n, s).then((e)=>("object" == typeof e && null != e && e.type && i(e), i(bg({
                    imageUrl: t1,
                    cropped: o
                })), !0)).catch((e)=>Promise.reject({
                    type: Gl,
                    reason: e
                }));
        })(this[iT], e, t1);
    }
    stopPreviewVirtualBackground() {
        return ((e)=>{
            const { store: { getState: t1 }, mediaAgent: o } = e, { video: { virtualBackground: { isVBConfigured: r } } } = t1();
            return r ? (o.stopVirtualBackgroundSetting(), Promise.resolve(!0)) : Promise.reject({
                type: Gl,
                reason: "Cannot stop preview virtual background before start"
            });
        })(this[iT]);
    }
    previewVideoMask(e, t1) {
        return ((e, t1, o)=>{
            const { store: { getState: r, dispatch: i }, mediaAgent: n } = e, s = r();
            return o.rootWidth && o.rootHeight || Object.assign(o, {
                rootWidth: t1.width,
                rootHeight: t1.height
            }), yw(o, n, s, t1).then((e)=>("object" == typeof e && null != e && e.type && i(e), i(Ug(o)), !0)).catch((e)=>Promise.reject({
                    type: Gl,
                    reason: e
                }));
        })(this[iT], e, t1);
    }
    updateVideoMask(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { video: { mask: s, backgroundMode: a } } = n, { isMaskConfigured: d } = s;
            if (a === Hd.VirtualBackground) return Promise.reject({
                type: Gl,
                reason: "Cannot update mask in the virtual background mode"
            });
            if (d) {
                const e = {
                    ...t1
                };
                return [
                    "imageUrl",
                    "cropped",
                    "clip",
                    "rootHeight",
                    "rootWidth"
                ].forEach((o)=>{
                    void 0 === (null == t1 ? void 0 : t1[o]) && ("imageUrl" === o ? Object.assign(e, {
                        imageUrl: s.imageSrc
                    }) : Object.assign(e, {
                        [`${o}`]: s[o]
                    }));
                }), yw(e, i, n).then((t1)=>("object" == typeof t1 && null != t1 && t1.type && r(t1), r(Ug(e)), !0)).catch((e)=>Promise.reject({
                        type: Gl,
                        reason: e
                    }));
            }
            return Promise.reject({
                type: Gl,
                reason: "Cannot update mask"
            });
        })(this[iT], e);
    }
    stopPreviewVideoMask() {
        return ((e)=>{
            const { store: { getState: t1 }, mediaAgent: o } = e, { video: { mask: { isMaskConfigured: r } } } = t1();
            return r ? (o.stopMaskSetting(), Promise.resolve(!0)) : Promise.reject({
                type: Gl,
                reason: "Cannot stop preview mask before start"
            });
        })(this[iT]);
    }
    requestFarEndCameraControl(e) {
        return ((e, t1)=>{
            const { store: { getState: o }, rwgAgent: r } = e, i = o(), { meeting: { userId: n }, video: { farEndCameraControlStatus: { controlledUserList: s } } } = i;
            return n === t1 ? Promise.reject({
                type: Gl,
                reason: 'Using "stream.controlCamera" method to control self camera'
            }) : -1 !== QD(i).findIndex((e)=>e.userId === t1) ? (s.includes(t1) || r.sendFarEndCameraControl(Vd.Request, t1), Promise.resolve("")) : Promise.reject({
                type: Ql,
                reason: "Cannot request control camera with video off"
            });
        })(this[iT], e);
    }
    approveFarEndCameraControl(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, { video: { currentCameraControlStatus: { isRequested: n, isInControl: s, controllingUserId: a }, ptz: d, activeCamera: u } } = o();
            if (n) {
                if (s && (!a || t1 === a)) return Promise.resolve("");
                i.sendFarEndCameraControl(Vd.Approve, t1);
                const e = null == d ? void 0 : d[u];
                return void 0 !== e && i.sendCameraAblity({
                    pan: !!e.pan,
                    tilt: !!e.tilt,
                    zoom: !!e.zoom
                }), r(wg(!1)), r(Tg({
                    isInControl: !0,
                    userId: t1
                })), ep(wu, {
                    isControlled: !0,
                    userId: t1
                }), Promise.resolve("");
            }
            return Promise.reject({
                type: Gl,
                reason: "Cannot approve before request"
            });
        })(this[iT], e);
    }
    declineFarEndCameraControl(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, { video: { currentCameraControlStatus: { isInControl: n, isRequested: s } } } = o();
            return s || n ? (i.sendFarEndCameraControl(Vd.Decline, t1), r(wg(!1)), r(Tg({
                isInControl: !1,
                userId: 0
            })), ep(wu, {
                isControlled: !1
            }), Promise.resolve("")) : Promise.reject({
                type: Gl,
                reason: "Cannot decline before request"
            });
        })(this[iT], e);
    }
    giveUpFarEndCameraControl(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, { video: { farEndCameraControlStatus: { controlledUserList: n } } } = o();
            return n.includes(t1) ? (i.sendFarEndCameraControl(Vd.GiveUp, t1), r(Dg(t1)), Promise.resolve("")) : Promise.reject({
                type: Gl,
                reason: "Cannot give up control befire aquired"
            });
        })(this[iT], e);
    }
    controlCamera(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { video: { isCurrentUserStartedVideo: n, ptz: s, activeCamera: a } } = o();
            if (n) {
                const { cmd: e, range: o, reset: n } = t1, d = s[a];
                if (d) {
                    const t1 = iw(d) || {}, { key: s, range: u } = rw(e, o);
                    if (d[s]) return Object.assign(t1, {
                        [s]: n ? 0 : ow(d[s].capability, d[s].value, u)
                    }), i.movePTZCamera(t1).then(()=>{
                        r(Mg({
                            constraints: t1,
                            deviceId: a
                        }));
                    }).catch((e)=>Promise.reject({
                            type: Gl,
                            reason: e
                        }));
                }
                return Promise.resolve("");
            }
            return Promise.reject({
                type: Gl,
                reason: "Cannot control the camera before it's started"
            });
        })(this[iT], e);
    }
    controlFarEndCamera(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, n = o(), { video: { farEndCameraControlStatus: { controlledUserList: s, isControlling: a } } } = n, { userId: d, cmd: u, range: l } = t1;
            if (a) return Promise.reject({
                type: Gl,
                reason: "Cannot send new command while the previous control is not done"
            });
            if (s.includes(d)) {
                if (u === Ud.SwitchCamera) return i.sendFarEndCameraControl(Vd.SwitchCamera, d, Ud.SwitchCamera), Promise.resolve("");
                {
                    const e = QD(n).find((e)=>e.userId === d);
                    if (null == e || !e.nFECC) return Promise.reject({
                        type: Gl,
                        reason: "The far end camera does not support PTZ"
                    });
                    if (l && l > 0) {
                        const e = l / 100 * 1e4;
                        return i.sendFarEndCameraControl(Vd.StartControl, d, u), r(kg(!0)), Ze(200).pipe(ht(Qe(e - 100).pipe(it(1)))).subscribe(()=>{
                            i.sendFarEndCameraControl(Vd.ContinueControl, d, u);
                        }), Te(Qe(e).pipe(gt(()=>{
                            i.sendFarEndCameraControl(Vd.StopControl, d, u), r(kg(!1));
                        }))).then(()=>"");
                    }
                    return Promise.reject({
                        type: Ql,
                        reason: "Range cannot be negative or 0"
                    });
                }
            }
            return Promise.reject({
                type: Gl,
                reason: "Cannot control before request granted"
            });
        })(this[iT], e);
    }
    attachVideo(e, t1, o) {
        return ((e, t1, o, r)=>{
            const { store: { getState: i, dispatch: n }, rwgAgent: s } = e, a = i(), { meeting: { userId: d }, media: { enforceMultipleVideos: u, alternativeNameForVideoPlayer: l, enforceVirtualBackground: c, disableRenderLimits: p }, video: { videoAttachments: h, subscribedVideoList: m } } = a, g = ys(!!u, p);
            if (g > 1 && m.length > g) throw Promise.reject({
                type: Gl,
                reason: `subscribe video counts greater than maximum size (${g})`
            });
            if (-1 === JD(a).findIndex((e)=>e.userId === t1)) return Promise.reject({
                type: Ql,
                reason: "user is not send video"
            });
            const { media: { videoDecodeStatus: v } } = a;
            let f;
            const y = null != l ? l : "video-player";
            if (r) {
                var S, b;
                if ("string" == typeof r) {
                    if (f = document.querySelector(r), !f) return Promise.reject({
                        type: "INVALID_PARAMETERS",
                        reason: "Cannot find the element"
                    });
                } else f = r;
                if ((null === (S = f) || void 0 === S || null === (S = S.tagName) || void 0 === S ? void 0 : S.toUpperCase()) !== y.toUpperCase()) return Promise.reject({
                    type: "INVALID_PARAMETERS",
                    reason: "Invalid element type"
                });
                const e = Number(null !== (b = f.getAttribute("node-id")) && void 0 !== b ? b : "0");
                if (e !== t1 && sw(c) && [
                    e,
                    t1
                ].includes(d)) {
                    var E;
                    const t1 = document.createElement(y);
                    for (const e of f.attributes)t1.setAttribute(e.name, e.value);
                    e && (f.setAttribute("node-id", "0"), n(Gg({
                        userId: e,
                        element: f
                    }))), null === (E = f.parentElement) || void 0 === E || E.replaceChild(t1, f), f = t1;
                }
            } else f = document.createElement(y);
            return Ey("video", "success", v).subscribe(async (e)=>{
                let [r, a] = e;
                if (a) {
                    const [e, r] = aw(t1, o, i()), a = h[`${t1}`];
                    var u;
                    f && a && -1 !== a.findIndex((e)=>e === f) ? f.setAttribute("video-quality", `${r}`) : null === (u = f) || void 0 === u || u.setAttribute("node-id", `${t1}`), n(Wg({
                        userId: t1,
                        element: f
                    })), t1 !== d && s.subscribeVideo(t1, r, !1), m.includes(t1) || n(ug(t1)), n(hg({
                        userId: t1,
                        key: Dd,
                        canvasId: Md,
                        videoQuality: e,
                        aspectRatio: 16 / 9
                    }));
                }
            }), Promise.resolve(f);
        })(this[iT], e, t1, o);
    }
    detachVideo(e, t1) {
        return ((e, t1, o)=>{
            const { store: { getState: r, dispatch: i }, rwgAgent: n } = e, s = r(), { video: { subscribedVideoList: a, videoAttachments: d }, meeting: { userId: u }, media: { alternativeNameForVideoPlayer: l } } = s;
            if (a.includes(t1)) {
                let e;
                const s = null != l ? l : "video-player";
                var c;
                o && (e = "string" == typeof o ? document.querySelector(o) : o, (null === (c = e) || void 0 === c || null === (c = c.tagName) || void 0 === c ? void 0 : c.toUpperCase()) !== s.toUpperCase() && (e = void 0));
                const a = d[`${t1}`];
                let h;
                if (a && 0 !== a.length) {
                    var p;
                    e ? -1 !== a.findIndex((t1)=>t1 === e) ? (h = e, h.setAttribute("node-id", "0"), i(Gg({
                        userId: t1,
                        element: h
                    }))) : console.warn(`${o} has not been attached with userID:${t1}`) : (h = [
                        ...a
                    ], h.forEach((e)=>{
                        e.setAttribute("node-id", "0");
                    }), i(Gg({
                        userId: t1,
                        element: h
                    })));
                    const { video: { videoAttachments: s, renderedVideoList: d } } = r();
                    0 === (null === (p = s[`${t1}`]) || void 0 === p ? void 0 : p.length) && (0 === d.filter((e)=>e.userId === t1 && e.canvasId !== Md).length && (t1 !== u && n.unsubscribeVideo(t1), i(lg(t1))), i(mg({
                        userId: t1,
                        key: Dd,
                        canvasId: Md
                    })));
                } else console.warn(`UserId:${t1} has not been attached.`);
                return Promise.resolve(h);
            }
            return Promise.resolve(void 0);
        })(this[iT], e, t1);
    }
    spotlight(e, t1) {
        return ((e, t1, o)=>{
            const { store: { getState: r }, rwgAgent: i } = e, n = r(), { video: { spotlightUserList: s } } = n;
            return s.includes(t1) ? Promise.reject({
                type: Ql,
                reason: `userId:${t1} has already spotlighted`
            }) : -1 === JD(n).findIndex((e)=>e.userId === t1) ? Promise.reject({
                type: Ql,
                reason: `userId:${t1} has not started video`
            }) : (i.spotlightVideo(t1, {
                bReplace: o,
                bSpotlight: !0,
                bUnSpotlightAll: !1
            }), rp(gu, (e)=>{
                const { spotlightList: o } = e;
                return o.includes(t1);
            }));
        })(this[iT], e, t1);
    }
    removeSpotlight(e) {
        return ((e, t1)=>{
            const { store: { getState: o }, rwgAgent: r } = e, i = o(), { meeting: { userId: n }, video: { spotlightUserList: s } } = i, a = t1 || n, d = ch(i);
            if (!s.includes(a) || -1 === d.findIndex((e)=>e.userId === a)) return Promise.reject({
                type: Ql,
                reason: `userId:${t1} is not spotlighted`
            });
            const u = ah(i);
            if (s.length > 1 && a === n && !u) return Promise.reject({
                type: Gl,
                reason: "Cannot remove spotlight for self when the host has multiple spotlighted videos"
            });
            if (a !== n && !u) return Promise.reject({
                type: ql,
                reason: "only host or co-host can cancel others spotlight"
            });
            r.spotlightVideo(a, {
                bReplace: !1,
                bSpotlight: !1,
                bUnSpotlightAll: !1
            });
            const l = a === n && 1 === s.length ? Lu : gu;
            return rp(l, (e)=>{
                const { spotlightList: t1 } = e;
                return !t1.includes(a);
            });
        })(this[iT], e);
    }
    removeAllSpotlights() {
        return ((e)=>{
            const { store: { getState: t1 }, rwgAgent: o } = e, { video: { spotlightUserList: r } } = t1();
            return 0 === r.length ? Promise.resolve("") : (o.spotlightVideo(null, {
                bUnSpotlightAll: !0
            }), rp(gu, (e)=>{
                const { spotlightList: t1 } = e;
                return 0 === t1.length;
            }));
        })(this[iT]);
    }
    isCapturingVideo() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.video && o.video.isCurrentUserStartedVideo;
        })(this[iT]);
    }
    isCameraTaken() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.video && o.video.isCameraTaken;
        })(this[iT]);
    }
    isCaptureForbidden() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.video && o.video.isCaptureForbidden;
        })(this[iT]);
    }
    getCameraList() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            if (!o.video) return [];
            const { video: { cameraDevicesList: r } } = o;
            return r.map((e)=>Object.assign({}, e));
        })(this[iT]);
    }
    getActiveCamera() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.video ? o.video.activeCamera : "";
        })(this[iT]);
    }
    getActiveVideoId() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.video ? o.video.activeVideoId : 0;
        })(this[iT]);
    }
    getVideoMaxQuality() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.video ? o.video.receivedVideoMaxQuality : yd.Video_90P;
        })(this[iT]);
    }
    getReceivedVideoDimension() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.video ? o.video.receivedVideoDimension : null;
        })(this[iT]);
    }
    getCapturedVideoResolution() {
        return ((e)=>{
            const { store: { getState: t1 } } = e;
            return {
                ...t1().video.capturedVideoDimension
            };
        })(this[iT]);
    }
    isSupportMultipleVideos() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, { media: { enforceMultipleVideos: o } } = t1();
            return fs() || !!o && !ms.isSupportSharedArrayBuffer && ys(o) > 1;
        })(this[iT]);
    }
    isSupportHDVideo() {
        return ((e)=>{
            var t1;
            const { store: { getState: o } } = e;
            return null === (t1 = o().video) || void 0 === t1 ? void 0 : t1.isSupportHDVideo;
        })(this[iT]);
    }
    getHardwareAccelerationStatus() {
        return ((e)=>{
            var t1;
            const { store: { getState: o } } = e;
            return null === (t1 = o().video) || void 0 === t1 ? void 0 : t1.hardwareAcceleration;
        })(this[iT]);
    }
    getVideoStatisticData() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { video: { statistic: o } } = t1();
            return {
                ...o
            };
        })(this[iT]);
    }
    isSupportVirtualBackground() {
        return ((e)=>{
            const { store: { getState: t1 } } = e;
            return Py(t1().media.enforceVirtualBackground);
        })(this[iT]);
    }
    getVirtualbackgroundStatus() {
        return ((e)=>{
            const { store: { getState: t1 } } = e;
            return {
                ...t1().video.virtualBackground
            };
        })(this[iT]);
    }
    isRenderSelfViewWithVideoElement() {
        return sw(this[eT].getState().media.enforceVirtualBackground);
    }
    getNetworkQuality(e) {
        return ((e, t1)=>{
            var o;
            const { store: { getState: r } } = e, i = r(), { video: n, meeting: { userId: s } } = i, a = null != t1 ? t1 : s, d = null == n || null === (o = n.networkQuality) || void 0 === o ? void 0 : o[`${a}`];
            if (d) {
                const e = {};
                return d.uplink && Object.assign(e, {
                    uplink: d.uplink.level
                }), d.downlink && Object.assign(e, {
                    downlink: d.downlink.level
                }), e;
            }
            return null;
        })(this[iT], e);
    }
    getFarEndCameraPTZCapability(e) {
        return ((e, t1)=>{
            const { store: { getState: o } } = e, r = QD(o()).find((e)=>e.userId === t1);
            return void 0 !== (null == r ? void 0 : r.nFECC) ? nw(null == r ? void 0 : r.nFECC) : {
                pan: !1,
                tilt: !1,
                zoom: !1
            };
        })(this[iT], e);
    }
    getCameraPTZCapability(e) {
        return ((e, t1)=>{
            const { store: { getState: o } } = e, { video: { ptz: r, activeCamera: i } } = o(), n = r[null != t1 ? t1 : i];
            return {
                pan: !(null == n || !n.pan),
                tilt: !(null == n || !n.tilt),
                zoom: !(null == n || !n.zoom)
            };
        })(this[iT], e);
    }
    isBrowserSupportPTZ() {
        const { pan: e, tilt: t1, zoom: o } = la.getPTZCapability();
        return e || t1 || o;
    }
    getVideoMaskStatus() {
        return ((e)=>{
            var t1;
            const { store: { getState: o } } = e, r = o(), { isMaskConfigured: i, imageSrc: n, ...s } = (null === (t1 = r.video) || void 0 === t1 ? void 0 : t1.mask) || {};
            return {
                ...s,
                imageUrl: n
            };
        })(this[iT]);
    }
    isVideoMirrored() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, { video: { isMirrored: o } } = t1();
            return o;
        })(this[iT]);
    }
    getSpotlightedUserList() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            if (!o.video) return [];
            const { video: { spotlightUserList: r } } = o;
            return ch(o).filter((e)=>r.includes(e.userId)).map((e)=>fT(e));
        })(this[iT]);
    }
    getVideoMediaPlaybackController() {
        return ((e)=>{
            let { store: { getState: t1 }, mediaAgent: o } = e;
            const r = t1(), { video: { isUsingMediaPlayback: i } } = r;
            if (i) {
                const { videoElement: e } = $y.getInstance();
                return By(e, "video", r, o);
            }
            return null;
        })(this[iT]);
    }
    startShareView(e, t1, o) {
        return ((e, t1, o, r)=>{
            const { store: { getState: i, dispatch: n }, mediaAgent: s, rwgAgent: a } = e, { share: { isReceiveSharing: d, isRemoteSharingActive: u, activeNodeId: l, activeSsrc: c, status: p, renderedEnsuredCanvas: h, isReceiveSharingFromMainSession: m }, media: { sharingDecodeStatus: g } } = i();
            if (!t1 || o !== l) return Promise.reject({
                type: Ql,
                reason: ""
            });
            if (!u || d || p !== fd.End) return Promise.reject({
                type: Gl,
                reason: ""
            });
            t1.id || (t1.id = Xr("__ZOOM_SDK_SHARE_CANVAS_@__"));
            const v = !!r;
            return Ey("sharing", "success", g).subscribe((e)=>{
                let [, d] = e;
                if (d) {
                    let e = t1;
                    h.includes(t1.id) || (e = Ry(t1), n(km(t1.id))), n(mm(!0)), bE(a, i(), o), s.renderSharing(c, e, v, r, m), OE(o, i(), s);
                }
            }), "failed" === g ? Promise.reject({
                type: Kl,
                reason: ""
            }) : rp(Sl, (e)=>!!e, 6e4);
        })(this[iT], e, t1, o);
    }
    stopShareView() {
        return ((e)=>{
            const { store: { dispatch: t1, getState: o }, rwgAgent: r, mediaAgent: i } = e, { share: { isReceiveSharing: n, activeNodeId: s }, breakoutRoom: a } = o();
            if (!n) return Promise.resolve("");
            let d = !1;
            return (null == a ? void 0 : a.currentRoom.status) === Jp.InRoom && a.mainSessionAttendeeList.length > 0 && (d = a.mainSessionAttendeeList.findIndex((e)=>e.userId === s) > -1), i.stopRenderSharing(), r.unsubscribeSharing(s, d), t1(mm(!1)), Promise.resolve("");
        })(this[iT]);
    }
    switchShareView(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), { share: { isReceiveSharing: a, activeNodeId: d, isReceiveSharingFromMainSession: u, remoteControlledUserList: l, isGrabRemoteControl: c }, breakoutRoom: p } = s;
            if (!a) return Promise.reject({
                type: Gl
            });
            if (t1 === d) return Promise.resolve("");
            let h = [];
            return h = u ? p.mainSessionAttendeeList.filter((e)=>e.bShareToBORooms && e.sharerOn) : dS(s), h.findIndex((e)=>e.userId === d) > -1 ? (l.includes(d) && (c && i.subscribeGrabRemoteControl(d, !1), n.updateRemoteControlProperties({
                isControllerNow: !1
            })), i.unsubscribeSharing(d, u), bE(i, o(), t1), n.switchSharingSource(t1, u), l.includes(t1) && wE(t1, void 0, s, i, n), OE(t1, o(), n), r(hm({
                bStatus: 1,
                activeNodeID: t1,
                ssrc: t1
            })), ep(wl, {
                userId: t1
            }), Promise.resolve("")) : Promise.reject({
                type: Ql,
                reason: "no matching user id"
            });
        })(this[iT], e);
    }
    updateSharingCanvasDimension(e, t1) {
        return ((e, t1, o)=>{
            const { store: { getState: r }, mediaAgent: i } = e, n = r(), { share: { isReceiveSharing: s, isGrabRemoteControl: a, remoteControlViewportDomSelector: d } } = n;
            if (s && (i.updateRenderedSharingDimension(t1, o), a && d)) {
                const e = document.querySelector(d);
                i.updateRemoteControlProperties({
                    dimension: e && _y(e)
                });
            }
            return Promise.resolve("");
        })(this[iT], e, t1);
    }
    startShareScreen(e, t1) {
        return ((e, t1, o)=>{
            var r;
            const { store: { getState: i, dispatch: n }, mediaAgent: s } = e, a = i(), { meeting: { bIbDisableShare: d, meetingOptions: u }, share: { sharePrivilege: l, ssrc: c, isChromeExtensionInstalled: p, capturedEnsuredCanvas: h, isReceiveSharingFromMainSession: m }, media: { sharingEncodeStatus: g }, breakoutRoom: v } = a, { isSupportMediaStreamTrackProcessor: f, isLegacyChrome: y } = ms;
            if (d) return Promise.reject({
                type: Gl,
                reason: "information barrier"
            });
            if ("function" != typeof (null === (r = navigator.mediaDevices) || void 0 === r ? void 0 : r.getDisplayMedia)) return Promise.reject({
                type: Gl,
                reason: "Unable to share your screen due to the technical limitation"
            });
            if (m) return Promise.reject({
                type: Gl,
                reason: "Unable to share your screen while someone is sharing from the main session"
            });
            var S;
            if (f) {
                if (!(t1 instanceof HTMLVideoElement)) return Promise.reject({
                    type: Ql,
                    reason: "Use Video element instead of Canvas element when WebCodecs enabled"
                });
            } else if (!(t1 instanceof HTMLCanvasElement)) return Promise.reject({
                type: Ql,
                reason: `Expected to accept HTMLCanvasElement, but actual it is ${"object" == typeof t1 && null !== t1 ? null === (S = Object.getPrototypeOf(t1)) || void 0 === S ? void 0 : S.constructor.name : t1}`
            });
            const b = ah(a);
            if (null != o && o.broadcastToBreakoutRoom) {
                if (!b || (null == v ? void 0 : v.currentRoom.status) === Jp.InRoom) return b ? Promise.reject({
                    type: Gl,
                    reason: "Unable to share screen to breakout room when in the room"
                }) : Promise.reject({
                    type: ql
                });
                n(_m(!0));
            } else n(_m(!1));
            void 0 !== (null == o ? void 0 : o.requestReadReceipt) && n(Tm(null == o ? void 0 : o.requestReadReceipt)), void 0 !== (null == o ? void 0 : o.optimizedForSharedVideo) && l !== vd.MultipleShare && n(Om((null == o ? void 0 : o.optimizedForSharedVideo) && la.isSupportVideoShareSend()));
            const E = dS(a);
            if (l === vd.OnlyHost && !b) return Promise.reject({
                type: ql,
                reason: "only host can start screen share"
            });
            if (l === vd.HostGrab && !b && E.length > 0) return Promise.reject({
                type: ql,
                reason: "only host can grab screen share"
            });
            const I = sh(a);
            if (!0 === (null == I ? void 0 : I.sharerOn)) return Promise.reject({
                type: Gl,
                reason: "you have already started screen share."
            });
            let A = _e(!0);
            return y && !p && (s.checkChromeSharingExtension(), A = ip(vl, 1)), t1.id || (t1.id = Xr("__ZOOM_SDK_SELF_SHARE_CANVAS_@__")), $e([
                Ey("sharing", g, "success"),
                A
            ]).subscribe((e)=>{
                let [r, i] = e;
                const [a] = r;
                if (a && i) {
                    h.includes(t1.id) || (Ry(t1), n(Mm(t1.id)));
                    let e = document.querySelector(`#${Od}`);
                    e && "VIDEO" === e.tagName || (e = document.createElement("video"), e.id = Od, e.style.display = "none", document.body.appendChild(e));
                    const r = null != o && o.secondaryCameraId ? {
                        cameraId: o.secondaryCameraId,
                        width: o.captureWidth,
                        height: o.captureHeight
                    } : void 0, i = !(null != o && o.hideShareAudioOption);
                    s.startDesktopSharing(c, t1, e, r, null != u && u.isDisableShareAudioIntoBo ? i && !(null != o && o.broadcastToBreakoutRoom) : i, null == o ? void 0 : o.displaySurface, null == o ? void 0 : o.sourceId, null == o ? void 0 : o.controls), n(um(void 0)), n(Rm(!!r));
                }
            }), new Promise((e, t1)=>{
                ot(ip(pa).pipe(tt((e)=>void 0 !== e.sharerOn), it(1)), ip(vl).pipe(tt((e)=>!e), it(1), dt(Re({
                    reason: "required extension",
                    extensionUrl: "https://chrome.google.com/webstore/detail/zoom-scheduler/kgjfgplpablkjnlkjmjdecgdpfankdle"
                }))), ip(fl, 1).pipe(Be((e)=>Re({
                        reason: e.reason || "user deny screen share"
                    })))).subscribe((o)=>{
                    if (!0 === o.sharerOn) {
                        const { share: { isSharingToBreakoutRoom: t1 }, meeting: { meetingOptions: o } } = i(), r = !(null != o && o.isDisableShareAudioIntoBo || !t1);
                        s.enableShareAudioToBreakoutRoom(r), e("");
                    } else t1({
                        type: Kl
                    });
                }, (e)=>{
                    t1({
                        type: Gl,
                        ...e
                    });
                });
            });
        })(this[iT], e, t1);
    }
    stopShareScreen() {
        return ((e)=>{
            const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, { share: { status: n }, meeting: { userId: s } } = t1();
            return n === fd.End ? Promise.resolve("") : (o(ym(fd.End)), r.stopSharing(s), i.stopDesktopSharing(), rp(pa, (e)=>!1 === e.sharerOn));
        })(this[iT]);
    }
    pauseShareScreen() {
        return ((e)=>{
            const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, n = t1(), { share: { status: s }, breakoutRoom: a } = n;
            if (s === fd.Sharing) {
                if (r.pauseSharing(), i.pauseDesktopSharing(), a && IT(n)) {
                    const e = sh(n);
                    return Promise.resolve("").then(()=>{
                        if (e) {
                            const { userId: t1, sharerOn: r, bShareAudioOn: i, bVideoShare: n } = e, s = {
                                userId: t1,
                                sharerOn: r,
                                sharerPause: !0,
                                bShareAudioOn: i,
                                bVideoShare: n
                            };
                            o(Sp({
                                update: [
                                    s
                                ]
                            })), o(ym(fd.Paused)), ep(pa, s);
                        }
                    });
                }
                return rp(pa, (e)=>!0 === e.sharerPause).then(()=>(o(ym(fd.Paused)), ""));
            }
            return Promise.reject({
                type: Gl
            });
        })(this[iT]);
    }
    resumeShareScreen() {
        return ((e)=>{
            const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, n = t1(), { share: { status: s }, breakoutRoom: a } = n;
            if (s === fd.Paused) {
                if (r.resumeSharing(), i.resumeDesktopSharing(), a && IT(n)) {
                    const e = sh(n);
                    return Promise.resolve("").then(()=>{
                        if (e) {
                            const { userId: t1, sharerOn: r, bShareAudioOn: i, bVideoShare: n } = e, s = {
                                userId: t1,
                                sharerOn: r,
                                sharerPause: !1,
                                bShareAudioOn: i,
                                bVideoShare: n
                            };
                            o(Sp({
                                update: [
                                    s
                                ]
                            })), o(ym(fd.Sharing)), ep(pa, s);
                        }
                    });
                }
                return rp(pa, (e)=>!0 === e.sharerOn && !1 === e.sharerPause).then(()=>(o(ym(fd.Sharing)), ""));
            }
            return Promise.reject({
                type: Gl
            });
        })(this[iT]);
    }
    setSharePrivilege(e) {
        return qD(this[iT], e);
    }
    lockShare(e) {
        return ((e, t1)=>qD(e, t1 ? vd.OnlyHost : vd.HostGrab))(this[iT], e);
    }
    shareToBreakoutRoom() {
        return ((e)=>{
            const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, { meeting: { userId: n }, breakoutRoom: s, share: { isSharingToBreakoutRoom: a, status: d } } = t1();
            return d === fd.End ? Promise.reject({
                type: Gl,
                reason: "Invalid sharing status"
            }) : a ? Promise.resolve("") : s.currentRoom.status === Jp.InRoom ? Promise.reject({
                type: Gl,
                reason: "Unable to share screen to breakout room when in the room"
            }) : (r.startShareToBreakoutRoom(n), o(_m(!0)), i.enableShareAudioToBreakoutRoom(!0), Promise.resolve(""));
        })(this[iT]);
    }
    stopShareToBreakoutRoom() {
        return ((e)=>{
            const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, { meeting: { userId: n }, share: { isSharingToBreakoutRoom: s } } = t1();
            return s && (r.stopShareToBreakoutRoom(n), o(_m(!1)), i.enableShareAudioToBreakoutRoom(!1)), Promise.resolve("");
        })(this[iT]);
    }
    muteOthersScreenShare(e) {
        return ((e, t1)=>{
            const { store: { getState: o }, rwgAgent: r } = e, i = o(), { meeting: { userId: n } } = i, s = dS(i);
            return t1 === n ? Promise.reject({
                type: Gl,
                reason: "Cannot mute self share, use 'stopScreenShare' instead"
            }) : -1 === s.findIndex((e)=>e.userId === t1) ? Promise.reject({
                type: Ql,
                reason: "Target user is not sharing"
            }) : (r.stopSharing(t1), rp(ma, (e)=>e.some((e)=>e.userId === t1 && !1 === e.sharerOn)));
        })(this[iT], e);
    }
    enableOptimizeForSharedVideo(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i, rwgAgent: n } = e, { share: { status: s, isOptimizedForSharedVideo: a, isSharingToBreakoutRoom: d, sharePrivilege: u }, audio: { isSharingAudio: l }, meeting: { userId: c } } = o();
            return s !== fd.End ? a === t1 ? Promise.resolve("") : u !== vd.MultipleShare ? t1 && !la.isSupportVideoShareSend() ? Promise.reject({
                type: Gl,
                reason: "Cannot enable optimize for shared video due to the platform is not supported "
            }) : (n.startSharing(c, {
                bShareAudio: l,
                bShareToBO: d,
                bShareVideo: t1
            }), i.switchSharingMode(t1 ? Fd.VideoMode : Fd.Normal), rp({
                event: pa,
                operations: [
                    tt((e)=>void 0 !== e.bVideoShare),
                    it(1)
                ]
            }, (e)=>e.bVideoShare === t1).then(()=>(r(Om(t1)), ""))) : Promise.reject({
                type: Gl,
                reason: "Cannot enable optimize for shared video when enabling multiple screen shares"
            }) : Promise.reject({
                type: Gl,
                reason: "Cannot enable optimize for shared video when screen share is not started"
            });
        })(this[iT], e);
    }
    updateSharedVideoQuality(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, n = o(), { share: { shareQuality: s, activeNodeId: a, isReceiveSharing: d } } = n, u = uS(n);
            return d && 0 !== a ? (u && s !== t1 && (bE(i, n, a, t1), r(bm(t1))), Promise.resolve("")) : Promise.reject({
                type: Gl,
                reason: "Cannot update shared video quality when screen share is not started"
            });
        })(this[iT], e);
    }
    subscribeShareStatisticData(e) {
        return (async (e, t1)=>{
            const { mediaAgent: o, store: { getState: r } } = e, i = r(), { media: { sharingEncodeStatus: n, sharingDecodeStatus: s } } = r(), a = sh(i), d = !t1 || t1.decode, u = !t1 || t1.encode;
            if (!a) return Promise.reject({
                type: Gl,
                reason: "Call this function after the 'join' method resolved."
            });
            {
                const e = Gp(a.userRole) || !ms.isSupportSendScreenSharing ? "failed" : n;
                Ey("sharing", e, s).subscribe((e)=>{
                    let [t1, r] = e;
                    d && r && o.subscribeToQos([
                        da.SharingDecode
                    ], Td), u && t1 && o.subscribeToQos([
                        da.SharingEncode
                    ], Td);
                });
            }
            return "";
        })(this[iT], e);
    }
    unsubscribeShareStatisticData(e) {
        return (async (e, t1)=>{
            const { mediaAgent: o, store: { dispatch: r } } = e, i = !t1 || t1.decode, n = !t1 || t1.encode;
            return i && (o.unsubscribeFromQos([
                da.SharingDecode
            ]), r(Pm(Nd))), n && (o.unsubscribeFromQos([
                da.SharingEncode
            ]), r(Pm(Nd))), null;
        })(this[iT], e);
    }
    getShareUserList() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            if (!o.share) return [];
            const { share: { isReceiveSharingFromMainSession: r } } = o;
            if (r) {
                const { breakoutRoom: { mainSessionAttendeeList: e } } = o;
                return e.filter((e)=>e.bShareToBORooms && (e.sharerOn || e.sharerPause)).map((e)=>fT(e));
            }
            return dS(o).map((e)=>fT(e));
        })(this[iT]);
    }
    getActiveShareUserId() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.share && o.share.isRemoteSharingActive ? o.share.activeNodeId : 0;
        })(this[iT]);
    }
    isReceiveSharing() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.share && o.share.isReceiveSharing;
        })(this[iT]);
    }
    getShareViewDimension() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            if (o.share) {
                if (o.share.status !== fd.End) return {
                    ...o.share.shareDimension
                };
                {
                    const { share: { receivedShareDimension: e } } = o;
                    return {
                        width: e.width,
                        height: e.height
                    };
                }
            }
            return null;
        })(this[iT]);
    }
    getShareStatus() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.share ? o.share.status : null;
        })(this[iT]);
    }
    isShareLocked() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.share && o.share.sharePrivilege === vd.OnlyHost;
        })(this[iT]);
    }
    isReceiveSharingFromMainSession() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.share && o.share.isReceiveSharingFromMainSession;
        })(this[iT]);
    }
    getSharePrivilege() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.share ? o.share.sharePrivilege : null;
        })(this[iT]);
    }
    isStartShareScreenWithVideoElement() {
        return ms.isSupportMediaStreamTrackProcessor;
    }
    isOptimizeForSharedVideoEnabled() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.share && o.share.isOptimizedForSharedVideo;
        })(this[iT]);
    }
    isSupportOptimizedForSharedVideo() {
        return la.isSupportVideoShareSend();
    }
    getShareStatisticData() {
        return ((e)=>{
            let { store: { getState: t1 } } = e;
            const { share: { statistic: o } } = t1();
            return {
                ...o
            };
        })(this[iT]);
    }
    requestRemoteControl() {
        return ((e)=>{
            const { store: { getState: t1 }, rwgAgent: o } = e, { share: { isReceiveSharing: r, activeNodeId: i, isRemoteControlEnabled: n } } = t1();
            return n ? ZD(e, i) ? r ? lS(t1()) ? Promise.reject({
                type: Gl,
                reason: "Already get the approval"
            }) : (o.sharingRequestRemoteControl(i, !0), new Promise((e)=>{
                ip(Tl, 1).subscribe((t1)=>{
                    e(t1);
                });
            })) : Promise.reject({
                type: Gl,
                reason: "Cannot request control due to no sharing available"
            }) : Promise.reject({
                type: Ql
            }) : Promise.reject({
                type: Gl,
                reason: "Cannot request control due to the feature is not enabled."
            });
        })(this[iT]);
    }
    giveUpRemoteControl() {
        return ((e)=>{
            const { store: { getState: t1 }, rwgAgent: o } = e, { share: { isGrabRemoteControl: r, activeNodeId: i } } = t1();
            return lS(t1()) ? (r && o.subscribeGrabRemoteControl(i, !1), o.sharingRequestRemoteControl(i, !1), rp(Tl, (e)=>!1 === e)) : Promise.reject({
                type: Gl
            });
        })(this[iT]);
    }
    startRemoteControl(e) {
        return (async (e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i, rwgAgent: n } = e, { share: { isSDKGrabControl: s, activeNodeId: a } } = o();
            return lS(o()) ? (await wE(a, t1, o(), n, i), t1.dataset.zmrvId || t1.setAttribute("data-zmrv-id", Xr("__ZOOM_SDK_RC_VIEWPORT_DATA_ID_@__")), r(zm(`${t1.tagName}[data-zmrv-id="${t1.dataset.zmrvId}"]`)), s ? rp(Ol, (e)=>!!e) : op({
                success: Pl,
                fail: [
                    Ml
                ]
            })) : Promise.reject({
                type: Gl,
                reason: "required to be approved"
            });
        })(this[iT], e);
    }
    grabRemoteControl() {
        return ((e)=>{
            const { store: { getState: t1 }, rwgAgent: o } = e, { share: { isGrabRemoteControl: r, activeNodeId: i } } = t1();
            return lS(t1()) ? r ? Promise.resolve("") : (o.subscribeGrabRemoteControl(i, !0), rp(Ol, (e)=>!!e)) : Promise.reject({
                type: Gl,
                reason: "should be approved before grab"
            });
        })(this[iT]);
    }
    updateRemoteControlViewportDimension(e) {
        return ((e, t1)=>{
            const { store: { getState: o }, mediaAgent: r } = e;
            return lS(o()) && r.updateRemoteControlProperties({
                dimension: {
                    scaleWidth: t1.width,
                    scaleHeight: t1.height,
                    srcOffsetX: t1.left,
                    srcOffsetY: t1.top
                }
            }), Promise.resolve("");
        })(this[iT], e);
    }
    approveRemoteControl(e, t1) {
        return ((e, t1, o)=>{
            const { store: { getState: r, dispatch: i }, rwgAgent: n, mediaAgent: s } = e, a = r(), { share: { status: d, isEnableAutoDeleteRcApp: u, remoteControllingSsrc: l, userSsrcMapping: c }, meeting: { userId: p } } = a;
            if (d === fd.End) return Promise.reject({
                type: Gl,
                reason: "Cannot approve remote control when sharing is not ongoing."
            });
            if (d === fd.Paused && (n.resumeSharing(), s.resumeDesktopSharing(), i(ym(fd.Sharing))), s.isSharingEntireScreen()) {
                var h, m;
                l && !Zr(l, t1) && (RE(a, n), i(Hm("")));
                const e = null !== (h = c[`${t1}`]) && void 0 !== h ? h : t1, { isMacOS: r } = ms, d = null === (m = ch(a).find((t1)=>Zr(t1.userId, e))) || void 0 === m ? void 0 : m.displayName;
                return n.remoteControlConsent(Wd.Approve, e, p, {
                    ...s.getShareStreamInfo(),
                    platform: ms.isMacOS ? "mac" : "win",
                    controllerName: d ? Hr(d) : ""
                }, u, r ? void 0 : o ? 1 : 0), i(Vm(e)), rp(xl);
            }
            return Promise.reject({
                type: Gl,
                reason: "Cannot approve remote control when not sharing entire screen."
            });
        })(this[iT], e, t1);
    }
    declineRemoteControl(e) {
        return ((e, t1)=>{
            var o;
            const { store: { getState: r }, rwgAgent: i, mediaAgent: n } = e, s = r(), { meeting: { userId: a }, share: { isEnableAutoDeleteRcApp: d, userSsrcMapping: u } } = s, l = null !== (o = u[`${t1}`]) && void 0 !== o ? o : t1;
            return i.remoteControlConsent(Wd.Decline, l, a, {
                ...n.getShareStreamInfo(),
                platform: ms.isMacOS ? "mac" : "win"
            }, d), Promise.resolve("");
        })(this[iT], e);
    }
    stopRemoteControl() {
        return ((e)=>{
            const { store: { getState: t1, dispatch: o }, rwgAgent: r } = e;
            return RE(t1(), r), o(Hm("")), o(Vm(0)), Promise.resolve("");
        })(this[iT]);
    }
    launchRemoteControlApp(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r } } = e, i = o(), { share: { remoteControlAppLaunchSheme: n } } = i;
            return n ? (r(Hm(t1 ? `${n}&bAutoDelete=1` : n)), r(jm(Gd.Unknown)), Promise.resolve("")) : Promise.reject({
                type: Gl,
                reason: "Cannot launch app due to no permission"
            });
        })(this[iT], e);
    }
    isRemoteControlEnabled() {
        return ((e)=>{
            var t1;
            const { store: { getState: o } } = e;
            return !(null === (t1 = o().share) || void 0 === t1 || !t1.isRemoteControlEnabled);
        })(this[iT]);
    }
    getRemoteControlAppDownloadUrl() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return o.share ? o.share.remoteControlAppDownloadUrl : null;
        })(this[iT]);
    }
    isTargetShareSupportRemoteControl(e) {
        return ZD(this[iT], e);
    }
    isRemotelyControlApproved() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.share && lS(o);
        })(this[iT]);
    }
    isControllingUserRemotely() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            return !!o.share && o.share.isGrabRemoteControl;
        })(this[iT]);
    }
    getRemotelyControllingUser() {
        return ((e)=>{
            const { store: { getState: t1 } } = e, o = t1();
            if (o.share) {
                const { remoteControllingSsrc: e } = o.share;
                if (e) return ch(o).find((t1)=>Zr(t1.userId, e));
            }
            return null;
        })(this[iT]);
    }
}, Xw(RM.prototype, "startAudio", [
    nT,
    YD,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "startAudio"), RM.prototype), Xw(RM.prototype, "stopAudio", [
    nT,
    XD,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopAudio"), RM.prototype), Xw(RM.prototype, "muteAudio", [
    nT,
    eP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "muteAudio"), RM.prototype), Xw(RM.prototype, "unmuteAudio", [
    nT,
    tP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "unmuteAudio"), RM.prototype), Xw(RM.prototype, "dialOut", [
    nT,
    oP,
    rP
], Object.getOwnPropertyDescriptor(RM.prototype, "dialOut"), RM.prototype), Xw(RM.prototype, "cancelDialOut", [
    nT,
    iP,
    nP
], Object.getOwnPropertyDescriptor(RM.prototype, "cancelDialOut"), RM.prototype), Xw(RM.prototype, "hangup", [
    nT,
    sP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "hangup"), RM.prototype), Xw(RM.prototype, "switchMicrophone", [
    nT,
    aP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "switchMicrophone"), RM.prototype), Xw(RM.prototype, "switchSpeaker", [
    nT,
    dP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "switchSpeaker"), RM.prototype), Xw(RM.prototype, "muteShareAudio", [
    nT,
    uP,
    lP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "muteShareAudio"), RM.prototype), Xw(RM.prototype, "unmuteShareAudio", [
    nT,
    cP,
    pP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "unmuteShareAudio"), RM.prototype), Xw(RM.prototype, "subscribeAudioStatisticData", [
    nT,
    hP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "subscribeAudioStatisticData"), RM.prototype), Xw(RM.prototype, "unsubscribeAudioStatisticData", [
    nT,
    mP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "unsubscribeAudioStatisticData"), RM.prototype), Xw(RM.prototype, "enableBackgroundNoiseSuppression", [
    nT,
    gP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "enableBackgroundNoiseSuppression"), RM.prototype), Xw(RM.prototype, "enableSyncButtonsOnHeadset", [
    nT,
    vP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "enableSyncButtonsOnHeadset"), RM.prototype), Xw(RM.prototype, "enableOriginalSound", [
    nT,
    fP,
    wM
], Object.getOwnPropertyDescriptor(RM.prototype, "enableOriginalSound"), RM.prototype), Xw(RM.prototype, "callCRCDevice", [
    nT,
    yP,
    SP
], Object.getOwnPropertyDescriptor(RM.prototype, "callCRCDevice"), RM.prototype), Xw(RM.prototype, "cancelCallCRCDevice", [
    nT,
    bP,
    EP
], Object.getOwnPropertyDescriptor(RM.prototype, "cancelCallCRCDevice"), RM.prototype), Xw(RM.prototype, "muteAllAudio", [
    sT,
    nT,
    IP
], Object.getOwnPropertyDescriptor(RM.prototype, "muteAllAudio"), RM.prototype), Xw(RM.prototype, "unmuteAllAudio", [
    sT,
    nT,
    AP
], Object.getOwnPropertyDescriptor(RM.prototype, "unmuteAllAudio"), RM.prototype), Xw(RM.prototype, "muteAudioUponEntry", [
    sT,
    nT,
    CP
], Object.getOwnPropertyDescriptor(RM.prototype, "muteAudioUponEntry"), RM.prototype), Xw(RM.prototype, "startVideo", [
    nT,
    _P,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "startVideo"), RM.prototype), Xw(RM.prototype, "stopVideo", [
    nT,
    RP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopVideo"), RM.prototype), Xw(RM.prototype, "switchCamera", [
    nT,
    wP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "switchCamera"), RM.prototype), Xw(RM.prototype, "renderVideo", [
    kM,
    nT,
    TP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "renderVideo"), RM.prototype), Xw(RM.prototype, "stopRenderVideo", [
    NM,
    nT,
    OP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopRenderVideo"), RM.prototype), Xw(RM.prototype, "updateVideoCanvasDimension", [
    LM,
    nT,
    DP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "updateVideoCanvasDimension"), RM.prototype), Xw(RM.prototype, "adjustRenderedVideoPosition", [
    NM,
    nT,
    PP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "adjustRenderedVideoPosition"), RM.prototype), Xw(RM.prototype, "clearVideoCanvas", [
    LM,
    nT,
    MP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "clearVideoCanvas"), RM.prototype), Xw(RM.prototype, "mirrorVideo", [
    nT,
    kP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "mirrorVideo"), RM.prototype), Xw(RM.prototype, "enableHardwareAcceleration", [
    nT,
    LP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "enableHardwareAcceleration"), RM.prototype), Xw(RM.prototype, "subscribeVideoStatisticData", [
    nT,
    NP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "subscribeVideoStatisticData"), RM.prototype), Xw(RM.prototype, "unsubscribeVideoStatisticData", [
    nT,
    VP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "unsubscribeVideoStatisticData"), RM.prototype), Xw(RM.prototype, "previewVirtualBackground", [
    MM,
    nT,
    UP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "previewVirtualBackground"), RM.prototype), Xw(RM.prototype, "updateVirtualBackgroundImage", [
    nT,
    jP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "updateVirtualBackgroundImage"), RM.prototype), Xw(RM.prototype, "stopPreviewVirtualBackground", [
    nT,
    xP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopPreviewVirtualBackground"), RM.prototype), Xw(RM.prototype, "previewVideoMask", [
    MM,
    nT,
    BP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "previewVideoMask"), RM.prototype), Xw(RM.prototype, "updateVideoMask", [
    nT,
    FP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "updateVideoMask"), RM.prototype), Xw(RM.prototype, "stopPreviewVideoMask", [
    nT,
    HP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopPreviewVideoMask"), RM.prototype), Xw(RM.prototype, "requestFarEndCameraControl", [
    nT,
    $P,
    DM
], Object.getOwnPropertyDescriptor(RM.prototype, "requestFarEndCameraControl"), RM.prototype), Xw(RM.prototype, "approveFarEndCameraControl", [
    nT,
    WP,
    DM
], Object.getOwnPropertyDescriptor(RM.prototype, "approveFarEndCameraControl"), RM.prototype), Xw(RM.prototype, "declineFarEndCameraControl", [
    nT,
    GP,
    DM
], Object.getOwnPropertyDescriptor(RM.prototype, "declineFarEndCameraControl"), RM.prototype), Xw(RM.prototype, "giveUpFarEndCameraControl", [
    nT,
    KP,
    DM
], Object.getOwnPropertyDescriptor(RM.prototype, "giveUpFarEndCameraControl"), RM.prototype), Xw(RM.prototype, "controlCamera", [
    nT,
    zP,
    DM
], Object.getOwnPropertyDescriptor(RM.prototype, "controlCamera"), RM.prototype), Xw(RM.prototype, "controlFarEndCamera", [
    nT,
    qP,
    DM
], Object.getOwnPropertyDescriptor(RM.prototype, "controlFarEndCamera"), RM.prototype), Xw(RM.prototype, "attachVideo", [
    nT,
    JP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "attachVideo"), RM.prototype), Xw(RM.prototype, "detachVideo", [
    nT,
    QP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "detachVideo"), RM.prototype), Xw(RM.prototype, "spotlight", [
    sT,
    nT,
    ZP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "spotlight"), RM.prototype), Xw(RM.prototype, "removeSpotlight", [
    nT,
    YP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "removeSpotlight"), RM.prototype), Xw(RM.prototype, "removeAllSpotlights", [
    aT,
    nT,
    XP,
    TM
], Object.getOwnPropertyDescriptor(RM.prototype, "removeAllSpotlights"), RM.prototype), Xw(RM.prototype, "startShareView", [
    MM,
    nT,
    eM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "startShareView"), RM.prototype), Xw(RM.prototype, "stopShareView", [
    nT,
    tM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopShareView"), RM.prototype), Xw(RM.prototype, "switchShareView", [
    nT,
    oM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "switchShareView"), RM.prototype), Xw(RM.prototype, "updateSharingCanvasDimension", [
    nT,
    rM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "updateSharingCanvasDimension"), RM.prototype), Xw(RM.prototype, "startShareScreen", [
    nT,
    iM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "startShareScreen"), RM.prototype), Xw(RM.prototype, "stopShareScreen", [
    nT,
    nM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopShareScreen"), RM.prototype), Xw(RM.prototype, "pauseShareScreen", [
    nT,
    sM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "pauseShareScreen"), RM.prototype), Xw(RM.prototype, "resumeShareScreen", [
    nT,
    aM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "resumeShareScreen"), RM.prototype), Xw(RM.prototype, "setSharePrivilege", [
    sT,
    dM,
    nT,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "setSharePrivilege"), RM.prototype), Xw(RM.prototype, "lockShare", [
    sT,
    uM,
    nT,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "lockShare"), RM.prototype), Xw(RM.prototype, "shareToBreakoutRoom", [
    nT,
    sT,
    lM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "shareToBreakoutRoom"), RM.prototype), Xw(RM.prototype, "stopShareToBreakoutRoom", [
    nT,
    sT,
    cM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopShareToBreakoutRoom"), RM.prototype), Xw(RM.prototype, "muteOthersScreenShare", [
    nT,
    sT,
    pM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "muteOthersScreenShare"), RM.prototype), Xw(RM.prototype, "enableOptimizeForSharedVideo", [
    nT,
    hM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "enableOptimizeForSharedVideo"), RM.prototype), Xw(RM.prototype, "updateSharedVideoQuality", [
    nT,
    mM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "updateSharedVideoQuality"), RM.prototype), Xw(RM.prototype, "subscribeShareStatisticData", [
    nT,
    gM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "subscribeShareStatisticData"), RM.prototype), Xw(RM.prototype, "unsubscribeShareStatisticData", [
    nT,
    vM,
    OM
], Object.getOwnPropertyDescriptor(RM.prototype, "unsubscribeShareStatisticData"), RM.prototype), Xw(RM.prototype, "requestRemoteControl", [
    nT,
    fM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "requestRemoteControl"), RM.prototype), Xw(RM.prototype, "giveUpRemoteControl", [
    nT,
    yM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "giveUpRemoteControl"), RM.prototype), Xw(RM.prototype, "startRemoteControl", [
    nT,
    SM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "startRemoteControl"), RM.prototype), Xw(RM.prototype, "grabRemoteControl", [
    nT,
    bM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "grabRemoteControl"), RM.prototype), Xw(RM.prototype, "updateRemoteControlViewportDimension", [
    nT,
    EM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "updateRemoteControlViewportDimension"), RM.prototype), Xw(RM.prototype, "approveRemoteControl", [
    nT,
    IM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "approveRemoteControl"), RM.prototype), Xw(RM.prototype, "declineRemoteControl", [
    nT,
    AM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "declineRemoteControl"), RM.prototype), Xw(RM.prototype, "stopRemoteControl", [
    nT,
    CM,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "stopRemoteControl"), RM.prototype), Xw(RM.prototype, "launchRemoteControlApp", [
    nT,
    _M,
    PM
], Object.getOwnPropertyDescriptor(RM.prototype, "launchRemoteControlApp"), RM.prototype), RM);
var UM, jM, xM, BM, FM, HM, $M, WM, GM;
const KM = hT("Audio"), zM = hT("Sharing");
let qM = (UM = dT("share"), jM = dT("audio"), xM = dT("audio"), BM = dT("audio"), FM = dT("audio"), HM = dT("audio"), $M = dT("audio"), WM = dT("audio"), GM = class extends VM {
    switchSharingSecondaryCamera(e) {
        return ((e, t1)=>{
            const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { video: { cameraDevicesList: s }, share: { status: a, isSharingWithSecondCamera: d } } = n;
            return "default" !== t1 && -1 === s.map((e)=>e.deviceId).indexOf(t1) ? Promise.reject({
                type: Ql,
                reason: "Cannot find cameraDeviceId in camera devices list."
            }) : (a === fd.Sharing && d && i.changeSharingSecondCamera(t1), r(wm(t1)), Promise.resolve());
        })(this[iT], e);
    }
    muteUserAudioLocally(e) {
        return ((e, t1)=>{
            const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, n = r(), { audio: { locallyMutedAudioList: s } } = n, a = ch(n).filter((e)=>e.audio === $d.Computer);
            return s.includes(t1) || -1 === a.findIndex((e)=>e.userId === t1) || (o.muteOrUnmuteOtherAudio(t1, !0), i(qh(t1))), Promise.resolve("");
        })(this[iT], e);
    }
    unmuteUserAudioLocally(e) {
        return ((e, t1)=>{
            const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { audio: { locallyMutedAudioList: n } } = r();
            return n.includes(t1) ? (o.muteOrUnmuteOtherAudio(t1, !1), i(Jh(t1)), Promise.resolve("")) : Promise.resolve("");
        })(this[iT], e);
    }
    adjustUserAudioVolumeLocally(e, t1) {
        return ((e, t1, o)=>{
            const { mediaAgent: r, store: { getState: i, dispatch: n } } = e, s = i();
            return -1 !== ch(s).findIndex((e)=>e.userId === t1) && (r.adjustOtherAudioVolume(t1, o), n(Qh({
                userId: t1,
                volume: o
            }))), Promise.resolve("");
        })(this[iT], e, t1);
    }
    muteAllUserAudioLocally() {
        return ((e)=>{
            const { mediaAgent: t1, store: { getState: o, dispatch: r } } = e, { audio: { isStopAllImcomingAudio: i } } = o();
            return i || (t1.stopAllIncomingAudio(!0), r(om(!0))), Promise.resolve("");
        })(this[iT]);
    }
    unmuteAllUserAudioLocally() {
        return ((e)=>{
            const { mediaAgent: t1, store: { getState: o, dispatch: r } } = e, { audio: { isStopAllImcomingAudio: i, locallyMutedAudioList: n } } = o();
            return i && (t1.stopAllIncomingAudio(!1), r(om(!1)), n.length > 0 && n.forEach((e)=>{
                t1.muteOrUnmuteOtherAudio(e, !1), r(Jh(e));
            })), Promise.resolve("");
        })(this[iT]);
    }
    startSecondaryAudio(e, t1) {
        return (async (e, t1, o)=>{
            const { mediaAgent: r, rwgAgent: i, store: { getState: n, dispatch: s } } = e, a = n(), { audio: { microphoneDevicesList: d, activeMicrophone: u }, share: { status: l } } = a, c = sh(a);
            if (!la.isSupportShare2ndAudioDevice(gs())) return Promise.reject({
                type: Gl,
                reason: "Cannot start secondary audio due to platform is not supported"
            });
            if ((null == c ? void 0 : c.audio) === $d.Computer && u === t1) return Promise.reject({
                type: Gl,
                reason: "Cannot start secondary audio with the same microphone"
            });
            if (l !== fd.End) return Promise.reject({
                type: Gl,
                reason: "Cannot start secondary audio while screen sharing is in progress"
            });
            let p = d;
            if (0 === d.length) {
                const { microphones: e } = await Te(Cy());
                p = e;
            }
            return t1 && -1 === p.findIndex((e)=>e.deviceId === t1) ? Promise.reject({
                type: Ql,
                reason: "Cannot find the microphone"
            }) : (i.muteShareAudio(!1, !0), r.share2ndAudio(t1, o), s(um(t1)), rp(al));
        })(this[iT], e, t1);
    }
    stopSecondaryAudio() {
        return (async (e)=>{
            const { mediaAgent: t1, rwgAgent: o, store: { getState: r, dispatch: i } } = e, n = r(), { audio: { secondaryAudioMicrophoneId: s } } = n;
            if (!s) return Promise.reject({
                type: Gl,
                reason: "Cannot stop secondary audio due to not started "
            });
            o.muteShareAudio(!0, !0), t1.leaveSharingAudio(!1), i(um(void 0));
        })(this[iT]);
    }
    isUserAudioMutedLocally(e) {
        return ((e, t1)=>{
            let { store: { getState: o } } = e;
            const { audio: { locallyMutedAudioList: r } } = o();
            return r.includes(t1);
        })(this[iT], e);
    }
    getUserVolumeLocally(e) {
        return ((e, t1)=>{
            var o, r;
            let { store: { getState: i } } = e;
            const { audio: { localUserAudioVolumeList: n, locallyMutedAudioList: s } } = i();
            return null !== (o = null === (r = n.find((e)=>e.userId === t1)) || void 0 === r ? void 0 : r.volume) && void 0 !== o ? o : s.includes(t1) ? 0 : 100;
        })(this[iT], e);
    }
}, Xw(GM.prototype, "switchSharingSecondaryCamera", [
    nT,
    UM,
    zM
], Object.getOwnPropertyDescriptor(GM.prototype, "switchSharingSecondaryCamera"), GM.prototype), Xw(GM.prototype, "muteUserAudioLocally", [
    nT,
    jM,
    KM
], Object.getOwnPropertyDescriptor(GM.prototype, "muteUserAudioLocally"), GM.prototype), Xw(GM.prototype, "unmuteUserAudioLocally", [
    nT,
    xM,
    KM
], Object.getOwnPropertyDescriptor(GM.prototype, "unmuteUserAudioLocally"), GM.prototype), Xw(GM.prototype, "adjustUserAudioVolumeLocally", [
    nT,
    BM,
    KM
], Object.getOwnPropertyDescriptor(GM.prototype, "adjustUserAudioVolumeLocally"), GM.prototype), Xw(GM.prototype, "muteAllUserAudioLocally", [
    nT,
    FM,
    KM
], Object.getOwnPropertyDescriptor(GM.prototype, "muteAllUserAudioLocally"), GM.prototype), Xw(GM.prototype, "unmuteAllUserAudioLocally", [
    nT,
    HM,
    KM
], Object.getOwnPropertyDescriptor(GM.prototype, "unmuteAllUserAudioLocally"), GM.prototype), Xw(GM.prototype, "startSecondaryAudio", [
    nT,
    $M,
    KM
], Object.getOwnPropertyDescriptor(GM.prototype, "startSecondaryAudio"), GM.prototype), Xw(GM.prototype, "stopSecondaryAudio", [
    nT,
    WM,
    KM
], Object.getOwnPropertyDescriptor(GM.prototype, "stopSecondaryAudio"), GM.prototype), GM);
const JM = {
    controlStatus: zp.NotStarted,
    sequenceId: 1,
    rooms: [],
    isHugeBO: !1,
    allocationPattern: Kp.Automatically,
    currentRoom: {
        status: Jp.Initial,
        boStatus: qp.NoToken,
        boConfId: "",
        boId: "",
        name: "",
        boToken: ""
    },
    options: {
        isAutoJoinRoom: !1,
        isBackToMainSessionEnabled: !0,
        isTimerEnabled: !1,
        timerDuration: 1800,
        isTimerAutoEnabled: !1,
        waitSeconds: 60,
        isAutoMovetoMainSession: !1,
        isRoomSelectionEnabled: !1
    },
    mainSessionAttendeeList: [],
    preAssignedRooms: [],
    meetingElapsedTime: 0,
    startRoomElapsedTime: 0,
    closingRoomTime: 0,
    broadcastMessage: "",
    hostReplyToQuestionerType: void 0,
    hostReplyToRequestId: void 0,
    isUserRoleUpdated: !1,
    mainSessionConfId: "",
    isEnableBOBroadcast: !1,
    isEnableBreakoutRoom: !1,
    isEnableBOViewActivityStatus: !1,
    inRoomUserActivityStatusMap: {},
    isEnableBOBroadcastVoice: !1,
    isBroadcastVoice: !1
}, QM = So({
    [`${Fv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        Array.isArray(o) ? e.rooms.push(...o) : e.rooms.push(o);
    }),
    [`${Hv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.allocationPattern = o;
    }),
    [`${$v}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.sequenceId = o;
    }),
    [`${Wv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.meetingElapsedTime = o;
    }),
    [`${Gv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.startRoomElapsedTime = o;
    }),
    [`${Kv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { options: r } = e;
        Object.assign(r, o);
    }),
    [`${zv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.controlStatus = o;
    }),
    [`${qv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.rooms = o;
    }),
    [`${Jv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { currentRoom: r } = e;
        Object.assign(r, o);
    }),
    [`${Qv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { currentRoom: r } = e;
        r.status = o;
    }),
    [`${Zv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { currentRoom: r } = e;
        r.boConfId = o;
    }),
    [`${Yv}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { currentRoom: r } = e;
        r.boToken = o;
    }),
    [`${ef}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.closingRoomTime = o;
    }),
    [`${tf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.broadcastMessage = o;
    }),
    [`${of}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.hostReplyToQuestionerType = o;
    }),
    [`${rf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.hostReplyToRequestId = o;
    }),
    [`${nf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        void 0 !== o.add && o.add.length > 0 && o.add.forEach((t1)=>{
            const o = e.mainSessionAttendeeList.find((e)=>e.userId === t1.userId);
            void 0 !== o ? Object.assign(o, t1) : Wp(t1.userRole) || e.mainSessionAttendeeList.push(t1);
        }), void 0 !== o.update && o.update.length > 0 && o.update.forEach((t1)=>{
            const o = e.mainSessionAttendeeList.find((e)=>e.userId === t1.userId);
            void 0 !== o && Object.assign(o, t1);
        }), void 0 !== o.remove && o.remove.length > 0 && o.remove.forEach((t1)=>{
            const o = e.mainSessionAttendeeList.findIndex((e)=>e.userId === t1.userId);
            -1 !== o && e.mainSessionAttendeeList.splice(o, 1);
        });
    }),
    [`${sf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isHugeBO = o;
    }),
    [`${df}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isUserRoleUpdated = o;
    }),
    [`${af}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.preAssignedRooms = o;
    }),
    [`${uf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isEnableBreakoutRoom = o.isEnableBreakoutRoom, e.isEnableBOBroadcast = o.isEnableBOBroadcast, e.isEnableBOViewActivityStatus = o.isEnableBOViewActivityStatus, e.isEnableBOBroadcastVoice = o.isEnableBOBroadcastVoice;
    }),
    [`${lf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { userGuid: r, status: i } = o, { inRoomUserActivityStatusMap: n } = e;
        n[`${r}`] = i;
    }),
    [`${cf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isBroadcastVoice = o;
    }),
    [`${Xv}`]: (e)=>{
        const { currentRoom: { status: t1 } } = e;
        return t1 === Jp.Joining ? {
            ...JM,
            preAssignedRooms: e.preAssignedRooms,
            currentRoom: e.currentRoom,
            closingRoomTime: e.closingRoomTime
        } : t1 === Jp.Leaving ? {
            ...JM,
            preAssignedRooms: e.preAssignedRooms,
            closingRoomTime: e.closingRoomTime
        } : {
            ...JM,
            preAssignedRooms: e.preAssignedRooms
        };
    }
}, JM);
var ZM = Uint8Array, YM = Uint16Array, XM = Uint32Array, ek = new ZM([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    0,
    0,
    0
]), tk = new ZM([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    0,
    0
]), ok = new ZM([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]), rk = function(e, t1) {
    for(var o = new YM(31), r = 0; r < 31; ++r)o[r] = t1 += 1 << e[r - 1];
    var i = new XM(o[30]);
    for(r = 1; r < 30; ++r)for(var n = o[r]; n < o[r + 1]; ++n)i[n] = n - o[r] << 5 | r;
    return [
        o,
        i
    ];
}, ik = rk(ek, 2), nk = ik[0], sk = ik[1];
nk[28] = 258, sk[258] = 28;
for(var ak = rk(tk, 0), dk = ak[0], uk = ak[1], lk = new YM(32768), ck = 0; ck < 32768; ++ck){
    var pk = (43690 & ck) >>> 1 | (21845 & ck) << 1;
    pk = (61680 & (pk = (52428 & pk) >>> 2 | (13107 & pk) << 2)) >>> 4 | (3855 & pk) << 4, lk[ck] = ((65280 & pk) >>> 8 | (255 & pk) << 8) >>> 1;
}
var hk = function(e, t1, o) {
    for(var r = e.length, i = 0, n = new YM(t1); i < r; ++i)e[i] && ++n[e[i] - 1];
    var s, a = new YM(t1);
    for(i = 0; i < t1; ++i)a[i] = a[i - 1] + n[i - 1] << 1;
    if (o) {
        s = new YM(1 << t1);
        var d = 15 - t1;
        for(i = 0; i < r; ++i)if (e[i]) for(var u = i << 4 | e[i], l = t1 - e[i], c = a[e[i] - 1]++ << l, p = c | (1 << l) - 1; c <= p; ++c)s[lk[c] >>> d] = u;
    } else for(s = new YM(r), i = 0; i < r; ++i)e[i] && (s[i] = lk[a[e[i] - 1]++] >>> 15 - e[i]);
    return s;
}, mk = new ZM(288);
for(ck = 0; ck < 144; ++ck)mk[ck] = 8;
for(ck = 144; ck < 256; ++ck)mk[ck] = 9;
for(ck = 256; ck < 280; ++ck)mk[ck] = 7;
for(ck = 280; ck < 288; ++ck)mk[ck] = 8;
var gk = new ZM(32);
for(ck = 0; ck < 32; ++ck)gk[ck] = 5;
var vk = hk(mk, 9, 0), fk = hk(mk, 9, 1), yk = hk(gk, 5, 0), Sk = hk(gk, 5, 1), bk = function(e) {
    for(var t1 = e[0], o = 1; o < e.length; ++o)e[o] > t1 && (t1 = e[o]);
    return t1;
}, Ek = function(e, t1, o) {
    var r = t1 / 8 | 0;
    return (e[r] | e[r + 1] << 8) >> (7 & t1) & o;
}, Ik = function(e, t1) {
    var o = t1 / 8 | 0;
    return (e[o] | e[o + 1] << 8 | e[o + 2] << 16) >> (7 & t1);
}, Ak = function(e) {
    return (e + 7) / 8 | 0;
}, Ck = function(e, t1, o) {
    (null == t1 || t1 < 0) && (t1 = 0), (null == o || o > e.length) && (o = e.length);
    var r = new (2 == e.BYTES_PER_ELEMENT ? YM : 4 == e.BYTES_PER_ELEMENT ? XM : ZM)(o - t1);
    return r.set(e.subarray(t1, o)), r;
}, _k = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
], Rk = function(e, t1, o) {
    var r = new Error(t1 || _k[e]);
    if (r.code = e, Error.captureStackTrace && Error.captureStackTrace(r, Rk), !o) throw r;
    return r;
}, wk = function(e, t1, o) {
    o <<= 7 & t1;
    var r = t1 / 8 | 0;
    e[r] |= o, e[r + 1] |= o >>> 8;
}, Tk = function(e, t1, o) {
    o <<= 7 & t1;
    var r = t1 / 8 | 0;
    e[r] |= o, e[r + 1] |= o >>> 8, e[r + 2] |= o >>> 16;
}, Ok = function(e, t1) {
    for(var o = [], r = 0; r < e.length; ++r)e[r] && o.push({
        s: r,
        f: e[r]
    });
    var i = o.length, n = o.slice();
    if (!i) return [
        Vk,
        0
    ];
    if (1 == i) {
        var s = new ZM(o[0].s + 1);
        return s[o[0].s] = 1, [
            s,
            1
        ];
    }
    o.sort(function(e, t1) {
        return e.f - t1.f;
    }), o.push({
        s: -1,
        f: 25001
    });
    var a = o[0], d = o[1], u = 0, l = 1, c = 2;
    for(o[0] = {
        s: -1,
        f: a.f + d.f,
        l: a,
        r: d
    }; l != i - 1;)a = o[o[u].f < o[c].f ? u++ : c++], d = o[u != l && o[u].f < o[c].f ? u++ : c++], o[l++] = {
        s: -1,
        f: a.f + d.f,
        l: a,
        r: d
    };
    var p = n[0].s;
    for(r = 1; r < i; ++r)n[r].s > p && (p = n[r].s);
    var h = new YM(p + 1), m = Dk(o[l - 1], h, 0);
    if (m > t1) {
        r = 0;
        var g = 0, v = m - t1, f = 1 << v;
        for(n.sort(function(e, t1) {
            return h[t1.s] - h[e.s] || e.f - t1.f;
        }); r < i; ++r){
            var y = n[r].s;
            if (!(h[y] > t1)) break;
            g += f - (1 << m - h[y]), h[y] = t1;
        }
        for(g >>>= v; g > 0;){
            var S = n[r].s;
            h[S] < t1 ? g -= 1 << t1 - h[S]++ - 1 : ++r;
        }
        for(; r >= 0 && g; --r){
            var b = n[r].s;
            h[b] == t1 && (--h[b], ++g);
        }
        m = t1;
    }
    return [
        new ZM(h),
        m
    ];
}, Dk = function(e, t1, o) {
    return -1 == e.s ? Math.max(Dk(e.l, t1, o + 1), Dk(e.r, t1, o + 1)) : t1[e.s] = o;
}, Pk = function(e) {
    for(var t1 = e.length; t1 && !e[--t1];);
    for(var o = new YM(++t1), r = 0, i = e[0], n = 1, s = function(e) {
        o[r++] = e;
    }, a = 1; a <= t1; ++a)if (e[a] == i && a != t1) ++n;
    else {
        if (!i && n > 2) {
            for(; n > 138; n -= 138)s(32754);
            n > 2 && (s(n > 10 ? n - 11 << 5 | 28690 : n - 3 << 5 | 12305), n = 0);
        } else if (n > 3) {
            for(s(i), --n; n > 6; n -= 6)s(8304);
            n > 2 && (s(n - 3 << 5 | 8208), n = 0);
        }
        for(; n--;)s(i);
        n = 1, i = e[a];
    }
    return [
        o.subarray(0, r),
        t1
    ];
}, Mk = function(e, t1) {
    for(var o = 0, r = 0; r < t1.length; ++r)o += e[r] * t1[r];
    return o;
}, kk = function(e, t1, o) {
    var r = o.length, i = Ak(t1 + 2);
    e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];
    for(var n = 0; n < r; ++n)e[i + n + 4] = o[n];
    return 8 * (i + 4 + r);
}, Lk = function(e, t1, o, r, i, n, s, a, d, u, l) {
    wk(t1, l++, o), ++i[256];
    for(var c = Ok(i, 15), p = c[0], h = c[1], m = Ok(n, 15), g = m[0], v = m[1], f = Pk(p), y = f[0], S = f[1], b = Pk(g), E = b[0], I = b[1], A = new YM(19), C = 0; C < y.length; ++C)A[31 & y[C]]++;
    for(C = 0; C < E.length; ++C)A[31 & E[C]]++;
    for(var _ = Ok(A, 7), R = _[0], w = _[1], T = 19; T > 4 && !R[ok[T - 1]]; --T);
    var O, D, P, M, k = u + 5 << 3, L = Mk(i, mk) + Mk(n, gk) + s, N = Mk(i, p) + Mk(n, g) + s + 14 + 3 * T + Mk(A, R) + (2 * A[16] + 3 * A[17] + 7 * A[18]);
    if (k <= L && k <= N) return kk(t1, l, e.subarray(d, d + u));
    if (wk(t1, l, 1 + (N < L)), l += 2, N < L) {
        O = hk(p, h, 0), D = p, P = hk(g, v, 0), M = g;
        var V = hk(R, w, 0);
        for(wk(t1, l, S - 257), wk(t1, l + 5, I - 1), wk(t1, l + 10, T - 4), l += 14, C = 0; C < T; ++C)wk(t1, l + 3 * C, R[ok[C]]);
        l += 3 * T;
        for(var U = [
            y,
            E
        ], j = 0; j < 2; ++j){
            var x = U[j];
            for(C = 0; C < x.length; ++C){
                var B = 31 & x[C];
                wk(t1, l, V[B]), l += R[B], B > 15 && (wk(t1, l, x[C] >>> 5 & 127), l += x[C] >>> 12);
            }
        }
    } else O = vk, D = mk, P = yk, M = gk;
    for(C = 0; C < a; ++C)if (r[C] > 255) {
        B = r[C] >>> 18 & 31, Tk(t1, l, O[B + 257]), l += D[B + 257], B > 7 && (wk(t1, l, r[C] >>> 23 & 31), l += ek[B]);
        var F = 31 & r[C];
        Tk(t1, l, P[F]), l += M[F], F > 3 && (Tk(t1, l, r[C] >>> 5 & 8191), l += tk[F]);
    } else Tk(t1, l, O[r[C]]), l += D[r[C]];
    return Tk(t1, l, O[256]), l + D[256];
}, Nk = new XM([
    65540,
    131080,
    131088,
    131104,
    262176,
    1048704,
    1048832,
    2114560,
    2117632
]), Vk = new ZM(0), Uk = function() {
    for(var e = new Int32Array(256), t1 = 0; t1 < 256; ++t1){
        for(var o = t1, r = 9; --r;)o = (1 & o && -306674912) ^ o >>> 1;
        e[t1] = o;
    }
    return e;
}(), jk = function(e, t1, o) {
    for(; o; ++t1)e[t1] = o, o >>>= 8;
};
function xk(e, t1) {
    t1 || (t1 = {});
    var o = function() {
        var e = -1;
        return {
            p: function(t1) {
                for(var o = e, r = 0; r < t1.length; ++r)o = Uk[255 & o ^ t1[r]] ^ o >>> 8;
                e = o;
            },
            d: function() {
                return ~e;
            }
        };
    }(), r = e.length;
    o.p(e);
    var i = function(e, t1, o, r) {
        return function(e, t1, o, r, i, n) {
            var s = e.length, a = new ZM(r + s + 5 * (1 + Math.ceil(s / 7e3)) + i), d = a.subarray(r, a.length - i), u = 0;
            if (!t1 || s < 8) for(var l = 0; l <= s; l += 65535){
                var c = l + 65535;
                c >= s && (d[u >> 3] = n), u = kk(d, u + 1, e.subarray(l, c));
            }
            else {
                for(var p = Nk[t1 - 1], h = p >>> 13, m = 8191 & p, g = (1 << o) - 1, v = new YM(32768), f = new YM(g + 1), y = Math.ceil(o / 3), S = 2 * y, b = function(t1) {
                    return (e[t1] ^ e[t1 + 1] << y ^ e[t1 + 2] << S) & g;
                }, E = new XM(25e3), I = new YM(288), A = new YM(32), C = 0, _ = 0, R = (l = 0, 0), w = 0, T = 0; l < s; ++l){
                    var O = b(l), D = 32767 & l, P = f[O];
                    if (v[D] = P, f[O] = D, w <= l) {
                        var M = s - l;
                        if ((C > 7e3 || R > 24576) && M > 423) {
                            u = Lk(e, d, 0, E, I, A, _, R, T, l - T, u), R = C = _ = 0, T = l;
                            for(var k = 0; k < 286; ++k)I[k] = 0;
                            for(k = 0; k < 30; ++k)A[k] = 0;
                        }
                        var L = 2, N = 0, V = m, U = D - P & 32767;
                        if (M > 2 && O == b(l - U)) for(var j = Math.min(h, M) - 1, x = Math.min(32767, l), B = Math.min(258, M); U <= x && --V && D != P;){
                            if (e[l + L] == e[l + L - U]) {
                                for(var F = 0; F < B && e[l + F] == e[l + F - U]; ++F);
                                if (F > L) {
                                    if (L = F, N = U, F > j) break;
                                    var H = Math.min(U, F - 2), $ = 0;
                                    for(k = 0; k < H; ++k){
                                        var W = l - U + k + 32768 & 32767, G = W - v[W] + 32768 & 32767;
                                        G > $ && ($ = G, P = W);
                                    }
                                }
                            }
                            U += (D = P) - (P = v[D]) + 32768 & 32767;
                        }
                        if (N) {
                            E[R++] = 268435456 | sk[L] << 18 | uk[N];
                            var K = 31 & sk[L], z = 31 & uk[N];
                            _ += ek[K] + tk[z], ++I[257 + K], ++A[z], w = l + L, ++C;
                        } else E[R++] = e[l], ++I[e[l]];
                    }
                }
                u = Lk(e, d, n, E, I, A, _, R, T, l - T, u);
            }
            return Ck(a, 0, r + Ak(u) + i);
        }(e, null == t1.level ? 6 : t1.level, null == t1.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t1.mem, o, r, !0);
    }(e, t1, function(e) {
        return 10 + (e.filename && e.filename.length + 1 || 0);
    }(t1), 8), n = i.length;
    return function(e, t1) {
        var o = t1.filename;
        if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t1.level < 2 ? 4 : 9 == t1.level ? 2 : 0, e[9] = 3, 0 != t1.mtime && jk(e, 4, Math.floor(new Date(t1.mtime || Date.now()) / 1e3)), o) {
            e[3] = 8;
            for(var r = 0; r <= o.length; ++r)e[r + 10] = o.charCodeAt(r);
        }
    }(i, t1), jk(i, n - 8, o.d()), jk(i, n - 4, r), i;
}
var Bk = "undefined" != typeof TextEncoder && new TextEncoder, Fk = "undefined" != typeof TextDecoder && new TextDecoder;
try {
    Fk.decode(Vk, {
        stream: !0
    });
} catch (e) {}
const { WebclientBreakoutRoomAttendeeStatus: Hk, WebclientBreakoutRoomCommand: $k } = ns, Wk = fE(la.getInstance());
function Gk(e, t1) {
    let o = 0;
    for(; o < e.length; o++){
        const r = e[o], { attendeeGuidList: i } = r;
        if (null != i && i.includes(t1)) break;
    }
    return o < e.length ? e[o] : void 0;
}
function Kk() {
    is.remove(Hk), is.remove($k);
}
function zk() {
    return ra.createAgent().leaveBO(1), ep(ba, {
        reason: qn.BackToMainSession
    }), Kk(), [
        Qv(Jp.Leaving),
        nn(es.NormalCase)
    ];
}
function qk(e, t1) {
    return ep(ba, {
        reason: qn.JoinBreakoutRoom,
        roomName: e
    }), t1 === Jp.InRoom && ra.createAgent().leaveBO(1), [
        Qv(Jp.Joining),
        nn(es.NormalCase)
    ];
}
function Jk(e) {
    return ep(ba, {
        reason: qn.MoveToBreakoutRoom,
        roomName: e
    }), ra.createAgent().leaveBO(1), [
        Qv(Jp.Joining),
        nn(es.NormalCase)
    ];
}
function Qk(e) {
    return e !== Jp.InRoom && e !== Jp.Joining && e !== Jp.Leaving;
}
function Zk(e) {
    const t1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? Jp.InRoom : Jp.Invited;
    return is.set(Hk, JSON.stringify({
        status: t1,
        boId: e.boId
    }), os.SessionStorage), Jv({
        status: t1,
        boId: e.boId,
        name: e.name,
        boStatus: e.boStatus
    });
}
function Yk(e) {
    const { breakoutRoom: { isUserRoleUpdated: t1, currentRoom: { boConfId: o } } } = e.value, r = sh(e.value);
    if (r && (!o || o && t1)) return _e(r.isHost);
    {
        const t1 = o ? ip(wc, 1) : ip(ca, 1).pipe(Be((e)=>Hp(e.userRole) ? Ce([
                1
            ]) : ot(ip(pa).pipe(tt((e)=>void 0 !== e.userRole && void 0 === e.displayName || void 0 !== e.bVideoConnect), it(1)), ip(ha).pipe(tt((e)=>e.some((e)=>Hp(e.userRole))), it(1)), Qe(3e3))));
        return t1.pipe(Ee(X), vt(e), ke((e)=>{
            let [, t1] = e;
            return sh(t1).isHost;
        }));
    }
}
function Xk(e) {
    return $e({
        boIdList: ip(fc).pipe(ut((e, t1)=>[
                ...e,
                t1
            ], []), it(e))
    }).pipe(Pe(1e4));
}
const eL = [
    {
        mask: th.Connect,
        key: "audio",
        value: ""
    },
    {
        mask: th.Voip,
        key: "audio",
        value: "computer"
    },
    {
        mask: th.Muted,
        key: "muted",
        value: !0
    },
    {
        mask: oh.Connect,
        key: "bVideoOn",
        value: !1
    },
    {
        mask: oh.On,
        key: "bVideoOn",
        value: !0
    },
    {
        mask: rh.Share,
        key: "sharerOn",
        value: !0
    },
    {
        mask: rh.ShareAudio,
        key: "bShareAudioOn",
        value: !0
    }
];
function tL(e, t1) {
    const o = (IT(t1) ? t1.breakoutRoom.mainSessionAttendeeList : t1.participants.attendeesList).find((t1)=>t1.userId === Number(e));
    return o ? {
        inviterId: o.userId,
        inviterGuid: o.userGUID,
        inviterName: o.displayName
    } : {};
}
const oL = ra.createAgent(), rL = [
    "userRole",
    "bCoHost",
    "bCCEditor",
    "bHold"
], iL = ra.createAgent(), nL = fE(la.getInstance());
var sL;
const aL = ra.createAgent(), dL = fE(la.getInstance()), uL = hT("Breakout Room");
let lL = (sL = class extends gT {
    createRooms(e, t1) {
        const o = this[tT](), r = this[oT], { breakoutRoom: { isHugeBO: i, sequenceId: n, rooms: s, controlStatus: a, isEnableBreakoutRoom: d } } = o;
        if (!d) return Promise.reject({
            type: Gl,
            reason: "Breakout room feature is not enabled."
        });
        if (a === zp.InProgress || a === zp.Closing) return Promise.resolve({
            type: Gl,
            reason: "breakout room has started!"
        });
        let u;
        u = "string" == typeof e ? [
            e
        ] : "number" == typeof e ? Array.from({
            length: e
        }).map((e, t1)=>`${Zp} ${t1 + n}`) : e;
        const l = i ? 100 : 50;
        return u.length < 1 || s.length + u.length > l ? Promise.reject({
            type: Ql,
            reason: "exceed maximum size"
        }) : (aL.batchCreateBOToken(u), new Promise((e, i)=>{
            Xk(u.length).subscribe({
                next (i) {
                    let { boIdList: s } = i, a = s.map((e, t1)=>({
                            boId: e,
                            name: u[t1]
                        }));
                    if (t1 === Kp.Automatically) {
                        const e = AT(o), t1 = a.length, r = e.length;
                        a = a.map((o, i)=>{
                            const n = [];
                            let s = i;
                            for(; s < r;)n.push(e[s]), s += t1;
                            return {
                                ...o,
                                attendeeList: n
                            };
                        });
                    }
                    const d = a.map((e)=>{
                        let { boId: t1, name: o, attendeeList: r } = e;
                        return {
                            boId: t1,
                            name: o,
                            attendeeGuidList: r && r.map((e)=>e.userGUID)
                        };
                    });
                    if (r(Fv(d)), r(Hv(t1)), r($v(n + a.length)), t1 === Kp.Automatically) {
                        const t1 = a.map((e)=>({
                                roomId: e.boId,
                                name: e.name,
                                attendeeList: e.attendeeList.map((e)=>({
                                        userId: e.userId,
                                        avatar: e.avatar,
                                        displayName: e.displayName
                                    }))
                            }));
                        e(t1);
                    } else e(a.map((e)=>({
                            roomId: e.boId,
                            name: e.name,
                            attendeeList: []
                        })));
                },
                error () {
                    i({
                        type: Kl
                    });
                }
            });
        }));
    }
    recreateRooms(e, t1) {
        const o = this[tT](), r = this[oT], { breakoutRoom: { isHugeBO: i, sequenceId: n, rooms: s, controlStatus: a, isEnableBreakoutRoom: d } } = o;
        if (!d) return Promise.reject({
            type: Gl,
            reason: "Breakout room feature is not enabled."
        });
        if (a === zp.InProgress || a === zp.Closing) return Promise.resolve({
            type: Gl,
            reason: "breakout room has started!"
        });
        let u;
        u = "string" == typeof e ? [
            e
        ] : "number" == typeof e ? Array.from({
            length: e
        }).map((e, t1)=>`${Zp} ${t1 + n}`) : e;
        const l = i ? 100 : 50;
        return u.length < 1 || s.length + u.length > l ? Promise.reject({
            type: Ql,
            reason: "exceed maximum size"
        }) : (aL.batchCreateBOToken(u), new Promise((e, i)=>{
            Xk(u.length).subscribe((i)=>{
                let { boIdList: s } = i, a = s.map((e, t1)=>({
                        boId: e,
                        name: u[t1]
                    }));
                if (t1 === Kp.Automatically) {
                    const e = a.length, t1 = CT(o), r = t1.length;
                    a = a.map((o, i)=>{
                        const n = [];
                        let s = i;
                        for(; s < r;)n.push(t1[s]), s += e;
                        return {
                            ...o,
                            attendeeList: n
                        };
                    });
                }
                const d = a.map((e)=>{
                    let { boId: t1, name: o, attendeeList: r } = e;
                    return {
                        boId: t1,
                        name: o,
                        attendeeGuidList: r && r.map((e)=>e.userGUID)
                    };
                });
                if (r(qv(d)), r(Hv(t1)), r($v(n + a.length)), t1 === Kp.Automatically) {
                    const t1 = a.map((e)=>({
                            roomId: e.boId,
                            name: e.name,
                            attendeeList: e.attendeeList.map((e)=>({
                                    userId: e.userId,
                                    avatar: e.avatar,
                                    displayName: e.displayName
                                }))
                        }));
                    e(t1);
                } else e(a.map((e)=>({
                        roomId: e.boId,
                        name: e.name,
                        attendeeList: []
                    })));
            }, ()=>{
                i({
                    type: Kl
                });
            });
        }));
    }
    openRooms(e, t1) {
        var o;
        const r = this[tT](), i = {
            isAutoJoinRoom: !1,
            isBackToMainSessionEnabled: !0,
            isTimerEnabled: !1,
            timerDuration: 1800,
            isTimerAutoEnabled: !1,
            waitSeconds: 60,
            isAutoMoveBackToMainSession: !1,
            isRoomSelectionEnabled: !1
        }, { breakoutRoom: { controlStatus: n, rooms: s, sequenceId: a, isHugeBO: d } } = r;
        if (n === zp.InProgress || n === zp.Closing) return Promise.resolve({
            type: Gl,
            reason: "breakout room has started!"
        });
        if (e.some((e)=>-1 === s.findIndex((t1)=>t1.boId === e.roomId))) return Promise.reject({
            type: Ql,
            reason: "roomId is wrong"
        });
        const u = ch(r);
        if (e.reduce((e, t1)=>e.concat(t1.attendeeList), []).some((e)=>-1 === u.findIndex((t1)=>t1.userId === e.userId))) return Promise.reject({
            type: Ql,
            reason: "bad user"
        });
        const l = e.map((e)=>{
            const { attendeeList: t1 } = e, o = t1.map((e)=>{
                const t1 = u.find((t1)=>t1.userId === e.userId);
                return null == t1 ? void 0 : t1.userGUID;
            });
            return {
                BID: e.roomId,
                MeetingTitle: e.name,
                MeetingToken: void 0,
                Status: qp.Started,
                HostID: "",
                ParticipantList: o
            };
        }), c = t1 ? {
            ...i,
            ...t1
        } : i, p = {
            ControlStatus: zp.InProgress,
            NameIndex: a,
            IsAutoJoinEnabled: +c.isAutoJoinRoom,
            IsBackToMainSessionEnabled: +c.isBackToMainSessionEnabled,
            IsTimerEnabled: +c.isTimerEnabled,
            TimerDuration: c.timerDuration,
            IsTimerAutoEndEnabled: +c.isTimerAutoEnabled,
            WaitSeconds: c.waitSeconds < 0 ? 0 : c.waitSeconds,
            StartTimeOnMMR: void 0,
            ItemList: l,
            IsAutoMovetoMainSessionEnabled: c.isAutoMoveBackToMainSession,
            IsParticipantsChooseRoomEnabled: +c.isRoomSelectionEnabled
        };
        let h = Wr(JSON.stringify(p));
        if (d && (h = ((e)=>Fr(xk(function(e) {
                if (Bk) return Bk.encode(e);
                for(var t1 = e.length, o = new ZM(e.length + (e.length >> 1)), r = 0, i = function(e) {
                    o[r++] = e;
                }, n = 0; n < t1; ++n){
                    if (r + 5 > o.length) {
                        var s = new ZM(r + 8 + (t1 - n << 1));
                        s.set(o), o = s;
                    }
                    var a = e.charCodeAt(n);
                    a < 128 ? i(a) : a < 2048 ? (i(192 | a >> 6), i(128 | 63 & a)) : a > 55295 && a < 57344 ? (i(240 | (a = 65536 + (1047552 & a) | 1023 & e.charCodeAt(++n)) >> 18), i(128 | a >> 12 & 63), i(128 | a >> 6 & 63), i(128 | 63 & a)) : (i(224 | a >> 12), i(128 | a >> 6 & 63), i(128 | 63 & a));
                }
                return Ck(o, 0, r);
            }(e))))(h)), null !== (o = sh(r)) && void 0 !== o && o.isHost) aL.startBO(h);
        else {
            const e = _T(r);
            e && aL.coHostStartBO(h, e.userId);
        }
        return rp(Cc, (e)=>e.controlStatus === zp.InProgress);
    }
    joinRoom(e) {
        const t1 = this[tT](), o = sh(t1), { breakoutRoom: { controlStatus: r, rooms: i, options: { isRoomSelectionEnabled: n }, currentRoom: { status: s, boId: a } }, meeting: { userGUID: d } } = t1;
        if (r !== zp.InProgress) return Promise.reject({
            type: Jl,
            reason: "Breakout room is not started"
        });
        if (null != o && o.isHost) {
            const t1 = i.find((t1)=>t1.boId === e);
            if (!t1) return Promise.reject({
                type: Ql,
                reason: "Room ID is not correct"
            });
            aL.joinBO(t1.boId);
        } else if (null != o && o.bCoHost) {
            const o = i.find((t1)=>t1.boId === e);
            if (!o) return Promise.reject({
                type: Ql,
                reason: "Room ID is not correct"
            });
            {
                const o = _T(t1);
                if (!o) return Promise.reject({
                    type: Gl,
                    reason: "No host in the meeting, cannot join the room"
                });
                aL.wantJoinBO(null == o ? void 0 : o.userId, e);
            }
        } else {
            if (s === Jp.InRoom && a === e) return Promise.resolve("");
            {
                let o = !1;
                const r = Gk(i, d);
                if (r && r.boId === e) aL.joinBO(r.boId);
                else if (n) if (-1 !== i.findIndex((t1)=>t1.boId === e)) {
                    const o = _T(t1);
                    if (!o) return Promise.reject({
                        type: Gl,
                        reason: "No host in the meeting, cannot join the room"
                    });
                    aL.wantJoinBO(o.userId, e);
                } else o = !0;
                else o = !0;
                if (o) return Promise.reject({
                    type: Ql,
                    reason: "Room ID is not correct"
                });
            }
        }
        return rp(_c, (t1)=>t1.boId === e);
    }
    leaveRoom() {
        const e = this[tT](), t1 = this[oT], { breakoutRoom: { controlStatus: o, options: r, currentRoom: { status: i } } } = e;
        if (o !== zp.InProgress && o !== zp.Closing || i !== Jp.InRoom) return Promise.reject({
            type: Gl
        });
        {
            const o = ah(e);
            if (!r.isBackToMainSessionEnabled && !o) return Promise.reject({
                type: ql,
                reason: "Can not return main session during the breakout room"
            });
            zk().forEach((e)=>t1(e));
        }
        return Promise.resolve("");
    }
    askForHelp() {
        const e = this[tT](), { breakoutRoom: { controlStatus: t1, mainSessionAttendeeList: o, currentRoom: { status: r } }, participants: { attendeesList: i } } = e, n = ah(e);
        if (t1 !== zp.InProgress || r !== Jp.InRoom) return Promise.reject({
            type: Gl,
            reason: "you are not in breakout room"
        });
        if (n) return Promise.reject({
            type: Gl,
            reason: "host or co-host can not ask for help"
        });
        {
            const e = o.find((e)=>e.isHost);
            if (e) {
                if (i.findIndex((t1)=>t1.zoomID === e.zoomID) > -1) return Promise.reject({
                    type: Gl,
                    reason: "host is in room"
                });
                aL.askForHelpBO(e.userId);
            }
        }
        return rp(Ac, (e)=>e.result === Yp.Received);
    }
    postponeHelping(e) {
        const t1 = this[tT](), o = this[oT], { breakoutRoom: { mainSessionAttendeeList: r, currentRoom: { status: i } }, participants: { attendeesList: n } } = t1;
        let s = n;
        return i === Jp.InRoom && (s = r), s.findIndex((t1)=>t1.userId === e) > -1 ? (aL.askForHelpResultBO(e, Yp.Ignore), o(of(Yp.Ignore)), Promise.resolve("")) : Promise.reject({
            type: Ql,
            reason: "user id is not correct"
        });
    }
    broadcast(e) {
        const { breakoutRoom: { isEnableBOBroadcast: t1 } } = this[tT]();
        return t1 ? e ? ws.beginEncrypt({
            text: e,
            type: As.BO_BROADCAST
        }).then((e)=>(aL.broadcastBO(e), Promise.resolve(""))) : Promise.reject({
            type: Ql,
            reason: "content empty"
        }) : Promise.reject({
            type: Gl,
            reason: "Cannot broadcast message due to the feature is not enable"
        });
    }
    startBroadcastVoice() {
        const e = this[tT](), t1 = this[oT], { breakoutRoom: { isEnableBOBroadcast: o, isEnableBOBroadcastVoice: r, isBroadcastVoice: i } } = e;
        if (o && r) {
            if (IT(e)) return Promise.reject({
                type: Gl,
                reason: "Cannot broadcast voice in the room"
            });
            {
                if (i) return Promise.resolve("");
                const o = sh(e);
                return (null == o ? void 0 : o.audio) === $d.Computer && !1 === o.muted ? (aL.broadcastVoiceReq(!0), dL.broadcastVoiceToBreakoutRoom(!0), t1(cf(!0)), Promise.resolve("")) : Promise.reject({
                    type: Gl,
                    reason: "Start audio and unmute to broadcast"
                });
            }
        }
        return Promise.reject({
            type: Gl,
            reason: "Cannot broadcast voice due to the feature is not enable"
        });
    }
    stopBroadcastVoice() {
        const e = this[tT](), t1 = this[oT], { breakoutRoom: { isBroadcastVoice: o } } = e;
        return o ? (aL.broadcastVoiceReq(!1), dL.broadcastVoiceToBreakoutRoom(!1), t1(cf(!1)), Promise.resolve("")) : Promise.reject({
            type: Gl,
            reason: "Cannot stop broadcast voice due to it is not started"
        });
    }
    assignUserToRoom(e, t1) {
        const o = this[tT](), { breakoutRoom: { rooms: r } } = o, i = AT(o).find((t1)=>t1.userId === e);
        if (!(i && r.findIndex((e)=>e.boId === t1) > -1)) return Promise.reject({
            type: Ql,
            reason: ""
        });
        var n;
        if (null !== (n = sh(o)) && void 0 !== n && n.isHost) aL.assignToBO(e, t1);
        else {
            const e = _T(o);
            e && aL.coHostAssignToBO(i.userGUID, t1, e.userId);
        }
        return rp(Cc, (e)=>{
            const { controlStatus: o, roomList: r } = e, n = r.find((e)=>e.boId === t1);
            return o === zp.InProgress && n && n.attendeeGuidList.includes(i.userGUID);
        });
    }
    moveUserToRoom(e, t1) {
        const o = this[tT](), { breakoutRoom: { rooms: r, mainSessionAttendeeList: i }, participants: { attendeesList: n } } = o, s = (IT(o) ? i : n).find((t1)=>t1.userId === e);
        if (!s) return Promise.reject({
            type: Ql,
            reason: "user id not correct"
        });
        {
            const i = Gk(r, s.userGUID);
            if (!i) return Promise.reject({
                type: Gl,
                reason: "user not in a room"
            });
            if (i.boId === t1) return Promise.reject({
                type: Gl,
                reason: "user already in the target room"
            });
            {
                const i = r.find((e)=>e.boId === t1);
                if (!i) return Promise.reject({
                    type: Ql,
                    reason: "invalid room id"
                });
                var a;
                if (null !== (a = sh(o)) && void 0 !== a && a.isHost) aL.switchBO(e, i.boId);
                else {
                    const e = _T(o);
                    e && aL.coHostAssignToBO(s.userGUID, i.boId, e.userId);
                }
            }
        }
        return rp(Cc, (e)=>{
            const { controlStatus: o, roomList: r } = e, i = r.find((e)=>e.boId === t1);
            return o === zp.InProgress && i && i.attendeeGuidList.includes(s.userGUID);
        });
    }
    moveBackToMainSession(e) {
        const t1 = this[tT](), { breakoutRoom: { rooms: o, mainSessionAttendeeList: r }, participants: { attendeesList: i } } = t1, n = (IT(t1) ? r : i).find((t1)=>t1.userId === e);
        if (!n) return Promise.reject({
            type: Ql,
            reason: "user id not correct"
        });
        if (!Gk(o, n.userGUID)) return Promise.reject({
            type: Gl,
            reason: "user not in a room"
        });
        var s;
        if (null !== (s = sh(t1)) && void 0 !== s && s.isHost) aL.moveToMainSession(n.userGUID);
        else {
            const e = _T(t1);
            e && aL.coHostMoveToMainSession(n.userGUID, e.userId);
        }
        return rp(Cc, (e)=>{
            const { controlStatus: t1, roomList: o } = e;
            return t1 === zp.InProgress && o.some((e)=>{
                const { attendeeGuidList: t1 } = e;
                return t1.includes(n.userGUID);
            });
        });
    }
    closeRoom() {
        const e = this[tT](), { breakoutRoom: { controlStatus: t1 } } = e;
        if (t1 !== zp.InProgress) return Promise.reject({
            type: Gl,
            reason: "room is not started"
        });
        var o;
        if (null !== (o = sh(e)) && void 0 !== o && o.isHost) aL.stopBO(zp.Closing);
        else {
            const t1 = _T(e);
            t1 && aL.coHostStopBO(zp.Closing, t1.userId);
        }
        return rp(Cc, (e)=>e.controlStatus === zp.Closing);
    }
    loadPreAssignedRooms() {
        const e = this[tT](), { meeting: { meetingOptions: t1 }, breakoutRoom: { controlStatus: o } } = e;
        return !t1.isAllowBreakoutRoomPreAssign || o !== zp.NotStarted && o !== zp.Closed ? Promise.reject({
            type: Gl
        }) : (aL.preAssignBreakoutRoom(), rp(Tc));
    }
    getUnassignedAttendeeList() {
        const e = this[tT](), t1 = sh(e);
        return null != t1 && t1.isHost || null != t1 && t1.bCoHost ? AT(e).map((e)=>fT(e)) : [];
    }
    getRoomList() {
        const e = this[tT](), { breakoutRoom: { rooms: t1, currentRoom: { status: o, boId: r }, mainSessionAttendeeList: i, inRoomUserActivityStatusMap: n, options: { isRoomSelectionEnabled: s } }, participants: { attendeesList: a } } = e, d = sh(e);
        if (d && (d.isHost || d.bCoHost || s)) {
            const e = o === Jp.InRoom, s = e ? i : a;
            return t1.map((t1)=>{
                const { attendeeGuidList: o, boId: i, name: a } = t1, u = (o || []).map((e)=>s.find((t1)=>t1.userGUID === e)).filter((e)=>!(null != e && e.isHost)).filter(Boolean);
                return e && d.isHost && i === r && u.unshift(d), {
                    roomId: i,
                    name: a,
                    attendeeList: u.filter((e)=>!!e).map((e)=>{
                        var t1;
                        const o = null !== (t1 = n[e.userGUID]) && void 0 !== t1 ? t1 : {};
                        return {
                            userId: e.userId,
                            displayName: e.displayName,
                            avatar: e.avatar,
                            isInRoom: e.bid === i,
                            userGuid: e.userGUID,
                            ...o
                        };
                    })
                };
            });
        }
        return e.breakoutRoom.rooms.map((e)=>{
            const { boId: t1, name: o } = e;
            return {
                roomId: t1,
                name: o,
                attendeeList: []
            };
        });
    }
    getAttendeeStatus() {
        return this[tT]().breakoutRoom.currentRoom.status;
    }
    getRoomStatus() {
        return this[tT]().breakoutRoom.controlStatus;
    }
    getCurrentRoom() {
        const e = this[tT](), { breakoutRoom: { currentRoom: { status: t1, name: o, boId: r } } } = e;
        return {
            attendeeStatus: t1,
            name: o,
            roomId: r
        };
    }
    getRoomOptions() {
        const e = this[tT](), { breakoutRoom: { options: t1 } } = e, { whoStart: o, whoStop: r, ...i } = t1;
        return {
            ...i
        };
    }
}, Xw(sL.prototype, "createRooms", [
    nT,
    sT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "createRooms"), sL.prototype), Xw(sL.prototype, "recreateRooms", [
    nT,
    sT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "recreateRooms"), sL.prototype), Xw(sL.prototype, "openRooms", [
    nT,
    sT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "openRooms"), sL.prototype), Xw(sL.prototype, "joinRoom", [
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "joinRoom"), sL.prototype), Xw(sL.prototype, "leaveRoom", [
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "leaveRoom"), sL.prototype), Xw(sL.prototype, "askForHelp", [
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "askForHelp"), sL.prototype), Xw(sL.prototype, "postponeHelping", [
    aT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "postponeHelping"), sL.prototype), Xw(sL.prototype, "broadcast", [
    sT,
    nT
], Object.getOwnPropertyDescriptor(sL.prototype, "broadcast"), sL.prototype), Xw(sL.prototype, "startBroadcastVoice", [
    aT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "startBroadcastVoice"), sL.prototype), Xw(sL.prototype, "stopBroadcastVoice", [
    aT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "stopBroadcastVoice"), sL.prototype), Xw(sL.prototype, "assignUserToRoom", [
    sT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "assignUserToRoom"), sL.prototype), Xw(sL.prototype, "moveUserToRoom", [
    sT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "moveUserToRoom"), sL.prototype), Xw(sL.prototype, "moveBackToMainSession", [
    sT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "moveBackToMainSession"), sL.prototype), Xw(sL.prototype, "closeRoom", [
    sT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "closeRoom"), sL.prototype), Xw(sL.prototype, "loadPreAssignedRooms", [
    aT,
    nT,
    uL
], Object.getOwnPropertyDescriptor(sL.prototype, "loadPreAssignedRooms"), sL.prototype), sL);
const cL = {
    breakoutRoomSharingEpics0: (e, t1)=>nr(e, Ds).pipe(tt((e)=>{
            var t1;
            const { payload: { body: o } } = e;
            return null == o || null === (t1 = o.update) || void 0 === t1 ? void 0 : t1.some((e)=>void 0 !== e.bShareToBORooms || void 0 !== e.bShareOn);
        }), vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { payload: { body: { update: r } } } = t1, { breakoutRoom: { mainSessionAttendeeList: i } } = o, n = r.filter((e)=>e.bShareOn && e.bShareToBORooms), s = r.filter((e)=>!e.bShareOn || !e.bShareToBORooms), a = i.filter((e)=>e.sharerOn && e.bShareToBORooms);
            return n.length > 0 && n.forEach((e)=>{
                -1 === a.findIndex((t1)=>t1.userId === e.id) && ep(Al, {
                    ...e,
                    isFromMainSession: !0
                });
            }), s.length > 0 && s.forEach((e)=>{
                ep(Cl, {
                    ...e,
                    isFromMainSession: !0
                });
            }), r.map((e)=>{
                if (e.bShareOn && e.bShareToBORooms) {
                    if (0 === i.filter((t1)=>t1.sharerOn && t1.bShareToBORooms && t1.userId !== e.id).length) return {
                        activeNodeID: e.id,
                        bStatus: 1,
                        ssrc: e.shareSsrc
                    };
                    {
                        const t1 = i.find((t1)=>t1.userId === e.id);
                        if (null != t1 && t1.isHost) return {
                            activeNodeID: e.id,
                            bStatus: 1,
                            ssrc: e.shareSsrc
                        };
                    }
                } else if (!e.bShareOn || !e.bShareToBORooms) {
                    const t1 = i.filter((e)=>e.bShareToBORooms && e.sharerOn);
                    if (1 === t1.length && t1[0].userId === e.id) return {
                        activeNodeID: e.id,
                        bStatus: 0,
                        ssrc: 0
                    };
                    {
                        const o = t1.filter((t1)=>t1.userId !== e.id), r = o.find((e)=>e.isHost);
                        if (r) return {
                            activeNodeID: r.userId,
                            bStatus: 1,
                            ssrc: r.shareSsrc
                        };
                        {
                            const e = o[0];
                            if (e) return {
                                activeNodeID: e.userId,
                                bStatus: 1,
                                ssrc: e.shareSsrc
                            };
                        }
                    }
                }
            }).filter(Boolean);
        }), Be((e)=>{
            const { share: { status: o }, meeting: { userId: r } } = t1.value, i = [];
            return e.map((e)=>{
                const { activeNodeID: n, bStatus: s, ssrc: a } = e, d = 1 === s;
                i.push(Cm(d)), d && o !== fd.End && (iL.stopSharing(r), nL.stopDesktopSharing(), i.push(ym(fd.End)), ep(Il));
                let u = {
                    activeNodeID: n,
                    bStatus: s,
                    ssrc: a,
                    fromMainSession: !0
                };
                if (!d) {
                    const { participants: { attendeesList: e } } = t1.value, o = e.filter((e)=>e.sharerOn);
                    if (o.length > 0) {
                        const e = o[0];
                        u = {
                            activeNodeID: e.userId,
                            bStatus: 1,
                            ssrc: e.shareSsrc || 0
                        };
                    }
                }
                i.push(Co({
                    evt: Ts,
                    body: u
                }));
            }), Ce(i);
        })),
    breakoutRoomSharingEpics1: (e, t1)=>nr(e, Ls).pipe(pt((o)=>{
            const { payload: { body: { userID: r, confID: i } } } = o;
            return Ye(...[
                "sharing",
                "audio"
            ].map((o)=>(function(e, t1, o, r, i) {
                    return nr(t1, "audio" === e ? Ms : Os).pipe(it(1), gt((t1)=>{
                        const { payload: { body: { encryptKey: n, additionalType: s } } } = t1, { media: { sharingDecodeStatus: a, audioDecodeStatus: d }, meeting: { svcUrl: u, meetingNumber: l, conId: c, zoomId: p, meetingId: h } } = o.value;
                        Ey(e, "success", "audio" === e ? d : a).subscribe((t1)=>{
                            let [, a] = t1;
                            if (a) {
                                const t1 = `wss://${u}/wc/media/${l}?type=${"audio" === e ? "ma" : "ms"}&cid=${c}&mode=1`;
                                Wk.createMainSessionChannel(e, t1), Wk.updateMediaParams({
                                    iVType: "audio" === e ? Es.AUDIO_DECODE : Es.SHARING_DECODE,
                                    isFromMainSession: !0,
                                    updateParams: {
                                        userId: r,
                                        sn: Kr(p),
                                        confId: i,
                                        encryptType: s,
                                        encryptKey: Kr(n),
                                        meetingId: h,
                                        meetingNumber: l
                                    }
                                });
                                const { breakoutRoom: { mainSessionAttendeeList: a } } = o.value;
                                if ((null == a ? void 0 : a.length) > 0) {
                                    const t1 = a.map((e)=>({
                                            userid: e.userId,
                                            sn: e.zoomID && Kr(e.zoomID)
                                        }));
                                    Wk.updateUserMediaSN({
                                        added: t1,
                                        isFromMainSession: !0,
                                        iVType: "audio" === e ? Es.AUDIO_DECODE : Es.SHARING_DECODE
                                    });
                                }
                            }
                        });
                    }), Be(()=>ie));
                })(o, e, t1, r, i)));
        }))
}, pL = {
    epics0: (e, t1)=>e.pipe(Ot(`${Sn}`), pt((e)=>{
            const { breakoutRoom: o, meeting: { meetingOptions: r } } = t1.value, { payload: { hugeBO: i, elapsed: n } } = e, s = [];
            return o && (r && (s.push(sf(i && !0 === r.isBO100Enabled)), s.push(uf({
                isEnableBreakoutRoom: r.isEnableBreakoutRoom,
                isEnableBOBroadcast: r.isEnableBOBroadcast,
                isEnableBOViewActivityStatus: r.isEnableBOViewActivityStatus,
                isEnableBOBroadcastVoice: r.isEnableBOBroadcastVoice
            }))), o.currentRoom.boConfId && s.push(wo()), void 0 !== n && s.push(Wv(n))), Ce(s);
        })),
    epics1: (e)=>ir(e, 4174).pipe(gt((e)=>{
            ep(fc, e.payload.body.bid);
        }), dt(ie)),
    epics2: (e, t1)=>ar(e, 7950).pipe(vt(t1), pt((e)=>{
            let [o, r] = e;
            const { payload: { body: { proto: i } } } = o, { breakoutRoom: { isHugeBO: n, currentRoom: { status: s, boId: a } }, meeting: { userGUID: d } } = r;
            let u = i;
            n && (u = function(e) {
                if (Fk) return Fk.decode(e);
                var t1 = function(e) {
                    for(var t1 = "", o = 0;;){
                        var r = e[o++], i = (r > 127) + (r > 223) + (r > 239);
                        if (o + i > e.length) return [
                            t1,
                            Ck(e, o - 1)
                        ];
                        i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[o++]) << 12 | (63 & e[o++]) << 6 | 63 & e[o++]) - 65536, t1 += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t1 += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[o++]) : String.fromCharCode((15 & r) << 12 | (63 & e[o++]) << 6 | 63 & e[o++]) : t1 += String.fromCharCode(r);
                    }
                }(e), o = t1[0];
                return t1[1].length && Rk(8), o;
            }(function(e) {
                return function(e, t1, o) {
                    var r = e.length;
                    if (!r || o && o.f && !o.l) return t1 || new ZM(0);
                    var i = !t1 || o, n = !o || o.i;
                    o || (o = {}), t1 || (t1 = new ZM(3 * r));
                    var s = function(e) {
                        var o = t1.length;
                        if (e > o) {
                            var r = new ZM(Math.max(2 * o, e));
                            r.set(t1), t1 = r;
                        }
                    }, a = o.f || 0, d = o.p || 0, u = o.b || 0, l = o.l, c = o.d, p = o.m, h = o.n, m = 8 * r;
                    do {
                        if (!l) {
                            a = Ek(e, d, 1);
                            var g = Ek(e, d + 1, 3);
                            if (d += 3, !g) {
                                var v = e[(w = Ak(d) + 4) - 4] | e[w - 3] << 8, f = w + v;
                                if (f > r) {
                                    n && Rk(0);
                                    break;
                                }
                                i && s(u + v), t1.set(e.subarray(w, f), u), o.b = u += v, o.p = d = 8 * f, o.f = a;
                                continue;
                            }
                            if (1 == g) l = fk, c = Sk, p = 9, h = 5;
                            else if (2 == g) {
                                var y = Ek(e, d, 31) + 257, S = Ek(e, d + 10, 15) + 4, b = y + Ek(e, d + 5, 31) + 1;
                                d += 14;
                                for(var E = new ZM(b), I = new ZM(19), A = 0; A < S; ++A)I[ok[A]] = Ek(e, d + 3 * A, 7);
                                d += 3 * S;
                                var C = bk(I), _ = (1 << C) - 1, R = hk(I, C, 1);
                                for(A = 0; A < b;){
                                    var w, T = R[Ek(e, d, _)];
                                    if (d += 15 & T, (w = T >>> 4) < 16) E[A++] = w;
                                    else {
                                        var O = 0, D = 0;
                                        for(16 == w ? (D = 3 + Ek(e, d, 3), d += 2, O = E[A - 1]) : 17 == w ? (D = 3 + Ek(e, d, 7), d += 3) : 18 == w && (D = 11 + Ek(e, d, 127), d += 7); D--;)E[A++] = O;
                                    }
                                }
                                var P = E.subarray(0, y), M = E.subarray(y);
                                p = bk(P), h = bk(M), l = hk(P, p, 1), c = hk(M, h, 1);
                            } else Rk(1);
                            if (d > m) {
                                n && Rk(0);
                                break;
                            }
                        }
                        i && s(u + 131072);
                        for(var k = (1 << p) - 1, L = (1 << h) - 1, N = d;; N = d){
                            var V = (O = l[Ik(e, d) & k]) >>> 4;
                            if ((d += 15 & O) > m) {
                                n && Rk(0);
                                break;
                            }
                            if (O || Rk(2), V < 256) t1[u++] = V;
                            else {
                                if (256 == V) {
                                    N = d, l = null;
                                    break;
                                }
                                var U = V - 254;
                                if (V > 264) {
                                    var j = ek[A = V - 257];
                                    U = Ek(e, d, (1 << j) - 1) + nk[A], d += j;
                                }
                                var x = c[Ik(e, d) & L], B = x >>> 4;
                                if (x || Rk(3), d += 15 & x, M = dk[B], B > 3 && (j = tk[B], M += Ik(e, d) & (1 << j) - 1, d += j), d > m) {
                                    n && Rk(0);
                                    break;
                                }
                                i && s(u + 131072);
                                for(var F = u + U; u < F; u += 4)t1[u] = t1[u - M], t1[u + 1] = t1[u + 1 - M], t1[u + 2] = t1[u + 2 - M], t1[u + 3] = t1[u + 3 - M];
                                u = F;
                            }
                        }
                        o.l = l, o.p = N, o.b = u, o.f = a, l && (a = 1, o.m = p, o.d = c, o.n = h);
                    }while (!a)
                    return u == t1.length ? t1 : Ck(t1, 0, u);
                }(e.subarray(function(e) {
                    31 == e[0] && 139 == e[1] && 8 == e[2] || Rk(6, "invalid gzip data");
                    var t1 = e[3], o = 10;
                    4 & t1 && (o += e[10] | 2 + (e[11] << 8));
                    for(var r = (t1 >> 3 & 1) + (t1 >> 4 & 1); r > 0; r -= !e[o++]);
                    return o + (2 & t1);
                }(e), -8), new ZM(function(e) {
                    var t1 = e.length;
                    return (e[t1 - 4] | e[t1 - 3] << 8 | e[t1 - 2] << 16 | e[t1 - 1] << 24) >>> 0;
                }(e)));
            }(Kr(i))));
            const l = [];
            let c;
            try {
                const e = JSON.parse($r(u)), { ControlStatus: r, NameIndex: i, IsAutoJoinEnabled: n, IsBackToMainSessionEnabled: p, IsParticipantsChooseRoomEnabled: h, IsTimerEnabled: m, TimerDuration: g, IsTimerAutoEndEnabled: v, WaitSeconds: f, StartTimeOnMMR: y, ItemList: S, WhoStart: b, WhoStop: E, IsAutoMovetoMainSessionEnabled: I } = e, A = {
                    isAutoJoinRoom: n,
                    isBackToMainSessionEnabled: p,
                    isTimerEnabled: m,
                    timerDuration: g,
                    isTimerAutoEnabled: v,
                    waitSeconds: f,
                    isAutoMoveBackToMainSession: I,
                    isRoomSelectionEnabled: h,
                    whoStart: b,
                    whoStop: E
                };
                l.push(Kv(A)), l.push(Gv(y)), l.push($v(i)), l.push(zv(r));
                const C = S && S.map((e)=>({
                        boId: e.BID,
                        name: e.MeetingTitle,
                        boStatus: e.Status,
                        hostId: e.HostID,
                        attendeeGuidList: e.ParticipantList || []
                    })) || [];
                switch(l.push(qv(C)), ep(Cc, {
                    controlStatus: r,
                    roomList: C
                }), r){
                    case zp.InProgress:
                        if (s !== Jp.InRoom && s !== Jp.Joining) {
                            const e = function(e, t1) {
                                const { meeting: { isHost: o, userGUID: r }, breakoutRoom: { currentRoom: { status: i, boId: n } } } = t1.value, s = is.get(Hk), a = [];
                                if (s) try {
                                    const { status: d, boId: u } = JSON.parse(s);
                                    if (d === Jp.Invited) if (o) Kk();
                                    else {
                                        const t1 = Gk(e, r);
                                        t1 && (a.push(Zk(t1)), i !== Jp.Initial && n === t1.boId || ep(yc, {
                                            roomId: t1.boId,
                                            name: t1.name
                                        }));
                                    }
                                    else if (d === Jp.InRoom) {
                                        let i;
                                        if (i = o ? e.find((e)=>e.boId === u) : Gk(e, r), i) {
                                            a.push(Zk(i));
                                            const e = i.boId;
                                            Iy(t1).subscribe(()=>{
                                                ra.createAgent().joinBO(e);
                                            });
                                        }
                                        Kk();
                                    }
                                } catch (e) {
                                    console.error(e);
                                }
                                return a;
                            }(C, t1);
                            if (0 === e.length) {
                                const e = Gk(C, d);
                                e && l.push(Zk(e));
                            } else l.push(...e);
                        } else if (s === Jp.InRoom && o.type === `${Oo}`) {
                            const e = Gk(C, d);
                            e && Yk(t1).subscribe((t1)=>{
                                a === e.boId || t1 || oL.joinBO(e.boId);
                            });
                        }
                        A.isTimerEnabled && A.timerDuration > 0 && (c = function(e, t1, o) {
                            return Yk(e).pipe(vt(e), pt((r)=>{
                                let [i, n] = r;
                                const { breakoutRoom: { currentRoom: { status: s }, meetingElapsedTime: a }, meeting: { joinMeetingTimeStamp: d } } = n, u = d - 1e3 * a + 1e3 * o + 1e3 * t1;
                                if (performance.now() < u) {
                                    if (i) return Ze(1e3).pipe(ke(()=>Math.floor((u - performance.now()) / 1e3)), vt(e), mt((e)=>{
                                        let [t1, o] = e;
                                        const { breakoutRoom: { controlStatus: r, currentRoom: { status: i } }, socket: { zoomSocketStatus: n }, meeting: { isHost: s } } = o;
                                        return t1 >= 0 && s && r === zp.InProgress && (i === Jp.InRoom || i === Jp.MainSession || i === Jp.Initial) && n === yh.Connected;
                                    }), gt((e)=>{
                                        let [t1] = e;
                                        ep(bc, {
                                            countdown: t1
                                        });
                                    }), tt((e)=>{
                                        let [t1] = e;
                                        return 0 === t1;
                                    }), gt((e)=>{
                                        let [, t1] = e;
                                        const { breakoutRoom: { options: o } } = t1;
                                        o.isTimerAutoEnabled ? ra.createAgent().stopBO(zp.Closing) : ep(Rc);
                                    }), Be(()=>ie));
                                    if (s === Jp.InRoom) return Ze(1e3).pipe(ke(()=>Math.floor((u - performance.now()) / 1e3)), vt(e), mt((e)=>{
                                        let [t1, o] = e;
                                        const { breakoutRoom: { currentRoom: { status: r } }, meeting: { isHost: i }, socket: { zoomSocketStatus: n } } = o;
                                        return t1 >= 0 && r === Jp.InRoom && !i && n === yh.Connected;
                                    }), gt((e)=>{
                                        let [t1] = e;
                                        ep(bc, {
                                            countdown: t1
                                        });
                                    }), Be(()=>ie));
                                }
                                return ie;
                            }));
                        }(t1, A.timerDuration, y));
                        break;
                    case zp.Closing:
                        c = Yk(t1).pipe(tt((e)=>e), Be(()=>{
                            const e = [], { breakoutRoom: { closingRoomTime: o, currentRoom: { status: r } }, participants: { attendeesList: i } } = t1.value;
                            let n = A.waitSeconds;
                            if (0 !== o && A.waitSeconds > 0) {
                                const e = Math.floor((performance.now() - o) / 1e3);
                                n = Math.max(A.waitSeconds - e, 0);
                            }
                            if (0 === n) return oL.stopBO(zp.Closed), ie;
                            {
                                if (r !== Jp.InRoom && i.length > 1 && i.every((e)=>!e.bid)) return oL.stopBO(zp.Closed), ie;
                                o || e.push(ef(performance.now()));
                                const s = performance.now() + 1e3 * n;
                                return Ye(Ce(e), Qe(0, 1e3).pipe(ke(()=>Math.floor((s - performance.now()) / 1e3)), vt(t1), mt((e)=>{
                                    let [, t1] = e;
                                    const { breakoutRoom: { controlStatus: o }, meeting: { isHost: r }, socket: { zoomSocketStatus: i } } = t1;
                                    return o === zp.Closing && i === yh.Connected && r;
                                }), gt((e)=>{
                                    let [t1] = e;
                                    t1 >= 0 && ep(Sc, {
                                        countdown: t1
                                    });
                                }), tt((e)=>{
                                    let [t1] = e;
                                    return t1 <= 0;
                                }), gt(()=>{
                                    oL.stopBO(zp.Closed);
                                }), Be(()=>ie)));
                            }
                        }));
                        break;
                    case zp.Closed:
                        l.push(ef(0)), s === Jp.Leaving ? l.push(Qv(Jp.MainSession)) : s === Jp.Invited ? l.push(Qv(Jp.Initial)) : s !== Jp.InRoom && s !== Jp.Joining || l.push(...zk()), Kk();
                }
            } catch (e) {
                console.error(e);
            }
            return c ? Ye(Ce(l), c) : Ce(l);
        })),
    epics3: (e, t1)=>ar(e, 4194).pipe(vt(t1), pt((e)=>{
            let [t1, o] = e;
            const { payload: { body: { bid: r, botoken: i, confID: n } } } = t1, { meeting: { isHost: s }, breakoutRoom: { rooms: a, currentRoom: { status: d } } } = o, u = [], l = a.find((e)=>e.boId === r);
            return l && (u.push(Zk(l, s)), u.push(Zv(n)), u.push(Yv(i)), s || d !== Jp.InRoom ? u.push(...qk(l.name, d)) : u.push(...Jk(l.name))), ep(_c, {
                boId: r
            }), Ce(u);
        })),
    epics4: (e, t1)=>e.pipe(Ot(`${Co}`, `${Oo}`), tt((e)=>7949 === e.payload.evt), vt(t1), Be((e)=>{
            var o;
            let [r, i] = e;
            const { payload: { body: n } } = r, { meeting: { userGUID: s }, breakoutRoom: { rooms: a, options: { isAutoJoinRoom: d, isAutoMovetoMainSession: u }, currentRoom: { status: l }, mainSessionAttendeeList: c }, participants: { attendeesList: p } } = i, { commandType: h } = n, m = [];
            let g;
            const v = null === (o = (Qk(l) ? p : c).find((e)=>e.userGUID === s)) || void 0 === o ? void 0 : o.userId;
            switch(h){
                case Qp.Join:
                    {
                        const { targetBID: e, botoken: t1, confID: o, joinReason: r, requestSourceID: u } = n, l = Gk(a, s);
                        if (l && l.boId === e) {
                            m.push(Zv(o)), m.push(Yv(t1));
                            const n = Number(r) === eh.Active && v === Number(u);
                            d || n ? (n && ep(_c, {
                                boId: e
                            }), m.push(...qk(l.name))) : (is.set(ns.WebclientBreakoutRoomCommand, h, os.SessionStorage), ep(yc, {
                                roomId: e,
                                name: l.name,
                                ...tL(u, i)
                            }));
                        }
                        break;
                    }
                case Qp.Switch:
                    {
                        const { targetBID: e, botoken: t1, confID: o, joinMethod: r, requestSourceID: u } = n, c = Gk(a, s);
                        if (c && c.boId === e) {
                            m.push(Jv({
                                boId: c.boId,
                                boToken: t1,
                                boConfId: o,
                                name: c.name
                            }));
                            const n = v === Number(u) && Number(r) === Xp.AskToLeave;
                            l === Jp.Invited ? (is.set(ns.WebclientBreakoutRoomCommand, h, os.SessionStorage), d || v === Number(u) ? m.push(...qk(c.name)) : ep(yc, {
                                roomId: e,
                                name: c.name,
                                ...tL(u, i)
                            })) : m.push(...Jk(c.name)), n && ep(_c, {
                                boId: e
                            });
                        }
                        break;
                    }
                case Qp.Leave:
                    {
                        const { waitTime: e, joinMethod: o } = n;
                        if (Qk(l)) m.push(Jv({
                            boId: "",
                            boToken: "",
                            boConfId: "",
                            status: Jp.Initial
                        }));
                        else {
                            const r = Number(e);
                            if (r > 0) {
                                const e = performance.now() + 1e3 * r;
                                g = Qe(0, 1e3).pipe(ke(()=>Math.floor((e - performance.now()) / 1e3)), vt(t1), mt((e)=>{
                                    let [t1, o] = e;
                                    const { breakoutRoom: { controlStatus: r, currentRoom: { status: i } }, meeting: { isHost: n }, socket: { zoomSocketStatus: s } } = o;
                                    return t1 >= 0 && s === yh.Connected && r === zp.Closing && i === Jp.InRoom && !n;
                                }), gt((e)=>{
                                    let [t1] = e;
                                    t1 >= 0 && ep(Sc, {
                                        countdown: t1
                                    });
                                }), dt(ie));
                            } else if (Number(o) !== Xp.AskToLeave || u) m.push(...zk());
                            else {
                                var f, y, S;
                                const { requestSourceID: e } = n, t1 = Number(e), { participants: { attendeesList: o } } = i;
                                let r = o.find((e)=>e.userId === t1);
                                if (!r) {
                                    const { breakoutRoom: { mainSessionAttendeeList: e } } = i;
                                    r = e.find((e)=>e.userId === t1);
                                }
                                ep(Dc, {
                                    inviterId: null === (f = r) || void 0 === f ? void 0 : f.userId,
                                    inviterGuid: null === (y = r) || void 0 === y ? void 0 : y.userGUID,
                                    inviterName: null === (S = r) || void 0 === S ? void 0 : S.displayName
                                });
                            }
                            Kk();
                        }
                        break;
                    }
                case Qp.Broadcast:
                    {
                        const { textContent: e, requestID: t1 } = n;
                        if (e) {
                            const { meeting: { encType: o }, participants: { attendeesList: r }, breakoutRoom: { mainSessionAttendeeList: n } } = i;
                            let s = "";
                            if (o === Is.AES_GCM) {
                                const e = (Qk(l) ? r : n).find((e)=>e.userId === Number(t1));
                                e && (s = e.zoomID);
                            }
                            g = Ce(ws.beginDecrypt({
                                decryptedText: e,
                                type: As.BO_BROADCAST,
                                zoomId: s
                            }).then((e)=>{
                                let { message: t1 } = e;
                                return ep(Ec, {
                                    message: t1
                                }), tf(t1);
                            }));
                        }
                        break;
                    }
                case Qp.HelpReq:
                    {
                        const { requestID: e } = n, { breakoutRoom: { mainSessionAttendeeList: t1, rooms: o, currentRoom: { boId: r }, hostReplyToQuestionerType: s, hostReplyToRequestId: a }, participants: { attendeesList: d } } = i;
                        if (e) {
                            if (l === Jp.InRoom) {
                                const o = t1.find((t1)=>t1.userId === e);
                                if (o && o.bid === r) {
                                    oL.askForHelpResultBO(e, Yp.AlreadyInRoom);
                                    break;
                                }
                            }
                            if (s === Yp.Received && a !== e) oL.askForHelpResultBO(e, Yp.Busy);
                            else {
                                oL.askForHelpResultBO(e, Yp.Received), m.push(of(Yp.Received), rf(e));
                                const r = (l === Jp.InRoom ? t1 : d).find((t1)=>t1.userId === e);
                                if (r) {
                                    const t1 = r.bid, i = o.find((e)=>e.boId === t1);
                                    i && ep(Ic, {
                                        userId: e,
                                        userGuid: r.userGUID,
                                        displayName: r.displayName,
                                        roomName: i.name,
                                        roomId: i.boId
                                    });
                                }
                            }
                        }
                        break;
                    }
                case Qp.HelpRes:
                    {
                        const { helpResult: e } = n;
                        ep(Ac, {
                            result: Number(e)
                        });
                        break;
                    }
                case Qp.BOActivity:
                    {
                        var b;
                        const { activityRoster: e, activityTalking: t1, requestID: o } = n, r = null === (b = (IT(i) ? i.breakoutRoom.mainSessionAttendeeList : i.participants.attendeesList).find((e)=>e.userId === o)) || void 0 === b ? void 0 : b.userGUID;
                        if (r) {
                            const { breakoutRoom: { rooms: n } } = i, s = Gk(n, r), a = function(e, t1) {
                                const o = {
                                    isTalking: 1 === t1
                                };
                                return eL.forEach((t1)=>{
                                    const { mask: r, key: i, value: n } = t1;
                                    return (r & e) === r && Object.assign(o, {
                                        [`${i}`]: n
                                    }), o;
                                }), o;
                            }(Number(e), Number(t1));
                            m.push(lf({
                                userGuid: r,
                                status: a
                            })), ep(Pc, {
                                ...a,
                                userId: o,
                                userGuid: r,
                                roomId: null == s ? void 0 : s.boId,
                                roomName: null == s ? void 0 : s.name
                            });
                        }
                        break;
                    }
            }
            return g ? Ye(Ce(m), g) : Ce(m);
        })),
    epics5: (e, t1)=>nr(e, Ls).pipe(vt(t1), pt((e)=>{
            let [t1, o] = e;
            const { payload: { body: { res: r, elapsed: i } } } = t1, n = [];
            return r === ui.MeetingHasClosed || r === ui.UserHasBeenRemoved ? (Kk(), n.push(...Wy(o, !1))) : r === ui.Success && (n.push(Wv(i)), n.push(Qv(Jp.InRoom)), is.set(ns.WebclientBreakoutRoomAttendeeStatus, JSON.stringify({
                status: Jp.InRoom,
                boId: o.breakoutRoom.currentRoom.boId
            }), os.SessionStorage)), Ce(n);
        })),
    epics6: (e)=>nr(e, Ds).pipe(ke((e)=>jA(e.payload.body)), Be((e)=>{
            const t1 = [
                nf(e)
            ];
            return ep(Oc), Ce(t1);
        })),
    epics7: (e, t1)=>nr(e, Ds).pipe(ke((e)=>jA(e.payload.body)), ke((e)=>{
            const t1 = [];
            return [
                "add",
                "update"
            ].forEach((o)=>e[o] && t1.push(...e[o])), t1.filter((e)=>[
                    ...rL,
                    "bAudioUnencrytped"
                ].some((t1)=>void 0 !== e[t1]));
        }), tt((e)=>e.length > 0), Ee(X), Be((e)=>{
            const o = [], { participants: { attendeesList: r }, breakoutRoom: { mainSessionAttendeeList: i, isUserRoleUpdated: n }, meeting: { userId: s } } = t1.value, a = e.map((e)=>{
                const t1 = i.find((t1)=>t1.userId === e.userId), a = r.find((e)=>e.userGUID === (null == t1 ? void 0 : t1.userGUID));
                if (a) {
                    if (void 0 !== e.bCCEditor && o.push(_v({
                        editorId: e.bCCEditor ? a.userId : "",
                        isEditor: !!e.bCCEditor,
                        editorZoomId: e.bCCEditor ? a.zoomID : ""
                    })), delete e.bRaiseHand, delete e.bCapsPinMultiVideo, !n && a.userId === s) {
                        const r = {};
                        Hp(e.userRole) ? Object.assign(r, e) : (i.some((e)=>e.isHost) || void 0 !== e.bAudioUnencrytped) && Object.assign(r, t1), void 0 !== r.userId && (o.push(df(!0)), ep(wc, e));
                    }
                    return {
                        ...e,
                        userId: a.userId
                    };
                }
            }).filter((e)=>!!e && rL.some((t1)=>void 0 !== e[t1]));
            return a.length > 0 && (ep(ma, a), o.push(Sp({
                update: a
            }))), Ce(o);
        })),
    epics8: (e)=>nr(e, Ps).pipe(tt((e)=>{
            const { payload: { body: t1 } } = e;
            return void 0 !== (null == t1 ? void 0 : t1.bAllowAttendeeRename) || void 0 !== (null == t1 ? void 0 : t1.chatPriviledge) || void 0 !== (null == t1 ? void 0 : t1.lockShare);
        }), ke((e)=>{
            const { payload: { body: t1 } } = e;
            return void 0 !== t1.bAllowAttendeeRename ? bn(e.payload.body) : void 0 !== t1.chatPriviledge ? cv(t1.chatPriviledge) : void 0 !== t1.lockShare ? pm(t1.lockShare) : void 0;
        })),
    epics9: (e, t1)=>ir(e, Ds).pipe(vt(t1), tt((e)=>{
            let [, t1] = e;
            const { meeting: { isHost: o }, breakoutRoom: { controlStatus: r, currentRoom: { status: i } } } = t1;
            return o && r === zp.Closing && i !== Jp.InRoom;
        }), Ee(X), gt(()=>{
            const { participants: { attendeesList: e } } = t1.value;
            e.every((e)=>!e.bid) && e.length > 1 && oL.stopBO(zp.Closed);
        }), dt(ie)),
    epics10: (e, t1)=>ir(e, 4214).pipe(vt(t1), pt((e)=>{
            let [o, r] = e;
            const { payload: { body: { proto: i } } } = o, { breakoutRoom: { rooms: n, isHugeBO: s } } = r;
            try {
                const e = JSON.parse($r(i)), o = [];
                if (e && e.PreAssignBoList && Array.isArray(e.PreAssignBoList)) {
                    const r = e.PreAssignBoList.map((e)=>({
                            name: e.BoName,
                            emails: e.email
                        }));
                    o.push(af(r));
                    const i = s ? 100 : 50;
                    if (n.length + r.length < i) {
                        const e = r.map((e)=>e.name);
                        return oL.batchCreateBOToken(e), Ye(Ce(o), Xk(e.length).pipe(vt(t1), Be((e)=>{
                            let [{ boIdList: t1 }, o] = e;
                            const i = ch(o), n = r.map((e, o)=>{
                                const { emails: r, name: n } = e;
                                let s = [];
                                return r && Array.isArray(r) && (s = r.map((e)=>i.filter((t1)=>t1.userEmail === e).map((e)=>e.userGUID)).reduce((e, t1)=>[
                                        ...e,
                                        ...t1
                                    ], [])), {
                                    boId: t1[o],
                                    name: n,
                                    attendeeGuidList: s
                                };
                            }), s = n.map((e, t1)=>({
                                    roomId: e.boId,
                                    name: e.name,
                                    emails: r[t1].emails
                                }));
                            return ep(Tc, {
                                rooms: s
                            }), Ce([
                                qv(n),
                                af(s)
                            ]);
                        })));
                    }
                    return Ce(o);
                }
            } catch (e) {
                console.error("pre assign proto is not valid");
            }
            return ie;
        })),
    epics11: (e, t1)=>ar(e, Ds).pipe(vt(t1), tt((e)=>{
            let [t1, o] = e;
            const { meeting: { isHost: r, meetingStatus: i, meetingOptions: n }, breakoutRoom: { controlStatus: s } } = o, { payload: { body: a } } = t1;
            return i === Yn.Joined && (null == n ? void 0 : n.isAllowBreakoutRoomPreAssign) && r && (s === zp.NotStarted || s === zp.InProgress) && Array.isArray(a.add);
        }), Be((e)=>{
            let [t1, o] = e;
            const { breakoutRoom: { controlStatus: r, rooms: i, preAssignedRooms: n, currentRoom: { status: s } }, participants: { failoverAttendeesList: a } } = o, d = null == n ? void 0 : n.filter((e)=>i.findIndex((t1)=>t1.boId === e.roomId) > -1), { payload: { body: { add: u } } } = t1, l = [];
            return d.length > 0 && u.filter((e)=>e.userEmail && e.userGUID).filter((e)=>-1 === a.findIndex((t1)=>t1.zoomID === e.zoomID)).forEach((e)=>{
                if (!Gk(i, e.userGUID)) for(let o = 0; o < (null == d ? void 0 : d.length); o++){
                    const n = d[o];
                    if (n.emails.includes(e.userEmail)) {
                        if (r === zp.NotStarted) {
                            const t1 = TI(i, (t1)=>{
                                const o = t1.find((e)=>e.boId === n.roomId);
                                null == o || o.attendeeGuidList.push(e.userGUID);
                            });
                            l.push(qv(t1));
                        } else r === zp.InProgress && (s === Jp.InRoom && t1.type === `${Oo}` ? oL.assignToBO(e.id, String(n.roomId)) : s !== Jp.Initial && s !== Jp.MainSession || oL.assignToBO(e.id, String(n.roomId)));
                        break;
                    }
                }
            }), Ce(l);
        })),
    epics12: (e, t1)=>ir(e, Ds).pipe(tt((e)=>{
            const { breakoutRoom: { mainSessionAttendeeList: o } } = t1.value, { payload: { body: r } } = e;
            return o.length > 0 && (void 0 !== r.add || void 0 !== r.update);
        }), Ee(ee), ke((e)=>jA(e.payload.body)), Be((e)=>{
            const { breakoutRoom: { mainSessionAttendeeList: o, isUserRoleUpdated: r }, participants: { attendeesList: i } } = t1.value;
            let n = [];
            const s = [];
            [
                "add",
                "update"
            ].forEach((t1)=>e[t1] && n.push(...e[t1]));
            const a = [
                ...rL,
                "isHost"
            ];
            n = n.filter((e)=>a.some((t1)=>void 0 !== e[t1]));
            const d = n.filter((e)=>void 0 !== e.zoomID);
            return n = n.map((e)=>{
                var t1, n, u, l;
                const c = null !== (t1 = null !== (n = e.zoomID) && void 0 !== n ? n : null === (u = d.find((t1)=>t1.userId === e.userId)) || void 0 === u ? void 0 : u.zoomID) && void 0 !== t1 ? t1 : null === (l = i.find((t1)=>t1.userId === e.userId)) || void 0 === l ? void 0 : l.zoomID;
                if (c) {
                    const t1 = o.find((e)=>e.zoomID === c);
                    if (t1) return r || (s.push(df(!0)), ep(wc, t1)), Object.keys(e).filter((t1)=>Object.prototype.hasOwnProperty.call(e, t1)).filter((e)=>a.includes(e)).reduce((o, r)=>{
                        const i = t1[r];
                        if (void 0 !== i || "bCoHost" === r) {
                            const t1 = "boolean" == typeof e[r] ? !!i : i;
                            Object.assign(o, {
                                [r]: t1
                            });
                        }
                        return o;
                    }, {
                        userId: e.userId
                    });
                }
            }).filter(Boolean), n.length > 0 && (ep(ma, n), s.push(Sp({
                update: n
            }))), Ce(s);
        })),
    epics13: (e)=>nr(e, 7999).pipe(gt((e)=>{
            const { payload: { body: { bStatus: t1 } } } = e;
            ep(Mc, {
                status: !!t1
            });
        }), Be(()=>ie)),
    epics14: (e, t1)=>ir(e, 7940).pipe(Be((e)=>{
            const { payload: { body: { bHost: o } } } = e, { breakoutRoom: { isBroadcastVoice: r } } = t1.value, i = [];
            return !o && r && (la.getInstance().broadcastVoiceToBreakoutRoom(!1), i.push(cf(!1))), Ce(i);
        }))
}, hL = rr(pL, cL);
let mL = function(e) {
    return e[e.Ready = 0] = "Ready", e[e.UserSub = 1] = "UserSub", e[e.ManualCaptionerEnabled = 2] = "ManualCaptionerEnabled", e[e.ManualCaptionerDisabled = 3] = "ManualCaptionerDisabled", e;
}({}), gL = function(e) {
    return e[e.Unspecified = -1] = "Unspecified", e[e.English = 0] = "English", e[e["Chinese (Simplified)"] = 1] = "Chinese (Simplified)", e[e.Japanese = 2] = "Japanese", e[e.German = 3] = "German", e[e.French = 4] = "French", e[e.Russian = 5] = "Russian", e[e.Portuguese = 6] = "Portuguese", e[e.Spanish = 7] = "Spanish", e[e.Korean = 8] = "Korean", e[e.Italian = 9] = "Italian", e[e.Reserved = 10] = "Reserved", e[e.Vietnamese = 11] = "Vietnamese", e[e.Dutch = 12] = "Dutch", e[e.Ukrainian = 13] = "Ukrainian", e[e.Arabic = 14] = "Arabic", e[e["Chinese (Traditional)"] = 16] = "Chinese (Traditional)", e[e.Czech = 17] = "Czech", e[e.Estonian = 18] = "Estonian", e[e.Finnish = 19] = "Finnish", e[e.Hebrew = 21] = "Hebrew", e[e.Hindi = 22] = "Hindi", e[e.Hungarian = 23] = "Hungarian", e[e.Indonesian = 24] = "Indonesian", e[e.Malay = 25] = "Malay", e[e.Persian = 26] = "Persian", e[e.Polish = 27] = "Polish", e[e.Romanian = 28] = "Romanian", e[e.Swedish = 29] = "Swedish", e[e.Tamil = 30] = "Tamil", e[e.Telugu = 31] = "Telugu", e[e.Tagalog = 32] = "Tagalog", e[e.Turkish = 33] = "Turkish", e[e["French (Canada)"] = 34] = "French (Canada)", e[e.Danish = 35] = "Danish", e[e.Thai = 37] = "Thai", e[e.Cantonese = 44] = "Cantonese", e[e.NoTranslation = 400] = "NoTranslation", e[e.DefaultManualInput = 401] = "DefaultManualInput", e[e.Customized = 500] = "Customized", e;
}({}), vL = function(e) {
    return e[e.Unknown = 0] = "Unknown", e[e.Close = 1] = "Close", e[e.New = 2] = "New", e[e.Insert = 3] = "Insert", e[e.Delete = 4] = "Delete", e[e.Reset = 5] = "Reset", e[e.Audiodesc = 6] = "Audiodesc", e[e.Speaker = 7] = "Speaker", e[e.Error = 8] = "Error", e;
}({}), fL = function(e) {
    return e[e.TranslateNotSupport = 1] = "TranslateNotSupport", e;
}({}), yL = function(e) {
    return e[e.Unspecified = 0] = "Unspecified", e[e.InMeetingManual = 1] = "InMeetingManual", e[e.ExternalCaptioner = 2] = "ExternalCaptioner", e[e.ASR = 4] = "ASR", e;
}({});
const SL = {
    en: 0,
    zh: 1,
    ja: 2,
    de: 3,
    fr: 4,
    ru: 5,
    pt: 6,
    es: 7,
    ko: 8,
    it: 9,
    en1: 10,
    vi: 11,
    nl: 12,
    uk: 13,
    ar: 14,
    "zh-hant": 16,
    cs: 17,
    et: 18,
    fi: 19,
    he: 21,
    hi: 22,
    hu: 23,
    id: 24,
    ms: 25,
    fa: 26,
    pl: 27,
    ro: 28,
    sv: 29,
    ta: 30,
    te: 31,
    tl: 32,
    tr: 33,
    "fr-ca": 34,
    da: 35,
    th: 37,
    "zh-yue": 44,
    ca: 48
}, bL = Object.keys(gL).filter((e)=>/\d+/.test(gL[e])).reduce((e, t1)=>({
        ...e,
        [`${gL[t1]}`]: t1
    }), {}), EL = Object.keys(SL).reduce((e, t1)=>(Object.assign(e, {
        [`${SL[`${t1}`]}`]: t1
    }), e), {}), IL = "zoom-sdk-live-trasncription", AL = "live-trasncription";
let CL = function(e) {
    return e[e.English = 0] = "English", e[e.Chinese = 1] = "Chinese", e[e.Japanese = 2] = "Japanese", e[e.German = 3] = "German", e[e.French = 4] = "French", e[e.Russian = 5] = "Russian", e[e.Portuguese = 6] = "Portuguese", e[e.Spanish = 7] = "Spanish", e[e.Korean = 8] = "Korean", e[e.Italian = 9] = "Italian", e[e.Reserved = 10] = "Reserved", e[e.Vietnamese = 11] = "Vietnamese", e[e.Dutch = 12] = "Dutch", e[e.Ukrainian = 13] = "Ukrainian", e[e.Arabic = 14] = "Arabic", e[e["Chinese (Traditional)"] = 16] = "Chinese (Traditional)", e[e.Czech = 17] = "Czech", e[e.Estonian = 18] = "Estonian", e[e.Finnish = 19] = "Finnish", e[e.Hebrew = 21] = "Hebrew", e[e.Hindi = 22] = "Hindi", e[e.Hungarian = 23] = "Hungarian", e[e.Indonesian = 24] = "Indonesian", e[e.Malay = 25] = "Malay", e[e.Persian = 26] = "Persian", e[e.Polish = 27] = "Polish", e[e.Romanian = 28] = "Romanian", e[e.Swedish = 29] = "Swedish", e[e.Tamil = 30] = "Tamil", e[e.Telugu = 31] = "Telugu", e[e.Tagalog = 32] = "Tagalog", e[e.Turkish = 33] = "Turkish", e[e["French (Canada)"] = 34] = "French (Canada)", e[e.Danish = 35] = "Danish", e[e.Thai = 37] = "Thai", e[e.Cantonese = 44] = "Cantonese", e[e.Catalan = 48] = "Catalan", e[e.NoTranslation = 400] = "NoTranslation", e[e.DefaultManualInput = 401] = "DefaultManualInput", e;
}({}), _L = function(e) {
    return e.English = "en", e["Chinese (Simplified)"] = "zh", e.Japanese = "ja", e.German = "de", e.French = "fr", e.Russian = "ru", e.Portuguese = "pt", e.Spanish = "es", e.Korean = "ko", e.Italian = "it", e.Reserved = "en1", e.Vietnamese = "vi", e.Dutch = "nl", e.Ukrainian = "uk", e.Arabic = "ar", e["Chinese (Traditional)"] = "zh-hant", e.Czech = "cs", e.Estonian = "et", e.Finnish = "fi", e.Hebrew = "he", e.Hindi = "hi", e.Hungarian = "hu", e.Indonesian = "id", e.Malay = "ms", e.Persian = "fa", e.Polish = "pl", e.Romanian = "ro", e.Swedish = "sv", e.Tamil = "ta", e.Telugu = "te", e.Tagalog = "tl", e.Turkish = "tr", e["French (Canada)"] = "fr-ca", e.Danish = "da", e.Thai = "th", e.Cantonese = "zh-yue", e.Catalan = "ca", e;
}({});
function RL(e) {
    const t1 = e === gL.Unspecified ? gL.Reserved : e;
    la.getInstance().selectLanguageChannelForNewLTT(t1);
}
const wL = Lp(kp, function(e, t1) {
    return qR(e, t1);
})([
    ch,
    (e)=>{
        let { meeting: { gatewayUserList: t1 } } = e;
        return t1;
    }
], (e, t1)=>{
    const o = {};
    return e.forEach((e)=>{
        Object.assign(o, {
            [`${e.userId}`]: e.zoomID
        });
    }), null == t1 || t1.forEach((e)=>{
        Object.assign(o, {
            [`${e.userId}`]: e.sn
        });
    }), o;
}), TL = Np([
    ch
], (e)=>e.find((e)=>!0 === e.bCCEditor)), OL = Np([
    ch,
    Up
], (e, t1)=>e.some((e)=>!0 === e.bCCEditor && e.userId === t1)), DL = ra.createAgent(), PL = {
    isEnableTranslatedCaptions: !1,
    isHostLockSpeakingLanguage: !1,
    transcriptionLang: [],
    isEnableAutomatedCaptions: !1,
    supportedTranscriptionLanguage: [],
    isLiveTranscriptionEnabled: !1,
    isHostDisableCaptions: !1,
    isManualCaptionerEnabled: !1,
    gatewayId: void 0,
    isLiveTranscriptionSubscribed: !1,
    messageRecords: [],
    isRecordsReduced: !1,
    reducedRecordsCount: 0
}, ML = So({
    [`${Vf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isLiveTranscriptionEnabled = o;
    }),
    [`${Uf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { transcriptionLang: r, translatedSetting: i, ...n } = o;
        r && (e.transcriptionLang = r.split(";").map((e)=>{
            const t1 = e && SL[e];
            return void 0 !== t1 ? {
                lang: e,
                code: t1
            } : null;
        }).filter(Boolean)), i && (e.translatedSetting = Object.keys(i).map((e)=>{
            const t1 = i[e];
            if (t1) {
                const o = t1.split(";").map((e)=>{
                    const t1 = e && SL[e];
                    return void 0 !== t1 ? {
                        lang: e,
                        code: t1
                    } : null;
                }).filter(Boolean);
                return {
                    lang: e,
                    code: SL[e],
                    translatedToLanguage: o
                };
            }
            return null;
        }).filter(Boolean)), Object.assign(e, n);
    }),
    [`${jf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isManualCaptionerEnabled = o;
    }),
    [`${xf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.gatewayId = o;
    }),
    [`${Zf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isHostDisableCaptions = o;
    }),
    [`${Bf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.supportedTranscriptionLanguage = o;
    }),
    [`${Hf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.currentTranscriptionLang = o;
    }),
    [`${$f}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.currentTranslationLang = o;
    }),
    [`${Wf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.messageRecords.push(o);
    }),
    [`${Gf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const r = e.messageRecords.find((e)=>e.msgId === o.msgId);
        r && Object.assign(r, o);
    }),
    [`${Kf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        const { remains: r, reducedRecordsCount: i } = o, n = e.messageRecords.length - r;
        e.isRecordsReduced = !0, e.reducedRecordsCount = i, e.messageRecords.splice(0, n);
    }),
    [`${Ff}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isLiveTranscriptionSubscribed = o;
    }),
    [`${zf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.liveTransEngineType = o;
    }),
    [`${qf}`]: TI((e)=>{
        e.stateBeforeFailover = void 0;
    }),
    [`${Jf}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.lastManualCaption = o;
    }),
    [`${Qf}`]: (e, t1)=>{
        let { payload: o } = t1;
        return o ? {
            ...PL,
            stateBeforeFailover: {
                currentTranscriptionLang: e.currentTranscriptionLang,
                currentTranslationLang: e.currentTranslationLang,
                isLiveTranscriptionSubscribed: e.isLiveTranscriptionSubscribed
            },
            messageRecords: e.messageRecords,
            isRecordsReduced: e.isRecordsReduced,
            reducedRecordsCount: e.reducedRecordsCount
        } : {
            ...PL
        };
    }
}, PL);
var kL;
const LL = ra.createAgent(), NL = hT("Live transcription");
let VL = (kL = class extends gT {
    startLiveTranscription() {
        const { [tT]: e, [oT]: t1 } = this, { liveTranscription: { isLiveTranscriptionEnabled: o, isEnableTranslatedCaptions: r, isLiveTranscriptionSubscribed: i, isHostLockSpeakingLanguage: n, isHostDisableCaptions: s } } = e();
        return i ? Promise.resolve("") : s ? Promise.reject({
            type: Gl,
            reason: "Captions has been disabled by host."
        }) : o ? (LL.enableNewLLT(), rp(Da).then(()=>(n ? LL.setSpokenLanguage(gL.English) : RL(gL.Unspecified), t1(Hf(gL.English)), r && LL.setTranslationLanguage(), rp({
                event: Da,
                operations: [
                    tt((e)=>!0 === e.autoCaption && void 0 !== e.lang)
                ]
            })))) : Promise.reject({
            type: Gl,
            reason: "Live transcription is not enabled."
        });
    }
    disableCaptions(e) {
        const { [tT]: t1 } = this, { liveTranscription: { isHostDisableCaptions: o } } = t1();
        return e ? o ? Promise.resolve() : (LL.disableCaptions(!0), rp(Ma)) : o ? (LL.disableCaptions(!1), rp(Ma)) : Promise.resolve();
    }
    setSpeakingLanguage(e) {
        const { [tT]: t1, [oT]: o } = this, { liveTranscription: { isLiveTranscriptionSubscribed: r, isHostLockSpeakingLanguage: i, transcriptionLang: n } } = t1(), s = n.find((t1)=>t1.lang === e);
        if (s) {
            const { code: e } = s;
            return r ? (i ? LL.setSpokenLanguage(e) : RL(e), o(Hf(e)), Promise.resolve("")) : Promise.reject({
                type: Gl,
                reason: "Cannot set speaking language before starting live transcription"
            });
        }
        return Promise.reject({
            type: Ql,
            reason: "Unsupported transcription language"
        });
    }
    setTranslationLanguage(e) {
        const { [tT]: t1, [oT]: o } = this, r = t1(), { liveTranscription: { isEnableTranslatedCaptions: i, isLiveTranscriptionSubscribed: n, translatedSetting: s, currentTranscriptionLang: a } } = r;
        if (!i) return Promise.reject({
            type: Gl,
            reason: "Live translation is not enabled."
        });
        if (!n) return Promise.reject({
            type: Gl,
            reason: "Cannot set translation language before starting live transcription"
        });
        if (e) {
            const t1 = null == s ? void 0 : s.find((e)=>e.code === a);
            if (t1) {
                const { translatedToLanguage: o } = t1, r = o.find((t1)=>t1.lang === e);
                if (r) return LL.setTranslationLanguage(r.code), rp({
                    event: Da,
                    operations: [
                        tt((e)=>!0 === e.autoCaption && e.lang === r.code),
                        it(1)
                    ]
                }, (e)=>{
                    let { lang: t1 } = e;
                    return t1 === r.code;
                });
            }
            return Promise.reject({
                type: Gl,
                reason: `Cannot support translating ${bL[a || 0]} to ${e}`
            });
        }
        return LL.setTranslationLanguage(), o($f(void 0)), Promise.resolve("");
    }
    enableManualCaptioner() {
        const { [tT]: e } = this, { meeting: { meetingOptions: t1 }, liveTranscription: { isManualCaptionerEnabled: o, isHostDisableCaptions: r } } = e();
        if (r) return Promise.reject({
            type: Gl,
            reason: "Captions has been disabled by host."
        });
        const { isEnableManualCaptions: i, isEnableClosedCaption: n } = t1;
        return (null != i ? i : n) ? o ? Promise.resolve() : (LL.enableManualCaption(!0), rp(Da, (e)=>{
            let { autoCaption: t1 } = e;
            return !1 === t1;
        })) : Promise.reject({
            type: Gl,
            reason: "Manual caption is not enabled."
        });
    }
    disableManualCaptioner() {
        const { [tT]: e } = this, { liveTranscription: { isManualCaptionerEnabled: t1 } } = e();
        return t1 ? (LL.enableManualCaption(!1), rp(Da, (e)=>{
            let { autoCaption: t1 } = e;
            return !0 === t1;
        })) : Promise.resolve();
    }
    assignManualCaption(e) {
        var t1;
        const { [tT]: o } = this, r = o(), { liveTranscription: { isManualCaptionerEnabled: i }, participants: { attendeesList: n }, meeting: { userId: s } } = r;
        if (!i) return Promise.reject({
            type: Gl,
            reason: "Cannot assign caption editor due to the manual captioner is not enabled."
        });
        if ((null === (t1 = TL(r)) || void 0 === t1 ? void 0 : t1.userId) === e) return Promise.resolve("");
        const a = n.find((t1)=>t1.userId === e);
        return a ? (LL.assignCC(e, !0), rp({
            event: s === e ? pa : ma,
            operations: [
                tt((t1)=>t1.userId === e),
                it(1)
            ]
        }, (e)=>!0 === e.bCCEditor)) : Promise.reject({
            type: Ql,
            reason: "Cannot find the user"
        });
    }
    sendCaptionTextManually(e, t1) {
        var o;
        const { [tT]: r, [oT]: i } = this, n = r(), { liveTranscription: { lastManualCaption: s }, meeting: { userId: a } } = n, d = sh(n);
        let u = Promise.resolve();
        const l = null === (o = TL(n)) || void 0 === o ? void 0 : o.userId;
        return null != d && d.isHost && l !== a && (u = this.assignManualCaption(a)), u.then(()=>OL(r()) ? function(e, t1, o) {
                const r = e.length, i = [];
                var n;
                if (o) i.push({
                    op: "close",
                    text: e,
                    msgId: null !== (n = null == t1 ? void 0 : t1.msgId) && void 0 !== n ? n : Jr()
                });
                else if (t1 && null != t1 && t1.text) {
                    const o = t1.text.length;
                    let n = 0, s = 0;
                    for(; e[n] === t1.text[n] && n < r;)s += zr(e[n]), n += 1;
                    n === o && n === r ? i.push({
                        op: "same"
                    }) : n === o && n < r ? i.push({
                        op: "insert",
                        text: e.slice(n),
                        size: 0,
                        pos: s,
                        msgId: t1.msgId
                    }) : n < o && n === r ? i.push({
                        op: "delete",
                        size: 0,
                        pos: s,
                        msgId: t1.msgId
                    }) : (i.push({
                        op: "delete",
                        size: 0,
                        pos: s,
                        msgId: t1.msgId
                    }), i.push({
                        op: "insert",
                        text: e.slice(n),
                        pos: s,
                        msgId: t1.msgId
                    }));
                } else r > 0 && i.push({
                    op: "start",
                    text: e,
                    pos: 0,
                    size: 0,
                    msgId: Jr()
                });
                return i.filter((e)=>"same" !== e.op);
            }(e, s, t1) : Promise.reject({
                type: ql,
                reason: "Cannot type caption "
            })).then((e)=>Array.isArray(e) ? (e.forEach((e)=>{
                const { text: o, ...r } = e;
                ws.beginEncrypt({
                    text: null != o ? o : "",
                    type: As.CC_MESSAGE
                }).then((n)=>{
                    LL.sendManualCaption({
                        text: n,
                        ...r
                    });
                    const s = t1 ? void 0 : {
                        text: o,
                        msgId: e.msgId
                    };
                    i(Jf(s));
                });
            }), rp(Oa, (e)=>e.source === yL.InMeetingManual)) : "");
    }
    getLiveTranscriptionStatus() {
        const { [tT]: e } = this, { liveTranscription: { isLiveTranscriptionEnabled: t1, isEnableTranslatedCaptions: o, isManualCaptionerEnabled: r, transcriptionLang: i, translatedSetting: n, isHostDisableCaptions: s } } = e();
        return {
            isLiveTranscriptionEnabled: t1,
            isLiveTranslationEnabled: o,
            isHostDisableCaptions: s,
            isManualCaptionerEnabled: r,
            transcriptionLanguage: i.map((e)=>e.lang).join(";"),
            translationLanguage: null == n ? void 0 : n.map((e)=>({
                    speakingLanguage: e.lang,
                    translatedToLanguage: e.translatedToLanguage.map((e)=>e.lang).join(";")
                }))
        };
    }
    getLiveTranscriptionSetting() {
        const { [tT]: e } = this, { meeting: { meetingOptions: t1 } } = e(), { isEnableManualCaptions: o, isEnableLiveTranscription: r, isEnableClosedCaption: i, isEnableAllowThirdPartyCCToken: n, isEnableViewFullTranscript: s, isEnableSaveCaptions: a } = t1 || {};
        return {
            isEnableManualCaptions: o,
            isEnableLiveTranscription: r,
            isEnableClosedCaption: i,
            isEnableAllowThirdPartyCCToken: n,
            isEnableViewFullTranscript: s,
            isEnableSaveCaptions: a
        };
    }
    getCurrentTranscriptionLanguage() {
        const { [tT]: e } = this, { liveTranscription: { currentTranscriptionLang: t1 } } = e();
        return void 0 !== t1 ? {
            code: EL[t1],
            name: bL[t1]
        } : null;
    }
    getCurrentTranslationLanguage() {
        const { [tT]: e } = this, { liveTranscription: { currentTranslationLang: t1 } } = e();
        return void 0 !== t1 ? {
            code: EL[t1],
            name: bL[t1]
        } : null;
    }
    getLatestTranscription() {
        const { [tT]: e } = this, { liveTranscription: { messageRecords: t1, isManualCaptionerEnabled: o } } = e(), r = o ? gL.DefaultManualInput : gL.NoTranslation, i = t1.filter((e)=>e.language === r);
        return i.length ? i[i.length - 1].text : "";
    }
    getLatestTranslation() {
        const { [tT]: e } = this, { liveTranscription: { messageRecords: t1, currentTranslationLang: o, isEnableTranslatedCaptions: r } } = e();
        if (r || void 0 !== o) {
            const e = t1.filter((e)=>e.language === o);
            return e.length ? e[e.length - 1].text : "";
        }
        return "";
    }
    getFullTranscriptionHistory() {
        const { [tT]: e } = this, t1 = e(), { liveTranscription: { messageRecords: o, isRecordsReduced: r } } = t1;
        return r ? (function(e) {
            return void 0 !== window.indexedDB ? new Promise((t1)=>{
                const o = window.indexedDB.open(IL, 1);
                o.addEventListener("success", ()=>{
                    const r = o.result;
                    if (r.objectStoreNames.contains(AL)) {
                        const o = r.transaction([
                            AL
                        ], "readonly").objectStore(AL), i = [], n = e.meeting.meetingId, s = o.openCursor();
                        s.onsuccess = ()=>{
                            const e = s.result;
                            e ? (e.value.mid === n && i.push(...e.value.records), e.continue()) : (t1(i), r.close());
                        };
                    } else t1("");
                });
            }) : Promise.resolve("");
        })(t1).then((e)=>Array.isArray(e) ? e.concat(o) : [
                ...o
            ]) : [
            ...o
        ];
    }
    getManualCaptionEditor() {
        const { [tT]: e } = this, t1 = e(), { closedCaption: { editorId: o } } = t1;
        let r;
        if (!o) return {};
        if (r = ch(t1).find((e)=>e.userId === o), !r) return {};
        const { userId: i, isHost: n, displayName: s, avatar: a, bCoHost: d, zoomID: u } = r;
        return {
            userId: i,
            isHost: n,
            displayName: s,
            avatar: a,
            bCoHost: d,
            zoomID: u
        };
    }
    getManualCaptionUrl() {
        const { [tT]: e } = this, { meeting: { meetingOptions: t1, ccUrl: o } } = e(), { isEnableManualCaptions: r } = t1 || {};
        return r ? o : (console.warn("you not enable manual caption"), "");
    }
}, Xw(kL.prototype, "startLiveTranscription", [
    nT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "startLiveTranscription"), kL.prototype), Xw(kL.prototype, "disableCaptions", [
    aT,
    nT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "disableCaptions"), kL.prototype), Xw(kL.prototype, "setSpeakingLanguage", [
    nT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "setSpeakingLanguage"), kL.prototype), Xw(kL.prototype, "setTranslationLanguage", [
    nT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "setTranslationLanguage"), kL.prototype), Xw(kL.prototype, "enableManualCaptioner", [
    aT,
    nT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "enableManualCaptioner"), kL.prototype), Xw(kL.prototype, "disableManualCaptioner", [
    aT,
    nT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "disableManualCaptioner"), kL.prototype), Xw(kL.prototype, "assignManualCaption", [
    nT,
    aT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "assignManualCaption"), kL.prototype), Xw(kL.prototype, "sendCaptionTextManually", [
    nT,
    NL
], Object.getOwnPropertyDescriptor(kL.prototype, "sendCaptionTextManually"), kL.prototype), kL);
const UL = {
    epics0: (e)=>e.pipe(Ot(`${cn}`), ke((e)=>{
            const { payload: { liveTranscription: t1 } } = e;
            return Uf(t1);
        })),
    epics1: (e, t1)=>ir(e, Ps).pipe(tt((e)=>{
            var t1, o;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.NewLttAvaliable) || void 0 !== (null === (o = e.payload.body) || void 0 === o ? void 0 : o.LiveTransEngineType);
        }), ke((e)=>{
            const { payload: { body: { NewLttAvaliable: o, LiveTransEngineType: r } } } = e, { liveTranscription: { isEnableAutomatedCaptions: i } } = t1.value;
            return void 0 !== o ? (ep(Pa, !!o), Vf(i && !!o)) : zf(r);
        })),
    epics2: (e, t1)=>ir(e, 7982).pipe(Be((e)=>{
            const { payload: { body: { status: o, gwId: r } } } = e, i = [];
            switch(o){
                case mL.Ready:
                    i.push(xf(r));
                    break;
                case mL.ManualCaptionerEnabled:
                    ep(Da, {
                        autoCaption: !1
                    }), i.push(jf(!0));
                    break;
                case mL.ManualCaptionerDisabled:
                    ep(Da, {
                        autoCaption: !0
                    }), i.push(_v({
                        editorId: "",
                        isEditor: !1,
                        editorZoomId: ""
                    })), i.push(jf(!1));
                    break;
                case mL.UserSub:
                    {
                        ep(Da, {
                            autoCaption: t1.value.liveTranscription.isLiveTranscriptionEnabled
                        });
                        const { liveTranscription: { stateBeforeFailover: e } } = t1.value;
                        if (null != e && e.isLiveTranscriptionSubscribed) {
                            var n;
                            DL.enableNewLLT();
                            const t1 = null !== (n = e.currentTranscriptionLang) && void 0 !== n ? n : gL.Unspecified;
                            RL(t1), i.push(Hf(t1)), void 0 !== e.currentTranslationLang && DL.setTranslationLanguage(e.currentTranslationLang), i.push(qf());
                        }
                        break;
                    }
            }
            return Ce(i);
        })),
    epics3: (e)=>ir(e, 7984).pipe(ke((e)=>{
            const { payload: { body: { langs: t1 } } } = e;
            return Bf(t1);
        })),
    epics4: (e)=>ir(e, 8011).pipe(Be((e)=>{
            const { payload: { body: { disabled: t1 } } } = e, o = [];
            return ep(Ma, t1), o.push(Zf(t1)), t1 && o.push(Ff(!1)), Ce(o);
        })),
    epics5: (e)=>ir(e, 7985).pipe(tt((e)=>{
            var t1;
            return !0 === (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.success);
        }), Be((e)=>{
            const { payload: { body: { src: t1, lang: o, success: r } } } = e, i = [];
            return r && i.push(Ff(!0)), t1 === yL.ASR ? (o === gL.NoTranslation ? i.push($f(void 0)) : i.push($f(o)), ep(Da, {
                autoCaption: !0,
                lang: o
            })) : [
                yL.InMeetingManual,
                yL.ExternalCaptioner
            ].includes(t1) && ep(Da, {
                autoCaption: !1
            }), Ce(i);
        })),
    epics6: (e, t1)=>ir(e, 7986).pipe(vt(t1), Be((e)=>{
            let [t1, o] = e;
            const r = sh(o), { liveTranscription: { currentTranscriptionLang: i } } = o, { payload: { body: n } } = t1, s = [];
            if (void 0 !== (null == n ? void 0 : n.lang)) {
                const { lang: e } = n;
                "computer" === (null == r ? void 0 : r.audio) && i !== e && RL(e), s.push(Hf(e));
            }
            return Ce(s);
        })),
    epics7: (e, t1)=>dr(e, nd.JoinComputerAudioComplete).pipe(tt(()=>t1.value.liveTranscription.isLiveTranscriptionSubscribed), gt(()=>{
            const { liveTranscription: { currentTranscriptionLang: e } } = t1.value;
            e && RL(e);
        }), dt(ie)),
    epics8: (e, t1)=>ir(e, 7983).pipe(tt((e)=>void 0 !== e.payload.body), Be((e)=>{
            const { payload: { body: { msgType: o, errorCode: r, language: i, source: n, content: s, keyNodeId: a, msgId: d, nodeId: u, pos: l, size: c, audioLanguage: p } } } = e;
            if (o === vL.Error) {
                if (r === fL.TranslateNotSupport) {
                    const { liveTranscription: { currentTranslationLang: e } } = t1.value;
                    e && ep(Oa, {
                        error: fL.TranslateNotSupport,
                        errorMessage: `${bL[p]} to ${bL[e]} translation is not supported!`,
                        audioLanguage: p,
                        translationLang: e
                    });
                }
            } else {
                const e = t1.value, r = ch(e), { liveTranscription: { isManualCaptionerEnabled: p } } = e;
                if (p && n === yL.ASR) return Promise.resolve();
                if (function(e, t1) {
                    const { liveTranscription: { isEnableTranslatedCaptions: o, isLiveTranscriptionEnabled: r }, meeting: { meetingOptions: i } } = t1, { isEnableManualCaptions: n, isEnableAllowHostAssignTypeCC: s, isEnableClosedCaption: a, isEnableAllowThirdPartyCCToken: d } = i;
                    return e === yL.ASR ? o || r : e === yL.InMeetingManual ? n && s || void 0 === n && a : e === yL.ExternalCaptioner ? d : void 0;
                }(n, e) && s && a) {
                    const h = wL(e)[a];
                    if (h) return ws.beginDecrypt({
                        decryptedText: s,
                        type: As.CC_MESSAGE,
                        zoomId: h
                    }).then((e)=>{
                        let { message: s } = e;
                        const { liveTranscription: { messageRecords: a } } = t1.value, h = [], m = a.find((e)=>e.msgId === d);
                        if (m) {
                            const { text: e } = m, t1 = ((e, t1)=>{
                                if (!e || 0 === t1) return "";
                                let o = 0;
                                for(let r = 0; r < e.length; r++)if (o += zr(e[r]), o === t1) return e.slice(0, r + 1);
                                return e;
                            })(e, l);
                            let r;
                            o === vL.Insert && 0 === c || o === vL.Delete && 0 === c ? r = {
                                ...m,
                                text: t1 + s,
                                msgType: o
                            } : o === vL.Close && (r = {
                                ...m,
                                text: s,
                                msgType: o,
                                done: !0
                            }), r && (h.push(Gf(r)), ep(Oa, r));
                        } else if ([
                            vL.New,
                            vL.Close
                        ].includes(o) || p && o === vL.Insert) {
                            const e = r.find((e)=>e.userId === u), t1 = {
                                msgId: d,
                                userId: u,
                                displayName: null == e ? void 0 : e.displayName,
                                avatar: null == e ? void 0 : e.avatar,
                                text: s,
                                source: n,
                                language: i,
                                timestamp: (new Date).getTime(),
                                done: o === vL.Close
                            };
                            h.push(Wf({
                                ...t1,
                                msgType: o
                            })), ep(Oa, t1);
                        }
                        return h;
                    });
                }
            }
            return Promise.resolve();
        }), Be((e)=>Array.isArray(e) ? Ce(e) : ie)),
    epics9: (e, t1)=>e.pipe(Ot(`${Wf}`), Ee(X), Be(()=>{
            const { liveTranscription: { messageRecords: e } } = t1.value;
            return e.length >= 1e5 ? function(e) {
                const { meeting: { meetingId: t1 }, liveTranscription: { messageRecords: o, reducedRecordsCount: r } } = e;
                return void 0 !== window.indexedDB ? new Promise((e)=>{
                    const i = window.indexedDB.open(IL, 1);
                    i.addEventListener("upgradeneeded", ()=>{
                        const e = i.result;
                        if (!e.objectStoreNames.contains(AL)) {
                            const t1 = e.createObjectStore(AL, {
                                keyPath: [
                                    "startIndex",
                                    "mid"
                                ],
                                autoIncrement: !1
                            });
                            t1.createIndex("mid", "mid", {
                                unique: !1
                            }), t1.transaction.oncomplete = ()=>{
                                console.log(`Create objectStore [${AL}] complete`);
                            };
                        }
                    }), i.addEventListener("success", ()=>{
                        const n = i.result, s = o.length, a = .9 * s, d = s - a, u = o.slice(0, a), l = r + u.length, c = n.transaction([
                            AL
                        ], "readwrite");
                        c.objectStore(AL).put({
                            startIndex: r,
                            mid: t1,
                            records: u
                        }), c.oncomplete = ()=>{
                            e(Kf({
                                remains: d,
                                reducedRecordsCount: l
                            })), n.close();
                        }, c.onerror = ()=>{
                            e(""), n.close();
                        };
                    });
                }) : Promise.resolve("");
            }(t1.value) : Promise.resolve("");
        }), tt((e)=>"object" == typeof e)),
    epics10: (e, t1)=>e.pipe(Ot(`${sn}`, `${dn}`), tt(()=>t1.value.liveTranscription.isRecordsReduced), gt(()=>{
            !function() {
                if (void 0 !== window.indexedDB) {
                    const e = window.indexedDB.open(IL, 1);
                    e.addEventListener("success", ()=>{
                        const t1 = e.result;
                        t1.objectStoreNames.contains(AL) && (window.indexedDB.deleteDatabase(IL), t1.close());
                    });
                }
            }();
        }), dt(ie)),
    epics11: (e, t1)=>dr(e, [
            nd.AudiobridgeSetCcLangSuccess,
            nd.AudiobridgeSetCcLangFailure
        ]).pipe(Be((e)=>{
            const { payload: { type: o, data: r } } = e, { liveTranscription: { currentTranscriptionLang: i } } = t1.value, n = [];
            return o === nd.AudiobridgeSetCcLangSuccess && r !== i ? n.push(Hf(r)) : o === nd.AudiobridgeSetCcLangFailure && n.push(Hf(void 0)), Ce(n);
        }))
}, jL = rr(UL), xL = {
    isLiveStreamEnable: !1,
    status: 0
}, BL = So({
    [`${cy}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.isLiveStreamEnable = o;
    }),
    [`${py}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.status = o;
    }),
    [`${hy}`]: (e, t1)=>{
        let { payload: o } = t1;
        return o ? {
            ...e
        } : {
            ...xL
        };
    }
}, xL);
let FL = function(e) {
    return e[e.Ended = 0] = "Ended", e[e.InProgress = 1] = "InProgress", e[e.Connecting = 2] = "Connecting", e[e.Timeout = 3] = "Timeout", e;
}({});
var HL;
const $L = ra.createAgent();
let WL = (Xw((HL = class extends gT {
    startLiveStream(e, t1, o) {
        const { [tT]: r, [oT]: i } = this, { liveStream: { isLiveStreamEnable: n, status: s } } = r();
        return s === FL.InProgress ? Promise.reject({
            type: Gl,
            reason: "Live stream is already on"
        }) : n ? e && t1 && o ? ($L.startLiveStream(e, t1, o), rp({
            event: Gc,
            operations: [
                tt((e)=>e === FL.InProgress),
                it(1)
            ]
        }, void 0, 3e4).then(()=>"").catch(()=>{
            const { liveStream: { status: e } } = r();
            return e === FL.Connecting ? (ep(Gc, FL.Timeout), i(py(FL.Timeout)), Promise.reject({
                type: Kl
            })) : Promise.resolve("");
        })) : Promise.reject({
            type: Ql,
            reason: "parameter cannot be empty"
        }) : Promise.reject({
            type: Gl,
            reason: "Live stream is not enabled"
        });
    }
    stopLiveStream() {
        const { [tT]: e, [oT]: t1 } = this, { liveStream: { status: o } } = e();
        return o === FL.InProgress && ($L.stopLiveStream(), ep(Gc, FL.Ended), t1(py(FL.Ended))), Promise.resolve("");
    }
    isLiveStreamEnabled() {
        var e;
        const { [tT]: t1 } = this;
        return !(null === (e = t1().liveStream) || void 0 === e || !e.isLiveStreamEnable);
    }
    getLiveStreamStatus() {
        var e;
        const { [tT]: t1 } = this;
        return null === (e = t1().liveStream) || void 0 === e ? void 0 : e.status;
    }
}).prototype, "startLiveStream", [
    aT
], Object.getOwnPropertyDescriptor(HL.prototype, "startLiveStream"), HL.prototype), Xw(HL.prototype, "stopLiveStream", [
    aT
], Object.getOwnPropertyDescriptor(HL.prototype, "stopLiveStream"), HL.prototype), HL);
const GL = rr({
    epics0: (e)=>e.pipe(Ot(`${cn}`), ke((e)=>{
            const { payload: { liveStreamInfo: t1 } } = e;
            return cy(!(null == t1 || !t1.isEnabledLiveStream));
        })),
    epics1: (e)=>ir(e, 7970).pipe(ke((e)=>{
            const { payload: { body: { channelName: t1, liveStreamOn: o, isApiCall: r, status: i, viewerUrl: n } } } = e;
            return ep(Gc, i), py(i);
        }))
}), { setSummaryEnable: KL, setSmartSummaryStatus: zL, resetSummary: qL } = mo("SET_SUMMARY_ENABLE", "SET_SMART_SUMMARY_STATUS", "RESET_SUMMARY"), { setMeetingQueryEnable: JL, setMeetingQueryStatus: QL } = mo("SET_MEETING_QUERY_ENABLE", "SET_MEETING_QUERY_STATUS");
let ZL = function(e) {
    return e.Default = "", e.Start = "Start", e.Paused = "Paused", e.Stopped = "Stopped", e;
}({}), YL = function(e) {
    return e[e.GW_IND_NONE = 0] = "GW_IND_NONE", e[e.GW_IND_START = 1] = "GW_IND_START", e[e.GW_IND_PAUSE = 2] = "GW_IND_PAUSE", e[e.GW_IND_STOP = 3] = "GW_IND_STOP", e;
}({}), XL = function(e) {
    return e.Default = "", e.Start = "Start", e.Paused = "Paused", e.Stopped = "Stopped", e;
}({}), eN = function(e) {
    return e[e.GW_IND_NONE = 0] = "GW_IND_NONE", e[e.GW_IND_START = 1] = "GW_IND_START", e[e.GW_IND_PAUSE = 2] = "GW_IND_PAUSE", e[e.GW_IND_STOP = 3] = "GW_IND_STOP", e;
}({});
const tN = {
    summaryStatus: YL.GW_IND_STOP,
    summaryEnable: !1,
    meetingQueryStatus: eN.GW_IND_STOP,
    meetingQueryEnable: !1
}, oN = So({
    [`${KL}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.summaryEnable = o;
    }),
    [`${zL}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.summaryStatus = o;
    }),
    [`${JL}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.meetingQueryEnable = o;
    }),
    [`${QL}`]: TI((e, t1)=>{
        let { payload: o } = t1;
        e.meetingQueryStatus = o;
    }),
    [`${qL}`]: ()=>({
            ...tN
        })
}, tN);
var rN, iN, nN, sN, aN;
const dN = ra.createAgent();
let uN = (rN = dT("summary"), iN = dT("summary"), nN = dT("summary"), sN = dT("summary"), Xw((aN = class extends gT {
    startSummary() {
        const e = this[tT](), { summary: { summaryEnable: t1, summaryStatus: o } } = e;
        return t1 ? o === YL.GW_IND_START ? Promise.resolve("") : (dN.summaryMeeting(!0), rp(Fc, (e)=>e.status === ZL.Start)) : Promise.reject({
            type: Gl,
            reason: "The account of the meeting disabled the smart summary"
        });
    }
    stopSummary() {
        const e = this[tT](), { summary: { summaryStatus: t1 } } = e;
        return t1 !== YL.GW_IND_START ? Promise.resolve("not start summary, do nothing") : (dN.summaryMeeting(!1), rp(Fc, (e)=>e.status === ZL.Stopped));
    }
    getSummaryStatus() {
        const e = this[tT](), { summary: { summaryStatus: t1 } } = e;
        return t1 === YL.GW_IND_START ? ZL.Start : t1 === YL.GW_IND_STOP ? ZL.Stopped : ZL.Default;
    }
    isSummaryEnabled() {
        const e = this[tT](), { summary: { summaryEnable: t1 } } = e;
        return t1;
    }
    startMeetingQuery() {
        const e = this[tT](), { summary: { meetingQueryEnable: t1, meetingQueryStatus: o } } = e;
        return t1 ? o === eN.GW_IND_START ? Promise.resolve("") : (dN.startMeetingQuery(!0), rp(Hc, (e)=>e.status === XL.Start)) : Promise.reject({
            type: Gl,
            reason: "The account of the meeting disabled the smart summary"
        });
    }
    stopMeetingQuery() {
        const e = this[tT](), { summary: { meetingQueryStatus: t1 } } = e;
        return t1 !== eN.GW_IND_START ? Promise.resolve("not start meeting query, do nothing") : (dN.startMeetingQuery(!1), rp(Hc, (e)=>e.status === XL.Stopped));
    }
    getMeetingQueryStatus() {
        const e = this[tT](), { summary: { meetingQueryStatus: t1 } } = e;
        return t1 === eN.GW_IND_START ? XL.Start : t1 === eN.GW_IND_STOP ? XL.Stopped : XL.Default;
    }
    isMeetingQueryEnabled() {
        const e = this[tT](), { summary: { meetingQueryEnable: t1 } } = e;
        return t1;
    }
}).prototype, "startSummary", [
    aT,
    nT,
    rN
], Object.getOwnPropertyDescriptor(aN.prototype, "startSummary"), aN.prototype), Xw(aN.prototype, "stopSummary", [
    aT,
    nT,
    iN
], Object.getOwnPropertyDescriptor(aN.prototype, "stopSummary"), aN.prototype), Xw(aN.prototype, "startMeetingQuery", [
    aT,
    nT,
    nN
], Object.getOwnPropertyDescriptor(aN.prototype, "startMeetingQuery"), aN.prototype), Xw(aN.prototype, "stopMeetingQuery", [
    aT,
    nT,
    sN
], Object.getOwnPropertyDescriptor(aN.prototype, "stopMeetingQuery"), aN.prototype), aN);
const lN = rr({
    moduleEpics0: (e)=>ir(e, 8007).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.supported);
        }), ke((e)=>{
            const { supported: t1 } = e.payload.body;
            return ep(Fc, {
                supported: t1
            }), KL(t1);
        })),
    moduleEpics1: (e, t1)=>ir(e, 8008).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.status);
        }), vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { status: r } = t1.payload.body, { summary: { summaryStatus: i } } = o, n = [];
            if (r !== i) switch(r){
                case YL.GW_IND_START:
                    ep(Fc, {
                        status: ZL.Start
                    });
                    break;
                case YL.GW_IND_PAUSE:
                    ep(Fc, {
                        status: ZL.Paused
                    });
                    break;
                case YL.GW_IND_STOP:
                    ep(Fc, {
                        status: ZL.Stopped
                    });
                    break;
                default:
                    ep(Fc, {
                        status: ""
                    });
            }
            return n.push(zL(r)), Ce(n);
        })),
    moduleEpics2: (e, t1)=>ir(e, 8015).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.supported);
        }), vt(t1), ke((e)=>{
            let [t1, o] = e;
            const { supported: r } = t1.payload.body;
            ep(Hc, {
                supported: r
            });
            const { meeting: { zlkJwtToken: i } } = o;
            if (i) {
                const { auto_transcription: e } = ti(i);
                e && (r ? ra.createAgent().startMeetingQuery(!0) : console.warn("You account don't support auto transcription"));
            }
            return JL(r);
        })),
    moduleEpics3: (e, t1)=>ir(e, 8016).pipe(tt((e)=>{
            var t1;
            return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.status);
        }), vt(t1), Be((e)=>{
            let [t1, o] = e;
            const { status: r } = t1.payload.body, { summary: { meetingQueryStatus: i } } = o, n = [];
            if (r !== i) switch(r){
                case eN.GW_IND_START:
                    ep(Hc, {
                        status: XL.Start
                    });
                    break;
                case eN.GW_IND_PAUSE:
                    ep(Hc, {
                        status: XL.Paused
                    });
                    break;
                case eN.GW_IND_STOP:
                    ep(Hc, {
                        status: XL.Stopped
                    });
                    break;
                default:
                    ep(Hc, {
                        status: ""
                    });
            }
            return n.push(QL(r)), Ce(n);
        }))
});
var cN;
const pN = {
    chat: {
        epic: uO,
        reducer: iO,
        Client: aO
    },
    logger: {
        epic: mD,
        reducer: lD,
        Client: class extends gT {
            getLogs(e) {
                return dD.getLogs(this[eT], e);
            }
            getStore() {
                return dD.doNotUseDirtyGetStore();
            }
            setLogOptions(e) {
                e && this[eT].dispatch(dy(e));
            }
            isAutoReportInAccountSettingEnabled() {
                const { meeting: { zlkJwtToken: e, enableAutoLog: t1, collectionToggleEnable: o, zsk: r } } = this[eT].getState();
                return !!e || (r ? t1 && o : t1);
            }
            reportMeetingProblem(e) {
                var t1;
                const { product: o, problem: r, timeOfOccurrence: i, description: n, ticket: s, isLogIncluded: a } = e, { meeting: { userId: d, confId: u, conId: l, svcUrl: c } } = this[eT].getState(), p = `'product':${o}\n'problem':${r}\n'timeOfOccurrence':${i}\n'description':${n}\n'ticketID':${s}\n'isLogIncluded':${a ? "Logs included" : ""}\n'nodeId':${d}\n'confId':${u}\n'conId':${l}\n'svcUrl':${c}`, h = [
                    "REPORT_NOTIFICATION"
                ];
                return null === (t1 = dD.makeLogger(h).logWithExtraProperties("", {
                    IM_NOTIFICATION: `${p}\nTrackingId:${dD.trackingId}`
                })) || void 0 === t1 ? void 0 : t1.then(()=>{
                    dD.reportToGlobalTracing(a ? void 0 : h, !0);
                });
            }
            reportToGlobalTracing(e) {
                return dD.reportToGlobalTracing(e, !0);
            }
            reportRating(e, t1) {
                const { meeting: o, media: r, socket: i } = this[eT].getState();
                if (o) {
                    var n, s, a, d;
                    const { zlkJwtToken: u, meetingStatus: l } = o, { assetsPath: c, enforceMultipleVideos: p, enforceVirtualBackground: h, disableRenderLimits: m } = r;
                    dD.report(`rating:${e}, feedback:${t1}, appKey:${u ? null === (n = ti(u)) || void 0 === n ? void 0 : n.app_key : ""}, CPU:${navigator.hardwareConcurrency}, GPU:${null !== (s = ms.gpu) && void 0 !== s ? s : ""}, browser:${ms.browser} ${ms.browserVersion}, OS:${ms.os} ${ms.osVersion}, SharedArrayBuffer:${!!ms.isSupportSharedArrayBuffer},\n         assetPath:${c},\n          enforceMultipleVideos:${p},\n          disableRenderLimits:${m},\n          enforceVirtualBackground:${h}, ${l === Yn.Joined ? `session duration:${Math.floor((performance.now() - (null !== (a = null == o ? void 0 : o.pingRWCTimestamp) && void 0 !== a ? a : 0)) / 1e3)}, rwg:${null == i || null === (d = i.rwgServerList) || void 0 === d || null === (d = d[i.retryCount]) || void 0 === d ? void 0 : d.rwg}, failover count:${null == o ? void 0 : o.failover.count}` : ""}`, "User Rating", "info"), Number(e) <= 2 && this.reportToGlobalTracing();
                }
                return Promise.resolve();
            }
        }
    },
    recording: {
        epic: PD,
        reducer: fD,
        Client: OD
    },
    cmd: {
        epic: KD,
        reducer: FD,
        Client: $D
    },
    breakoutRoom: {
        epic: hL,
        reducer: QM,
        Client: lL
    },
    liveTranscription: {
        epic: jL,
        reducer: ML,
        Client: VL
    },
    liveStream: {
        epic: GL,
        reducer: BL,
        Client: WL
    },
    summary: {
        epic: lN,
        reducer: oN,
        Client: uN
    }
}, hN = ra.createAgent();
let mN = (cN = class extends PT {
    constructor(e){
        super(e), this.mediaStream = void 0, this[rT] = pN;
    }
    getMediaStream() {
        return void 0 === this.mediaStream && (this.mediaStream = new qM(this[eT])), this.mediaStream;
    }
    joinInstant(e, t1, o, r, i, n) {
        const { [tT]: s, [oT]: a } = this, { meeting: { lang: d, meetingStatus: u }, socket: { zoomSocketStatus: l } } = s();
        return t1 ? u !== Yn.Joined && l === yh.Closed ? (a(on({
            topic: e,
            password: i || "",
            userName: o,
            zlk: t1,
            lang: d,
            cv: r
        })), n && a(Nn(n)), op(wa.JoinMeeting)) : Promise.reject({
            type: Gl,
            reason: "duplicated operation"
        }) : Promise.reject({
            type: Gl,
            reason: "invalid  signature"
        });
    }
    removeUser(e) {
        const t1 = this[eT].getState(), { participants: { attendeesList: o } } = t1, r = o.find((t1)=>t1.userId === e);
        return r ? (hN.expel(e), rp(ga, (t1)=>t1.some((t1)=>t1.userId === e))) : Promise.reject({
            type: Ql,
            reason: "no matched user"
        });
    }
}, Xw(cN.prototype, "removeUser", [
    sT,
    nT
], Object.getOwnPropertyDescriptor(cN.prototype, "removeUser"), cN.prototype), cN);
class gN {
    constructor(e){
        this.instant = void 0, this.context = void 0, this.script = void 0, this.mic = void 0, this.instant = 0, this.context = e, this.mic = null, this.script = e.createScriptProcessor(2048, 1, 1), this.script.onaudioprocess = (e)=>{
            const t1 = e.inputBuffer.getChannelData(0);
            let o, r = 0;
            for(o = 0; o < t1.length; ++o)r += t1[o] * t1[o];
            this.instant = Math.sqrt(r / t1.length);
        };
    }
    connectToSource(e) {
        console.log("InputMicDetector is listening");
        try {
            var t1;
            this.mic = this.context.createMediaStreamSource(e), this.mic.connect(this.script), null === (t1 = this.script) || void 0 === t1 || t1.connect(this.context.destination);
        } catch (e) {
            console.error(e);
        }
    }
    stop() {
        var e, t1;
        console.log("Audio Previewer stopped"), null === (e = this.mic) || void 0 === e || e.disconnect(), this.mic = null, null === (t1 = this.script) || void 0 === t1 || t1.disconnect(), this.script = null;
    }
    getMicVolume() {
        return this.instant;
    }
}
const vN = "https://st1.zoom.us/web_client/4qu8baa/audio/ring.mp3";
class fN {
    constructor(){
        this.sampleAudio = void 0, this.audioCtx = void 0, this.destinationNode = void 0, this.audioPlayer = void 0, this.analyzserInterval = void 0, this.analyserNode = void 0, this.analyserNodeBufferDataArray = void 0, this.analyserCallback = void 0, this.sourceNode = void 0, this.mAudioStream = void 0, this.mSourceNode = void 0, this.mediaRecorder = void 0, this.isRecording = void 0, this.recorderChunks = [], this.recorderObjUrl = void 0, this.recorderPlayer = void 0, this.maximumRecordingTimer = void 0, this.shouldPlayAfterRecording = !0, this.isRunning = !1;
    }
    testSpeaker(e) {
        var t1;
        if ("function" != typeof AudioContext || "function" != typeof MediaStreamAudioDestinationNode || !AudioContext.prototype.decodeAudioData) return void console.warn("Cannot test the speaker due to the browser capability");
        const { speakerId: o, sampleAudioUrl: r = vN, onAnalyseFrequency: i } = e || {};
        if (this.isRunning) return void console.warn("A tester is running,please stop it first");
        this.isRunning = !0, this.initAudioContext(), ((null === (t1 = this.sampleAudio) || void 0 === t1 ? void 0 : t1.url) === r && this.sampleAudio.data ? Promise.resolve(this.sampleAudio.data) : window.fetch(r).then((e)=>e.arrayBuffer()).then((e)=>this.audioCtx.decodeAudioData(e)).then((e)=>(this.sampleAudio = {
                url: r,
                data: e
            }, e))).then((e)=>{
            var t1, r, n;
            this.sourceNode = this.audioCtx.createBufferSource(), this.sourceNode.buffer = e, this.sourceNode.loop = !0, o && null !== (t1 = this.audioPlayer) && void 0 !== t1 && t1.setSinkId && this.audioPlayer.setSinkId(o), i ? "function" == typeof AudioContext.prototype.createAnalyser ? (this.analyzserInterval && window.clearInterval(this.analyzserInterval), this.analyserCallback = i, this.initAnalyserNode(), this.analyserNode && this.sourceNode.connect(this.analyserNode)) : (this.sourceNode.connect(this.destinationNode), console.warn("Cannot analyze the stream due to the browser capability")) : (this.analyserCallback = void 0, this.sourceNode.connect(this.destinationNode)), this.sourceNode.start(0), "running" !== (null === (r = this.audioCtx) || void 0 === r ? void 0 : r.state) && (null === (n = this.audioCtx) || void 0 === n || n.resume()), this.audioPlayer && (this.audioPlayer.muted = !1, this.audioPlayer.currentTime = 0, this.audioPlayer.play());
        });
        const n = ()=>{
            this.isRunning = !1, this.audioPlayer && (this.audioPlayer.currentTime = 0, this.audioPlayer.pause()), this.analyserNode && this.analyzserInterval && (window.clearInterval(this.analyzserInterval), this.analyzserInterval = void 0, this.analyserNodeBufferDataArray = void 0), this.sourceNode && (this.sourceNode.stop(0), this.sourceNode.disconnect(), this.sourceNode.buffer = null, this.sourceNode = void 0);
        };
        return {
            stop: n,
            destroy: ()=>{
                var e;
                n(), this.analyserNode && this.destinationNode && (this.analyserNode.disconnect(this.destinationNode), this.analyserNode = void 0), null === (e = this.audioCtx) || void 0 === e || e.close(), this.audioCtx = void 0;
            }
        };
    }
    testMicrophone(e) {
        var t1;
        if ("function" != typeof AudioContext || "function" != typeof MediaStreamAudioDestinationNode || "function" != typeof AudioContext.prototype.createMediaStreamSource || "function" != typeof (null === (t1 = navigator.mediaDevices) || void 0 === t1 ? void 0 : t1.getUserMedia)) return void console.warn("Cannot test the microphone due to the browser capability");
        const { microphoneId: o, speakerId: r, recordAndPlay: i, maxRecordDuration: n, onAnalyseFrequency: s, onStartRecording: a, onStopRecording: d, onStartPlayRecording: u, onStopPlayRecording: l } = e || {};
        if (this.isRunning) return void console.warn("A tester is running,please stop it first");
        this.isRunning = !0, this.initAudioContext();
        const c = ()=>{
            i && this.mediaRecorder && this.isRecording && (this.shouldPlayAfterRecording = !0, "inactive" !== this.mediaRecorder.state && this.mediaRecorder.stop());
        };
        window.navigator.mediaDevices.getUserMedia({
            audio: !o || {
                deviceId: {
                    exact: o
                }
            }
        }).then((e)=>{
            var t1, o, p, h;
            this.mAudioStream = e, this.mSourceNode = null === (t1 = this.audioCtx) || void 0 === t1 ? void 0 : t1.createMediaStreamSource(e), this.audioPlayer.muted = !0, s ? (this.analyzserInterval && window.clearInterval(this.analyzserInterval), this.analyserCallback = s, this.initAnalyserNode(), this.analyserNode && (null === (p = this.mSourceNode) || void 0 === p || p.connect(this.analyserNode))) : this.analyserCallback = void 0, i && ("function" == typeof MediaRecorder ? (this.recorderObjUrl && window.URL.revokeObjectURL(this.recorderObjUrl), this.mediaRecorder = new MediaRecorder(this.mAudioStream), this.mediaRecorder.ondataavailable = (e)=>{
                e.data && this.recorderChunks.push(e.data);
            }, this.mediaRecorder.onstop = ()=>{
                if (this.isRecording = !1, this.maximumRecordingTimer && (window.clearTimeout(this.maximumRecordingTimer), this.maximumRecordingTimer = void 0), null == d || d(), this.recorderChunks.length > 0) {
                    var e;
                    const t1 = new Blob(this.recorderChunks, {
                        type: (null === (e = this.recorderChunks[0]) || void 0 === e ? void 0 : e.type) || "audio/ogg; codecs=opus"
                    });
                    this.recorderObjUrl = window.URL.createObjectURL(t1), this.shouldPlayAfterRecording && this.playRecording(this.recorderObjUrl, r, u, l).catch((e)=>{
                        this.analyzserInterval && (window.clearInterval(this.analyzserInterval), this.analyzserInterval = void 0, this.analyserNodeBufferDataArray = void 0), console.warn(e);
                    }), this.recorderChunks = [], this.mediaRecorder && (this.mediaRecorder.ondataavailable = null, this.mediaRecorder.onstop = null, this.mediaRecorder = void 0);
                }
            }, this.mediaRecorder.start(), this.isRecording = !0, null == a || a(), this.maximumRecordingTimer = window.setTimeout(()=>{
                c();
            }, n || 1e4)) : console.warn("Cannot record the sound due to the browser capability")), "running" !== (null === (o = this.audioCtx) || void 0 === o ? void 0 : o.state) && (null === (h = this.audioCtx) || void 0 === h || h.resume()), this.audioPlayer && (this.audioPlayer.currentTime = 0, this.audioPlayer.play());
        });
        const p = ()=>{
            this.isRunning = !1, this.maximumRecordingTimer && (window.clearTimeout(this.maximumRecordingTimer), this.maximumRecordingTimer = void 0), this.audioPlayer && (this.audioPlayer.currentTime = 0, this.audioPlayer.pause()), this.analyserNode && this.analyzserInterval && (window.clearInterval(this.analyzserInterval), this.analyzserInterval = void 0, this.analyserNodeBufferDataArray = void 0), this.mSourceNode && (s && this.analyserNode && this.mSourceNode.disconnect(this.analyserNode), this.mSourceNode = void 0), this.mAudioStream && (this.mAudioStream.getAudioTracks().forEach((e)=>{
                e.stop();
            }), this.mAudioStream = void 0), this.mediaRecorder && (this.shouldPlayAfterRecording = !1, this.mediaRecorder.ondataavailable = null, this.mediaRecorder.onstop = null, "inactive" !== this.mediaRecorder.state && this.mediaRecorder.stop(), this.isRecording = !1, this.mediaRecorder = void 0, this.recorderChunks = []), this.recorderPlayer && (this.recorderPlayer.currentTime = 0, this.recorderPlayer.pause());
        };
        return {
            stop: p,
            stopRecording: c,
            destroy: ()=>{
                var e;
                p(), this.analyserNode && this.destinationNode && (this.analyserNode.disconnect(this.destinationNode), this.analyserNode = void 0), null === (e = this.audioCtx) || void 0 === e || e.close(), this.audioCtx = void 0;
            }
        };
    }
    initAudioContext() {
        this.audioCtx && this.audioPlayer || (this.audioCtx = new AudioContext, this.destinationNode = new MediaStreamAudioDestinationNode(this.audioCtx), this.audioPlayer = new Audio, this.audioPlayer.loop = !0, this.audioPlayer.srcObject = this.destinationNode.stream);
    }
    initAnalyserNode() {
        if (!this.audioCtx) return;
        this.analyserNode || (this.analyserNode = this.audioCtx.createAnalyser(), this.analyserNode.connect(this.destinationNode), this.analyserNode.fftSize = 1024);
        const e = this.analyserNode.frequencyBinCount;
        this.analyserNodeBufferDataArray = new Uint8Array(e), this.analyzserInterval = window.setInterval(this.audioAnalyserCallback.bind(this), 20);
    }
    audioAnalyserCallback() {
        if (this.analyserNodeBufferDataArray && this.analyserNode && this.analyserCallback) {
            this.analyserNode.getByteFrequencyData(this.analyserNodeBufferDataArray);
            let e = 0;
            for (const t1 of this.analyserNodeBufferDataArray)e += t1;
            const t1 = e / this.analyserNodeBufferDataArray.length;
            this.analyserCallback(t1);
        }
    }
    playRecording(e, t1, o, r) {
        this.recorderPlayer = new Audio, this.recorderPlayer.src = e, this.recorderPlayer.currentTime = 0, this.recorderPlayer.setSinkId && t1 && this.recorderPlayer.setSinkId(t1);
        const i = ()=>{
            null == r || r(), this.recorderPlayer && (this.recorderPlayer.onpause = null, this.recorderPlayer.onended = null, this.recorderPlayer = void 0, this.isRunning = !1);
        };
        return new Promise((e, t1)=>{
            this.recorderPlayer && (this.recorderPlayer.onpause = ()=>{
                e(!0);
            }, this.recorderPlayer.onended = ()=>{
                e(!0);
            }, this.recorderPlayer.onerror = t1, null == o || o(), this.recorderPlayer.play().catch(t1));
        }).finally(()=>{
            window.URL.revokeObjectURL(e), i();
        });
    }
}
const yN = "AudioNotStartedError";
class SN {
    constructor(){
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        this.audioContext = void 0, this.inputMicDetector = void 0, this.isMicUnmuted = void 0, this.isAudioStarted = void 0, this.audioStream = void 0, this.deviceId = void 0, this.tester = void 0, this.audioContext = null, this.inputMicDetector = null, this.isMicUnmuted = !1, this.isAudioStarted = !1, this.audioStream = null, this.deviceId = e, this.tester = new fN;
    }
    async start() {
        if (this.audioStream || this.isAudioStarted) throw new Error("AudioAlreadyStartedError");
        try {
            const e = await navigator.mediaDevices.getUserMedia(this.getAudioConstraints());
            this.audioStream = e, this.isAudioStarted = !0;
        } catch (e) {
            throw e;
        }
    }
    async unmute() {
        if (!this.audioStream || !this.isAudioStarted) throw new Error(yN);
        if (this.isMicUnmuted) throw new Error("AudioAlreadyUnmutedError");
        return this.toggleMicIsMuted(!0);
    }
    async mute() {
        if (!this.audioStream || !this.isAudioStarted) throw new Error(yN);
        if (!this.isMicUnmuted) throw new Error("AudioAlreadyMutedError");
        return this.toggleMicIsMuted(!1);
    }
    getCurrentVolume() {
        return this.inputMicDetector ? this.inputMicDetector.getMicVolume() : 0;
    }
    async stop() {
        if (!this.audioStream || !this.isAudioStarted) throw new Error(yN);
        this.audioStream.getAudioTracks().forEach((e)=>e.stop()), this.audioStream = null, this.isAudioStarted = !1;
    }
    async toggleMicIsMuted(e) {
        if (e) {
            if (!this.audioContext) {
                const e = window.AudioContext || window.webkitAudioContext;
                this.audioContext = new e;
            }
            this.inputMicDetector = new gN(this.audioContext), this.inputMicDetector.connectToSource(this.audioStream);
        } else this.inputMicDetector && this.inputMicDetector.stop(), this.inputMicDetector = null;
        this.isMicUnmuted = e;
    }
    getAudioConstraints() {
        return {
            audio: "" === this.deviceId || {
                deviceId: {
                    exact: this.deviceId
                }
            },
            video: !1
        };
    }
    testSpeaker(e) {
        return this.tester.testSpeaker(e);
    }
    testMicrophone(e) {
        return this.tester.testMicrophone(e);
    }
}
const bN = {
    width: {
        min: 1024,
        ideal: 1280,
        max: 1920
    },
    height: {
        min: 576,
        ideal: 720,
        max: 1080
    },
    aspectRatio: {
        ideal: 1.777777778
    }
};
class EN {
    constructor(){
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        this.isVideoStarted = void 0, this.videoStream = void 0, this.deviceId = void 0, this.localPreview = void 0, this.vbPreviewInProgress = void 0, this.videoParams = void 0, this.isVideoStarted = !1, this.videoStream = null, this.vbPreviewInProgress = !1, this.deviceId = e, this.localPreview = new kw;
    }
    async start(e, t1) {
        if (!e) throw new Error("Video DOM element is falsy");
        if (this.isVideoStarted || this.videoStream) throw new Error("VideoAlreadyStartedError");
        this.videoParams = {
            videoDOMElement: e,
            virtualBackground: t1
        };
        const o = async (t1)=>{
            if (!t1 || "OverconstrainedError" !== t1.name && "ConstraintNotSatisfiedError" !== t1.name) throw t1;
            console.log(`Warning: detected ${t1.name} -- trying to fall back to lower aspect ratio`);
            try {
                const t1 = await navigator.mediaDevices.getUserMedia(this.getVideoConstraints(!0));
                return this.tryPlayVideo(e, t1);
            } catch (e) {
                throw e;
            }
        };
        if (!(e instanceof HTMLVideoElement)) {
            if (e instanceof HTMLCanvasElement) return this.localPreview.setup().then(()=>this.localPreview.startPreview(e, {
                    ...t1,
                    deviceId: this.deviceId
                })).then(()=>{
                this.vbPreviewInProgress = !0, this.isVideoStarted = !0;
            });
            throw new Error("Cannot start video with virtual background");
        }
        try {
            const t1 = await navigator.mediaDevices.getUserMedia(this.getVideoConstraints());
            return this.tryPlayVideo(e, t1);
        } catch (e) {
            return o(e);
        }
    }
    async stop() {
        if (this.vbPreviewInProgress) await this.localPreview.stopPreview(), this.vbPreviewInProgress = !1, this.isVideoStarted = !1;
        else {
            if (!this.videoStream || !this.isVideoStarted) throw new Error("VideoNotStartedError");
            this.videoStream.getVideoTracks().forEach((e)=>e.stop()), this.videoStream = null, this.isVideoStarted = !1;
        }
    }
    async switchCamera(e) {
        e !== this.deviceId && (this.deviceId = e, await this.stop(), this.videoParams && await this.start(this.videoParams.videoDOMElement, this.videoParams.virtualBackground));
    }
    async updateVirtualBackground(e, t1) {
        this.vbPreviewInProgress && await this.localPreview.updatePreview(e, t1);
    }
    getVideoConstraints() {
        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t1 = bN;
        return wd.includes(this.deviceId) ? {
            audio: !1,
            video: {
                facingMode: this.deviceId
            }
        } : (e ? t1 = "" === this.deviceId || {
            deviceId: {
                exact: this.deviceId
            }
        } : "" !== this.deviceId && (t1.deviceId = {
            exact: this.deviceId
        }), {
            audio: !1,
            video: t1
        });
    }
    async tryPlayVideo(e, t1) {
        if (!e) throw new Error("Video DOM element is falsy");
        try {
            this.videoStream = t1, e.muted = !0, e.playsInline = !0, e.srcObject = this.videoStream, await e.play(), this.isVideoStarted = !0;
        } catch (e) {
            throw e;
        }
    }
}
class IN {
    static createClient() {
        if (!this.meetingClient) {
            const e = function() {
                const e = function(e) {
                    void 0 === e && (e = {});
                    var t1, o = new re.constructor(re.schedulerActionCtor), r = new U, i = function(i) {
                        t1 = i;
                        var n = new U, s = new U, a = n.asObservable().pipe(Ee(o)), d = new wt(s.pipe(Ee(o)), t1.getState());
                        return r.pipe(ke(function(t1) {
                            var o = t1(a, d, e.dependencies);
                            if (!o) throw new TypeError('Your root Epic "' + (t1.name || "<anonymous>") + "\" does not return a stream. Double check you're not missing a return statement!");
                            return o;
                        }), Be(function(e) {
                            return Ce(e).pipe(Ie(o), Ee(o));
                        })).subscribe(t1.dispatch), function(e) {
                            return function(o) {
                                var r = e(o);
                                return s.next(t1.getState()), n.next(o), r;
                            };
                        };
                    };
                    return i.run = function(e) {
                        r.next(e);
                    }, i;
                }(), { epicSubject: t1, rootEpic: o } = function() {
                    const e = new x(or(gA, VA, WA, Jw));
                    return {
                        epicSubject: e,
                        rootEpic: (t1, o, r)=>e.pipe(ht(t1.pipe(Ot(`${ln}`))), Be((e)=>e(t1, o, r)))
                    };
                }(), r = [
                    e
                ], i = _t(Yw(), Zw(function() {
                    for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
                    return function(e) {
                        return function() {
                            var o = e.apply(void 0, arguments), r = function() {
                                throw new Error(Et(15));
                            }, i = {
                                getState: o.getState,
                                dispatch: function() {
                                    return r.apply(void 0, arguments);
                                }
                            }, n = t1.map(function(e) {
                                return e(i);
                            });
                            return r = Rt.apply(void 0, n)(o.dispatch), bt(bt({}, o), {}, {
                                dispatch: r
                            });
                        };
                    };
                }(...r)));
                return i.asyncReducers = {}, i.injectReducer = (e, t1)=>{
                    void 0 === i.asyncReducers[e] && (i.asyncReducers[e] = t1, i.replaceReducer(Yw(i.asyncReducers)));
                }, i.injectEpic = (e)=>{
                    t1.next(e);
                }, e.run(o), i;
            }();
            this.meetingClient = new mN(e);
        }
        return this.meetingClient;
    }
    static destroyClient() {
        if (this.meetingClient) {
            const e = this.meetingClient[oT];
            this.meetingClient.leave().then(()=>{
                Qe(500).subscribe(()=>{
                    null == e || e(ln()), sp();
                });
            }), this.meetingClient = null;
        }
    }
    static checkFeatureRequirements() {
        return function() {
            const e = [], t1 = [], { isAndroidOrIOSBrowser: o, browser: r, browserVersion: i, os: n, osVersion: s, isChrome: a, isFirefox: d, isSafari: u } = ms;
            !o && (a || d || u) && bs() ? e.push("Virtual Background") : t1.push("Virtual Background"), (o || a) && bs() ? e.push("Share Chrome Tab Audio") : t1.push("Share Chrome Tab Audio"), !o && bs() ? (e.push("Screen Share (send)"), e.push("720p Video (receive)"), e.push("Share 2nd Camera")) : (t1.push("Screen Share (send)"), t1.push("720p Video (receive)"), t1.push("Share 2nd Camera")), bs() ? (e.push("Audio"), e.push("Video"), e.push("Screen Share (receive)"), e.push("Chat"), e.push("Closed Captioning"), e.push("Live Transcription"), e.push("Live Translation"), e.push("Cloud Recording"), e.push("Call Out (PSTN)"), e.push("Command Channel"), e.push("RTMP Live Streaming"), e.push("Encryption"), e.push("720p Video (send)"), e.push("Render Multiple Videos")) : (t1.push("Audio"), t1.push("Video"), t1.push("Screen Share (receive)"), t1.push("Chat"), t1.push("Closed Captioning"), t1.push("Live Transcription"), t1.push("Live Translation"), t1.push("Cloud Recording"), t1.push("Call Out (PSTN)"), t1.push("Command Channel"), t1.push("RTMP Live Streaming"), t1.push("Encryption"), e.push("720p Video (send)"), e.push("Render Multiple Videos"));
            const l = o ? `${n}${s}` : `${r}${i}`;
            return t1.length > 0 && console.log("Some features are not supported on your platform, please refer to https://developers.zoom.us/docs/video-sdk/web/browser-support/"), {
                platform: l,
                supportFeatures: e,
                unSupportFeatures: t1
            };
        }();
    }
    static checkSystemRequirements() {
        return yT();
    }
    static getDevices(e) {
        return e ? navigator.mediaDevices.enumerateDevices() : navigator.mediaDevices.getUserMedia({
            audio: !0,
            video: !0
        }).then((e)=>(e.getTracks().forEach((e)=>e.stop()), navigator.mediaDevices.enumerateDevices())).catch((e)=>(console.warn(e), navigator.mediaDevices.enumerateDevices()));
    }
    static createLocalAudioTrack() {
        return new SN(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "");
    }
    static createLocalVideoTrack() {
        return new EN(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "");
    }
    static preloadDependentAssets(e) {
        (async (e)=>{
            const t1 = e || vr, o = `${t1}/${Jn}`, r = [], i = [], n = `${t1}/`;
            if (Ty()) {
                const { workers: e, wasms: t1 } = ky("audio", "simd", n);
                r.push(...e), i.push(...t1);
            } else {
                const { workers: e, wasms: t1 } = ky("audio", "", n);
                r.push(...e), i.push(...t1);
            }
            if (Ty() && function() {
                const { browser: e, browserVersion: t1, isAndroidBrowser: o, isSupportSharedArrayBuffer: r } = ms;
                return !o && "chrome" === e.toLowerCase() && qr(t1, "100") > 0 && r;
            }()) {
                const { workers: e, wasms: t1 } = ky([
                    "video",
                    "sharing"
                ], "videoShare", n);
                r.push(...e), i.push(...t1);
            } else if (Ty() && wy()) {
                const { workers: e, wasms: t1 } = ky([
                    "video",
                    "sharing"
                ], "simd,thread", n);
                r.push(...e), i.push(...t1);
            } else if (wy()) {
                const { workers: e, wasms: t1 } = ky([
                    "video",
                    "sharing"
                ], "thread", n);
                r.push(...e), i.push(...t1);
            } else if (Ty()) {
                const { workers: e, wasms: t1 } = ky([
                    "video",
                    "sharing"
                ], "simd", n);
                r.push(...e), i.push(...t1);
            } else {
                const { workers: e, wasms: t1 } = ky([
                    "video",
                    "sharing"
                ], "", n);
                r.push(...e), i.push(...t1);
            }
            const s = [
                My(o, "script")
            ];
            r.forEach((e)=>{
                s.push(My(e, "fetch"));
            }), i.forEach((e)=>{
                s.push(My(e, "fetch"));
            });
            try {
                document.head.append(...s);
            } catch (e) {}
        })(e);
    }
}
IN.meetingClient = void 0, IN.VERSION = mr;
const AN = "1.12.17", CN = "INVALID_PARAMETERS", _N = `https://dmogdx0jrul3u.cloudfront.net/videosdk/${AN}/lib`, RN = `https://source.zoom.us/videosdk/${AN}/lib`, wN = `https://jssdk.zoomus.cn/videosdk/${AN}/lib`, TN = (e)=>"string" == typeof e && e.length > 0, ON = (e)=>{
    let t1 = "";
    switch(e){
        case "Global":
            t1 = RN;
            break;
        case "CN":
            t1 = wN;
            break;
        case "CDN":
            t1 = _N;
            break;
        default:
            t1 = e;
    }
    return t1;
}, DN = [
    "userId",
    "avatar",
    "displayName",
    "isHost",
    "audio",
    "muted",
    "bVideoOn",
    "sharerOn",
    "sharerPause",
    "userIdentity",
    "isSpeakerOnly",
    "bVideoShare",
    "bShareAudioOn",
    "userGuid",
    "isPhoneUser",
    "isInFailover",
    {
        from: "isCoHost",
        to: "isManager"
    },
    {
        from: "bAllowISORecord",
        to: "isAllowIndividualRecording"
    },
    {
        from: "bVideoConnect",
        to: "isVideoConnect"
    },
    {
        from: "bShareToBORooms",
        to: "bShareToSubsession"
    },
    {
        from: "bid",
        to: "subsessionId"
    },
    {
        from: "phoneNumber",
        to: (e)=>void 0 === e ? {} : {
                phoneNumber: e
            }
    }
], PN = [
    ...DN,
    {
        from: "userGUID",
        to: "userGuid"
    },
    {
        from: "bCoHost",
        to: (e)=>({
                isManager: !!e
            })
    },
    {
        from: "userType",
        to: (e)=>({
                isPhoneUser: !(5 & ~e)
            })
    },
    {
        from: "bid",
        to: (e)=>e ? {
                subsessionId: e
            } : {}
    }
], MN = PN.map((e)=>"string" == typeof e ? e : e.from);
function kN(e, t1) {
    return "string" == typeof e ? {
        [`${e}`]: t1
    } : "string" == typeof e.to ? {
        [`${e.to}`]: t1
    } : e.to(t1);
}
function LN(e) {
    if (e) return DN.reduce((t1, o)=>{
        const r = "string" == typeof o ? o : o.from;
        return {
            ...t1,
            ...kN(o, e[r])
        };
    }, {});
}
function NN(e) {
    if (e) return Object.keys(e).reduce((t1, o)=>{
        const r = MN.indexOf(o);
        if (r > -1) {
            const o = PN[r], i = "string" == typeof o ? o : o.from, n = kN(o, e[i]);
            return {
                ...t1,
                ...n
            };
        }
        return t1;
    }, {});
}
const VN = Symbol("stream");
class UN {
    constructor(e){
        this[VN] = void 0, this[VN] = e;
    }
    startAudio(e) {
        return this[VN].startAudio(e);
    }
    stopAudio() {
        return this[VN].stopAudio();
    }
    muteAudio(e) {
        return this[VN].muteAudio(e);
    }
    unmuteAudio(e) {
        return this[VN].unmuteAudio(e);
    }
    inviteByPhone(e, t1, o, r) {
        return this[VN].dialOut(e, t1, o, r);
    }
    cancelInviteByPhone(e, t1, o) {
        return this[VN].cancelDialOut(e, t1, o);
    }
    hangup() {
        return this[VN].hangup();
    }
    getCurrentSessionCallinInfo() {
        return this[VN].getDialInInfo();
    }
    muteShareAudio(e) {
        return this[VN].muteShareAudio(e);
    }
    unmuteShareAudio(e) {
        return this[VN].unmuteShareAudio(e);
    }
    subscribeAudioStatisticData(e) {
        return this[VN].subscribeAudioStatisticData(e);
    }
    unsubscribeAudioStatisticData(e) {
        return this[VN].unsubscribeAudioStatisticData(e);
    }
    muteUserAudioLocally(e) {
        return this[VN].muteUserAudioLocally(e);
    }
    unmuteUserAudioLocally(e) {
        return this[VN].unmuteUserAudioLocally(e);
    }
    adjustUserAudioVolumeLocally(e, t1) {
        return this[VN].adjustUserAudioVolumeLocally(e, t1);
    }
    enableBackgroundNoiseSuppression(e) {
        return this[VN].enableBackgroundNoiseSuppression(e);
    }
    enableSyncButtonsOnHeadset(e) {
        return this[VN].enableSyncButtonsOnHeadset(e);
    }
    muteAllUserAudioLocally() {
        return this[VN].muteAllUserAudioLocally();
    }
    unmuteAllUserAudioLocally() {
        return this[VN].unmuteAllUserAudioLocally();
    }
    enableOriginalSound(e) {
        return this[VN].enableOriginalSound(e);
    }
    callCRCDevice(e, t1) {
        return this[VN].callCRCDevice(e, t1);
    }
    cancelCallCRCDevice(e, t1) {
        return this[VN].cancelCallCRCDevice(e, t1);
    }
    startSecondaryAudio(e, t1) {
        return this[VN].startSecondaryAudio(e, t1);
    }
    stopSecondaryAudio() {
        return this[VN].stopSecondaryAudio();
    }
    muteAllAudio() {
        return this[VN].muteAllAudio();
    }
    unmuteAllAudio() {
        return this[VN].unmuteAllAudio();
    }
    muteAudioUponStartAudio(e) {
        return this[VN].muteAudioUponEntry(e);
    }
    isAudioMuted(e) {
        return this[VN].isAudioMuted(e);
    }
    getMicList() {
        return this[VN].getMicList();
    }
    getSpeakerList() {
        return this[VN].getSpeakerList();
    }
    getActiveMicrophone() {
        return this[VN].getActiveMicrophone();
    }
    getActiveSpeaker() {
        return this[VN].getActiveSpeaker();
    }
    switchMicrophone(e) {
        return this[VN].switchMicrophone(e);
    }
    switchSpeaker(e) {
        return this[VN].switchSpeaker(e);
    }
    isSupportPhoneFeature() {
        return this[VN].isSupportCallOut();
    }
    getSupportCountryInfo() {
        return this[VN].getDialOutCountries();
    }
    getInviteByPhoneStatus() {
        return this[VN].getDialOutStatus();
    }
    getShareAudioStatus() {
        return this[VN].getShareAudioStatus();
    }
    isOthersShareAudioMutedLocally(e) {
        return this[VN].isOthersShareAudioMutedLocally(e);
    }
    getAudioStatisticData() {
        return this[VN].getAudioStatisticData();
    }
    isUserAudioMutedLocally(e) {
        return this[VN].isUserAudioMutedLocally(e);
    }
    getUserVolumeLocally(e) {
        return this[VN].getUserVolumeLocally(e);
    }
    isSupportMicrophoneAndShareAudioSimultaneously() {
        return this[VN].isSupportMicrophoneAndShareAudioSimultaneously();
    }
    getAudioMediaPlaybackController() {
        return this[VN].getAudioMediaPlaybackController();
    }
    startVideo(e) {
        return this[VN].startVideo(e);
    }
    stopVideo() {
        return this[VN].stopVideo();
    }
    renderVideo(e, t1, o, r, i, n, s, a) {
        return this[VN].renderVideo(e, t1, o, r, i, n, s, a);
    }
    stopRenderVideo(e, t1, o, r) {
        let i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = arguments.length > 5 ? arguments[5] : void 0;
        return this[VN].stopRenderVideo(e, t1, o, r, i, n);
    }
    updateVideoCanvasDimension(e, t1, o) {
        return this[VN].updateVideoCanvasDimension(e, t1, o);
    }
    adjustRenderedVideoPosition(e, t1, o, r, i, n, s) {
        return this[VN].adjustRenderedVideoPosition(e, t1, o, r, i, n, s);
    }
    clearVideoCanvas(e, t1) {
        return this[VN].clearVideoCanvas(e, t1);
    }
    mirrorVideo(e) {
        return this[VN].mirrorVideo(e);
    }
    enableHardwareAcceleration(e) {
        return this[VN].enableHardwareAcceleration(e);
    }
    previewVirtualBackground(e, t1, o, r) {
        return this[VN].previewVirtualBackground(e, t1, o, r);
    }
    updateVirtualBackgroundImage(e, t1) {
        return this[VN].updateVirtualBackgroundImage(e, t1);
    }
    stopPreviewVirtualBackground() {
        return this[VN].stopPreviewVirtualBackground();
    }
    previewVideoMask(e, t1) {
        return this[VN].previewVideoMask(e, t1);
    }
    updateVideoMask(e) {
        return this[VN].updateVideoMask(e);
    }
    stopPreviewVideoMask() {
        return this[VN].stopPreviewVideoMask();
    }
    switchCamera(e) {
        return this[VN].switchCamera(e);
    }
    subscribeVideoStatisticData(e) {
        return this[VN].subscribeVideoStatisticData(e);
    }
    unsubscribeVideoStatisticData(e) {
        return this[VN].unsubscribeVideoStatisticData(e);
    }
    attachVideo(e, t1, o) {
        return this[VN].attachVideo(e, t1, o);
    }
    detachVideo(e, t1) {
        return this[VN].detachVideo(e, t1);
    }
    spotlightVideo(e, t1) {
        return this[VN].spotlight(e, null != t1 && t1);
    }
    removeSpotlightedVideo(e) {
        return this[VN].removeSpotlight(e);
    }
    removeAllSpotlightedVideos() {
        return this[VN].removeAllSpotlights();
    }
    isCapturingVideo() {
        return this[VN].isCapturingVideo();
    }
    isCameraTaken() {
        return this[VN].isCameraTaken();
    }
    getActiveVideoId() {
        return this[VN].getActiveVideoId();
    }
    getActiveCamera() {
        return this[VN].getActiveCamera();
    }
    getCameraList() {
        return this[VN].getCameraList();
    }
    isCaptureForbidden() {
        return this[VN].isCaptureForbidden();
    }
    getVideoMaxQuality() {
        return this[VN].getVideoMaxQuality();
    }
    getReceivedVideoDimension() {
        return this[VN].getReceivedVideoDimension();
    }
    isSupportMultipleVideos() {
        return this[VN].isSupportMultipleVideos();
    }
    isSupportHDVideo() {
        return this[VN].isSupportHDVideo();
    }
    isSupportVirtualBackground() {
        return this[VN].isSupportVirtualBackground();
    }
    getVirtualbackgroundStatus() {
        return this[VN].getVirtualbackgroundStatus();
    }
    getVideoStatisticData() {
        return this[VN].getVideoStatisticData();
    }
    isRenderSelfViewWithVideoElement() {
        return this[VN].isRenderSelfViewWithVideoElement();
    }
    getCapturedVideoResolution() {
        return this[VN].getCapturedVideoResolution();
    }
    getVideoMaskStatus() {
        return this[VN].getVideoMaskStatus();
    }
    isVideoMirrored() {
        return this[VN].isVideoMirrored();
    }
    getSpotlightedUserList() {
        return this[VN].getSpotlightedUserList().map((e)=>LN(e));
    }
    getVideoMediaPlaybackController() {
        return this[VN].getVideoMediaPlaybackController();
    }
    startShareView(e, t1) {
        return this[VN].startShareView(e, t1);
    }
    stopShareView() {
        return this[VN].stopShareView();
    }
    switchShareView(e) {
        return this[VN].switchShareView(e);
    }
    startShareScreen(e, t1) {
        return void 0 !== (null == t1 ? void 0 : t1.broadcastToSubsession) && Object.assign(t1 || {}, {
            broadcastToBreakoutRoom: null == t1 ? void 0 : t1.broadcastToSubsession
        }), this[VN].startShareScreen(e, t1);
    }
    pauseShareScreen() {
        return this[VN].pauseShareScreen();
    }
    resumeShareScreen() {
        return this[VN].resumeShareScreen();
    }
    stopShareScreen() {
        return this[VN].stopShareScreen();
    }
    lockShare(e) {
        return this[VN].lockShare(e);
    }
    updateSharingCanvasDimension(e, t1) {
        return this[VN].updateSharingCanvasDimension(e, t1);
    }
    switchSharingSecondaryCamera(e) {
        return this[VN].switchSharingSecondaryCamera(e);
    }
    setSharePrivilege(e) {
        return this[VN].setSharePrivilege(e);
    }
    shareToSubsession() {
        return this[VN].shareToBreakoutRoom();
    }
    stopShareToSubsession() {
        return this[VN].stopShareToBreakoutRoom();
    }
    enableOptimizeForSharedVideo(e) {
        return this[VN].enableOptimizeForSharedVideo(e);
    }
    updateSharedVideoQuality(e) {
        return this[VN].updateSharedVideoQuality(e);
    }
    subscribeShareStatisticData(e) {
        return this[VN].subscribeShareStatisticData(e);
    }
    unsubscribeShareStatisticData(e) {
        return this[VN].unsubscribeShareStatisticData(e);
    }
    isShareLocked() {
        return this[VN].isShareLocked();
    }
    getSharePrivilege() {
        return this[VN].getSharePrivilege();
    }
    getActiveShareUserId() {
        return this[VN].getActiveShareUserId();
    }
    getShareStatus() {
        return this[VN].getShareStatus();
    }
    getShareUserList() {
        return this[VN].getShareUserList().map((e)=>LN(e));
    }
    isStartShareScreenWithVideoElement() {
        return this[VN].isStartShareScreenWithVideoElement();
    }
    isOptimizeForSharedVideoEnabled() {
        return this[VN].isOptimizeForSharedVideoEnabled();
    }
    isSupportOptimizedForSharedVideo() {
        return this[VN].isSupportOptimizedForSharedVideo();
    }
    getShareStatisticData() {
        return this[VN].getShareStatisticData();
    }
    requestFarEndCameraControl(e) {
        return this[VN].requestFarEndCameraControl(e);
    }
    approveFarEndCameraControl(e) {
        return this[VN].approveFarEndCameraControl(e);
    }
    declineFarEndCameraControl(e) {
        return this[VN].declineFarEndCameraControl(e);
    }
    giveUpFarEndCameraControl(e) {
        return this[VN].giveUpFarEndCameraControl(e);
    }
    controlCamera(e) {
        return this[VN].controlCamera(e);
    }
    controlFarEndCamera(e) {
        return this[VN].controlFarEndCamera(e);
    }
    getFarEndCameraPTZCapability(e) {
        return this[VN].getFarEndCameraPTZCapability(e);
    }
    getCameraPTZCapability(e) {
        return this[VN].getCameraPTZCapability(e);
    }
    isBrowserSupportPTZ() {
        return this[VN].isBrowserSupportPTZ();
    }
    getNetworkQuality(e) {
        return this[VN].getNetworkQuality(e);
    }
    requestRemoteControl() {
        return this[VN].requestRemoteControl();
    }
    giveUpRemoteControl() {
        return this[VN].giveUpRemoteControl();
    }
    startRemoteControl(e) {
        return this[VN].startRemoteControl(e);
    }
    grabRemoteControl() {
        return this[VN].grabRemoteControl();
    }
    approveRemoteControl(e, t1) {
        return this[VN].approveRemoteControl(e, t1);
    }
    declineRemoteControl(e) {
        return this[VN].declineRemoteControl(e);
    }
    stopRemoteControl() {
        return this[VN].stopRemoteControl();
    }
    launchRemoteControlApp(e) {
        return this[VN].launchRemoteControlApp(e);
    }
    isRemotelyControlApproved() {
        return this[VN].isRemotelyControlApproved();
    }
    isControllingUserRemotely() {
        return this[VN].isControllingUserRemotely();
    }
    isTargetShareSupportRemoteControl(e) {
        return this[VN].isTargetShareSupportRemoteControl(e);
    }
    getRemoteControlAppDownloadUrl() {
        return this[VN].getRemoteControlAppDownloadUrl();
    }
    getRemotelyControllingUser() {
        return this[VN].getRemotelyControllingUser();
    }
    isRemoteControlEnabled() {
        return this[VN].isRemoteControlEnabled();
    }
}
const jN = Symbol("chat");
class xN {
    constructor(e){
        this[jN] = void 0, this[jN] = e;
    }
    send(e, t1) {
        return this[jN].send(e, t1);
    }
    sendToAll(e) {
        return this[jN].send(e, Bs.All);
    }
    sendFile(e, t1) {
        return this[jN].sendFile(e, t1);
    }
    downloadFile(e, t1, o) {
        return this[jN].downloadFile(e, t1, o);
    }
    setPrivilege(e) {
        return this[jN].setPrivilege(e);
    }
    getPrivilege() {
        return this[jN].getPrivilege();
    }
    getReceivers() {
        return this[jN].getReceivers().map((e)=>{
            const { isCoHost: t1, ...o } = e;
            return {
                isManager: t1,
                ...o
            };
        });
    }
    getHistory() {
        return this[jN].getHistory();
    }
    isFileTransferEnabled() {
        return this[jN].isFileTransferEnabled();
    }
    getFileTransferSetting() {
        return this[jN].getFileTransferSetting();
    }
}
const BN = Symbol("recording");
class FN {
    constructor(e){
        this[BN] = void 0, this[BN] = e;
    }
    canStartRecording() {
        return this[BN].isRecordingEnabled();
    }
    startCloudRecording() {
        return this[BN].startRecording();
    }
    pauseCloudRecording() {
        return this[BN].pauseRecording();
    }
    resumeCloudRecording() {
        return this[BN].startRecording();
    }
    stopCloudRecording() {
        return this[BN].stopRecording();
    }
    getCloudRecordingStatus() {
        return this[BN].getRecordingStatus();
    }
    acceptIndividualRecording() {
        return this[BN].accept();
    }
    declineIndividualRecording() {
        return this[BN].decline();
    }
}
const HN = Symbol("command");
class $N {
    constructor(e){
        this[HN] = void 0, this[HN] = e;
    }
    send(e, t1) {
        return this[HN].send(e, t1);
    }
}
const WN = Symbol("breakout-room");
class GN {
    constructor(e){
        this[WN] = void 0, this[WN] = e;
    }
    createSubsessions(e, t1) {
        return this[WN].createRooms(e, t1).then((e)=>e.map((e)=>({
                    subsessionId: e.roomId,
                    subsessionName: e.name,
                    userList: e.attendeeList
                })));
    }
    openSubsessions(e, t1) {
        const o = t1 ? {
            ...t1,
            isAutoJoinRoom: t1.isAutoJoinSubsession,
            isRoomSelectionEnabled: t1.isSubsessionSelectionEnabled
        } : void 0, r = e.map((e)=>({
                roomId: e.subsessionId,
                name: e.subsessionName,
                attendeeList: e.userList
            }));
        return this[WN].openRooms(r, o);
    }
    joinSubsession(e) {
        return this[WN].joinRoom(e);
    }
    leaveSubsession() {
        return this[WN].leaveRoom();
    }
    askForHelp() {
        return this[WN].askForHelp();
    }
    postponeHelping(e) {
        return this[WN].postponeHelping(e);
    }
    broadcast(e) {
        return this[WN].broadcast(e);
    }
    assignUserToSubsession(e, t1) {
        return this[WN].assignUserToRoom(e, t1);
    }
    moveUserToSubsession(e, t1) {
        return this[WN].moveUserToRoom(e, t1);
    }
    moveBackToMainSession(e) {
        return this[WN].moveBackToMainSession(e);
    }
    closeAllSubsessions() {
        return this[WN].closeRoom();
    }
    startBroadcastVoice() {
        return this[WN].startBroadcastVoice();
    }
    stopBroadcastVoice() {
        return this[WN].stopBroadcastVoice();
    }
    getUnassignedUserList() {
        return this[WN].getUnassignedAttendeeList().map((e)=>LN(e));
    }
    getSubsessionList() {
        return this[WN].getRoomList().map((e)=>{
            const { roomId: t1, name: o, attendeeList: r } = e;
            return {
                subsessionId: t1,
                subsessionName: o,
                userList: r.map((e)=>{
                    const { isInRoom: t1, ...o } = e;
                    return {
                        isInSubsession: t1,
                        ...o
                    };
                })
            };
        });
    }
    getUserStatus() {
        return this[WN].getAttendeeStatus();
    }
    getSubsessionStatus() {
        return this[WN].getRoomStatus();
    }
    getCurrentSubsession() {
        const { attendeeStatus: e, name: t1, roomId: o } = this[WN].getCurrentRoom();
        return {
            userStatus: e,
            subsessionName: t1,
            subsessionId: o
        };
    }
    getSubsessionOptions() {
        const { isAutoJoinRoom: e, isRoomSelectionEnabled: t1, ...o } = this[WN].getRoomOptions();
        return {
            isAutoJoinSubsession: e,
            isSubsessionSelectionEnabled: t1,
            ...o
        };
    }
}
const KN = Symbol("liveTranscription");
class zN {
    constructor(e){
        this[KN] = void 0, this[KN] = e;
    }
    startLiveTranscription() {
        return this[KN].startLiveTranscription();
    }
    setSpeakingLanguage(e) {
        return this[KN].setSpeakingLanguage(e);
    }
    setTranslationLanguage(e) {
        return this[KN].setTranslationLanguage(e);
    }
    getLiveTranscriptionStatus() {
        return this[KN].getLiveTranscriptionStatus();
    }
    getCurrentTranscriptionLanguage() {
        return this[KN].getCurrentTranscriptionLanguage();
    }
    getCurrentTranslationLanguage() {
        return this[KN].getCurrentTranslationLanguage();
    }
    getLatestTranscription() {
        return this[KN].getLatestTranscription();
    }
    getLatestTranslation() {
        return this[KN].getLatestTranslation();
    }
    getFullTranscriptionHistory() {
        return this[KN].getFullTranscriptionHistory();
    }
    disableCaptions(e) {
        return this[KN].disableCaptions(e);
    }
}
const qN = Symbol("liveStream");
class JN {
    constructor(e){
        this[qN] = void 0, this[qN] = e;
    }
    startLiveStream(e, t1, o) {
        return this[qN].startLiveStream(e, t1, o);
    }
    stopLiveStream() {
        return this[qN].stopLiveStream();
    }
    isLiveStreamEnabled() {
        return this[qN].isLiveStreamEnabled();
    }
    getLiveStreamStatus() {
        return this[qN].getLiveStreamStatus();
    }
}
const QN = Symbol("logger");
class ZN {
    constructor(e, t1){
        if (this[QN] = void 0, this[QN] = e, t1) {
            const { debugMode: e, trackingId: o } = t1;
            this[QN].setLogOptions({
                debugMode: e,
                trackingId: o
            });
        }
    }
    reportToGlobalTracing(e) {
        return this[QN].reportToGlobalTracing(e);
    }
    reportRating(e, t1) {
        return this[QN].reportRating(e, t1);
    }
}
const YN = [
    {
        event: "connection-change",
        originalEvent: "connection-change",
        payloadTransform: (e)=>{
            const { roomName: t1, ...o } = e;
            return t1 ? {
                ...o,
                subsessionName: t1
            } : e;
        }
    },
    {
        event: "user-added",
        originalEvent: "user-added",
        payloadTransform: (e)=>e.map((e)=>NN(e))
    },
    {
        event: "user-updated",
        originalEvent: "user-updated",
        payloadTransform: (e)=>e.map((e)=>NN(e))
    },
    {
        event: "user-removed",
        originalEvent: "user-removed",
        payloadTransform: (e)=>e.map((e)=>NN(e))
    },
    {
        event: "subsession-invite-to-join",
        originalEvent: "invite-to-join",
        payloadTransform: (e)=>({
                subsessionId: e.roomId,
                subsessionName: e.name
            })
    },
    {
        event: "subsession-countdown",
        originalEvent: "room-countdown"
    },
    {
        event: "subsession-time-up",
        originalEvent: "room-time-up"
    },
    {
        event: "closing-subsession-countdown",
        originalEvent: "closing-room-countdown"
    },
    {
        event: "subsession-broadcast-message",
        originalEvent: "broadcast-message"
    },
    {
        event: "subsession-broadcast-voice",
        originalEvent: "broadcast-voice"
    },
    {
        event: "subsession-ask-for-help",
        originalEvent: "ask-for-help",
        payloadTransform: (e)=>({
                userId: e.userId,
                userGuid: e.userGuid,
                displayName: e.displayName,
                subsessionId: e.roomId,
                subsessionName: e.roomName
            })
    },
    {
        event: "subsession-ask-for-help-response",
        originalEvent: "ask-for-help-response"
    },
    {
        event: "subsession-invite-back-to-main-session",
        originalEvent: "invite-back-to-main-session"
    },
    {
        event: "subsession-state-change",
        originalEvent: "room-state-change"
    },
    {
        event: "host-ask-unmute-audio",
        originalEvent: "unmute-audio-consent"
    },
    {
        event: "subsession-user-update",
        originalEvent: "room-user-update",
        payloadTransform: (e)=>{
            const { roomId: t1, roomName: o, ...r } = e;
            return {
                subsessionId: t1,
                subsessionName: o,
                ...r
            };
        }
    },
    {
        event: "active-media-failed",
        originalEvent: "media-internal-error"
    }
], XN = Symbol("summary");
class eV {
    constructor(e){
        this[XN] = void 0, this[XN] = e;
    }
    startSummary() {
        return this[XN].startSummary();
    }
    stopSummary() {
        return this[XN].stopSummary();
    }
    isSummaryEnabled() {
        return this[XN].isSummaryEnabled();
    }
    getSummaryStatus() {
        return this[XN].getSummaryStatus();
    }
    startMeetingQuery() {
        return this[XN].startMeetingQuery();
    }
    stopMeetingQuery() {
        return this[XN].stopMeetingQuery();
    }
    isMeetingQueryEnabled() {
        return this[XN].isMeetingQueryEnabled();
    }
    getMeetingQueryStatus() {
        return this[XN].getMeetingQueryStatus();
    }
}
const tV = Symbol("Client"), oV = new WeakMap;
class rV {
    constructor(){
        this[tV] = void 0, this.stream = void 0, this.chat = void 0, this.command = void 0, this.recording = void 0, this.subsession = void 0, this.liveTranscription = void 0, this.logger = void 0, this.liveStream = void 0, this.aiClient = void 0, this[tV] = IN.createClient(), oV.set(this, new Map);
    }
    init() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "en-US", t1 = arguments.length > 2 ? arguments[2] : void 0;
        const o = ON(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Global");
        return !1 === window.isSecureContext && console.warn("The page is not in a secure context, to use audio, video, screen, a secure context must be enabled."), function() {
            const e = "__ZOOM_VIDEO_SDK_DOM_STORAGE_TEST__";
            try {
                return localStorage.setItem(e, e), localStorage.removeItem(e), sessionStorage.setItem(e, e), sessionStorage.removeItem(e), !0;
            } catch (e) {
                return !1;
            }
        }() || console.warn("localstorage or sessionstorage is not enabled, please enable to use the video sdk,"), this[tV].init("", "", {
            language: e,
            dependentAssets: o,
            constraints: {
                ...IN.checkSystemRequirements(),
                screen: "object" == typeof WebAssembly && "function" == typeof Worker
            },
            additionalFeatures: [
                "chat",
                "cmd",
                "recording",
                "breakoutRoom",
                "liveTranscription",
                "logger",
                "liveStream",
                "summary"
            ],
            webEndpoint: (null == t1 ? void 0 : t1.webEndpoint) || "zoom.us",
            skipJsMedia: null == t1 ? void 0 : t1.skipJsMedia,
            enforceMultipleVideos: null == t1 ? void 0 : t1.enforceMultipleVideos,
            stayAwake: null == t1 ? void 0 : t1.stayAwake,
            enforceVirtualBackground: null == t1 ? void 0 : t1.enforceVirtualBackground,
            quicklyLeaveMeeting: null == t1 ? void 0 : t1.leaveOnPageUnload,
            patchJsMedia: null == t1 ? void 0 : t1.patchJsMedia,
            alternativeNameForVideoPlayer: null == t1 ? void 0 : t1.alternativeNameForVideoPlayer
        });
    }
    join(e, t1, o, r, i) {
        return TN(e) && TN(t1) && TN(o) ? e.length > 200 ? Promise.reject({
            type: CN,
            reason: "The maximum length of topic is 200"
        }) : o.length > 200 ? Promise.reject({
            type: CN,
            reason: "The maximum length of username is 200"
        }) : r && ("string" != typeof r || r.length > 10) ? Promise.reject({
            type: CN,
            reason: "The maximum length of password is 10"
        }) : this[tV].joinInstant(e, t1, o, AN, r, i) : Promise.reject({
            type: CN,
            reason: "Topic, token and userName must be string and required"
        });
    }
    leave() {
        var e;
        return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? (null === (e = oV.get(this)) || void 0 === e || e.clear(), this[tV].end()) : this[tV].leave();
    }
    on(e, t1) {
        const o = YN.find((t1)=>t1.event === e);
        if (o) {
            const { originalEvent: r, payloadTransform: i } = o;
            if (i) {
                const o = (e)=>{
                    const o = i(e);
                    t1(o);
                };
                this[tV].on(r, o);
                const n = oV.get(this);
                if (n) {
                    n.has(e) || n.set(e, []);
                    const r = n.get(e);
                    null == r || r.push({
                        originalCb: t1,
                        newCb: o
                    });
                }
            } else this[tV].on(r, t1);
        } else this[tV].on(e, t1);
    }
    off(e, t1) {
        const o = YN.find((t1)=>t1.event === e);
        if (o) {
            const { originalEvent: r, payloadTransform: i } = o;
            if (i) {
                const o = oV.get(this);
                if (o) {
                    const i = o.get(e), n = null == i ? void 0 : i.find((e)=>e.originalCb === t1);
                    if (n && i) {
                        this[tV].off(r, n.newCb);
                        const s = null == i ? void 0 : i.filter((e)=>e.originalCb !== t1);
                        o.set(e, s);
                    }
                }
            } else this[tV].off(r, t1);
        } else this[tV].off(e, t1);
    }
    getMediaStream() {
        return this.stream || (this.stream = new UN(this[tV].getMediaStream())), this.stream;
    }
    getChatClient() {
        return this.chat || (this.chat = new xN(this[tV].getFeatureModule("chat"))), this.chat;
    }
    getRecordingClient() {
        return this.recording || (this.recording = new FN(this[tV].getFeatureModule("recording"))), this.recording;
    }
    getCommandClient() {
        return this.command || (this.command = new $N(this[tV].getFeatureModule("cmd"))), this.command;
    }
    getSubsessionClient() {
        return this.subsession || (this.subsession = new GN(this[tV].getFeatureModule("breakoutRoom"))), this.subsession;
    }
    getLiveTranscriptionClient() {
        return this.liveTranscription || (this.liveTranscription = new zN(this[tV].getFeatureModule("liveTranscription"))), this.liveTranscription;
    }
    getLoggerClient(e) {
        return this.logger || (this.logger = new ZN(this[tV].getFeatureModule("logger"), e)), this.logger;
    }
    getLiveStreamClient() {
        return this.liveStream || (this.liveStream = new JN(this[tV].getFeatureModule("liveStream"))), this.liveStream;
    }
    getAIClient() {
        return this.aiClient || (this.aiClient = new eV(this[tV].getFeatureModule("summary"))), this.aiClient;
    }
    getSessionInfo() {
        const e = this[tV].getMeetingInfo();
        return {
            isInMeeting: e.isInMeeting || !1,
            password: e.password || "",
            topic: e.topic,
            userName: e.userName,
            userId: e.userId,
            sessionId: e.meetingId
        };
    }
    getCurrentUserInfo() {
        return LN(this[tV].getCurrentUserInfo());
    }
    getUser(e) {
        return LN(this[tV].getParticipantsList().find((t1)=>t1.userId === e));
    }
    getAllUser() {
        return this[tV].getParticipantsList().map((e)=>LN(e));
    }
    changeName(e, t1) {
        return this[tV].changeName(e, t1);
    }
    makeHost(e) {
        return this[tV].makeHost(e);
    }
    removeUser(e) {
        return this[tV].removeUser(e);
    }
    makeManager(e) {
        return this[tV].makeCoHost(e);
    }
    revokeManager(e) {
        return this[tV].revokeCoHost(e);
    }
    reclaimHost() {
        return this[tV].reclaimHost();
    }
    isHost() {
        return this[tV].isHost();
    }
    isOriginalHost() {
        return this[tV].isOriginHost();
    }
    getSessionHost() {
        return LN(this[tV].getMeetingHost());
    }
    isManager() {
        return this[tV].isCoHost();
    }
}
class iV {
    static createClient() {
        return this.videoClient || (this.videoClient = new rV), this.videoClient;
    }
    static destroyClient() {
        this.videoClient && (this.videoClient.leave(), this.videoClient = null);
    }
    static checkSystemRequirements() {
        return IN.checkSystemRequirements();
    }
    static checkFeatureRequirements() {
        return IN.checkFeatureRequirements();
    }
    static getDevices(e) {
        return IN.getDevices(e);
    }
    static createLocalAudioTrack() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        return IN.createLocalAudioTrack(e);
    }
    static createLocalVideoTrack() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        return IN.createLocalVideoTrack(e);
    }
    static preloadDependentAssets() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Global";
        IN.preloadDependentAssets(ON(e));
    }
}
iV.videoClient = void 0, iV.VERSION = AN;
let nV = function(e) {
    return e[e.All = 1] = "All", e[e.NoOne = 4] = "NoOne", e[e.EveryonePublicly = 5] = "EveryonePublicly", e;
}({}), sV = function(e) {
    return e[e.All = 0] = "All", e;
}({}), aV = function(e) {
    return e[e.Automatically = Kp.Automatically] = "Automatically", e[e.Manually = Kp.Manually] = "Manually", e;
}({}), dV = function(e) {
    return e[e.Initial = Jp.Initial] = "Initial", e[e.Invited = Jp.Invited] = "Invited", e[e.Joining = Jp.Joining] = "Joining", e[e.InSubsession = Jp.InRoom] = "InSubsession", e[e.Leaving = Jp.Leaving] = "Leaving", e[e.MainSession = Jp.MainSession] = "MainSession", e;
}({}), uV = function(e) {
    return e[e.NotStarted = zp.NotStarted] = "NotStarted", e[e.InProgress = zp.InProgress] = "InProgress", e[e.Closing = zp.Closing] = "Closing", e[e.Closed = zp.Closed] = "Closed", e;
}({}), lV = function(e) {
    return e[e.Failover = qn.Failover] = "Failover", e[e.JoinSubsession = qn.JoinBreakoutRoom] = "JoinSubsession", e[e.MoveToSubsession = qn.MoveToBreakoutRoom] = "MoveToSubsession", e[e.BackToMainSession = qn.BackToMainSession] = "BackToMainSession", e;
}({}), cV = function(e) {
    return e[e.Unlocked = vd.HostGrab] = "Unlocked", e[e.Locked = vd.OnlyHost] = "Locked", e[e.MultipleShare = vd.MultipleShare] = "MultipleShare", e;
}({}), pV = function(e) {
    return e[e.Unknown = Gd.Unknown] = "Unknown", e[e.Uninstalled = Gd.Uninstalled] = "Uninstalled", e[e.Installed = Gd.Installed] = "Installed", e[e.Unlaunched = Kd.Unlaunched] = "Unlaunched", e[e.Launched = Kd.Launched] = "Launched", e;
}({});
;
}}),

};

//# sourceMappingURL=node_modules_%40zoom_videosdk_dist_index_esm_efd4b841.js.map