(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@zoom/videosdk/dist/index.umd.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
!function(e, t1) {
    ("TURBOPACK compile-time truthy", 1) ? t1(exports) : ("TURBOPACK unreachable", undefined);
}(this, function(e) {
    "use strict";
    var t1 = function(e, o) {
        return t1 = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(e, t1) {
            e.__proto__ = t1;
        } || function(e, t1) {
            for(var o in t1)Object.prototype.hasOwnProperty.call(t1, o) && (e[o] = t1[o]);
        }, t1(e, o);
    };
    function o(e, o) {
        if ("function" != typeof o && null !== o) throw new TypeError("Class extends value " + String(o) + " is not a constructor or null");
        function r() {
            this.constructor = e;
        }
        t1(e, o), e.prototype = null === o ? Object.create(o) : (r.prototype = o.prototype, new r);
    }
    var r = function() {
        return r = Object.assign || function(e) {
            for(var t1, o = 1, r = arguments.length; o < r; o++)for(var i in t1 = arguments[o])Object.prototype.hasOwnProperty.call(t1, i) && (e[i] = t1[i]);
            return e;
        }, r.apply(this, arguments);
    };
    function i(e, t1) {
        var o, r, i, n, s = {
            label: 0,
            sent: function() {
                if (1 & i[0]) throw i[1];
                return i[1];
            },
            trys: [],
            ops: []
        };
        return n = {
            next: a(0),
            throw: a(1),
            return: a(2)
        }, "function" == typeof Symbol && (n[Symbol.iterator] = function() {
            return this;
        }), n;
        "TURBOPACK unreachable";
        function a(n) {
            return function(a) {
                return function(n) {
                    if (o) throw new TypeError("Generator is already executing.");
                    for(; s;)try {
                        if (o = 1, r && (i = 2 & n[0] ? r.return : n[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, n[1])).done) return i;
                        switch(r = 0, i && (n = [
                            2 & n[0],
                            i.value
                        ]), n[0]){
                            case 0:
                            case 1:
                                i = n;
                                break;
                            case 4:
                                return s.label++, {
                                    value: n[1],
                                    done: !1
                                };
                            case 5:
                                s.label++, r = n[1], n = [
                                    0
                                ];
                                continue;
                            case 7:
                                n = s.ops.pop(), s.trys.pop();
                                continue;
                            default:
                                if (!((i = (i = s.trys).length > 0 && i[i.length - 1]) || 6 !== n[0] && 2 !== n[0])) {
                                    s = 0;
                                    continue;
                                }
                                if (3 === n[0] && (!i || n[1] > i[0] && n[1] < i[3])) {
                                    s.label = n[1];
                                    break;
                                }
                                if (6 === n[0] && s.label < i[1]) {
                                    s.label = i[1], i = n;
                                    break;
                                }
                                if (i && s.label < i[2]) {
                                    s.label = i[2], s.ops.push(n);
                                    break;
                                }
                                i[2] && s.ops.pop(), s.trys.pop();
                                continue;
                        }
                        n = t1.call(e, s);
                    } catch (e) {
                        n = [
                            6,
                            e
                        ], r = 0;
                    } finally{
                        o = i = 0;
                    }
                    if (5 & n[0]) throw n[1];
                    return {
                        value: n[0] ? n[1] : void 0,
                        done: !0
                    };
                }([
                    n,
                    a
                ]);
            };
        }
    }
    function n(e) {
        var t1 = "function" == typeof Symbol && Symbol.iterator, o = t1 && e[t1], r = 0;
        if (o) return o.call(e);
        if (e && "number" == typeof e.length) return {
            next: function() {
                return e && r >= e.length && (e = void 0), {
                    value: e && e[r++],
                    done: !e
                };
            }
        };
        throw new TypeError(t1 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function s(e, t1) {
        var o = "function" == typeof Symbol && e[Symbol.iterator];
        if (!o) return e;
        var r, i, n = o.call(e), s = [];
        try {
            for(; (void 0 === t1 || t1-- > 0) && !(r = n.next()).done;)s.push(r.value);
        } catch (e) {
            i = {
                error: e
            };
        } finally{
            try {
                r && !r.done && (o = n.return) && o.call(n);
            } finally{
                if (i) throw i.error;
            }
        }
        return s;
    }
    function a(e, t1) {
        for(var o = 0, r = t1.length, i = e.length; o < r; o++, i++)e[i] = t1[o];
        return e;
    }
    function d(e) {
        return this instanceof d ? (this.v = e, this) : new d(e);
    }
    function u(e) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var t1, o = e[Symbol.asyncIterator];
        return o ? o.call(e) : (e = n(e), t1 = {}, r("next"), r("throw"), r("return"), t1[Symbol.asyncIterator] = function() {
            return this;
        }, t1);
        "TURBOPACK unreachable";
        function r(o) {
            t1[o] = e[o] && function(t1) {
                return new Promise(function(r, i) {
                    !function(e, t1, o, r) {
                        Promise.resolve(r).then(function(t1) {
                            e({
                                value: t1,
                                done: o
                            });
                        }, t1);
                    }(r, i, (t1 = e[o](t1)).done, t1.value);
                });
            };
        }
    }
    function l(e) {
        return "function" == typeof e;
    }
    function c(e) {
        var t1 = e(function(e) {
            Error.call(e), e.stack = (new Error).stack;
        });
        return t1.prototype = Object.create(Error.prototype), t1.prototype.constructor = t1, t1;
    }
    var p = c(function(e) {
        return function(t1) {
            e(this), this.message = t1 ? t1.length + " errors occurred during unsubscription:\n" + t1.map(function(e, t1) {
                return t1 + 1 + ") " + e.toString();
            }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = t1;
        };
    });
    function h(e, t1) {
        if (e) {
            var o = e.indexOf(t1);
            0 <= o && e.splice(o, 1);
        }
    }
    var m = function() {
        function e(e) {
            this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
        }
        var t1;
        return e.prototype.unsubscribe = function() {
            var e, t1, o, r, i;
            if (!this.closed) {
                this.closed = !0;
                var d = this._parentage;
                if (d) if (this._parentage = null, Array.isArray(d)) try {
                    for(var u = n(d), c = u.next(); !c.done; c = u.next())c.value.remove(this);
                } catch (t1) {
                    e = {
                        error: t1
                    };
                } finally{
                    try {
                        c && !c.done && (t1 = u.return) && t1.call(u);
                    } finally{
                        if (e) throw e.error;
                    }
                }
                else d.remove(this);
                var h = this.initialTeardown;
                if (l(h)) try {
                    h();
                } catch (e) {
                    i = e instanceof p ? e.errors : [
                        e
                    ];
                }
                var m = this._finalizers;
                if (m) {
                    this._finalizers = null;
                    try {
                        for(var g = n(m), v = g.next(); !v.done; v = g.next()){
                            var y = v.value;
                            try {
                                f(y);
                            } catch (e) {
                                i = null != i ? i : [], e instanceof p ? i = a(a([], s(i)), s(e.errors)) : i.push(e);
                            }
                        }
                    } catch (e) {
                        o = {
                            error: e
                        };
                    } finally{
                        try {
                            v && !v.done && (r = g.return) && r.call(g);
                        } finally{
                            if (o) throw o.error;
                        }
                    }
                }
                if (i) throw new p(i);
            }
        }, e.prototype.add = function(t1) {
            var o;
            if (t1 && t1 !== this) if (this.closed) f(t1);
            else {
                if (t1 instanceof e) {
                    if (t1.closed || t1._hasParent(this)) return;
                    t1._addParent(this);
                }
                (this._finalizers = null !== (o = this._finalizers) && void 0 !== o ? o : []).push(t1);
            }
        }, e.prototype._hasParent = function(e) {
            var t1 = this._parentage;
            return t1 === e || Array.isArray(t1) && t1.includes(e);
        }, e.prototype._addParent = function(e) {
            var t1 = this._parentage;
            this._parentage = Array.isArray(t1) ? (t1.push(e), t1) : t1 ? [
                t1,
                e
            ] : e;
        }, e.prototype._removeParent = function(e) {
            var t1 = this._parentage;
            t1 === e ? this._parentage = null : Array.isArray(t1) && h(t1, e);
        }, e.prototype.remove = function(t1) {
            var o = this._finalizers;
            o && h(o, t1), t1 instanceof e && t1._removeParent(this);
        }, e.EMPTY = ((t1 = new e).closed = !0, t1), e;
    }(), g = m.EMPTY;
    function v(e) {
        return e instanceof m || e && "closed" in e && l(e.remove) && l(e.add) && l(e.unsubscribe);
    }
    function f(e) {
        l(e) ? e() : e.unsubscribe();
    }
    var y = void 0;
    function S(e) {
        !function(e, t1) {
            for(var o = [], r = 2; r < arguments.length; r++)o[r - 2] = arguments[r];
            setTimeout.apply(void 0, a([
                e,
                t1
            ], s(o)));
        }(function() {
            throw e;
        });
    }
    function b() {}
    function E(e) {
        e();
    }
    var I = function(e) {
        function t1(t1) {
            var o = e.call(this) || this;
            return o.isStopped = !1, t1 ? (o.destination = t1, v(t1) && t1.add(o)) : o.destination = R, o;
        }
        return o(t1, e), t1.create = function(e, t1, o) {
            return new C(e, t1, o);
        }, t1.prototype.next = function(e) {
            this.isStopped || this._next(e);
        }, t1.prototype.error = function(e) {
            this.isStopped || (this.isStopped = !0, this._error(e));
        }, t1.prototype.complete = function() {
            this.isStopped || (this.isStopped = !0, this._complete());
        }, t1.prototype.unsubscribe = function() {
            this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);
        }, t1.prototype._next = function(e) {
            this.destination.next(e);
        }, t1.prototype._error = function(e) {
            try {
                this.destination.error(e);
            } finally{
                this.unsubscribe();
            }
        }, t1.prototype._complete = function() {
            try {
                this.destination.complete();
            } finally{
                this.unsubscribe();
            }
        }, t1;
    }(m), A = function() {
        function e(e) {
            this.partialObserver = e;
        }
        return e.prototype.next = function(e) {
            var t1 = this.partialObserver;
            if (t1.next) try {
                t1.next(e);
            } catch (e) {
                _(e);
            }
        }, e.prototype.error = function(e) {
            var t1 = this.partialObserver;
            if (t1.error) try {
                t1.error(e);
            } catch (e) {
                _(e);
            }
            else _(e);
        }, e.prototype.complete = function() {
            var e = this.partialObserver;
            if (e.complete) try {
                e.complete();
            } catch (e) {
                _(e);
            }
        }, e;
    }(), C = function(e) {
        function t1(t1, o, r) {
            var i, n = e.call(this) || this;
            return i = l(t1) || !t1 ? {
                next: null != t1 ? t1 : void 0,
                error: null != o ? o : void 0,
                complete: null != r ? r : void 0
            } : t1, n.destination = new A(i), n;
        }
        return o(t1, e), t1;
    }(I);
    function _(e) {
        S(e);
    }
    var R = {
        closed: !0,
        next: b,
        error: function(e) {
            throw e;
        },
        complete: b
    }, w = "function" == typeof Symbol && Symbol.observable || "@@observable";
    function T(e) {
        return e;
    }
    function O() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        return D(e);
    }
    function D(e) {
        return 0 === e.length ? T : 1 === e.length ? e[0] : function(t1) {
            return e.reduce(function(e, t1) {
                return t1(e);
            }, t1);
        };
    }
    var P = function() {
        function e(e) {
            e && (this._subscribe = e);
        }
        return e.prototype.lift = function(t1) {
            var o = new e;
            return o.source = this, o.operator = t1, o;
        }, e.prototype.subscribe = function(e, t1, o) {
            var r, i = this, n = (r = e) && r instanceof I || function(e) {
                return e && l(e.next) && l(e.error) && l(e.complete);
            }(r) && v(r) ? e : new C(e, t1, o);
            return E(function() {
                var e = i, t1 = e.operator, o = e.source;
                n.add(t1 ? t1.call(n, o) : o ? i._subscribe(n) : i._trySubscribe(n));
            }), n;
        }, e.prototype._trySubscribe = function(e) {
            try {
                return this._subscribe(e);
            } catch (t1) {
                e.error(t1);
            }
        }, e.prototype.forEach = function(e, t1) {
            var o = this;
            return new (t1 = M(t1))(function(t1, r) {
                var i = new C({
                    next: function(t1) {
                        try {
                            e(t1);
                        } catch (e) {
                            r(e), i.unsubscribe();
                        }
                    },
                    error: r,
                    complete: t1
                });
                o.subscribe(i);
            });
        }, e.prototype._subscribe = function(e) {
            var t1;
            return null === (t1 = this.source) || void 0 === t1 ? void 0 : t1.subscribe(e);
        }, e.prototype[w] = function() {
            return this;
        }, e.prototype.pipe = function() {
            for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
            return D(e)(this);
        }, e.prototype.toPromise = function(e) {
            var t1 = this;
            return new (e = M(e))(function(e, o) {
                var r;
                t1.subscribe(function(e) {
                    return r = e;
                }, function(e) {
                    return o(e);
                }, function() {
                    return e(r);
                });
            });
        }, e.create = function(t1) {
            return new e(t1);
        }, e;
    }();
    function M(e) {
        var t1;
        return null !== (t1 = null != e ? e : y) && void 0 !== t1 ? t1 : Promise;
    }
    function k(e) {
        return function(t1) {
            if (function(e) {
                return l(null == e ? void 0 : e.lift);
            }(t1)) return t1.lift(function(t1) {
                try {
                    return e(t1, this);
                } catch (e) {
                    this.error(e);
                }
            });
            throw new TypeError("Unable to lift unknown Observable type");
        };
    }
    function L(e, t1, o, r, i) {
        return new V(e, t1, o, r, i);
    }
    var N, V = function(e) {
        function t1(t1, o, r, i, n, s) {
            var a = e.call(this, t1) || this;
            return a.onFinalize = n, a.shouldUnsubscribe = s, a._next = o ? function(e) {
                try {
                    o(e);
                } catch (e) {
                    t1.error(e);
                }
            } : e.prototype._next, a._error = i ? function(e) {
                try {
                    i(e);
                } catch (e) {
                    t1.error(e);
                } finally{
                    this.unsubscribe();
                }
            } : e.prototype._error, a._complete = r ? function() {
                try {
                    r();
                } catch (e) {
                    t1.error(e);
                } finally{
                    this.unsubscribe();
                }
            } : e.prototype._complete, a;
        }
        return o(t1, e), t1.prototype.unsubscribe = function() {
            var t1;
            if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                var o = this.closed;
                e.prototype.unsubscribe.call(this), !o && (null === (t1 = this.onFinalize) || void 0 === t1 || t1.call(this));
            }
        }, t1;
    }(I), U = c(function(e) {
        return function() {
            e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
        };
    }), j = function(e) {
        function t1() {
            var t1 = e.call(this) || this;
            return t1.closed = !1, t1.currentObservers = null, t1.observers = [], t1.isStopped = !1, t1.hasError = !1, t1.thrownError = null, t1;
        }
        return o(t1, e), t1.prototype.lift = function(e) {
            var t1 = new x(this, this);
            return t1.operator = e, t1;
        }, t1.prototype._throwIfClosed = function() {
            if (this.closed) throw new U;
        }, t1.prototype.next = function(e) {
            var t1 = this;
            E(function() {
                var o, r;
                if (t1._throwIfClosed(), !t1.isStopped) {
                    t1.currentObservers || (t1.currentObservers = Array.from(t1.observers));
                    try {
                        for(var i = n(t1.currentObservers), s = i.next(); !s.done; s = i.next())s.value.next(e);
                    } catch (e) {
                        o = {
                            error: e
                        };
                    } finally{
                        try {
                            s && !s.done && (r = i.return) && r.call(i);
                        } finally{
                            if (o) throw o.error;
                        }
                    }
                }
            });
        }, t1.prototype.error = function(e) {
            var t1 = this;
            E(function() {
                if (t1._throwIfClosed(), !t1.isStopped) {
                    t1.hasError = t1.isStopped = !0, t1.thrownError = e;
                    for(var o = t1.observers; o.length;)o.shift().error(e);
                }
            });
        }, t1.prototype.complete = function() {
            var e = this;
            E(function() {
                if (e._throwIfClosed(), !e.isStopped) {
                    e.isStopped = !0;
                    for(var t1 = e.observers; t1.length;)t1.shift().complete();
                }
            });
        }, t1.prototype.unsubscribe = function() {
            this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
        }, Object.defineProperty(t1.prototype, "observed", {
            get: function() {
                var e;
                return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0;
            },
            enumerable: !1,
            configurable: !0
        }), t1.prototype._trySubscribe = function(t1) {
            return this._throwIfClosed(), e.prototype._trySubscribe.call(this, t1);
        }, t1.prototype._subscribe = function(e) {
            return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e);
        }, t1.prototype._innerSubscribe = function(e) {
            var t1 = this, o = this, r = o.hasError, i = o.isStopped, n = o.observers;
            return r || i ? g : (this.currentObservers = null, n.push(e), new m(function() {
                t1.currentObservers = null, h(n, e);
            }));
        }, t1.prototype._checkFinalizedStatuses = function(e) {
            var t1 = this, o = t1.hasError, r = t1.thrownError, i = t1.isStopped;
            o ? e.error(r) : i && e.complete();
        }, t1.prototype.asObservable = function() {
            var e = new P;
            return e.source = this, e;
        }, t1.create = function(e, t1) {
            return new x(e, t1);
        }, t1;
    }(P), x = function(e) {
        function t1(t1, o) {
            var r = e.call(this) || this;
            return r.destination = t1, r.source = o, r;
        }
        return o(t1, e), t1.prototype.next = function(e) {
            var t1, o;
            null === (o = null === (t1 = this.destination) || void 0 === t1 ? void 0 : t1.next) || void 0 === o || o.call(t1, e);
        }, t1.prototype.error = function(e) {
            var t1, o;
            null === (o = null === (t1 = this.destination) || void 0 === t1 ? void 0 : t1.error) || void 0 === o || o.call(t1, e);
        }, t1.prototype.complete = function() {
            var e, t1;
            null === (t1 = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === t1 || t1.call(e);
        }, t1.prototype._subscribe = function(e) {
            var t1, o;
            return null !== (o = null === (t1 = this.source) || void 0 === t1 ? void 0 : t1.subscribe(e)) && void 0 !== o ? o : g;
        }, t1;
    }(j), B = function(e) {
        function t1(t1) {
            var o = e.call(this) || this;
            return o._value = t1, o;
        }
        return o(t1, e), Object.defineProperty(t1.prototype, "value", {
            get: function() {
                return this.getValue();
            },
            enumerable: !1,
            configurable: !0
        }), t1.prototype._subscribe = function(t1) {
            var o = e.prototype._subscribe.call(this, t1);
            return !o.closed && t1.next(this._value), o;
        }, t1.prototype.getValue = function() {
            var e = this, t1 = e.hasError, o = e.thrownError, r = e._value;
            if (t1) throw o;
            return this._throwIfClosed(), r;
        }, t1.prototype.next = function(t1) {
            e.prototype.next.call(this, this._value = t1);
        }, t1;
    }(j), F = {
        now: function() {
            return (F.delegate || Date).now();
        },
        delegate: void 0
    }, H = function(e) {
        function t1(t1, o, r) {
            void 0 === t1 && (t1 = 1 / 0), void 0 === o && (o = 1 / 0), void 0 === r && (r = F);
            var i = e.call(this) || this;
            return i._bufferSize = t1, i._windowTime = o, i._timestampProvider = r, i._buffer = [], i._infiniteTimeWindow = !0, i._infiniteTimeWindow = o === 1 / 0, i._bufferSize = Math.max(1, t1), i._windowTime = Math.max(1, o), i;
        }
        return o(t1, e), t1.prototype.next = function(t1) {
            var o = this, r = o.isStopped, i = o._buffer, n = o._infiniteTimeWindow, s = o._timestampProvider, a = o._windowTime;
            r || (i.push(t1), !n && i.push(s.now() + a)), this._trimBuffer(), e.prototype.next.call(this, t1);
        }, t1.prototype._subscribe = function(e) {
            this._throwIfClosed(), this._trimBuffer();
            for(var t1 = this._innerSubscribe(e), o = this._infiniteTimeWindow, r = this._buffer.slice(), i = 0; i < r.length && !e.closed; i += o ? 1 : 2)e.next(r[i]);
            return this._checkFinalizedStatuses(e), t1;
        }, t1.prototype._trimBuffer = function() {
            var e = this, t1 = e._bufferSize, o = e._timestampProvider, r = e._buffer, i = e._infiniteTimeWindow, n = (i ? 1 : 2) * t1;
            if (t1 < 1 / 0 && n < r.length && r.splice(0, r.length - n), !i) {
                for(var s = o.now(), a = 0, d = 1; d < r.length && r[d] <= s; d += 2)a = d;
                a && r.splice(0, a + 1);
            }
        }, t1;
    }(j), $ = function(e) {
        function t1(t1, o) {
            return e.call(this) || this;
        }
        return o(t1, e), t1.prototype.schedule = function(e, t1) {
            return this;
        }, t1;
    }(m), W = function(e) {
        function t1(t1, o) {
            var r = e.call(this, t1, o) || this;
            return r.scheduler = t1, r.work = o, r.pending = !1, r;
        }
        return o(t1, e), t1.prototype.schedule = function(e, t1) {
            var o;
            if (void 0 === t1 && (t1 = 0), this.closed) return this;
            this.state = e;
            var r = this.id, i = this.scheduler;
            return null != r && (this.id = this.recycleAsyncId(i, r, t1)), this.pending = !0, this.delay = t1, this.id = null !== (o = this.id) && void 0 !== o ? o : this.requestAsyncId(i, this.id, t1), this;
        }, t1.prototype.requestAsyncId = function(e, t1, o) {
            return void 0 === o && (o = 0), function(e, t1) {
                for(var o = [], r = 2; r < arguments.length; r++)o[r - 2] = arguments[r];
                return setInterval.apply(void 0, a([
                    e,
                    t1
                ], s(o)));
            }(e.flush.bind(e, this), o);
        }, t1.prototype.recycleAsyncId = function(e, t1, o) {
            if (void 0 === o && (o = 0), null != o && this.delay === o && !1 === this.pending) return t1;
            null != t1 && function(e) {
                clearInterval(e);
            }(t1);
        }, t1.prototype.execute = function(e, t1) {
            if (this.closed) return new Error("executing a cancelled action");
            this.pending = !1;
            var o = this._execute(e, t1);
            if (o) return o;
            !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }, t1.prototype._execute = function(e, t1) {
            var o, r = !1;
            try {
                this.work(e);
            } catch (e) {
                r = !0, o = e || new Error("Scheduled action threw falsy error");
            }
            if (r) return this.unsubscribe(), o;
        }, t1.prototype.unsubscribe = function() {
            if (!this.closed) {
                var t1 = this.id, o = this.scheduler, r = o.actions;
                this.work = this.state = this.scheduler = null, this.pending = !1, h(r, this), null != t1 && (this.id = this.recycleAsyncId(o, t1, null)), this.delay = null, e.prototype.unsubscribe.call(this);
            }
        }, t1;
    }($), G = 1, K = {};
    function z(e) {
        return e in K && (delete K[e], !0);
    }
    var q = function(e) {
        var t1 = G++;
        return K[t1] = !0, N || (N = Promise.resolve()), N.then(function() {
            return z(t1) && e();
        }), t1;
    }, J = function() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        return q.apply(void 0, a([], s(e)));
    }, Q = function(e) {
        return function(e) {
            z(e);
        }(e);
    }, Z = function(e) {
        function t1(t1, o) {
            var r = e.call(this, t1, o) || this;
            return r.scheduler = t1, r.work = o, r;
        }
        return o(t1, e), t1.prototype.requestAsyncId = function(t1, o, r) {
            return void 0 === r && (r = 0), null !== r && r > 0 ? e.prototype.requestAsyncId.call(this, t1, o, r) : (t1.actions.push(this), t1._scheduled || (t1._scheduled = J(t1.flush.bind(t1, void 0))));
        }, t1.prototype.recycleAsyncId = function(t1, o, r) {
            var i;
            if (void 0 === r && (r = 0), null != r ? r > 0 : this.delay > 0) return e.prototype.recycleAsyncId.call(this, t1, o, r);
            var n = t1.actions;
            null != o && (null === (i = n[n.length - 1]) || void 0 === i ? void 0 : i.id) !== o && (Q(o), t1._scheduled === o && (t1._scheduled = void 0));
        }, t1;
    }(W), Y = function() {
        function e(t1, o) {
            void 0 === o && (o = e.now), this.schedulerActionCtor = t1, this.now = o;
        }
        return e.prototype.schedule = function(e, t1, o) {
            return void 0 === t1 && (t1 = 0), new this.schedulerActionCtor(this, e).schedule(o, t1);
        }, e.now = F.now, e;
    }(), X = function(e) {
        function t1(t1, o) {
            void 0 === o && (o = Y.now);
            var r = e.call(this, t1, o) || this;
            return r.actions = [], r._active = !1, r;
        }
        return o(t1, e), t1.prototype.flush = function(e) {
            var t1 = this.actions;
            if (this._active) t1.push(e);
            else {
                var o;
                this._active = !0;
                do {
                    if (o = e.execute(e.state, e.delay)) break;
                }while (e = t1.shift())
                if (this._active = !1, o) {
                    for(; e = t1.shift();)e.unsubscribe();
                    throw o;
                }
            }
        }, t1;
    }(Y), ee = new (function(e) {
        function t1() {
            return null !== e && e.apply(this, arguments) || this;
        }
        return o(t1, e), t1.prototype.flush = function(e) {
            this._active = !0;
            var t1 = this._scheduled;
            this._scheduled = void 0;
            var o, r = this.actions;
            e = e || r.shift();
            do {
                if (o = e.execute(e.state, e.delay)) break;
            }while ((e = r[0]) && e.id === t1 && r.shift())
            if (this._active = !1, o) {
                for(; (e = r[0]) && e.id === t1 && r.shift();)e.unsubscribe();
                throw o;
            }
        }, t1;
    }(X))(Z), te = new X(W), oe = te, re = function(e) {
        function t1(t1, o) {
            var r = e.call(this, t1, o) || this;
            return r.scheduler = t1, r.work = o, r;
        }
        return o(t1, e), t1.prototype.schedule = function(t1, o) {
            return void 0 === o && (o = 0), o > 0 ? e.prototype.schedule.call(this, t1, o) : (this.delay = o, this.state = t1, this.scheduler.flush(this), this);
        }, t1.prototype.execute = function(t1, o) {
            return o > 0 || this.closed ? e.prototype.execute.call(this, t1, o) : this._execute(t1, o);
        }, t1.prototype.requestAsyncId = function(t1, o, r) {
            return void 0 === r && (r = 0), null != r && r > 0 || null == r && this.delay > 0 ? e.prototype.requestAsyncId.call(this, t1, o, r) : (t1.flush(this), 0);
        }, t1;
    }(W), ie = new (function(e) {
        function t1() {
            return null !== e && e.apply(this, arguments) || this;
        }
        return o(t1, e), t1;
    }(X))(re), ne = new P(function(e) {
        return e.complete();
    });
    function se(e) {
        return e && l(e.schedule);
    }
    function ae(e) {
        return e[e.length - 1];
    }
    function de(e) {
        return l(ae(e)) ? e.pop() : void 0;
    }
    function ue(e) {
        return se(ae(e)) ? e.pop() : void 0;
    }
    var le = function(e) {
        return e && "number" == typeof e.length && "function" != typeof e;
    };
    function ce(e) {
        return l(null == e ? void 0 : e.then);
    }
    function pe(e) {
        return l(e[w]);
    }
    function he(e) {
        return Symbol.asyncIterator && l(null == e ? void 0 : e[Symbol.asyncIterator]);
    }
    function me(e) {
        return new TypeError("You provided " + (null !== e && "object" == typeof e ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    var ge = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
    function ve(e) {
        return l(null == e ? void 0 : e[ge]);
    }
    function fe(e) {
        return function(e, t1, o) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var r, i = o.apply(e, t1 || []), n = [];
            return r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function() {
                return this;
            }, r;
            "TURBOPACK unreachable";
            function s(e) {
                i[e] && (r[e] = function(t1) {
                    return new Promise(function(o, r) {
                        n.push([
                            e,
                            t1,
                            o,
                            r
                        ]) > 1 || a(e, t1);
                    });
                });
            }
            function a(e, t1) {
                try {
                    !function(e) {
                        e.value instanceof d ? Promise.resolve(e.value.v).then(u, l) : c(n[0][2], e);
                    }(i[e](t1));
                } catch (e) {
                    c(n[0][3], e);
                }
            }
            function u(e) {
                a("next", e);
            }
            function l(e) {
                a("throw", e);
            }
            function c(e, t1) {
                e(t1), n.shift(), n.length && a(n[0][0], n[0][1]);
            }
        }(this, arguments, function() {
            var t1, o, r;
            return i(this, function(i) {
                switch(i.label){
                    case 0:
                        t1 = e.getReader(), i.label = 1;
                    case 1:
                        i.trys.push([
                            1,
                            ,
                            9,
                            10
                        ]), i.label = 2;
                    case 2:
                        return [
                            4,
                            d(t1.read())
                        ];
                    case 3:
                        return o = i.sent(), r = o.value, o.done ? [
                            4,
                            d(void 0)
                        ] : [
                            3,
                            5
                        ];
                    case 4:
                        return [
                            2,
                            i.sent()
                        ];
                    case 5:
                        return [
                            4,
                            d(r)
                        ];
                    case 6:
                        return [
                            4,
                            i.sent()
                        ];
                    case 7:
                        return i.sent(), [
                            3,
                            2
                        ];
                    case 8:
                        return [
                            3,
                            10
                        ];
                    case 9:
                        return t1.releaseLock(), [
                            7
                        ];
                    case 10:
                        return [
                            2
                        ];
                }
            });
        });
    }
    function ye(e) {
        return l(null == e ? void 0 : e.getReader);
    }
    function Se(e) {
        if (e instanceof P) return e;
        if (null != e) {
            if (pe(e)) return i = e, new P(function(e) {
                var t1 = i[w]();
                if (l(t1.subscribe)) return t1.subscribe(e);
                throw new TypeError("Provided object does not correctly implement Symbol.observable");
            });
            if (le(e)) return r = e, new P(function(e) {
                for(var t1 = 0; t1 < r.length && !e.closed; t1++)e.next(r[t1]);
                e.complete();
            });
            if (ce(e)) return o = e, new P(function(e) {
                o.then(function(t1) {
                    e.closed || (e.next(t1), e.complete());
                }, function(t1) {
                    return e.error(t1);
                }).then(null, S);
            });
            if (he(e)) return be(e);
            if (ve(e)) return t1 = e, new P(function(e) {
                var o, r;
                try {
                    for(var i = n(t1), s = i.next(); !s.done; s = i.next()){
                        var a = s.value;
                        if (e.next(a), e.closed) return;
                    }
                } catch (e) {
                    o = {
                        error: e
                    };
                } finally{
                    try {
                        s && !s.done && (r = i.return) && r.call(i);
                    } finally{
                        if (o) throw o.error;
                    }
                }
                e.complete();
            });
            if (ye(e)) return be(fe(e));
        }
        var t1, o, r, i;
        throw me(e);
    }
    function be(e) {
        return new P(function(t1) {
            (function(e, t1) {
                var o, r, n, s;
                return function(e, t1, o, r) {
                    return new (o || (o = Promise))(function(t1, i) {
                        function n(e) {
                            try {
                                a(r.next(e));
                            } catch (e) {
                                i(e);
                            }
                        }
                        function s(e) {
                            try {
                                a(r.throw(e));
                            } catch (e) {
                                i(e);
                            }
                        }
                        function a(e) {
                            var r;
                            e.done ? t1(e.value) : (r = e.value, r instanceof o ? r : new o(function(e) {
                                e(r);
                            })).then(n, s);
                        }
                        a((r = r.apply(e, [])).next());
                    });
                }(this, 0, void 0, function() {
                    var a, d;
                    return i(this, function(i) {
                        switch(i.label){
                            case 0:
                                i.trys.push([
                                    0,
                                    5,
                                    6,
                                    11
                                ]), o = u(e), i.label = 1;
                            case 1:
                                return [
                                    4,
                                    o.next()
                                ];
                            case 2:
                                if ((r = i.sent()).done) return [
                                    3,
                                    4
                                ];
                                if (a = r.value, t1.next(a), t1.closed) return [
                                    2
                                ];
                                i.label = 3;
                            case 3:
                                return [
                                    3,
                                    1
                                ];
                            case 4:
                                return [
                                    3,
                                    11
                                ];
                            case 5:
                                return d = i.sent(), n = {
                                    error: d
                                }, [
                                    3,
                                    11
                                ];
                            case 6:
                                return i.trys.push([
                                    6,
                                    ,
                                    9,
                                    10
                                ]), r && !r.done && (s = o.return) ? [
                                    4,
                                    s.call(o)
                                ] : [
                                    3,
                                    8
                                ];
                            case 7:
                                i.sent(), i.label = 8;
                            case 8:
                                return [
                                    3,
                                    10
                                ];
                            case 9:
                                if (n) throw n.error;
                                return [
                                    7
                                ];
                            case 10:
                                return [
                                    7
                                ];
                            case 11:
                                return t1.complete(), [
                                    2
                                ];
                        }
                    });
                });
            })(e, t1).catch(function(e) {
                return t1.error(e);
            });
        });
    }
    function Ee(e, t1, o, r, i) {
        void 0 === r && (r = 0), void 0 === i && (i = !1);
        var n = t1.schedule(function() {
            o(), i ? e.add(this.schedule(null, r)) : this.unsubscribe();
        }, r);
        if (e.add(n), !i) return n;
    }
    function Ie(e, t1) {
        return void 0 === t1 && (t1 = 0), k(function(o, r) {
            o.subscribe(L(r, function(o) {
                return Ee(r, e, function() {
                    return r.next(o);
                }, t1);
            }, function() {
                return Ee(r, e, function() {
                    return r.complete();
                }, t1);
            }, function(o) {
                return Ee(r, e, function() {
                    return r.error(o);
                }, t1);
            }));
        });
    }
    function Ae(e, t1) {
        return void 0 === t1 && (t1 = 0), k(function(o, r) {
            r.add(e.schedule(function() {
                return o.subscribe(r);
            }, t1));
        });
    }
    function Ce(e, t1) {
        if (!e) throw new Error("Iterable cannot be null");
        return new P(function(o) {
            Ee(o, t1, function() {
                var r = e[Symbol.asyncIterator]();
                Ee(o, t1, function() {
                    r.next().then(function(e) {
                        e.done ? o.complete() : o.next(e.value);
                    });
                }, 0, !0);
            });
        });
    }
    function _e(e, t1) {
        return t1 ? function(e, t1) {
            if (null != e) {
                if (pe(e)) return function(e, t1) {
                    return Se(e).pipe(Ae(t1), Ie(t1));
                }(e, t1);
                if (le(e)) return function(e, t1) {
                    return new P(function(o) {
                        var r = 0;
                        return t1.schedule(function() {
                            r === e.length ? o.complete() : (o.next(e[r++]), o.closed || this.schedule());
                        });
                    });
                }(e, t1);
                if (ce(e)) return function(e, t1) {
                    return Se(e).pipe(Ae(t1), Ie(t1));
                }(e, t1);
                if (he(e)) return Ce(e, t1);
                if (ve(e)) return function(e, t1) {
                    return new P(function(o) {
                        var r;
                        return Ee(o, t1, function() {
                            r = e[ge](), Ee(o, t1, function() {
                                var e, t1, i;
                                try {
                                    t1 = (e = r.next()).value, i = e.done;
                                } catch (e) {
                                    return void o.error(e);
                                }
                                i ? o.complete() : o.next(t1);
                            }, 0, !0);
                        }), function() {
                            return l(null == r ? void 0 : r.return) && r.return();
                        };
                    });
                }(e, t1);
                if (ye(e)) return function(e, t1) {
                    return Ce(fe(e), t1);
                }(e, t1);
            }
            throw me(e);
        }(e, t1) : Se(e);
    }
    function Re() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        return _e(e, ue(e));
    }
    function we(e, t1) {
        var o = l(e) ? e : function() {
            return e;
        };
        return new P(function(e) {
            return e.error(o());
        });
    }
    var Te = c(function(e) {
        return function() {
            e(this), this.name = "EmptyError", this.message = "no elements in sequence";
        };
    });
    function Oe(e, t1) {
        return new Promise(function(t1, o) {
            var r = new C({
                next: function(e) {
                    t1(e), r.unsubscribe();
                },
                error: o,
                complete: function() {
                    o(new Te);
                }
            });
            e.subscribe(r);
        });
    }
    function De(e) {
        return e instanceof Date && !isNaN(e);
    }
    var Pe = c(function(e) {
        return function(t1) {
            void 0 === t1 && (t1 = null), e(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this.info = t1;
        };
    });
    function Me(e, t1) {
        var o = De(e) ? {
            first: e
        } : "number" == typeof e ? {
            each: e
        } : e, r = o.first, i = o.each, n = o.with, s = void 0 === n ? ke : n, a = o.scheduler, d = void 0 === a ? te : a, u = o.meta, l = void 0 === u ? null : u;
        if (null == r && null == i) throw new TypeError("No timeout provided.");
        return k(function(e, t1) {
            var o, n, a = null, u = 0, c = function(e) {
                n = Ee(t1, d, function() {
                    try {
                        o.unsubscribe(), Se(s({
                            meta: l,
                            lastValue: a,
                            seen: u
                        })).subscribe(t1);
                    } catch (e) {
                        t1.error(e);
                    }
                }, e);
            };
            o = e.subscribe(L(t1, function(e) {
                null == n || n.unsubscribe(), u++, t1.next(a = e), i > 0 && c(i);
            }, void 0, void 0, function() {
                (null == n ? void 0 : n.closed) || null == n || n.unsubscribe(), a = null;
            })), !u && c(null != r ? "number" == typeof r ? r : +r - d.now() : i);
        });
    }
    function ke(e) {
        throw new Pe(e);
    }
    function Le(e, t1) {
        return k(function(o, r) {
            var i = 0;
            o.subscribe(L(r, function(o) {
                r.next(e.call(t1, o, i++));
            }));
        });
    }
    var Ne = Array.isArray;
    function Ve(e) {
        return Le(function(t1) {
            return function(e, t1) {
                return Ne(t1) ? e.apply(void 0, a([], s(t1))) : e(t1);
            }(e, t1);
        });
    }
    var Ue = Array.isArray, je = Object.getPrototypeOf, xe = Object.prototype, Be = Object.keys;
    function Fe(e, t1, o) {
        return void 0 === o && (o = 1 / 0), l(t1) ? Fe(function(o, r) {
            return Le(function(e, i) {
                return t1(o, e, r, i);
            })(Se(e(o, r)));
        }, o) : ("number" == typeof t1 && (o = t1), k(function(t1, r) {
            return function(e, t1, o, r) {
                var i = [], n = 0, s = 0, a = !1, d = function() {
                    !a || i.length || n || t1.complete();
                }, u = function(e) {
                    n++;
                    var a = !1;
                    Se(o(e, s++)).subscribe(L(t1, function(e) {
                        t1.next(e);
                    }, function() {
                        a = !0;
                    }, void 0, function() {
                        if (a) try {
                            for(n--; i.length && n < r;)e = i.shift(), u(e);
                            d();
                        } catch (e) {
                            t1.error(e);
                        }
                        var e;
                    }));
                };
                return e.subscribe(L(t1, function(e) {
                    return n < r ? u(e) : i.push(e);
                }, function() {
                    a = !0, d();
                })), function() {};
            }(t1, r, e, o);
        }));
    }
    function He(e) {
        return void 0 === e && (e = 1 / 0), Fe(T, e);
    }
    function $e() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        return He(1)(_e(e, ue(e)));
    }
    function We() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        var o = de(e), r = function(e) {
            if (1 === e.length) {
                var t1 = e[0];
                if (Ue(t1)) return {
                    args: t1,
                    keys: null
                };
                if ((r = t1) && "object" == typeof r && je(r) === xe) {
                    var o = Be(t1);
                    return {
                        args: o.map(function(e) {
                            return t1[e];
                        }),
                        keys: o
                    };
                }
            }
            var r;
            return {
                args: e,
                keys: null
            };
        }(e), i = r.args, n = r.keys, s = new P(function(e) {
            var t1 = i.length;
            if (t1) for(var o = new Array(t1), r = t1, s = t1, a = function(t1) {
                var a = !1;
                Se(i[t1]).subscribe(L(e, function(e) {
                    a || (a = !0, s--), o[t1] = e;
                }, function() {
                    return r--;
                }, void 0, function() {
                    r && a || (s || e.next(n ? function(e, t1) {
                        return e.reduce(function(e, o, r) {
                            return e[o] = t1[r], e;
                        }, {});
                    }(n, o) : o), e.complete());
                }));
            }, d = 0; d < t1; d++)a(d);
            else e.complete();
        });
        return o ? s.pipe(Ve(o)) : s;
    }
    var Ge = [
        "addListener",
        "removeListener"
    ], Ke = [
        "addEventListener",
        "removeEventListener"
    ], ze = [
        "on",
        "off"
    ];
    function qe(e, t1, o, r) {
        if (l(o) && (r = o, o = void 0), r) return qe(e, t1, o).pipe(Ve(r));
        var i = s(function(e) {
            return l(e.addEventListener) && l(e.removeEventListener);
        }(e) ? Ke.map(function(r) {
            return function(i) {
                return e[r](t1, i, o);
            };
        }) : function(e) {
            return l(e.addListener) && l(e.removeListener);
        }(e) ? Ge.map(Je(e, t1)) : function(e) {
            return l(e.on) && l(e.off);
        }(e) ? ze.map(Je(e, t1)) : [], 2), n = i[0], a = i[1];
        if (!n && le(e)) return Fe(function(e) {
            return qe(e, t1, o);
        })(Se(e));
        if (!n) throw new TypeError("Invalid event target");
        return new P(function(e) {
            var t1 = function() {
                for(var t1 = [], o = 0; o < arguments.length; o++)t1[o] = arguments[o];
                return e.next(1 < t1.length ? t1 : t1[0]);
            };
            return n(t1), function() {
                return a(t1);
            };
        });
    }
    function Je(e, t1) {
        return function(o) {
            return function(r) {
                return e[o](t1, r);
            };
        };
    }
    function Qe(e, t1, o) {
        return o ? Qe(e, t1).pipe(Ve(o)) : new P(function(o) {
            var r = function() {
                for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
                return o.next(1 === e.length ? e[0] : e);
            }, i = e(r);
            return l(t1) ? function() {
                return t1(r, i);
            } : void 0;
        });
    }
    function Ze(e, t1, o) {
        void 0 === e && (e = 0), void 0 === o && (o = oe);
        var r = -1;
        return null != t1 && (se(t1) ? o = t1 : r = t1), new P(function(t1) {
            var i = De(e) ? +e - o.now() : e;
            i < 0 && (i = 0);
            var n = 0;
            return o.schedule(function() {
                t1.closed || (t1.next(n++), 0 <= r ? this.schedule(void 0, r) : t1.complete());
            }, i);
        });
    }
    function Ye(e, t1) {
        return void 0 === e && (e = 0), void 0 === t1 && (t1 = te), e < 0 && (e = 0), Ze(e, e, t1);
    }
    function Xe() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        var o = ue(e), r = function(e) {
            return "number" == typeof ae(e) ? e.pop() : 1 / 0;
        }(e), i = e;
        return i.length ? 1 === i.length ? Se(i[0]) : He(r)(_e(i, o)) : ne;
    }
    var et = Array.isArray;
    function tt(e, t1) {
        return function(o, r) {
            return !e.call(t1, o, r);
        };
    }
    function ot(e, t1) {
        return k(function(o, r) {
            var i = 0;
            o.subscribe(L(r, function(o) {
                return e.call(t1, o, i++) && r.next(o);
            }));
        });
    }
    function rt() {
        for(var e, t1 = [], o = 0; o < arguments.length; o++)t1[o] = arguments[o];
        return 1 === (t1 = 1 === (e = t1).length && et(e[0]) ? e[0] : e).length ? Se(t1[0]) : new P(function(e) {
            return function(t1) {
                for(var o = [], r = function(r) {
                    o.push(Se(e[r]).subscribe(L(t1, function(e) {
                        if (o) {
                            for(var i = 0; i < o.length; i++)i !== r && o[i].unsubscribe();
                            o = null;
                        }
                        t1.next(e);
                    })));
                }, i = 0; o && !t1.closed && i < e.length; i++)r(i);
            };
        }(t1));
    }
    function it(e) {
        return k(function(t1, o) {
            var r, i = null, n = !1;
            i = t1.subscribe(L(o, void 0, void 0, function(s) {
                r = Se(e(s, it(e)(t1))), i ? (i.unsubscribe(), i = null, r.subscribe(o)) : n = !0;
            })), n && (i.unsubscribe(), i = null, r.subscribe(o));
        });
    }
    function nt(e) {
        return e <= 0 ? function() {
            return ne;
        } : k(function(t1, o) {
            var r = 0;
            t1.subscribe(L(o, function(t1) {
                ++r <= e && (o.next(t1), e <= r && o.complete());
            }));
        });
    }
    function st() {
        return k(function(e, t1) {
            e.subscribe(L(t1, b));
        });
    }
    function at(e) {
        return Le(function() {
            return e;
        });
    }
    function dt(e, t1) {
        void 0 === t1 && (t1 = te);
        var o, r = Ze(e, t1);
        return o = function() {
            return r;
        }, Fe(function(e, t1) {
            return Se(o()).pipe(nt(1), at(e));
        });
    }
    function ut(e, t1, o) {
        return void 0 === o && (o = 1 / 0), l(t1) ? Fe(function() {
            return e;
        }, t1, o) : Fe(function() {
            return e;
        }, o);
    }
    function lt(e, t1) {
        return k(function(e, t1, o) {
            return function(r, i) {
                var n = o, s = t1, a = 0;
                r.subscribe(L(i, function(t1) {
                    var o = a++;
                    s = n ? e(s, t1, o) : (n = !0, t1), i.next(s);
                }, undefined));
            };
        }(e, t1, arguments.length >= 2));
    }
    function ct(e) {
        return k(function(t1, o) {
            var r = !1, i = 0;
            t1.subscribe(L(o, function(t1) {
                return (r || (r = !e(t1, i++))) && o.next(t1);
            }));
        });
    }
    function pt() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        var o = ue(e);
        return k(function(t1, r) {
            (o ? $e(e, t1, o) : $e(e, t1)).subscribe(r);
        });
    }
    function ht(e, t1) {
        return k(function(o, r) {
            var i = null, n = 0, s = !1, a = function() {
                return s && !i && r.complete();
            };
            o.subscribe(L(r, function(o) {
                null == i || i.unsubscribe();
                var s = 0, d = n++;
                Se(e(o, d)).subscribe(i = L(r, function(e) {
                    return r.next(t1 ? t1(o, e, d, s++) : e);
                }, function() {
                    i = null, a();
                }));
            }, function() {
                s = !0, a();
            }));
        });
    }
    function mt(e) {
        return k(function(t1, o) {
            Se(e).subscribe(L(o, function() {
                return o.complete();
            }, b)), !o.closed && t1.subscribe(o);
        });
    }
    function gt(e, t1) {
        return void 0 === t1 && (t1 = !1), k(function(o, r) {
            var i = 0;
            o.subscribe(L(r, function(o) {
                var n = e(o, i++);
                (n || t1) && r.next(o), !n && r.complete();
            }));
        });
    }
    function vt(e, t1, o) {
        var r = l(e) || t1 || o ? {
            next: e,
            error: t1,
            complete: o
        } : e;
        return r ? k(function(e, t1) {
            var o;
            null === (o = r.subscribe) || void 0 === o || o.call(r);
            var i = !0;
            e.subscribe(L(t1, function(e) {
                var o;
                null === (o = r.next) || void 0 === o || o.call(r, e), t1.next(e);
            }, function() {
                var e;
                i = !1, null === (e = r.complete) || void 0 === e || e.call(r), t1.complete();
            }, function(e) {
                var o;
                i = !1, null === (o = r.error) || void 0 === o || o.call(r, e), t1.error(e);
            }, function() {
                var e, t1;
                i && (null === (e = r.unsubscribe) || void 0 === e || e.call(r)), null === (t1 = r.finalize) || void 0 === t1 || t1.call(r);
            }));
        }) : T;
    }
    function ft() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        var o = de(e);
        return k(function(t1, r) {
            for(var i = e.length, n = new Array(i), d = e.map(function() {
                return !1;
            }), u = !1, l = function(t1) {
                Se(e[t1]).subscribe(L(r, function(e) {
                    n[t1] = e, u || d[t1] || (d[t1] = !0, (u = d.every(T)) && (d = null));
                }, b));
            }, c = 0; c < i; c++)l(c);
            t1.subscribe(L(r, function(e) {
                if (u) {
                    var t1 = a([
                        e
                    ], s(n));
                    r.next(o ? o.apply(void 0, a([], s(t1))) : t1);
                }
            }));
        });
    }
    function yt(e) {
        return yt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e;
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        }, yt(e);
    }
    function St(e, t1, o) {
        return (t1 = function(e) {
            var t1 = function(e, t1) {
                if ("object" != yt(e) || !e) return e;
                var o = e[Symbol.toPrimitive];
                if (void 0 !== o) {
                    var r = o.call(e, t1);
                    if ("object" != yt(r)) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(e);
            }(e, "string");
            return "symbol" == yt(t1) ? t1 : t1 + "";
        }(t1)) in e ? Object.defineProperty(e, t1, {
            value: o,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t1] = o, e;
    }
    function bt(e, t1) {
        var o = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t1 && (r = r.filter(function(t1) {
                return Object.getOwnPropertyDescriptor(e, t1).enumerable;
            })), o.push.apply(o, r);
        }
        return o;
    }
    function Et(e) {
        for(var t1 = 1; t1 < arguments.length; t1++){
            var o = null != arguments[t1] ? arguments[t1] : {};
            t1 % 2 ? bt(Object(o), !0).forEach(function(t1) {
                St(e, t1, o[t1]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(o)) : bt(Object(o)).forEach(function(t1) {
                Object.defineProperty(e, t1, Object.getOwnPropertyDescriptor(o, t1));
            });
        }
        return e;
    }
    function It(e) {
        return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. ";
    }
    var At = "function" == typeof Symbol && Symbol.observable || "@@observable", Ct = function() {
        return Math.random().toString(36).substring(7).split("").join(".");
    }, _t = {
        INIT: "@@redux/INIT" + Ct(),
        REPLACE: "@@redux/REPLACE" + Ct(),
        PROBE_UNKNOWN_ACTION: function() {
            return "@@redux/PROBE_UNKNOWN_ACTION" + Ct();
        }
    };
    function Rt(e, t1, o) {
        var r;
        if ("function" == typeof t1 && "function" == typeof o || "function" == typeof o && "function" == typeof arguments[3]) throw new Error(It(0));
        if ("function" == typeof t1 && void 0 === o && (o = t1, t1 = void 0), void 0 !== o) {
            if ("function" != typeof o) throw new Error(It(1));
            return o(Rt)(e, t1);
        }
        if ("function" != typeof e) throw new Error(It(2));
        var i = e, n = t1, s = [], a = s, d = !1;
        function u() {
            a === s && (a = s.slice());
        }
        function l() {
            if (d) throw new Error(It(3));
            return n;
        }
        function c(e) {
            if ("function" != typeof e) throw new Error(It(4));
            if (d) throw new Error(It(5));
            var t1 = !0;
            return u(), a.push(e), function() {
                if (t1) {
                    if (d) throw new Error(It(6));
                    t1 = !1, u();
                    var o = a.indexOf(e);
                    a.splice(o, 1), s = null;
                }
            };
        }
        function p(e) {
            if (!function(e) {
                if ("object" != typeof e || null === e) return !1;
                for(var t1 = e; null !== Object.getPrototypeOf(t1);)t1 = Object.getPrototypeOf(t1);
                return Object.getPrototypeOf(e) === t1;
            }(e)) throw new Error(It(7));
            if (void 0 === e.type) throw new Error(It(8));
            if (d) throw new Error(It(9));
            try {
                d = !0, n = i(n, e);
            } finally{
                d = !1;
            }
            for(var t1 = s = a, o = 0; o < t1.length; o++)(0, t1[o])();
            return e;
        }
        return p({
            type: _t.INIT
        }), (r = {
            dispatch: p,
            subscribe: c,
            getState: l,
            replaceReducer: function(e) {
                if ("function" != typeof e) throw new Error(It(10));
                i = e, p({
                    type: _t.REPLACE
                });
            }
        })[At] = function() {
            var e, t1 = c;
            return (e = {
                subscribe: function(e) {
                    if ("object" != typeof e || null === e) throw new Error(It(11));
                    function o() {
                        e.next && e.next(l());
                    }
                    return o(), {
                        unsubscribe: t1(o)
                    };
                }
            })[At] = function() {
                return this;
            }, e;
        }, r;
    }
    function wt() {
        for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
        return 0 === t1.length ? function(e) {
            return e;
        } : 1 === t1.length ? t1[0] : t1.reduce(function(e, t1) {
            return function() {
                return e(t1.apply(void 0, arguments));
            };
        });
    }
    var Tt = function(e) {
        function t1(t1, o) {
            var r = e.call(this, function(e) {
                var t1 = r.__notifier.subscribe(e);
                return t1 && !t1.closed && e.next(r.value), t1;
            }) || this;
            return r.__notifier = new j, r.value = o, t1.subscribe(function(e) {
                e !== r.value && (r.value = e, r.__notifier.next(e));
            }), r;
        }
        return o(t1, e), t1;
    }(P), Ot = function(e, t1) {
        return e === t1 || "function" == typeof t1 && e === t1.toString();
    };
    function Dt() {
        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
        var o = e.length;
        return ot(1 === o ? function(t1) {
            return Ot(t1.type, e[0]);
        } : function(t1) {
            for(var r = 0; r < o; r++)if (Ot(t1.type, e[r])) return !0;
            return !1;
        });
    }
    var Pt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e;
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    };
    function Mt(e, t1) {
        e.super_ = t1, e.prototype = Object.create(t1.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        });
    }
    function kt(e, t1) {
        Object.defineProperty(this, "kind", {
            value: e,
            enumerable: !0
        }), t1 && t1.length && Object.defineProperty(this, "path", {
            value: t1,
            enumerable: !0
        });
    }
    ("object" === ("undefined" == typeof global ? "undefined" : Pt(global)) && global ? global : "undefined" != typeof window ? window : {}).DeepDiff, Mt(function e(t1, o, r) {
        e.super_.call(this, "E", t1), Object.defineProperty(this, "lhs", {
            value: o,
            enumerable: !0
        }), Object.defineProperty(this, "rhs", {
            value: r,
            enumerable: !0
        });
    }, kt), Mt(function e(t1, o) {
        e.super_.call(this, "N", t1), Object.defineProperty(this, "rhs", {
            value: o,
            enumerable: !0
        });
    }, kt), Mt(function e(t1, o) {
        e.super_.call(this, "D", t1), Object.defineProperty(this, "lhs", {
            value: o,
            enumerable: !0
        });
    }, kt), Mt(function e(t1, o, r) {
        e.super_.call(this, "A", t1), Object.defineProperty(this, "index", {
            value: o,
            enumerable: !0
        }), Object.defineProperty(this, "item", {
            value: r,
            enumerable: !0
        });
    }, kt);
    const Lt = !1;
    var Nt, Vt, Ut = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function jt(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    function xt(e) {
        if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
        var t1 = e.default;
        if ("function" == typeof t1) {
            var o = function e() {
                return this instanceof e ? Reflect.construct(t1, arguments, this.constructor) : t1.apply(this, arguments);
            };
            o.prototype = t1.prototype;
        } else o = {};
        return Object.defineProperty(o, "__esModule", {
            value: !0
        }), Object.keys(e).forEach(function(t1) {
            var r = Object.getOwnPropertyDescriptor(e, t1);
            Object.defineProperty(o, t1, r.get ? r : {
                enumerable: !0,
                get: function() {
                    return e[t1];
                }
            });
        }), o;
    }
    var Bt = (Vt || (Vt = 1, Nt = function(e, t1, o, r, i, n, s, a) {
        if (!e) {
            var d;
            if (void 0 === t1) d = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
            else {
                var u = [
                    o,
                    r,
                    i,
                    n,
                    s,
                    a
                ], l = 0;
                (d = new Error(t1.replace(/%s/g, function() {
                    return u[l++];
                }))).name = "Invariant Violation";
            }
            throw d.framesToPop = 1, d;
        }
    }), Nt), Ft = jt(Bt), Ht = function(e) {
        return "function" == typeof e;
    }, $t = function(e) {
        return e.toString();
    }, Wt = function(e) {
        return "string" == typeof e;
    }, Gt = "||", Kt = function(e) {
        return e;
    }, zt = function(e) {
        return null === e;
    };
    function qt(e, t1, o) {
        void 0 === t1 && (t1 = Kt), Ft(Ht(t1) || zt(t1), "Expected payloadCreator to be a function, undefined or null");
        var r = zt(t1) || t1 === Kt ? Kt : function(e) {
            for(var o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)r[i - 1] = arguments[i];
            return e instanceof Error ? e : t1.apply(void 0, [
                e
            ].concat(r));
        }, i = Ht(o), n = e.toString(), s = function() {
            var t1 = r.apply(void 0, arguments), n = {
                type: e
            };
            return t1 instanceof Error && (n.error = !0), void 0 !== t1 && (n.payload = t1), i && (n.meta = o.apply(void 0, arguments)), n;
        };
        return s.toString = function() {
            return n;
        }, s;
    }
    var Jt, Qt, Zt, Yt, Xt, eo, to = function(e) {
        if ("object" != typeof e || null === e) return !1;
        for(var t1 = e; null !== Object.getPrototypeOf(t1);)t1 = Object.getPrototypeOf(t1);
        return Object.getPrototypeOf(e) === t1;
    }, oo = function(e) {
        return Array.isArray(e);
    }, ro = function(e) {
        return null == e;
    };
    var io = jt(function() {
        if (eo) return Xt;
        eo = 1;
        var e = function() {
            if (Yt) return Zt;
            Yt = 1;
            var e = function() {
                if (Qt) return Jt;
                Qt = 1, Jt = function(n) {
                    return e.test(n) ? n.toLowerCase() : t1.test(n) ? ((function(e) {
                        return e.replace(r, function(e, t1) {
                            return t1 ? " " + t1 : "";
                        });
                    })(n) || n).toLowerCase() : o.test(n) ? (function(e) {
                        return e.replace(i, function(e, t1, o) {
                            return t1 + " " + o.toLowerCase().split("").join(" ");
                        });
                    })(n).toLowerCase() : n.toLowerCase();
                };
                var e = /\s/, t1 = /(_|-|\.|:)/, o = /([a-z][A-Z]|[A-Z][a-z])/, r = /[\W_]+(.|$)/g, i = /(.)([A-Z]+)/g;
                return Jt;
            }();
            return Zt = function(t1) {
                return e(t1).replace(/[\W_]+(.|$)/g, function(e, t1) {
                    return t1 ? " " + t1 : "";
                }).trim();
            };
        }();
        return Xt = function(t1) {
            return e(t1).replace(/\s(\w)/g, function(e, t1) {
                return t1.toUpperCase();
            });
        };
    }()), no = function(e) {
        return -1 === e.indexOf("/") ? io(e) : e.split("/").map(io).join("/");
    }, so = function(e, t1) {
        return e.reduce(function(e, o) {
            return t1(e, o);
        }, {});
    }, ao = function(e) {
        return "undefined" != typeof Map && e instanceof Map;
    };
    function uo(e) {
        if (ao(e)) return Array.from(e.keys());
        if ("undefined" != typeof Reflect && "function" == typeof Reflect.ownKeys) return Reflect.ownKeys(e);
        var t1 = Object.getOwnPropertyNames(e);
        return "function" == typeof Object.getOwnPropertySymbols && (t1 = t1.concat(Object.getOwnPropertySymbols(e))), t1;
    }
    function lo(e, t1) {
        return ao(t1) ? t1.get(e) : t1[e];
    }
    var co = function(e) {
        return function t1(o, r, i, n) {
            var s = void 0 === r ? {} : r, a = s.namespace, d = void 0 === a ? "/" : a, u = s.prefix;
            return void 0 === i && (i = {}), void 0 === n && (n = ""), uo(o).forEach(function(r) {
                var s = function(e) {
                    return n || !u || u && new RegExp("^" + u + d).test(e) ? e : "" + u + d + e;
                }(function(e) {
                    var t1;
                    if (!n) return e;
                    var o = e.toString().split(Gt), r = n.split(Gt);
                    return (t1 = []).concat.apply(t1, r.map(function(e) {
                        return o.map(function(t1) {
                            return "" + e + d + t1;
                        });
                    })).join(Gt);
                }(r)), a = lo(r, o);
                e(a) ? t1(a, {
                    namespace: d,
                    prefix: u
                }, i, s) : i[s] = a;
            }), i;
        };
    }, po = co(to);
    function ho(e) {
        for(var t1 = 1; t1 < arguments.length; t1++){
            var o = null != arguments[t1] ? arguments[t1] : {}, r = Object.keys(o);
            "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(o).filter(function(e) {
                return Object.getOwnPropertyDescriptor(o, e).enumerable;
            }))), r.forEach(function(t1) {
                mo(e, t1, o[t1]);
            });
        }
        return e;
    }
    function mo(e, t1, o) {
        return t1 in e ? Object.defineProperty(e, t1, {
            value: o,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t1] = o, e;
    }
    function go(e) {
        for(var t1 = arguments.length, o = new Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
        var i, n = to((i = o)[i.length - 1]) ? o.pop() : {};
        return Ft(o.every(Wt) && (Wt(e) || to(e)), "Expected optional object followed by string action types"), Wt(e) ? fo([
            e
        ].concat(o), n) : ho({}, function(e, t1) {
            return function(e, t1) {
                var o = void 0 === t1 ? {} : t1, r = o.namespace, i = void 0 === r ? "/" : r, n = o.prefix;
                function s(t1, o, r) {
                    var i = no(r.shift());
                    0 === r.length ? o[i] = e[t1] : (o[i] || (o[i] = {}), s(t1, o[i], r));
                }
                var a = {};
                return Object.getOwnPropertyNames(e).forEach(function(e) {
                    var t1 = n ? e.replace("" + n + i, "") : e;
                    return s(e, a, t1.split(i));
                }), a;
            }(vo(po(e, t1)), t1);
        }(e, n), fo(o, n));
    }
    function vo(e, t1) {
        var o = void 0 === t1 ? {} : t1, r = o.prefix, i = o.namespace, n = void 0 === i ? "/" : i;
        return so(Object.keys(e), function(t1, o) {
            var i, s = e[o];
            Ft(function(e) {
                if (Ht(e) || ro(e)) return !0;
                if (oo(e)) {
                    var t1 = e[0], o = void 0 === t1 ? Kt : t1, r = e[1];
                    return Ht(o) && Ht(r);
                }
                return !1;
            }(s), "Expected function, undefined, null, or array with payload and meta functions for " + o);
            var a = r ? "" + r + n + o : o, d = oo(s) ? qt.apply(void 0, [
                a
            ].concat(s)) : qt(a, s);
            return ho({}, t1, ((i = {})[o] = d, i));
        });
    }
    function fo(e, t1) {
        var o = vo(so(e, function(e, t1) {
            var o;
            return ho({}, e, ((o = {})[t1] = Kt, o));
        }), t1);
        return so(Object.keys(o), function(e, t1) {
            var r;
            return ho({}, e, ((r = {})[no(t1)] = o[t1], r));
        });
    }
    var yo = function() {
        for(var e = arguments.length, t1 = Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
        var r = "function" != typeof t1[t1.length - 1] && t1.pop(), i = t1;
        if (void 0 === r) throw new TypeError("The initial state may not be undefined. If you do not want to set a value for this reducer, you can use null instead of undefined.");
        return function(e, t1) {
            for(var o = arguments.length, n = Array(o > 2 ? o - 2 : 0), s = 2; s < o; s++)n[s - 2] = arguments[s];
            var a = void 0 === e, d = void 0 === t1;
            return a && d && r ? r : i.reduce(function(e, o) {
                return o.apply(void 0, [
                    e,
                    t1
                ].concat(n));
            }, a && !d && r ? r : e);
        };
    }, So = co(function(e) {
        return (to(e) || ao(e)) && !function(e) {
            var t1 = uo(e), o = t1.every(function(e) {
                return "next" === e || "throw" === e;
            });
            return t1.length && t1.length <= 2 && o;
        }(e);
    });
    function bo(e, t1, o) {
        void 0 === o && (o = {}), Ft(to(e) || ao(e), "Expected handlers to be a plain object.");
        var r = So(e, o), i = uo(r).map(function(e) {
            return function(e, t1, o) {
                void 0 === t1 && (t1 = Kt);
                var r = $t(e).split(Gt);
                Ft(!(void 0 === o), "defaultState for reducer handling " + r.join(", ") + " should be defined"), Ft(Ht(t1) || to(t1), "Expected reducer to be a function or object with next and throw reducers");
                var i = Ht(t1) ? [
                    t1,
                    t1
                ] : [
                    t1.next,
                    t1.throw
                ].map(function(e) {
                    return ro(e) ? Kt : e;
                }), n = i[0], s = i[1];
                return function(e, t1) {
                    void 0 === e && (e = o);
                    var i = t1.type;
                    return i && -1 !== r.indexOf($t(i)) ? (!0 === t1.error ? s : n)(e, t1) : e;
                };
            }(e, lo(e, r), t1);
        }), n = yo.apply(void 0, i.concat([
            t1
        ]));
        return function(e, o) {
            return void 0 === e && (e = t1), n(e, o);
        };
    }
    const Eo = qt("CONNECT_ZOOM_SOCKET"), Io = qt("CONNECT_XMPP_SOCKET"), Ao = qt("CLOSE_ZOOM_SOCKET"), Co = qt("CLOSE_XMPP_SOCKET"), _o = qt("RECEIVE_MESSAGE_FROM_ZOOM_SOCKET"), Ro = qt("RECEIVE_SHARING_PAYLOAD_FROM_ZOOM_SOCKET"), wo = qt("RECEIVE_MESSAGE_FROM_XMPP_SOCKET"), To = qt("CONNECT_MAIN_SESSION_SOCKET"), Oo = qt("CLOSE_MAIN_SESSION_SOCKET"), Do = qt("RECEIVE_MESSAGE_FROM_MAIN_SESSION_SOCKET"), { setZoomSocketStatus: Po, setRwgServersList: Mo, setRwgRetryCount: ko, setXmppSocketStatus: Lo, setMainSessionSocketStatus: No, resetSocket: Vo } = go("SET_ZOOM_SOCKET_STATUS", "SET_RWG_SERVERS_LIST", "SET_RWG_RETRY_COUNT", "SET_XMPP_SOCKET_STATUS", "SET_MAIN_SESSION_SOCKET_STATUS", "RESET_SOCKET"), Uo = qt("CONNECT_TO_MEDIA_STREAM"), jo = qt("RECEIVE_PAYLOAD_FROM_MEDIA_SDK"), { setAudioEncodeStatus: xo, setAudioDecodeStatus: Bo, setVideoEncodeStatus: Fo, setVideoDecodeStatus: Ho, setSharingEncodeStatus: $o, setSharingDecodeStatus: Wo, setMediaConstraints: Go, setMediaEncryptKey: Ko, setIsEnableDecoderInWorklet: zo, setPatchedMediaSdkStatus: qo, setMediaAssetsPath: Jo, setIsEnableVideoAudioQos: Qo, setIsAudioBridgeReceiveReady: Zo, setIsAudioBridgeSendReady: Yo, setIsMediaAgentInitialized: Xo, setAdaptedAbOptionForMediaSdk: er, resetMedia: tr } = go("SET_AUDIO_ENCODE_STATUS", "SET_AUDIO_DECODE_STATUS", "SET_VIDEO_ENCODE_STATUS", "SET_VIDEO_DECODE_STATUS", "SET_SHARING_ENCODE_STATUS", "SET_SHARING_DECODE_STATUS", "SET_MEDIA_CONSTRAINTS", "SET_MEDIA_ENCRYPT_KEY", "SET_IS_ENABLE_DECODER_IN_WORKLET", "SET_PATCHED_MEDIA_SDK_STATUS", "SET_MEDIA_ASSETS_PATH", "SET_IS_ENABLE_VIDEO_AUDIO_QOS", "SET_IS_AUDIO_BRIDGE_RECEIVE_READY", "SET_IS_AUDIO_BRIDGE_SEND_READY", "SET_IS_MEDIA_AGENT_INITIALIZED", "SET_ADAPTED_AB_OPTION_FOR_MEDIA_SDK", "RESET_MEDIA");
    function or(e, t1) {
        for(var o = arguments.length, r = new Array(o > 2 ? o - 2 : 0), i = 2; i < o; i++)r[i - 2] = arguments[i];
        return e(Re(...r || []), t1, null);
    }
    function rr() {
        for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
        const r = function() {
            for(var e = arguments.length, o = new Array(e), r = 0; r < e; r++)o[r] = arguments[r];
            return Xe(...t1.map((e)=>{
                const t1 = e(...o);
                if (!t1) throw new TypeError(`combineEpics: one of the provided Epics "${e.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`);
                return t1.pipe(it((e, t1)=>(setTimeout(()=>{
                        throw e;
                    }, 0), t1)));
            }));
        };
        try {
            Object.defineProperty(r, "name", {
                value: `combineEpics(${t1.map((e)=>e.name || "<anonymous>").join(", ")})`
            });
        } catch (e) {}
        return r;
    }
    function ir() {
        for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
        return rr(...t1.flatMap((e)=>Object.values(e)));
    }
    function nr(e, t1) {
        return e.pipe(Dt(`${_o}`), ot((e)=>e.payload.evt === t1));
    }
    function sr(e, t1) {
        return e.pipe(Dt(`${Do}`), ot((e)=>e.payload.evt === t1));
    }
    function ar(e, t1) {
        return e.pipe(Dt(`${wo}`), ot((e)=>e.payload.evt === t1));
    }
    function dr(e, t1) {
        return e.pipe(Dt(`${_o}`, `${Do}`), ot((e)=>e.payload.evt === t1));
    }
    function ur(e, t1) {
        return e.pipe(Dt(`${jo}`), ot((e)=>Array.isArray(t1) ? t1.indexOf(e.payload.type) > -1 : e.payload.type === t1));
    }
    function lr(e, t1) {
        return e.pipe(Dt(`${Uo}`), ot(()=>{
            const { media: { assetsPath: e, mediaConstraints: o } } = t1.value;
            return void 0 !== e && void 0 !== o;
        }), ht(()=>{
            const { media: { isMediaAgentInitialized: o } } = t1.value;
            return o ? _e([
                0
            ]) : e.pipe(Dt(`${Xo}`), ot((e)=>!!e.payload), nt(1));
        }));
    }
    function cr(e, t1, o) {
        const r = document.createElement("script");
        r.type = "text/javascript", r.readyState ? r.onreadystatechange = ()=>{
            "loaded" !== r.readyState && "complete" !== r.readyState || (r.onreadystatechange = null, t1());
        } : (r.onload = ()=>{
            t1();
        }, r.onerror = ()=>{
            o();
        }), r.src = e, window.crossOriginIsolated && (r.crossOrigin = "anonymous"), "function" == typeof document.body.append ? document.getElementsByTagName("head")[0].append(r) : document.getElementsByTagName("head")[0].appendChild(r);
    }
    function pr(e, t1) {
        let o = e;
        /^https?:\/\//.test(o) || (o = `https://${e}`);
        try {
            const e = new URL(o);
            if (!t1) return e.href;
            if (t1.hostname) return e.hostname;
            if (t1.path) return e.pathname;
        } catch (e) {
            return "";
        }
        return "";
    }
    function hr(e) {
        if (e) {
            var t1;
            const o = document.getElementById(e);
            null == o || null === (t1 = o.parentNode) || void 0 === t1 || t1.removeChild(o);
        }
    }
    let mr = "zoom.us";
    const gr = "3.11.0", vr = `https://dmogdx0jrul3u.cloudfront.net/${gr}/lib/av`, fr = `https://source.zoom.us/${gr}/lib/av`, yr = `https://jssdk.zoomus.cn/${gr}/lib/av`, Sr = ()=>mr, br = "function" == typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"], Er = "function" == typeof TextDecoder ? new TextDecoder : void 0, Ir = "function" == typeof TextEncoder ? new TextEncoder : void 0, Ar = Array.prototype.slice.call("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="), Cr = (()=>{
        let e = {};
        return Ar.forEach((t1, o)=>e[t1] = o), e;
    })(), _r = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, Rr = String.fromCharCode.bind(String), wr = "function" == typeof Uint8Array.from ? Uint8Array.from.bind(Uint8Array) : (e)=>new Uint8Array(Array.prototype.slice.call(e, 0)), Tr = (e)=>e.replace(/=/g, "").replace(/[+\/]/g, (e)=>"+" == e ? "-" : "_"), Or = (e)=>e.replace(/[^A-Za-z0-9\+\/]/g, ""), Dr = "function" == typeof btoa ? (e)=>btoa(e) : br ? (e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e, "binary").toString("base64") : (e)=>{
        let t1, o, r, i, n = "";
        const s = e.length % 3;
        for(let s = 0; s < e.length;){
            if ((o = e.charCodeAt(s++)) > 255 || (r = e.charCodeAt(s++)) > 255 || (i = e.charCodeAt(s++)) > 255) throw new TypeError("invalid character found");
            t1 = o << 16 | r << 8 | i, n += Ar[t1 >> 18 & 63] + Ar[t1 >> 12 & 63] + Ar[t1 >> 6 & 63] + Ar[63 & t1];
        }
        return s ? n.slice(0, s - 3) + "===".substring(s) : n;
    }, Pr = br ? (e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e).toString("base64") : (e)=>{
        let t1 = [];
        for(let o = 0, r = e.length; o < r; o += 4096)t1.push(Rr.apply(null, e.subarray(o, o + 4096)));
        return Dr(t1.join(""));
    }, Mr = (e)=>{
        if (e.length < 2) return (t1 = e.charCodeAt(0)) < 128 ? e : t1 < 2048 ? Rr(192 | t1 >>> 6) + Rr(128 | 63 & t1) : Rr(224 | t1 >>> 12 & 15) + Rr(128 | t1 >>> 6 & 63) + Rr(128 | 63 & t1);
        var t1 = 65536 + 1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320);
        return Rr(240 | t1 >>> 18 & 7) + Rr(128 | t1 >>> 12 & 63) + Rr(128 | t1 >>> 6 & 63) + Rr(128 | 63 & t1);
    }, kr = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, Lr = br ? (e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e, "utf8").toString("base64") : Ir ? (e)=>Pr(Ir.encode(e)) : (e)=>Dr(((e)=>e.replace(kr, Mr))(e)), Nr = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, Vr = (e)=>{
        switch(e.length){
            case 4:
                var t1 = ((7 & e.charCodeAt(0)) << 18 | (63 & e.charCodeAt(1)) << 12 | (63 & e.charCodeAt(2)) << 6 | 63 & e.charCodeAt(3)) - 65536;
                return Rr(55296 + (t1 >>> 10)) + Rr(56320 + (1023 & t1));
            case 3:
                return Rr((15 & e.charCodeAt(0)) << 12 | (63 & e.charCodeAt(1)) << 6 | 63 & e.charCodeAt(2));
            default:
                return Rr((31 & e.charCodeAt(0)) << 6 | 63 & e.charCodeAt(1));
        }
    }, Ur = "function" == typeof atob ? (e)=>atob(Or(e)) : br ? (e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e, "base64").toString("binary") : (e)=>{
        if (e = e.replace(/\s+/g, ""), !_r.test(e)) throw new TypeError("malformed base64.");
        e += "==".slice(2 - (3 & e.length));
        let t1, o, r, i = "";
        for(let n = 0; n < e.length;)t1 = Cr[e.charAt(n++)] << 18 | Cr[e.charAt(n++)] << 12 | (o = Cr[e.charAt(n++)]) << 6 | (r = Cr[e.charAt(n++)]), i += 64 === o ? Rr(t1 >> 16 & 255) : 64 === r ? Rr(t1 >> 16 & 255, t1 >> 8 & 255) : Rr(t1 >> 16 & 255, t1 >> 8 & 255, 255 & t1);
        return i;
    }, jr = br ? (e)=>wr(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e, "base64")) : (e)=>wr(Ur(e).split("").map((e)=>e.charCodeAt(0))), xr = br ? (e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e, "base64").toString("utf8") : Er ? (e)=>Er.decode(jr(e)) : (e)=>((e)=>e.replace(Nr, Vr))(Ur(e)), Br = (e, t1 = !1)=>t1 ? Tr(Lr(e)) : Lr(e), Fr = (e)=>xr(((e)=>Or(e.replace(/[-_]/g, (e)=>"-" == e ? "+" : "/")))(e)), Hr = (e, t1 = !1)=>t1 ? Tr(Pr(e)) : Pr(e);
    function $r(e) {
        return Br(e, !0);
    }
    function Wr(e) {
        return Fr(e);
    }
    function Gr(e) {
        return Br(e, !1);
    }
    const Kr = {
        "-": "+",
        _: "/",
        ".": "="
    };
    function zr(e) {
        const t1 = e.replace(/[-_.]/g, (e)=>Kr[e]);
        return Uint8Array.from(window.atob(t1), (e)=>e.charCodeAt(0));
    }
    const qr = (e)=>{
        const t1 = e.charCodeAt(0);
        return t1 <= parseInt("0x7F", 16) ? 1 : t1 <= parseInt("0x7FF", 16) ? 2 : t1 <= parseInt("0xFFFF", 16) ? 3 : t1 <= parseInt("0x1FFFFF", 16) ? 4 : t1 <= parseInt("0x3FFFFFF", 16) ? 5 : 6;
    }, Jr = (e, t1)=>{
        const o = e.split(".").map((e)=>Number(e)).slice(0, 3), r = t1.split(".").map((e)=>Number(e)).slice(0, 3);
        let i = 0;
        for(let e = 0; e < 3; e++){
            const t1 = e < o.length ? o[e] : 0, n = e < r.length ? r[e] : 0;
            if (t1 < n) {
                i = -1;
                break;
            }
            if (t1 > n) {
                i = 1;
                break;
            }
        }
        return i;
    }, Qr = (e)=>{
        var t1;
        let o = (new Date).getTime(), r = 1e3 * (null === (t1 = performance) || void 0 === t1 ? void 0 : t1.now()) || 0;
        const i = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e)=>{
            let t1 = 16 * Math.random();
            return o > 0 ? (t1 = (o + t1) % 16 | 0, o = Math.floor(o / 16)) : (t1 = (r + t1) % 16 | 0, r = Math.floor(r / 16)), ("x" === e ? t1 : 3 & t1 | 8).toString(16);
        });
        return i + "";
    };
    function Zr(e, t1) {
        if (e === t1) return !0;
        if (!e || !t1) return !1;
        const o = Object.keys(e), r = Object.keys(t1), i = o.length;
        if (r.length !== i) return !1;
        for(let r = 0; r < i; r++){
            const i = o[r];
            if (e[i] !== t1[i] || !Object.prototype.hasOwnProperty.call(t1, i)) return !1;
        }
        return !0;
    }
    const Yr = (e, t1)=>e >> 10 == t1 >> 10, Xr = (e, t1)=>new Promise((o)=>{
            setTimeout(()=>{
                o(e());
            }, t1);
        }), ei = (e)=>{
        const t1 = `${Math.floor(1e4 * Math.random())}`;
        return e.indexOf("@") > -1 ? e.replace("@", t1) : `${e}${t1}`;
    }, ti = (e)=>{
        try {
            const t1 = new URL(e);
            return !("data:" === t1.protocol && "null" === t1.origin) && t1.origin !== location.origin;
        } catch (e) {
            return !0;
        }
    }, oi = (e)=>{
        const t1 = e.split(".")[1];
        if ("string" == typeof t1) {
            let o = t1.replace(/-/g, "+").replace(/_/g, "/");
            switch(o.length % 4){
                case 0:
                    break;
                case 2:
                    o += "==";
                    break;
                case 3:
                    o += "=";
                    break;
                default:
                    throw new Error("base64 string is not of the correct length");
            }
            try {
                const e = decodeURIComponent(window.atob(o).replace(/(.)/g, function(e, t1) {
                    let o = t1.charCodeAt(0).toString(16).toUpperCase();
                    return o.length < 2 && (o = "0" + o), "%" + o;
                }));
                return JSON.parse(e);
            } catch (e) {
                console.error("Invalid token specified: invalid base64");
            }
        }
    };
    function ri(e) {
        return e && e.endsWith("/") ? e.slice(0, e.length - 1) : e;
    }
    function ii(e) {
        return [
            ...new Uint8Array(e)
        ].map((e)=>e.toString(16).padStart(2, "0")).join("");
    }
    function ni(e) {
        return `${e.tagName}${e.id ? `#${e.id}` : ""}${e.className ? `${e.className.split(" ").map((e)=>`.${e}`).join("")}` : ""}`;
    }
    function si(e) {
        const t1 = function(e) {
            const t1 = e && e.getRootNode();
            if (t1 && "#document" !== t1.nodeName && t1.host) return ni(t1.host);
        }(e);
        return `${t1 ? `${t1}>` : ""}${ni(e)}`;
    }
    function ai(e) {
        return "object" == typeof e && null !== e ? e instanceof HTMLElement ? si(e) : ArrayBuffer.isView(e) ? ii(e.buffer) : Array.isArray(e) ? e.map((e)=>ai(e)) : Object.keys(e).reduce((t1, o)=>({
                ...t1,
                [`${o}`]: ai(e[o])
            }), {}) : e;
    }
    const di = [
        vr,
        yr,
        fr
    ].map((e)=>pr(e, {
            hostname: !0
        }));
    function ui(e) {
        return di.some((t1)=>new RegExp(`^https://${t1}`).test(null != e ? e : ""));
    }
    let li = function(e) {
        return e[e.Success = 0] = "Success", e[e.MeetingIsOver = 6] = "MeetingIsOver", e[e.UserFull = 9] = "UserFull", e[e.MeetingLocked = 12] = "MeetingLocked", e[e.WebinarBlockedEmail = 3033] = "WebinarBlockedEmail", e[e.MeetingNotStarted = 3008] = "MeetingNotStarted", e[e.MeetingHasClosed = 103003] = "MeetingHasClosed", e[e.UserHasBeenRemoved = 103039] = "UserHasBeenRemoved", e[e.MMRIBReject = 103043] = "MMRIBReject", e[e.MMRConfParticipantExists = 103044] = "MMRConfParticipantExists", e;
    }({}), ci = function(e) {
        return e[e.Unknown = 0] = "Unknown", e[e.Normal = 1] = "Normal", e[e.Userrequest = 2] = "Userrequest", e[e.SdkConnection = 3] = "SdkConnection", e[e.Reconnect = 5] = "Reconnect", e[e.PtRequest = 6] = "PtRequest", e[e.KickedByHost = 7] = "KickedByHost", e[e.EndByHost = 8] = "EndByHost", e[e.EndByHostStartAnotherMeeting = 9] = "EndByHostStartAnotherMeeting", e[e.FreeMeetingTimeout = 10] = "FreeMeetingTimeout", e[e.JBHTimeout = 11] = "JBHTimeout", e[e.EndBySingleStatus = 12] = "EndBySingleStatus", e[e.WebinarNeedRegister = 13] = "WebinarNeedRegister", e[e.ArchiveFail = 14] = "ArchiveFail", e[e.EndByNone = 15] = "EndByNone", e[e.EndByAdmin = 16] = "EndByAdmin", e[e.DuplicateSession = 17] = "DuplicateSession", e[e.MeetingTransfer = 18] = "MeetingTransfer", e;
    }({}), pi = function(e) {
        return e[e.WaitingRoomFailover = 1] = "WaitingRoomFailover", e[e.WebEndAndRejoin = 2] = "WebEndAndRejoin", e;
    }({}), hi = function(e) {
        return e[e.Success = 0] = "Success", e[e.CommonError = 200] = "CommonError", e[e.WrongPasscode = 3004] = "WrongPasscode", e[e.RoleTypeMissing = 3010] = "RoleTypeMissing", e[e.InvalidParameter = 4003] = "InvalidParameter", e;
    }({}), mi = function(e) {
        return e[e.Success = 0] = "Success", e[e.AnotherMeetingInProgress = 3e3] = "AnotherMeetingInProgress", e[e.MeetingNotExist = 3001] = "MeetingNotExist", e[e.NotHost = 3003] = "NotHost", e[e.WrongPasscode = 3004] = "WrongPasscode", e[e.MissingEmail = 3005] = "MissingEmail", e[e.MeetingNotStarted = 3008] = "MeetingNotStarted", e[e.UserHasBeenRemoved = 3009] = "UserHasBeenRemoved", e[e.RoleTypeMissing = 3010] = "RoleTypeMissing", e[e.WebinarEnforceLogin = 3034] = "WebinarEnforceLogin", e[e.RealNameMissing = 3082] = "RealNameMissing", e[e.RegisterRequired = 3099] = "RegisterRequired", e[e.SsoLoginWindow = 6024] = "SsoLoginWindow", e[e.ZoomLoginWindow = 3051] = "ZoomLoginWindow", e[e.ZoomSpecificLoginWindow = 3052] = "ZoomSpecificLoginWindow", e[e.LoginRequired = 3100] = "LoginRequired", e[e.Reconnecting = 4e3] = "Reconnecting", e[e.Disconnect = 4001] = "Disconnect", e[e.InvalidParameter = 4003] = "InvalidParameter", e[e.DeniedRegisterWithPanelist = 3032] = "DeniedRegisterWithPanelist", e[e.ServiceOffline = 403] = "ServiceOffline", e[e.RwcEmpty = 3621] = "RwcEmpty", e[e.RwcError = 3622] = "RwcError", e[e.FrequentCall = 3633] = "FrequentCall", e[e.FrequentJoin = 3634] = "FrequentJoin", e[e.WasmFail = 3635] = "WasmFail", e[e.CommonError = 200] = "CommonError", e[e.Upgrade = 1e4] = "Upgrade", e;
    }({});
    mi.Success, mi.RegisterRequired, mi.LoginRequired, mi.SsoLoginWindow, mi.ZoomLoginWindow, mi.ZoomSpecificLoginWindow, mi.MissingEmail, mi.MeetingNotExist, mi.NotHost, mi.WrongPasscode, mi.RoleTypeMissing, mi.AnotherMeetingInProgress, mi.MeetingNotStarted, mi.InvalidParameter, mi.Reconnecting, mi.UserHasBeenRemoved, mi.WebinarEnforceLogin, mi.Disconnect, mi.DeniedRegisterWithPanelist, mi.RwcEmpty, mi.RwcError, mi.FrequentCall, mi.FrequentJoin, mi.WasmFail, mi.Upgrade;
    const gi = {
        3004: {
            "apac.errorcodes_pac_mn_wrong": 3714
        },
        3005: {
            "apac.errorcodes_web_has_in_progress": 3e3
        },
        3008: {
            "apac.errorcodes_not_start": 3008
        },
        3027: {
            "apac.errorcodes_host_email_as_attendee": 3627
        },
        3033: {
            "apac.errorcodes_denied_email": 3620
        },
        1005: {
            "apac.errorcodes_no_response_from_web": 3621
        },
        131005: {
            "apac.errorcodes_no_response_from_web": 3621
        },
        1001: {
            "apac.errorcodes_host_inactive": 3625
        },
        131001: {
            "apac.errorcodes_host_inactive": 3625
        },
        131013: {
            "meeting ended": 4004
        },
        103039: {
            "apac.errorcodes_be_removed": 3009
        },
        6: {
            "meeting ended": 4004
        },
        9: {
            "meeting is at capacity": 4005
        },
        12: {
            "meeting locked": 4006
        },
        103043: {
            "reject for information barriers": 4007
        },
        103044: {
            "participant exist": 4008
        }
    };
    function vi(e, t1) {
        let o = {
            code: 200
        };
        if (void 0 !== gi[e]) {
            const t1 = gi[e], r = Object.keys(t1)[0];
            return o = {
                code: t1[r],
                i18nKey: r
            }, {
                reason: r.startsWith("apac") ? "" : r,
                errorCode: o.code
            };
        }
        return {
            code: 200,
            reason: "connection error"
        };
    }
    const fi = "SET_MEETING_INFO", yi = "SET_MEETING_JOIN_INFO", Si = "SET_WINDOWN_OPEN", bi = "SET_APPID_SIGNATURE", Ei = "SET_ZTK", Ii = "SET_ZSK", Ai = "SET_TK_MTKGUID", Ci = "SET_PING_RWC_TIMESTAMP", _i = "SET_IN_MEETING_INFO", Ri = "SET_MEETING_ATTRIBUTE", wi = "RESET_MEETING", Ti = "SET_IS_HOST", Oi = "SET_IS_COHOST", Di = "SET_MEETING_IS_ON_HOLD", Pi = "SET_IS_MEETING_RESET", Mi = "SET_AUDIO_VIDEO_BEFORE_ON_HOLD", ki = "SET_CURRENT_USER_AUDIO_BEFORE_RESET", Li = "SET_IS_CURRENT_USER_MUTED_BEFORE_RESET", Ni = "SET_IS_CURRENT_USER_START_VIDEO_BEFORE_RESET", Vi = "SET_MEETING_STATUS", Ui = "SET_MEETING_REGION", ji = "SET_JOIN_MEETING_TIME_STAMP", xi = "SET_ACTIVE_APP_INFO", Bi = "SET_MEETING_IDLE_START_TIME", Fi = "SET_SESSION_IDLE_TIMEOUT_MINUTES", Hi = "SET_IS_AUDIO_BRIDGE_ENABLED", $i = "ADD_DISCARDED_RWC_HOST", Wi = "SET_SHARE_PRONOUN_TYPE", Gi = "SET_IS_STAY_AWAKE_DURING_THE_SESSION", Ki = "SET_MEETING_JOIN_SUCCESS_TIMESTAMP", zi = "RESET_FAILOVER_RECORD", qi = "SET_FAILOVER_REASON", Ji = "SET_IS_QUICKLY_LEAVE_MEETING_AFTER_REFRESH", Qi = "SET_MEETING_INFO_TIMESTAMP", Zi = "SET_IS_ENABLE_ZMK_FROM_RWG", Yi = "SET_IS_RLB_TP", Xi = "SET_IS_RLB_TP_READY", en = [
        "bLock",
        "bHoldUponEntry",
        "viewOnly",
        "listenOnlyPhone",
        "bAllowRaiseHand",
        "bAllowAttendeeRename",
        "bBroadcast",
        "bAllowPlayChimeForEnterOrExit",
        "bIbDisableShare",
        "bIbDisableChat",
        "encryptKey",
        "bNoHostTimeOut",
        "bAllowShowCount",
        "bHasAST",
        "bHasRMC",
        "gatewayKey",
        "encryptKey"
    ], tn = {
        bChime: "bAllowPlayChimeForEnterOrExit",
        bHasAST: "hasAst",
        bHasRMC: "hasRmc",
        topic: (e)=>({
                meetingTopic: Wr(e)
            }),
        gatewayKey: (e)=>{
            const [, t1, o] = e.split(".");
            return t1 && o ? {
                gatewayUser: {
                    userId: Number(t1),
                    sn: o
                }
            } : {};
        },
        encryptKey: (e)=>({
                gcmSessinKey: zr(e)
            })
    }, on = qt("GET_MEETING_INFO"), rn = qt("GET_INSTANT_MEETING_INFO");
    qt("LOGON_ZOOM_DOMAIN"), qt("VERIFY_ZOOM_RECAPTCHA"), qt("LOGON_THIRD_PARTY_DOMAIN");
    const nn = qt("PING_RWC_SERVER"), sn = qt("MEETING_FAILOVER"), an = qt("LEAVE_MEETING"), dn = qt("LEAVE_WAITING_ROOM"), un = qt("END_MEETING");
    qt("REGISTER_WEBINAR");
    const ln = qt("TRIGGER_IDLE_CHECK"), cn = qt("END_OF_ZE_WORLD"), { setMeetingInfo: pn, setMeetingJoinInfo: hn, setWindownOpen: mn, setAppidSignature: gn, setZtk: vn, setZsk: fn, setTkMtkguid: yn, setPingRwcTimestamp: Sn, setInMeetingInfo: bn, setMeetingAttribute: En, resetMeeting: In, setIsHost: An, setIsCohost: Cn, setMeetingIsOnHold: _n, setIsMeetingReset: Rn, setAudioVideoBeforeOnHold: wn, setCurrentUserAudioBeforeReset: Tn, setIsCurrentUserMutedBeforeReset: On, setMeetingStatus: Dn, setMeetingRegion: Pn, setIsCurrentUserStartVideoBeforeReset: Mn, setJoinMeetingTimeStamp: kn, setActiveAppInfo: Ln, setMeetingIdleStartTime: Nn, setSessionIdleTimeoutMinutes: Vn, setIsAudioBridgeEnabled: Un, addDiscardedRwcHost: jn, setSharePronounType: xn, setIsStayAwakeDuringTheSession: Bn, setMeetingJoinSuccessTimestamp: Fn, resetFailoverRecord: Hn, setFailoverReason: $n, setIsQuicklyLeaveMeetingAfterRefresh: Wn, setMeetingInfoTimestamp: Gn, setIsEnableZmkFromRwg: Kn, setIsRlbTp: zn, setIsRlbTpReady: qn } = go({
        [fi]: (e)=>e,
        [yi]: (e)=>e,
        [Si]: (e)=>e,
        [bi]: (e)=>e,
        [Ei]: (e)=>e,
        [Ii]: (e)=>e,
        [Ai]: (e)=>e,
        [Ci]: (e)=>e,
        [_i]: (e)=>e,
        [Ri]: (e)=>{
            if (en.some((t1)=>e && void 0 !== e[t1])) {
                let t1 = e;
                return Object.keys(tn).some((t1)=>void 0 !== e[t1]) && (t1 = Object.keys(e).reduce((t1, o)=>{
                    const r = tn[o];
                    return "function" == typeof r ? Object.assign(t1, r(e[o])) : "string" == typeof r ? t1[r] = e[o] : (t1[o], e[o]), t1;
                }, {})), t1;
            }
            return {};
        },
        [Ti]: (e)=>e && e.bHost,
        [Oi]: (e)=>e && e.bCoHost,
        [wi]: (e)=>e,
        [Di]: (e)=>e,
        [Pi]: (e)=>e,
        [Mi]: (e)=>e,
        [ki]: (e)=>e,
        [Li]: (e)=>e,
        [Vi]: (e)=>e,
        [Ui]: (e)=>e,
        [Ni]: (e)=>e,
        [ji]: (e)=>e,
        [xi]: (e)=>e,
        [Bi]: (e)=>e,
        [Fi]: (e)=>e,
        [Hi]: (e)=>e,
        [$i]: (e)=>e,
        [Wi]: (e)=>e,
        [Gi]: (e)=>e,
        [Ki]: (e)=>e,
        [zi]: (e)=>e,
        [qi]: (e)=>e,
        [Ji]: (e)=>e,
        [Qi]: (e)=>e,
        [Zi]: (e)=>e,
        [Yi]: (e)=>e,
        [Xi]: (e)=>e
    });
    let Jn = function(e) {
        return e.Failover = "failover", e.OnHold = "on hold", e.Promote = "promote", e.Depromote = "depromote", e.JoinBreakoutRoom = "join breakout room", e.MoveToBreakoutRoom = "move to breakout room", e.BackToMainSession = "back to main session", e;
    }({});
    const Qn = "js_media.min.js";
    let Zn = function(e) {
        return e.CDN = "CDN", e.Global = "Global", e.CN = "CN", e;
    }({}), Yn = function(e) {
        return e.Connected = "Connected", e.Reconnecting = "Reconnecting", e.Closed = "Closed", e.Fail = "Fail", e;
    }({}), Xn = function(e) {
        return e.Initial = "initial", e.Joined = "joined", e.Closed = "closed", e;
    }({}), es = function(e) {
        return e.AudioBridgeEnable = "M:1,2;V:1,2", e.AudioDecodeInWorklet = "M:6;V:3", e.VideoFullHD = "M:8;V:4", e.VideoShareFullHD = "M:9;V:5", e.WebGL2Render = "M:20;V:8", e.WebGPURender = "M:21;V:9", e.ZMKFromRWG = "M:19;V:10", e;
    }({}), ts = function(e) {
        return e[e.NormalCase = -1] = "NormalCase", e[e.NoHeartbeat = 0] = "NoHeartbeat", e[e.NoHeartbeatMChannel = 1] = "NoHeartbeatMChannel", e[e.NetworkChange = 2] = "NetworkChange", e[e.NotifyUiFailover = 3] = "NotifyUiFailover", e[e.InvalidParameters = 4] = "InvalidParameters", e[e.OnError = 5] = "OnError", e[e.OnErrorMChannel = 6] = "OnErrorMChannel", e[e.Disconnect = 7] = "Disconnect", e[e.DisconnectMChannel = 8] = "DisconnectMChannel", e[e.DisconnectXmpp = 9] = "DisconnectXmpp", e[e.RefreshPage = 10] = "RefreshPage", e[e.OnErrorXmppChannel = 15] = "OnErrorXmppChannel", e;
    }({});
    const os = [
        "8-29",
        "9-21",
        "12-44"
    ];
    let rs = function(e) {
        return e.LocalStorage = "LocalStorage", e.SessionStorage = "SessionStorage", e.Memory = "Memory", e;
    }({});
    const is = $r("{}");
    class ns {
        constructor(e){
            this.sessionStorageKey = void 0, this.localStorageKey = void 0, this.sessionCache = void 0, this.localCache = void 0, this.memoryCache = void 0, this.sessionStorageKey = $r(`zoom-storage-${e}`), this.localStorageKey = $r("zoom-local-storage"), this.memoryCache = {};
            try {
                this.sessionCache = JSON.parse(Wr(sessionStorage.getItem(this.sessionStorageKey) || is)), this.localCache = JSON.parse(Wr(localStorage.getItem(this.localStorageKey) || is));
            } catch (e) {
                console.error(e), this.sessionCache = {}, this.localCache = {};
            }
        }
        static init(e) {
            this.instance = new ns(e);
        }
        static get(e) {
            if (void 0 === this.instance) throw new Error("read before initial");
            return this.instance.getValue(e).value;
        }
        static set(e, t1, o) {
            if (void 0 === this.instance) throw new Error("set before initial");
            return this.instance.setValue(e, t1, o);
        }
        static remove(e) {
            if (void 0 === this.instance) throw new Error("remove before initial");
            return this.instance.removeValue(e);
        }
        static clearSession() {
            if (void 0 === this.instance) throw new Error("clear before initial");
            return this.instance.memoryCache = {}, this.instance.sessionCache = {}, this.instance.localCache = {}, sessionStorage.removeItem(this.instance.sessionStorageKey);
        }
        getValue(e) {
            return this.sessionCache.hasOwnProperty(e) ? {
                value: this.sessionCache[e],
                type: rs.SessionStorage
            } : this.localCache.hasOwnProperty(e) ? {
                value: this.localCache[e],
                type: rs.LocalStorage
            } : {
                value: this.memoryCache[e],
                type: rs.Memory
            };
        }
        setValue(e, t1, o) {
            if (!e) throw new Error("key is null");
            switch(o){
                case rs.SessionStorage:
                    {
                        const o = this.sessionCache[e];
                        let r = t1;
                        return "function" == typeof t1 && (r = t1(o)), o !== r && (this.sessionCache[e] = r, this.flushValue(rs.SessionStorage)), r;
                    }
                case rs.LocalStorage:
                    {
                        const o = this.localCache[e];
                        let r = t1;
                        return "function" == typeof t1 && (r = t1(o)), o !== r && (this.localCache[e] = r, this.flushValue(rs.LocalStorage)), r;
                    }
                case rs.Memory:
                    {
                        const o = this.memoryCache[e];
                        let r = t1;
                        return "function" == typeof t1 && (r = t1(o)), this.memoryCache[e] = r, r;
                    }
                default:
                    return null;
            }
        }
        removeValue(e) {
            const { type: t1 } = this.getValue(e);
            switch(t1){
                case rs.SessionStorage:
                    delete this.sessionCache[e], this.flushValue(rs.SessionStorage);
                    break;
                case rs.LocalStorage:
                    delete this.localCache[e], this.flushValue(rs.LocalStorage);
                    break;
                case rs.Memory:
                    delete this.memoryCache[e];
            }
        }
        flushValue(e) {
            e === rs.SessionStorage ? sessionStorage.setItem(this.sessionStorageKey, $r(JSON.stringify(this.sessionCache))) : e === rs.LocalStorage && localStorage.setItem(this.localStorageKey, $r(JSON.stringify(this.localCache)));
        }
    }
    ns.instance = void 0;
    let ss = function(e) {
        return e.WebclientOpt = "WEB_CLIENT_OPT", e.WebclientWebinarToken = "WEB_CLIENT_WEBINAR_TOKEN", e.WebclientMeetingToken = "WEB_CLIENT_MEETING_TOKEN", e.WebclientZtk = "WEB_CLIENT_ZTK", e.WebclientZsk = "WEB_CLIENT_ZSK", e.WebclientTk = "WEB_CLIENT_TK", e.WebclientIVState = "WEB_CLIENT_IV_STATE", e.WebclientIsOnHold = "WEB_CLIENT_IS_ON_HOLD", e.WebclientParticipantId = "WEB_CLIENT_PARTICIPANT_ID", e.WebclientZoomId = "WEB_CLIENT_ZOOM_ID", e.WebclientUserName = "WEB_CLIENT_USER_NAME", e.WebclientUserEmail = "WEB_CLIENT_USER_EMAIL", e.WebclientBreakoutRoomAttendeeStatus = "WEB_CLIENT_BO_ATTENDEE_STATUS", e.WebclientBreakoutRoomCommand = "WEB_CLIENT_BO_COMMAND", e.WebclientAudioEncryptKey = "WEB_CLIENT_AUDIO_ENCRYPT_KEY", e.WebclientVideoEncryptKey = "WEB_CLIENT_VIDEO_ENCRYPT_KEY", e.WebclientSharingEncryptKey = "WEB_CLIENT_SHARING_ENCRYPT_KEY", e.WebclientFailoverCount = "WEB_CLIENT_FAILOVER_COUNT", e.WebclientRecordingToken = "WEB_CLIENT_RECORDING_TOKEN", e;
    }({}), as = function(e) {
        return e.WebclientDeviceId = "WEBCLIENT_DEVICE_ID", e.VSDKLogTrackingId = "ZM_VSDK_LOG_TRACKING_IDS", e;
    }({}), ds = function(e) {
        return e.EnforceWebRTCAudio = "ENFORCE_WEB_RTC_AUDIO", e.DisableAutoReportLogs = "DISABLE_AUTO_REPORT_LOGS", e;
    }({});
    function us(e, t1) {
        const o = t1.match(e);
        return o && o.length > 0 && o[1] || "";
    }
    function ls(e, t1) {
        const o = t1.match(e);
        return o && o.length > 1 && o[2] || "";
    }
    const cs = /version\/(\d+(\.?_?\d+)+)/i, ps = [
        {
            test: [
                /opera/i
            ],
            describe: (e)=>[
                    "Opera(Legacy)",
                    us(cs, e) || us(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: [
                /opr\/|opios/i
            ],
            describe: (e)=>[
                    "Opera",
                    us(/(?:opr|opios)[\s/](\S+)/i, e) || us(cs, e)
                ]
        },
        {
            test: [
                /SamsungBrowser/i
            ],
            describe: (e)=>[
                    "Samsung Internet for Android",
                    us(cs, e) || us(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: [
                /micromessenger/i
            ],
            describe: (e)=>[
                    "WeChat",
                    us(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || us(cs, e)
                ]
        },
        {
            test: [
                /qqbrowser/i
            ],
            describe: (e)=>[
                    /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser",
                    us(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || us(cs, e)
                ]
        },
        {
            test: [
                /msie|trident/i
            ],
            describe: (e)=>[
                    "Internet Explorer",
                    us(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: [
                /\sedg\//i
            ],
            describe: (e)=>[
                    "Microsoft Edge",
                    us(/\sedg\/(\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: [
                /edg([ea]|ios)/i
            ],
            describe: (e)=>[
                    "Microsoft Edge(Legacy)",
                    ls(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: [
                /firefox|iceweasel|fxios/i
            ],
            describe: (e)=>[
                    "Firefox",
                    us(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: [
                /electron/i
            ],
            describe: (e)=>[
                    "Electron",
                    us(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: [
                /chromium/i
            ],
            describe: (e)=>[
                    "Chromium",
                    us(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || us(cs, e)
                ]
        },
        {
            test: [
                /chrome|crios|crmo/i
            ],
            describe: (e)=>[
                    "Chrome",
                    us(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e)
                ]
        },
        {
            test: (e)=>!/like android/i.test(e) && /android/i.test(e),
            describe: (e)=>[
                    "Android Browser",
                    us(cs, e)
                ]
        },
        {
            test: [
                /safari|applewebkit/i
            ],
            describe: (e)=>[
                    "Safari",
                    us(cs, e)
                ]
        }
    ], hs = [
        {
            test: [
                /windows /i
            ],
            describe: (e)=>[
                    "Windows",
                    us(/Windows ((NT|XP)( \d\d?.\d)?)/i, e)
                ]
        },
        {
            test: [
                /Macintosh(.*?) FxiOS(.*?)\//
            ],
            describe: (e)=>[
                    "iOS",
                    ls(/(Version\/)(\d[\d.]+)/, e)
                ]
        },
        {
            test: [
                /macintosh/i
            ],
            describe: (e)=>[
                    "macOS",
                    us(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, ".")
                ]
        },
        {
            test: [
                /(ipod|iphone|ipad)/i
            ],
            describe: (e)=>[
                    "iOS",
                    us(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".")
                ]
        },
        {
            test: (e)=>!/like android/i.test(e) && /android/i.test(e),
            describe: (e)=>[
                    "Android",
                    us(/android[\s/-](\d+(\.\d+)*)/i, e)
                ]
        },
        {
            test: [
                /linux/i
            ],
            describe: ()=>[
                    "Linux"
                ]
        },
        {
            test: [
                /CrOS/
            ],
            describe: ()=>[
                    "Chrome OS"
                ]
        }
    ];
    class ms {
        constructor(){
            this.value = void 0, this.gpu = void 0;
        }
        get isSupported() {
            if (void 0 === this.value) if ("function" == typeof window.OffscreenCanvas) {
                const e = new OffscreenCanvas(1, 1);
                e.addEventListener("webglcontextlost", (e)=>{
                    e.preventDefault();
                });
                const t1 = e.getContext("webgl");
                if (this.value = !!t1, t1) {
                    const e = t1.getExtension("WEBGL_debug_renderer_info");
                    e && (this.gpu = t1.getParameter(e.UNMASKED_RENDERER_WEBGL));
                }
            } else this.value = !1;
            return this.value;
        }
    }
    const gs = new class {
        constructor(){
            this._browser = void 0, this._os = void 0, this._browserVersion = void 0, this._osVersion = void 0, this._offscreenCanvasCapality = void 0, this._clientHintsData = void 0, this._offscreenCanvasCapality = new ms, "userAgentData" in navigator && navigator.userAgentData.getHighEntropyValues([
                "architecture",
                "bitness",
                "formFactor",
                "model",
                "platformVersion",
                "wow64"
            ]).then((e)=>{
                this._clientHintsData = e, this._os && this._osVersion && this._clientHintsData.platform && this._clientHintsData.platformVersion && (this._os = this._clientHintsData.platform, this._osVersion = this._clientHintsData.platformVersion);
            }).catch((e)=>{
                console.warn(e);
            });
        }
        _getBrowserVersion() {
            var e;
            if (null !== (e = this._clientHintsData) && void 0 !== e && null !== (e = e.brands) && void 0 !== e && e.length) {
                const e = this._clientHintsData.brands.filter((e)=>!/(Chromium|Not.*Brand)/i.test(e.brand))[0];
                e && (this._browser = e.brand);
                const t1 = this._clientHintsData.brands.find((e)=>{
                    var t1;
                    return "chromium" === (null === (t1 = e.brand) || void 0 === t1 ? void 0 : t1.toLowerCase());
                });
                t1 ? (this._browserVersion = t1.version, this._browser || (this._browser = t1.brand)) : this._browserVersion = e.version;
            } else {
                const e = navigator.userAgent, t1 = ps.find((t1)=>"function" == typeof t1.test ? t1.test(e) : t1.test.some((t1)=>t1.test(e)));
                if (t1) {
                    const o = t1.describe(e);
                    this._browser = o[0], this._browserVersion = o[1], this.isIOSMobile && (this._browser = "ios-safari");
                } else this._browser = "unknown", this._browserVersion = "0";
            }
        }
        _getOSVersion() {
            var e, t1;
            if (null !== (e = this._clientHintsData) && void 0 !== e && e.platform && null !== (t1 = this._clientHintsData) && void 0 !== t1 && t1.platformVersion) this._os = this._clientHintsData.platform, this._osVersion = this._clientHintsData.platformVersion;
            else {
                const e = navigator.userAgent, t1 = hs.find((t1)=>"function" == typeof t1.test ? t1.test(e) : t1.test.some((t1)=>t1.test(e)));
                if (t1) {
                    const o = t1.describe(e);
                    this._os = o[0], this._osVersion = o[1];
                } else this._os = "unknown", this._osVersion = "0";
            }
        }
        get browser() {
            return this._browser || this._getBrowserVersion(), this._browser;
        }
        get browserVersion() {
            return this._browserVersion || this._getBrowserVersion(), this._browserVersion;
        }
        get os() {
            return this._os || this._getOSVersion(), this._os;
        }
        get osVersion() {
            return this._osVersion || this._getOSVersion(), this._osVersion;
        }
        get isIE() {
            return "Internet Explorer" === this.browser;
        }
        get isLegacyEdge() {
            return "Microsoft Edge(Legacy)" === this.browser;
        }
        get isLegacyOpera() {
            return "Opera(Legacy)" === this.browser;
        }
        get isFirefox() {
            return "Firefox" === this.browser;
        }
        get isSafari() {
            return "Safari" === this.browser;
        }
        get isChrome() {
            var e, t1;
            if (null !== (e = this._clientHintsData) && void 0 !== e && null !== (e = e.brands) && void 0 !== e && e.length) return null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.brands.some((e)=>{
                var t1;
                return "chromium" === (null === (t1 = e.brand) || void 0 === t1 ? void 0 : t1.toLocaleLowerCase());
            });
            const { userAgent: o } = navigator;
            return !this.isLegacyOpera && !this.isLegacyEdge && /chrome/i.test(o) && /webkit/i.test(o);
        }
        get isLegacyChrome() {
            var e;
            return this.isChrome && "function" != typeof (null === (e = navigator.mediaDevices) || void 0 === e ? void 0 : e.getDisplayMedia);
        }
        get isMacOS() {
            return "macOS" === this.os;
        }
        get isIPad() {
            var e;
            return /iPad/i.test(navigator.userAgent) || this.isMacOS && (null === (e = navigator) || void 0 === e ? void 0 : e.maxTouchPoints) > 2;
        }
        get isIOSMobile() {
            return "iOS" === this.os || this.isIPad;
        }
        get architecture() {
            var e, t1;
            return null !== (e = null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.architecture) && void 0 !== e ? e : "";
        }
        get isArm() {
            return this.architecture ? "arm" === this.architecture : /arm/i.test(navigator.userAgent);
        }
        get isChromeOS() {
            return "Chrome OS" === this.os;
        }
        get isAndroidBrowser() {
            var e;
            return "android" === (null === (e = this.os) || void 0 === e ? void 0 : e.toLowerCase());
        }
        get isArmChromeOS() {
            return this.isArm && this.isChromeOS;
        }
        get isAndroidOrIOSBrowser() {
            return this.isAndroidBrowser || this.isIOSMobile;
        }
        get isSupportEssentialAudioAndVideoAbility() {
            return "object" == typeof WebAssembly && "function" == typeof Worker;
        }
        get isSupportAudioWorklet() {
            return "function" == typeof AudioWorklet;
        }
        get isSupportImageCapture() {
            return "ImageCapture" in window;
        }
        get isSupportMediaStreamTrackProcessor() {
            return "MediaStreamTrackProcessor" in window;
        }
        get isSupportOffscreenCanvas() {
            return this._offscreenCanvasCapality.isSupported;
        }
        get gpu() {
            return this._offscreenCanvasCapality.isSupported ? this._offscreenCanvasCapality.gpu : "";
        }
        get bitness() {
            var e, t1;
            return null !== (e = null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.bitness) && void 0 !== e ? e : "";
        }
        get model() {
            var e, t1;
            return null !== (e = null === (t1 = this._clientHintsData) || void 0 === t1 ? void 0 : t1.model) && void 0 !== e ? e : "";
        }
        get wow64() {
            var e;
            if ("windows" === this.os.toLowerCase()) return null === (e = this._clientHintsData) || void 0 === e ? void 0 : e.wow64;
        }
        get isSupportSendScreenSharing() {
            return "getDisplayMedia" in navigator.mediaDevices && "function" == typeof navigator.mediaDevices.getDisplayMedia;
        }
        get isSupportSharedArrayBuffer() {
            return "function" == typeof SharedArrayBuffer;
        }
    };
    function vs() {
        return gs.isAndroidOrIOSBrowser || !!ns.get(ds.EnforceWebRTCAudio);
    }
    const fs = ()=>gs.isIE, ys = ()=>{
        var e;
        return gs.isSupportOffscreenCanvas && (null === (e = navigator) || void 0 === e ? void 0 : e.hardwareConcurrency) >= 2 && "function" == typeof requestAnimationFrame && gs.isSupportSharedArrayBuffer;
    }, Ss = (e, t1)=>{
        var o;
        const { isSafari: r, isIOSMobile: i, isSupportMediaStreamTrackProcessor: n, isAndroidOrIOSBrowser: s, isArmChromeOS: a, isChromeOS: d, isArm: u, isSupportOffscreenCanvas: l, isIPad: c } = gs;
        if (!ys()) {
            const o = r || i, s = "function" != typeof window.SharedArrayBuffer && (!!o || n && l);
            return e && s ? t1 ? 25 : navigator.hardwareConcurrency < 4 ? 2 : 4 : 1;
        }
        return s ? t1 ? 25 : c ? 9 : 4 : a || d && !u ? navigator.hardwareConcurrency >= 4 ? 9 : 2 : (null === (o = navigator) || void 0 === o ? void 0 : o.hardwareConcurrency) < 4 ? 2 : 25;
    };
    function bs() {
        var e;
        return "webkit" in window && !("chrome" in window) && !(null === (e = window.webkit.messageHandlers) || void 0 === e || !e.jsOCHelper);
    }
    function Es() {
        var e;
        const { isAndroidBrowser: t1, isIOSMobile: o, osVersion: r, browserVersion: i, isChrome: n, isFirefox: s, isSafari: a } = gs;
        var d, u;
        if (o) return Number(null === (d = r.match(/^\d+/)) || void 0 === d ? void 0 : d[0]) >= 15;
        if (t1) return Number(null === (u = r.match(/^\d+/)) || void 0 === u ? void 0 : u[0]) >= 10;
        const l = Number(null === (e = i.match(/^\d+/)) || void 0 === e ? void 0 : e[0]);
        return !!(n && l >= 69) || !!(a && l > 14) || !!(s && l >= 76);
    }
    let Is = function(e) {
        return e.VIDEO_ENCODE = "0", e.VIDEO_DECODE = "1", e.AUDIO_ENCODE = "2", e.AUDIO_DECODE = "3", e.SHARING_ENCODE = "4", e.SHARING_DECODE = "5", e;
    }({}), As = function(e) {
        return e[e.NONE = 0] = "NONE", e[e.AES_256 = 1] = "AES_256", e[e.AES_GCM = 2] = "AES_GCM", e;
    }({});
    const Cs = Object.freeze({
        RWG_CHAT: {
            gcmType: 1,
            sessionType: "RWG_CHAT"
        },
        XMPP_CHAT: {
            gcmType: 1,
            sessionType: "XMPP_CHAT"
        },
        CC_MESSAGE: {
            gcmType: 3,
            sessionType: "CC_MESSAGE"
        },
        BO_BROADCAST: {
            gcmType: 1,
            sessionType: "BO_BROADCAST"
        },
        CHAT_FILE: {
            gcmType: 2,
            sessionType: "CHAT_FILE"
        },
        CHAT_FILE_INFO: {
            gcmType: 1,
            sessionType: "CHAT_FILE_INFO"
        }
    }), _s = (window.crypto || window.msCrypto).subtle, Rs = ss.WebclientIVState, ws = Object.keys(Cs).map((e)=>Cs[e].sessionType);
    class Ts {
        constructor(e, t1, o){
            this.isGCMEnabled = void 0, this.gcmSessionKey = void 0, this.gcmMainSessionKey = void 0, this.zoomId = void 0, this.resetParameters(e, t1, o), ns.set(Rs, {}, rs.SessionStorage);
        }
        static init(e, t1, o) {
            this.instance ? this.instance.resetParameters(e, t1, o) : this.instance = new Ts(e, t1, o);
        }
        static destroy() {
            this.instance && (this.instance = void 0);
        }
        resetParameters(e, t1, o) {
            this.isGCMEnabled = !(gs.isIE || !gs.isSupportEssentialAudioAndVideoAbility) && o === As.AES_GCM, this.gcmSessionKey = zr(t1), this.gcmMainSessionKey || (this.gcmMainSessionKey = this.gcmSessionKey), this.zoomId = String(e);
        }
        beginCrypto(e, t1, o) {
            const r = new Uint32Array(1);
            r[0] = 9, r[0] += Number(o);
            const i = new Uint8Array(r.buffer);
            let n = new Uint8Array(132);
            const s = zr(t1);
            return n.set(s, 0), n.set(i, s.length), n = n.subarray(0, s.length + 4), _s.importKey("raw", e, {
                name: "HMAC",
                hash: "SHA-256"
            }, !0, [
                "sign"
            ]).then((e)=>_s.sign({
                    name: "HMAC"
                }, e, n)).then((e)=>_s.importKey("raw", e, {
                    name: "AES-GCM",
                    length: 256
                }, !0, [
                    "encrypt",
                    "decrypt"
                ]));
        }
        getNextIV(e) {
            const t1 = ns.get(Rs);
            return void 0 === t1[e] ? (t1[e] = 0, ns.set(Rs, t1, rs.SessionStorage)) : ns.set(Rs, (t1)=>({
                    ...t1,
                    [e]: t1[e] + 1
                }), rs.SessionStorage);
        }
        resetIVState() {
            const e = ns.get(Rs);
            if (void 0 === e) ;
            else {
                const t1 = Object.keys(e).filter((e)=>ws.indexOf(e) > -1);
                t1.length > 0 && (t1.forEach((t1)=>{
                    e[t1] += 1e6;
                }), ns.set(Rs, e, rs.SessionStorage));
            }
        }
        static resetIV() {
            if (void 0 === this.instance) throw new Error("reset before intialize");
            this.instance.resetIVState();
        }
        static beginEncrypt(e) {
            let { text: t1, type: o } = e;
            const r = new Uint8Array(0);
            if (this.instance && this.instance.isGCMEnabled) {
                const e = 16, i = 12, n = this.instance.getNextIV(o.sessionType), s = new ArrayBuffer(i), a = new Uint8Array(s);
                new DataView(s).setUint32(0, n, !0);
                let d = null;
                return d = "BO_BROADCAST" === o.sessionType || "XMPP_CHAT" === o.sessionType ? this.instance.gcmMainSessionKey : this.instance.gcmSessionKey, this.instance.beginCrypto(d, this.instance.zoomId, o.gcmType).then((o)=>{
                    const i = ArrayBuffer.isView(t1) ? t1 : (new TextEncoder).encode(t1);
                    return _s.encrypt({
                        name: "AES-GCM",
                        iv: a,
                        additionalData: r,
                        tagLength: 8 * e
                    }, o, i);
                }).then((t1)=>{
                    const i = 1 + a.byteLength + 2 + r.byteLength + 4 + t1.byteLength, n = new ArrayBuffer(i);
                    if (new Uint8Array(n)[0] = a.length, new Uint8Array(n, 1, a.byteLength).set(a), new DataView(n).setUint16(1 + a.byteLength, r.length, !0), new Uint8Array(n, 3 + a.byteLength).set(r), new DataView(n).setUint32(1 + a.byteLength + 2 + r.byteLength, t1.byteLength - e, !0), new Uint8Array(n, 1 + a.byteLength + 2 + r.byteLength + 4).set(new Uint8Array(t1)), o.sessionType === Cs.CHAT_FILE.sessionType) return n;
                    const s = new Uint8Array(n).reduce((e, t1)=>e + String.fromCharCode(t1), "");
                    return window.btoa(s).replace(/_/g, "/").replace(/-/g, "+").replace(/\=/g, "");
                });
            }
            return Promise.resolve(ArrayBuffer.isView(t1) ? t1 : $r(t1));
        }
        static beginDecrypt(e) {
            let { decryptedText: t1, type: o, zoomId: r } = e;
            if (this.instance && this.instance.isGCMEnabled) {
                const e = ArrayBuffer.isView(t1) || t1 instanceof ArrayBuffer ? new Uint8Array(t1) : function(e) {
                    let t1;
                    const o = e.length, r = new Array(o);
                    for(t1 = 0; t1 < o; ++t1)r[t1] = 255 & e.charCodeAt(t1);
                    return new Uint8Array(r);
                }(atob(t1.replace(/_/g, "/").replace(/-/g, "+"))), i = e[0], n = e.slice(1, i + 1), s = e.slice(1 + i, 3 + i), a = new DataView(s.buffer).getUint16(0, !0), d = e.slice(1 + i + 2, 1 + i + 2 + a), u = e.slice(1 + i + 2 + a, 1 + i + 2 + a + 4), l = new DataView(u.buffer).getUint32(0, !0), c = e.slice(1 + i + 2 + a + 4, 1 + i + 2 + a + 4 + l), p = e.slice(1 + i + 2 + a + 4 + l);
                let h = null;
                return h = "BO_BROADCAST" === o.sessionType || "XMPP_CHAT" === o.sessionType ? this.instance.gcmMainSessionKey : this.instance.gcmSessionKey, this.instance.beginCrypto(h, r, o.gcmType).then((e)=>{
                    const t1 = function(e, t1) {
                        e = new Uint8Array(e), t1 = new Uint8Array(t1);
                        const o = new Uint8Array(e.length + t1.length);
                        return o.set(e), o.set(t1, e.length), o;
                    }(c, p);
                    return _s.decrypt({
                        name: "AES-GCM",
                        iv: n,
                        additionalData: d,
                        tagLength: 8 * p.length
                    }, e, t1.buffer);
                }).then((e)=>({
                        message: o.sessionType === Cs.CHAT_FILE.sessionType ? e : (new TextDecoder).decode(e),
                        iv: n,
                        aad: d
                    })).catch((e)=>({
                        message: "[This is an encrypted message]",
                        iv: n,
                        aad: d
                    }));
            }
            {
                const e = new TextDecoder("utf-8");
                return Promise.resolve({
                    message: ArrayBuffer.isView(t1) || t1 instanceof ArrayBuffer ? t1 : e.decode(zr(t1))
                });
            }
        }
    }
    Ts.instance = void 0;
    const Os = 20225, Ds = 20234, Ps = 7937, Ms = 7938, ks = 12039, Ls = 16138, Ns = 4098, Vs = 4305, Us = 4343, js = 16428;
    let xs = function(e) {
        return e[e.NoAttendee = 0] = "NoAttendee", e[e.All = 1] = "All", e[e.AllPanelist = 2] = "AllPanelist", e[e.Host = 3] = "Host", e[e.NoOne = 4] = "NoOne", e[e.EveryonePublicly = 5] = "EveryonePublicly", e;
    }({}), Bs = function(e) {
        return e[e.AllPanelist = 1] = "AllPanelist", e[e.Everyone = 2] = "Everyone", e[e.Invalid = 0] = "Invalid", e;
    }({}), Fs = function(e) {
        return e[e.All = 0] = "All", e[e.Panelist = 1] = "Panelist", e[e.IndividualCcPanelist = 2] = "IndividualCcPanelist", e[e.Individual = 3] = "Individual", e[e.SilentModeUsers = 4] = "SilentModeUsers", e;
    }({}), Hs = function(e) {
        return e[e.None = 0] = "None", e[e.Delete = 1] = "Delete", e[e.Modify = 2] = "Modify", e;
    }({}), $s = function(e) {
        return e[e.Success = 0] = "Success", e[e.Delete = 1] = "Delete", e[e.Block = 3] = "Block", e;
    }({});
    const Ws = [
        xs.All,
        xs.Host,
        xs.NoOne,
        xs.EveryonePublicly
    ], Gs = [
        xs.NoOne,
        xs.All,
        xs.AllPanelist
    ], Ks = {
        AllPanelist: 11,
        Everyone: 12
    }, zs = {
        [Ks.AllPanelist]: Bs.AllPanelist,
        [Ks.Everyone]: Bs.Everyone
    }, qs = {
        userId: Fs.All,
        displayName: "Everyone",
        isHost: !1,
        isCoHost: !1
    }, Js = {
        userId: Fs.Panelist,
        displayName: "All panelists"
    }, Qs = {
        userId: Fs.SilentModeUsers,
        displayName: "Everyone (in Waiting Room)",
        isHost: !1,
        isCoHost: !1
    };
    let Zs = function(e) {
        return e[e.Local = 0] = "Local", e[e.ThirdParty = 1] = "ThirdParty", e;
    }({}), Ys = function(e) {
        return e[e.ChunkSize = 20971520] = "ChunkSize", e[e.EncodeBlockSize = 32768] = "EncodeBlockSize", e[e.DecodeBlockSize = 32803] = "DecodeBlockSize", e[e.MaxSize = 2147483648] = "MaxSize", e[e.ReaderChunkSize = 1073741824] = "ReaderChunkSize", e;
    }({}), Xs = function(e) {
        return e[e.Init = 0] = "Init", e[e.InProgress = 1] = "InProgress", e[e.Success = 2] = "Success", e[e.Fail = 3] = "Fail", e[e.Cancel = 4] = "Cancel", e[e.Complete = 5] = "Complete", e;
    }({}), ea = function(e) {
        return e[e.InProgress = 1] = "InProgress", e[e.Success = 2] = "Success", e[e.Fail = 3] = "Fail", e[e.Cancel = 4] = "Cancel", e;
    }({});
    const ta = {
        "7z": "application/x-7z-compressed",
        avi: "video/x-msvideo",
        bin: "application/octet-stream",
        bmp: "image/bmp",
        css: "text/css",
        csv: "text/csv",
        doc: "application/msword",
        docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        gif: "image/gif",
        gz: "application/gzip",
        html: "text/html",
        ics: "text/calendar",
        jar: "application/java-archive",
        jpeg: "image/jpeg",
        jpg: "image/jpeg",
        js: "text/javascript",
        json: "application/json",
        mid: "audio/midi",
        mov: "video/*",
        mp3: "audio/mpeg",
        mp4: "video/mp4",
        mpeg: "video/*",
        mpg: "video/*",
        pdf: "application/pdf",
        png: "image/png",
        ppt: "application/vnd.ms-powerpoint",
        pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        rar: "application/vnd.rar",
        rtf: "application/rtf",
        tar: "application/x-tar",
        tif: "image/tiff",
        tiff: "image/tiff",
        txt: "text/plain",
        wav: "audio/wav",
        webp: "image/webp",
        wma: "audio/*",
        wmv: "video/*",
        xls: "application/vnd.ms-excel",
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        xml: "application/xml",
        zip: "application/zip"
    };
    let oa = function(e) {
        return e.Open = "open", e.Message = "message", e.Error = "error", e.Close = "close", e.Inactive = "inactive", e;
    }({});
    class ra {
        constructor(){
            this.eventHandlers = void 0, this.websocket = void 0, this.seq = void 0, this.intervalsToBeCleardWhenSocketClose = [], this.isAlive = !1, this.isRlbTP = void 0, this.eventHandlers = new Map, this.websocket = null, this.seq = 1, this.isRlbTP = !1;
        }
        on(e, t1) {
            let o = this.eventHandlers.get(e);
            o || (o = []), o.push(t1), this.eventHandlers.set(e, o);
        }
        off(e, t1) {
            const o = this.eventHandlers.get(e);
            if (o) {
                const r = o.filter((e)=>e !== t1);
                this.eventHandlers.set(e, r);
            }
        }
        emit(e, t1) {
            const o = this.eventHandlers.get(e);
            o && o instanceof Array && o.slice(0).forEach((e)=>{
                try {
                    e(t1);
                } catch (e) {
                    console.error(e);
                }
            });
        }
        sendMessageToRwg(e) {
            this.seq += 1;
            const t1 = this.seq;
            return this.websocket && this.websocket.readyState === WebSocket.OPEN && this.websocket.send(JSON.stringify(Object.assign(e, {
                seq: t1
            }))), t1;
        }
        connect(e, t1) {
            this.websocket = t1 ? new window.ZoomTPModule.ZoomTPWebSocket(e) : new WebSocket(e), this.websocket.binaryType = "arraybuffer", this.isRlbTP = t1, this.addWebSocketEventListeners();
        }
        close() {
            var e;
            null === (e = this.websocket) || void 0 === e || e.close();
        }
        addHeartBeat() {
            const e = gs.isAndroidOrIOSBrowser ? 15e3 : 2e4, t1 = setInterval(()=>{
                this.isAlive || this.emit(oa.Inactive, {}), this.sendMessageToRwg({
                    evt: 0
                }), this.isAlive = !1;
            }, e);
            this.intervalsToBeCleardWhenSocketClose.push(t1);
        }
        clearIntervals() {
            this.intervalsToBeCleardWhenSocketClose.forEach((e)=>clearInterval(e)), this.isAlive = !1;
        }
        addWebSocketEventListeners() {
            this.websocket && (this.websocket.addEventListener("open", (e)=>{
                this.isRlbTP || this.addHeartBeat(), this.emit(oa.Open, e);
            }), this.websocket.addEventListener("message", (e)=>{
                this.isAlive = !0, this.emit(oa.Message, e);
            }), this.websocket.addEventListener("close", (e)=>{
                this.clearIntervals(), this.emit(oa.Close, e);
            }), this.websocket.addEventListener("error", (e)=>{
                this.clearIntervals(), this.emit(oa.Error, e);
            }));
        }
        sendLaunchParams(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4301,
                    body: e
                })
            };
        }
        joinMeeting(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4097,
                    body: {
                        meetingtoken: e
                    }
                })
            };
        }
        lockMeeting(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4099,
                    body: {
                        bLock: e
                    }
                })
            };
        }
        endMeeting() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4101,
                    body: {}
                })
            };
        }
        leaveMeeting() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? 4364 : 4103;
            return {
                seq: this.sendMessageToRwg({
                    evt: e,
                    body: {}
                })
            };
        }
        recordMeeting(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4105,
                    body: {
                        bRecord: e,
                        bPause: t1
                    }
                })
            };
        }
        localRecordingGrantPermission(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: Us,
                    body: {
                        cmdType: "permission_request_answer",
                        userId: e,
                        agreed: t1,
                        saveAgreed: o
                    }
                })
            };
        }
        hostGrantPermission(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: Us,
                    body: {
                        cmdType: "grant_permission",
                        userId: e,
                        grant: t1
                    }
                })
            };
        }
        localRecordingRequestPermission() {
            return {
                seq: this.sendMessageToRwg({
                    evt: Us,
                    body: {
                        cmdType: "request_permission"
                    }
                })
            };
        }
        localRecordingMeeting(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: Us,
                    body: {
                        cmdType: "change_recording_status",
                        status: e
                    }
                })
            };
        }
        summaryMeeting(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8009,
                    body: {
                        type: e ? "start" : "stop"
                    }
                })
            };
        }
        startMeetingQuery(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8017,
                    body: {
                        type: e ? "start" : "stop"
                    }
                })
            };
        }
        allowSelfRecord(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4325,
                    body: {
                        bAllowISORecord: e
                    }
                })
            };
        }
        enableZoomIQRecord(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4318,
                    body: {
                        check: e
                    }
                })
            };
        }
        expel(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4107,
                    body: {
                        id: e
                    }
                })
            };
        }
        expelAttendee(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4205,
                    body: {
                        jid: e
                    }
                })
            };
        }
        rename(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4109,
                    body: {
                        id: e,
                        dn2: t1,
                        olddn2: o
                    }
                })
            };
        }
        assignHost(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4111,
                    body: {
                        id: e,
                        bCoHost: t1
                    }
                })
            };
        }
        reclaimHost(e) {
            let t1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return {
                seq: this.sendMessageToRwg({
                    evt: 4133,
                    body: {
                        id: e,
                        bCoHost: t1
                    }
                })
            };
        }
        revokeCoHost(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4195,
                    body: {
                        id: e
                    }
                })
            };
        }
        putOnHold(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4113,
                    body: {
                        id: e,
                        bHold: t1
                    }
                })
            };
        }
        setMuteOnEntry(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4115,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        setHoldOnEntry(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4117,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        inviteCRCDevice(e, t1) {
            let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
            return {
                seq: this.sendMessageToRwg({
                    evt: 4119,
                    body: {
                        ip: e,
                        type: t1,
                        encrypt: o
                    }
                })
            };
        }
        cancelInviteCRCDevice(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4121,
                    body: {
                        transID: e
                    }
                })
            };
        }
        sendCloseCaption(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4125,
                    body: {
                        ...e
                    }
                })
            };
        }
        allowViewParticipantNumber(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4127,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        lowerAllHands() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4129,
                    body: {}
                })
            };
        }
        raiseLowerHand(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4131,
                    body: {
                        id: e,
                        bOn: t1
                    }
                })
            };
        }
        chat(e, t1, o, r) {
            const i = {
                text: e,
                destNodeID: t1
            };
            return o && Object.assign(i, {
                sn: o
            }), r && Object.assign(i, {
                attendeeNodeID: r
            }), {
                seq: this.sendMessageToRwg({
                    evt: 4135,
                    body: i
                })
            };
        }
        assignCC(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4137,
                    body: {
                        id: e,
                        bCCEditor: t1
                    }
                })
            };
        }
        enableLT(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4227,
                    body: {
                        op: e ? 2 : 4
                    }
                })
            };
        }
        enableNewLLT() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4285
                })
            };
        }
        disableCaptions(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: Vs,
                    body: {
                        type: 4,
                        disableNewLtt: e
                    }
                })
            };
        }
        enableManualCaption(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4291,
                    body: {
                        op: e ? 1 : 0
                    }
                })
            };
        }
        setTranslationLanguage(e) {
            return void 0 !== e ? {
                seq: this.sendMessageToRwg({
                    evt: Vs,
                    body: {
                        type: 1,
                        lang: e
                    }
                })
            } : {
                seq: this.sendMessageToRwg({
                    evt: Vs,
                    body: {
                        type: 3
                    }
                })
            };
        }
        setSpokenLanguage(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4287,
                    body: {
                        lang: e
                    }
                })
            };
        }
        allowAskLT(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4263,
                    body: {
                        bAnonymous: e
                    }
                })
            };
        }
        approveLT() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4262,
                    body: {
                        bApproved: !0
                    }
                })
            };
        }
        askLT(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4261,
                    body: {
                        bAnonymous: e
                    }
                })
            };
        }
        setChatPriviledge(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4141,
                    body: {
                        chatPriviledge: e
                    }
                })
            };
        }
        setPanelistChatPrivilege(e) {
            if (!Object.values(Ks).includes(e)) throw Error("Invalid panelist chat privilege req value");
            return {
                seq: this.sendMessageToRwg({
                    evt: 4141,
                    body: {
                        chatPriviledge: e
                    }
                })
            };
        }
        sendFeedback(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4143,
                    body: {
                        feedback: e
                    }
                })
            };
        }
        clearFeedback() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4145,
                    body: {}
                })
            };
        }
        allowUnmuteVideo(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4147,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        allowUnmuteAudio(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4149,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        allowRaiseHand(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4151,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        boToken(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4173,
                    body: {
                        topic: e
                    }
                })
            };
        }
        startBO(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4175,
                    body: {
                        proto: e
                    }
                })
            };
        }
        stopBO(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4177,
                    body: {
                        status: e
                    }
                })
            };
        }
        assignToBO(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4179,
                    body: {
                        targetID: e,
                        targetBID: t1
                    }
                })
            };
        }
        switchBO(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4181,
                    body: {
                        targetID: e,
                        targetBID: t1
                    }
                })
            };
        }
        wantJoinBO(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4183,
                    body: {
                        targetID: e,
                        targetBID: t1
                    }
                })
            };
        }
        joinBO(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4193,
                    body: {
                        targetBID: e
                    }
                })
            };
        }
        leaveBO() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            return {
                seq: this.sendMessageToRwg({
                    evt: 4185,
                    body: {
                        reason: e
                    }
                })
            };
        }
        broadcastBO(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4187,
                    body: {
                        textContent: e
                    }
                })
            };
        }
        askForHelpBO(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4189,
                    body: {
                        targetID: e
                    }
                })
            };
        }
        askForHelpResultBO(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4191,
                    body: {
                        targetID: e,
                        helpResult: t1
                    }
                })
            };
        }
        coHostStartBO(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4241,
                    body: {
                        proto: e,
                        targetID: t1
                    }
                })
            };
        }
        coHostStopBO(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4243,
                    body: {
                        status: e,
                        targetID: t1
                    }
                })
            };
        }
        coHostAssignToBO(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4245,
                    body: {
                        userGUID: e,
                        targetID: o,
                        targetBID: t1
                    }
                })
            };
        }
        moveToMainSession(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4247,
                    body: {
                        userGUID: e
                    }
                })
            };
        }
        coHostMoveToMainSession(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4249,
                    body: {
                        userGUID: e,
                        targetID: t1
                    }
                })
            };
        }
        allowParticipantRename(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4163,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        allowMessageFeedbackNotify(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4171,
                    body: {
                        bOn: e,
                        id: t1
                    }
                })
            };
        }
        setPlayChime(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4197,
                    body: {
                        bOn: e,
                        id: t1
                    }
                })
            };
        }
        admitAllSilentUsers() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4199,
                    body: {}
                })
            };
        }
        bindTeleUser(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4201,
                    body: {
                        teleUserID: e,
                        targetUserID: t1,
                        bBind: o
                    }
                })
            };
        }
        practiceSession() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4207,
                    body: null
                })
            };
        }
        roleChangeWebinar(e, t1, o, r) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4209,
                    body: {
                        jid: t1,
                        userID: o,
                        clientCap: r,
                        bPromote: e
                    }
                })
            };
        }
        sendPromoteConsent(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4254,
                    body: {
                        agreed: e,
                        req_id: t1
                    }
                })
            };
        }
        batchCreateBOToken(e) {
            const t1 = e.map((e, t1)=>({
                    topic: e,
                    index: t1
                }));
            return {
                seq: this.sendMessageToRwg({
                    evt: 4211,
                    body: t1
                })
            };
        }
        mute(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8193,
                    body: {
                        bMute: t1,
                        id: e
                    }
                })
            };
        }
        audioDrop(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8195,
                    body: {
                        id: e
                    }
                })
            };
        }
        audioDialout(e, t1, o, r, i) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8197,
                    body: {
                        pn: e,
                        dn2: $r(t1),
                        bCallme: o,
                        bPressOne: r,
                        bGreeting: i
                    }
                })
            };
        }
        audioCancelDialout(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8199,
                    body: {
                        pn: e,
                        bCallme: t1
                    }
                })
            };
        }
        audioMuteAll(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8201,
                    body: {
                        bMute: e
                    }
                })
            };
        }
        allowToTalk(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8204,
                    body: {
                        id: e,
                        bAllowTalk: t1
                    }
                })
            };
        }
        subscribeVideo() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t1 = arguments.length > 1 ? arguments[1] : void 0, o = arguments.length > 2 ? arguments[2] : void 0;
            return {
                seq: this.sendMessageToRwg({
                    evt: 12289,
                    body: {
                        id: e,
                        size: t1,
                        bOn: o
                    }
                })
            };
        }
        unsubscribeVideo() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            return {
                seq: this.sendMessageToRwg({
                    evt: 12291,
                    body: {
                        id: e
                    }
                })
            };
        }
        muteAttendeeVideo(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 12297,
                    body: {
                        id: e,
                        bOn: t1
                    }
                })
            };
        }
        notifyRwgIsMuteVideo(e, t1) {
            return this.muteAttendeeVideo(e, t1);
        }
        pauseSharing() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16385,
                    body: {}
                })
            };
        }
        resumeSharing() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16387,
                    body: {}
                })
            };
        }
        allowAnonymousQuestion(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4155,
                    body: {
                        userId: e,
                        bOn: t1
                    }
                })
            };
        }
        allowViewAll(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4157,
                    body: {
                        userId: e,
                        bOn: t1
                    }
                })
            };
        }
        allowVote(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4159,
                    body: {
                        userId: e,
                        bOn: t1
                    }
                })
            };
        }
        allowComment(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4161,
                    body: {
                        userId: e,
                        bOn: t1
                    }
                })
            };
        }
        sharingRequestRemoteControl(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16389,
                    body: {
                        id: e,
                        bOn: t1
                    }
                })
            };
        }
        subscribeGrabRemoteControl(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16393,
                    body: {
                        id: e,
                        bOn: t1
                    }
                })
            };
        }
        subscribeSharing(e, t1, o, r) {
            const i = {
                id: e,
                size: t1
            };
            return o && Object.assign(i, {
                bShareToBO: !0
            }), void 0 !== r && Object.assign(i, {
                bVideoShare: r
            }), {
                seq: this.sendMessageToRwg({
                    evt: 16415,
                    body: i
                })
            };
        }
        unsubscribeSharing(e, t1) {
            const o = {
                id: e
            };
            return t1 && Object.assign(o, {
                bShareToBO: !0
            }), {
                seq: this.sendMessageToRwg({
                    evt: 16417,
                    body: o
                })
            };
        }
        sendRWGConnectionPerformance(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4167,
                    body: {
                        data: e
                    }
                })
            };
        }
        sendSdkKeyToMonitor(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4167,
                    body: {
                        data: `ZoomConferenceClient,videoapp_HTML5_sdk_web_join,${o},2,${t1},${e}`
                    }
                })
            };
        }
        sendDatachannelOffer(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24321,
                    offer: e
                })
            };
        }
        joinOrLeaveVoip(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8203,
                    body: {
                        bOn: e
                    }
                })
            };
        }
        startSharing(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16409,
                    body: {
                        id: e,
                        boOn: !1,
                        ...null != t1 ? t1 : {}
                    }
                })
            };
        }
        stopSharing(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16409,
                    body: {
                        id: e,
                        bOn: !0
                    }
                })
            };
        }
        lockSharing(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4169,
                    body: {
                        lockShare: e
                    }
                })
            };
        }
        startShareToBreakoutRoom(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16425,
                    body: {
                        id: e,
                        bShareToBO: !0
                    }
                })
            };
        }
        stopShareToBreakoutRoom(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16425,
                    body: {
                        id: e,
                        bShareToBO: !1
                    }
                })
            };
        }
        preAssignBreakoutRoom() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4213,
                    body: {}
                })
            };
        }
        claimHost(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4215,
                    body: {
                        hostKey: e
                    }
                })
            };
        }
        allowMultiplePin(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4217,
                    body: {
                        userID: e,
                        bOn: t1
                    }
                })
            };
        }
        spotlightVideo(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4219,
                    body: {
                        id: e,
                        ...t1
                    }
                })
            };
        }
        connectCamera(e, t1) {
            const o = {
                evt: 12307,
                body: {
                    id: e,
                    bOn: t1
                }
            };
            return {
                seq: this.sendMessageToRwg(o)
            };
        }
        followHostLayout(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4223,
                    body: {
                        bFollowHostVideo: e
                    }
                })
            };
        }
        setVideoDragLayout(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4218,
                    body: {
                        drag_list: e
                    }
                })
            };
        }
        chatCmdReq(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4237,
                    body: {
                        msgID: e,
                        cmd: t1
                    }
                })
            };
        }
        activeAppLinkReq(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4257,
                    body: {
                        appId: e
                    }
                })
            };
        }
        activeAppInfoReq() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4255,
                    body: {}
                })
            };
        }
        muteShareAudio(e, t1) {
            const o = {
                bOn: !0,
                bShareAudio: !e
            };
            return t1 && Object.assign(o, {
                bShareAudioOnly: !0
            }), {
                seq: this.sendMessageToRwg({
                    evt: 16423,
                    body: o
                })
            };
        }
        localMuteAudio(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 8209,
                    body: {
                        id: e,
                        bMute: t1
                    }
                })
            };
        }
        changeSharePronoun(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4264,
                    body: {
                        bPronoun: e,
                        strPronoun: t1
                    }
                })
            };
        }
        sendReceivingSharingReady(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16421,
                    body: {
                        ssrc: e
                    }
                })
            };
        }
        sendManualCaption(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4289,
                    body: {
                        ...e
                    }
                })
            };
        }
        sendPollingAction(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4224,
                    body: {
                        action: e,
                        PollingId: t1,
                        ...o
                    }
                })
            };
        }
        broadcastUserNetworkQuality(e) {
            const t1 = {
                type: e.isUplink,
                level: e.level,
                bwLevel: e.bwLevel
            };
            return {
                seq: this.sendMessageToRwg({
                    evt: 4331,
                    body: t1
                })
            };
        }
        sendFarEndCameraControl(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4329,
                    body: {
                        cmd: e,
                        userID: t1,
                        buttonID: o
                    }
                })
            };
        }
        sendCameraAblity(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4330,
                    body: {
                        ...e,
                        focus: !1
                    }
                })
            };
        }
        sendReaction(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4259,
                    body: {
                        ...e
                    }
                })
            };
        }
        remoteControlConsent(e, t1, o, r) {
            let i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = arguments.length > 5 ? arguments[5] : void 0;
            const { deviceId: s, ...a } = r, d = void 0 !== n ? {
                runAsAdmin: n
            } : {};
            return {
                seq: this.sendMessageToRwg({
                    evt: 16427,
                    body: {
                        DeviceID: s,
                        op: e,
                        SendUserID: o,
                        AssignUserID: t1,
                        ...a,
                        bAutoDelete: i,
                        ...d
                    }
                })
            };
        }
        takeBackRemoteControlPermission(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16431,
                    body: {
                        SendUserID: e,
                        ReceiverUserID: t1
                    }
                })
            };
        }
        syncSharedContentMetaWithRcApp(e) {
            const { deviceId: t1, ...o } = e;
            return {
                seq: this.sendMessageToRwg({
                    evt: 16429,
                    body: {
                        DeviceID: t1,
                        ...o
                    }
                })
            };
        }
        startLiveStream(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 7977,
                    body: {
                        action: 1,
                        streamingURL: e,
                        streamingKey: t1,
                        broadcastURL: o
                    }
                })
            };
        }
        stopLiveStream() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 7977,
                    body: {
                        action: 0
                    }
                })
            };
        }
        sendRemoteControlAuth(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 16433,
                    body: {
                        auth: e
                    }
                })
            };
        }
        chatFileTransfer(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4307,
                    body: {
                        ...e,
                        fileType: 0,
                        receiverType: 0
                    }
                })
            };
        }
        broadcastVoiceReq(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 4314,
                    body: {
                        broadcastVoice: e
                    }
                })
            };
        }
    }
    class ia extends ra {
        static createAgent() {
            return this.rwgInstance || (this.rwgInstance = new ia), this.rwgInstance;
        }
    }
    ia.rwgInstance = null;
    class na extends ra {
        static getInstance() {
            return this.instance || (this.instance = new na), this.instance;
        }
    }
    na.instance = null;
    const sa = [
        {
            name: "audio_simd.min.js",
            category: "audio",
            type: "worker",
            tag: "simd",
            alias: "audioSIMDWorkletPath"
        },
        {
            name: "audio.simd.wasm",
            category: "audio",
            type: "wasm",
            tag: "simd",
            alias: "audioSIMDWasm"
        },
        {
            name: "js_audio_process.min.js",
            category: "audio",
            type: "worker",
            tag: "",
            alias: "audioWorkerPath"
        },
        {
            name: "audio.encode.wasm",
            category: "audio",
            type: "wasm",
            tag: "",
            alias: "audioWasm"
        },
        {
            name: "js_audio_worklet.min.js",
            category: "audio",
            type: "worklet",
            tag: "",
            alias: "audioWorkletPath"
        },
        {
            name: "js_audio_worklet_simd.min.js",
            category: "audio",
            type: "worklet",
            tag: "simd",
            alias: "audioWorkletSIMDPath"
        },
        {
            name: "js_audio_worklet_process.min.js",
            category: "audio",
            type: "worklet",
            tag: "",
            alias: "audioWorkletProcessPath"
        },
        {
            name: "js_sharing_audio_worklet.min.js",
            category: "audio",
            type: "worklet",
            tag: "",
            alias: "sharingAudioWorkletPath"
        },
        {
            name: "js_audio_level_worklet_process.min.js",
            category: "audio",
            type: "worklet",
            tag: "",
            alias: "audioLevelWorkletPath"
        },
        {
            name: "video_mtsimd.min.js",
            category: "video",
            type: "worker",
            tag: "simd,thread",
            alias: "videoMSIMDWorkerPath"
        },
        {
            name: "video.mtsimd.wasm",
            category: "video",
            type: "wasm",
            tag: "simd,thread,videoShare",
            alias: "videoMSIMDWasm"
        },
        {
            name: "video_m.min.js",
            category: "video",
            type: "worker",
            tag: "thread",
            alias: "videoMtWorkerPath"
        },
        {
            name: "video.mt.wasm",
            category: "video",
            type: "wasm",
            tag: "thread",
            alias: "videoMtWasm"
        },
        {
            name: "video_simd.min.js",
            category: "video",
            type: "worker",
            tag: "simd",
            alias: "videoSIMDWorkerPath"
        },
        {
            name: "video.simd.wasm",
            category: "video",
            type: "wasm",
            tag: "simd",
            alias: "videoSIMDWasm"
        },
        {
            name: "video_s.min.js",
            category: "video",
            type: "worker",
            tag: "",
            alias: "videoWorkerPath"
        },
        {
            name: "video.decode.wasm",
            category: "video",
            type: "wasm",
            tag: "",
            alias: "videoWasm"
        },
        {
            name: "video_share_mtsimd.min.js",
            category: "video",
            type: "worker",
            tag: "videoShare",
            alias: "vsmiworkerpath"
        },
        {
            name: "sharing_mtsimd.min.js",
            category: "sharing",
            type: "worker",
            tag: "simd,thread",
            alias: "sharingMSIMDWorkerPath"
        },
        {
            name: "sharing_m.min.js",
            category: "sharing",
            type: "worker",
            tag: "thread",
            alias: "sharingMtWorkerPath"
        },
        {
            name: "sharing_simd.min.js",
            category: "sharing",
            type: "worker",
            tag: "simd",
            alias: "sharingSIMDWorkerPath"
        },
        {
            name: "sharing_s.min.js",
            category: "sharing",
            type: "worker",
            tag: "",
            alias: "sharingWorkerPath"
        }
    ], aa = "1501", da = (e, t1)=>sa.reduce((o, r)=>{
            const { name: i, alias: n } = r;
            return Object.assign(o, {
                [`${n}`]: `${e}/${t1 && aa ? `${aa}_` : ""}${i}`
            }), o;
        }, {});
    let ua = function(e) {
        return e.VideoEncode = "0", e.VideoDecode = "1", e.AudioEncode = "2", e.AudioDecode = "3", e.SharingEncode = "4", e.SharingDecode = "5", e;
    }({});
    const la = ss.WebclientIVState;
    class ca {
        static getInstance() {
            return void 0 === this.agentInstance && (this.agentInstance = new ca), this.agentInstance;
        }
        constructor(){
            this.assetsPath = void 0, this.instance = void 0, this.callbackList = void 0, this.mediaWorkersPath = void 0, this.constraints = void 0, this.svcUrl = void 0, this.meetingNumber = void 0, this.confId = void 0, this.mediaSocketAddress = void 0, this.currentUserId = void 0, this.receivedSharingCanvas = void 0, this.sharingCanvas = void 0, this.mediaOptions = void 0, this.inProgress = void 0, this.callbackList = [];
        }
        init(e) {
            if (!this.instance && window.JsMediaSDK_Instance) {
                const t1 = {
                    ivObj: {
                        [Is.AUDIO_ENCODE]: ns.get(la) && ns.get(la)[Is.AUDIO_ENCODE],
                        [Is.VIDEO_ENCODE]: ns.get(la) && ns.get(la)[Is.VIDEO_ENCODE],
                        [Is.SHARING_ENCODE]: ns.get(la) && ns.get(la)[Is.SHARING_ENCODE]
                    },
                    globalTracingLogger: e
                };
                this.instance = new window.JsMediaSDK_Instance(t1), this.instance.setRWGAgent(ia.createAgent());
            }
        }
        setAssetsAndConstraint(e, t1, o, r) {
            var i;
            this.assetsPath = e, this.constraints = t1, this.mediaWorkersPath = da(this.assetsPath, !!o), this.onMediaSDKCallback = this.onMediaSDKCallback.bind(this), this.mediaOptions = r, null === (i = this.instance) || void 0 === i || i.JsMediaSDK_PreLoad(this.mediaWorkersPath, this.onMediaSDKCallback, r);
        }
        onMediaSDKCallback(e, t1) {
            this.callbackList.length > 0 && this.callbackList.forEach((o)=>o(e, t1));
        }
        registerCallback(e) {
            this.callbackList.push(e);
        }
        unregisterCallback(e) {
            this.callbackList = this.callbackList.filter((t1)=>t1 !== e);
        }
        static isSupportVideoEncodeHardwareAcceleration() {
            return window.JsMediaSDK_Instance.util.IsSupportVideoEncodeHardwareAcceleration();
        }
        static isSupportVideoDecodeHardwareAcceleration() {
            return window.JsMediaSDK_Instance.util.IsSupportVideoDecodeHardwareAcceleration();
        }
        static isCompatibleHardwareForEncode() {
            var e;
            return gs.isSupportOffscreenCanvas && 0 == (null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.AdapterWhiteListCheckForEncoder());
        }
        static getPTZCapability() {
            var e, t1, o, r, i, n;
            return {
                pan: !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || null === (t1 = e.isSupportCameraPan) || void 0 === t1 || !t1.call(e)),
                tilt: !(null === (o = window.JsMediaSDK_Instance) || void 0 === o || null === (o = o.util) || void 0 === o || null === (r = o.isSupportCameraTilt) || void 0 === r || !r.call(o)),
                zoom: !(null === (i = window.JsMediaSDK_Instance) || void 0 === i || null === (i = i.util) || void 0 === i || null === (n = i.isSupportCameraZoom) || void 0 === n || !n.call(i))
            };
        }
        static isSupportVideoShare() {
            var e, t1;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || null === (t1 = e.isSupportVideoShareReceive) || void 0 === t1 || !t1.call(e));
        }
        static isSupportVideoShareSend() {
            var e, t1;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || null === (t1 = e.isSupportVideoShareSend) || void 0 === t1 || !t1.call(e));
        }
        static isSupportSending720P() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || !e.get720pcapacity());
        }
        static isSupportSubscribing1080P() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util) || void 0 === e || !e.getsub1080pcapacity());
        }
        static isSupportOpenMicWhenShareAudio() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportOpenMicWhenShareAudio());
        }
        static isSupportMediaPlaybackAsVideoInput() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util.videoToMediaStreamManager) || void 0 === e || !e.isSupported());
        }
        static isSupportMediaPlaybackAsAudioInput() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || null === (e = e.util.audioToMediaStreamMananger) || void 0 === e || !e.isSupported());
        }
        static isSupportAudioDenoise(e) {
            var t1;
            return !(null === (t1 = window.JsMediaSDK_Instance) || void 0 === t1 || !t1.util.isSupportAudioDenoise(e));
        }
        static isSupportAudioBridgeAVSync() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportAudioBridgeAvsync());
        }
        static getAudioFeatureFlag() {
            var e;
            return null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.getAudioFeatureFlags();
        }
        static isSupportShareMultiStream() {
            var e;
            return null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.isSupportShareMultiStream();
        }
        static isSupportVideoLTR() {
            var e;
            return null === (e = window.JsMediaSDK_Instance) || void 0 === e ? void 0 : e.util.isSupportVideoLTR();
        }
        static isSupportStereoAudio() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isBrowserSupportStereo());
        }
        static isSupportFullHDVideo() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportSendVideoFullHD());
        }
        static isSupportFullHDVideoShare() {
            var e;
            return !(null === (e = window.JsMediaSDK_Instance) || void 0 === e || !e.util.isSupportSendVideoShareFullHD());
        }
        static isSupportShare2ndAudioDevice(e) {
            var t1;
            return !(null === (t1 = window.JsMediaSDK_Instance) || void 0 === t1 || !t1.util.isSupportShare2ndAudioDevice(e));
        }
        connect(e) {
            var t1, o, r, i, n, s;
            let { svcUrl: a, meetingNumber: d, conId: u, e2eEncrypt: l, isViewOnly: c, currentUserId: p, isWebinar: h, enableAudioQos: m, enableVideoQos: g = !1, enableWebtransport: v = !1, webtransportPort: f, rendererType: y, adaptedABOptionForMediaSDK: S, mediasdkConfig: b } = e;
            const { isSupportEssentialAudioAndVideoAbility: E, isSupportAudioWorklet: I, isSupportSendScreenSharing: A } = gs;
            this.svcUrl = a, this.meetingNumber = d, this.confId = u;
            const C = ((e, t1, o)=>({
                    videoSocketAddress: `wss://${e}/wc/media/${t1}?type=v&cid=${o}`,
                    audioSocketAddress: `wss://${e}/wc/media/${t1}?type=a&cid=${o}`,
                    sharingSocketAddress: `wss://${e}/wc/media/${t1}?type=${fs() ? "j" : "s"}&cid=${o}`
                }))(a, d, u);
            this.mediaSocketAddress = C, this.currentUserId = p;
            const _ = Ss(null === (t1 = this.mediaOptions) || void 0 === t1 ? void 0 : t1.enableMultiDecodeVideoWithoutSAB);
            var R, w, T, O, D, P, M, k, L;
            (null === (o = this.instance) || void 0 === o || o.setPropsBeforeInit({
                callback: this.onMediaSDKCallback,
                audioWorkerPath: E ? null === (r = this.mediaWorkersPath) || void 0 === r ? void 0 : r.audioWorkletPath : void 0,
                e2eEncrypt: l,
                isEnableListenInitEvent: !0,
                enableWebtransport: v,
                webtransportPort: f,
                featureOptions: S,
                rendererType: y,
                mediasdkConfig: b
            }), !0 === (null === (i = this.constraints) || void 0 === i ? void 0 : i.audio) && E && !vs()) && ((h || I) && (null === (R = this.instance) || void 0 === R || R.initAudioDecode(this.mediaWorkersPath, C.audioSocketAddress, p, Lt, u, d, _, m)), !I || h && c || null === (w = this.instance) || void 0 === w || w.initAudioEncode(this.mediaWorkersPath, C.audioSocketAddress, p, Lt, u, d, _, m));
            !0 === (null === (n = this.constraints) || void 0 === n ? void 0 : n.video) && E && (null === (T = this.instance) || void 0 === T || T.initVideoDecode(this.mediaWorkersPath, C.videoSocketAddress, p, Lt, u, d, _, null === (O = null === (D = window.JsMediaSDK_Instance) || void 0 === D || null === (D = D.util) || void 0 === D ? void 0 : D.isGraphicShouldUseHardwareAccelerationDecode()) || void 0 === O || O, g), h && c || null === (P = this.instance) || void 0 === P || P.initVideoEncode(this.mediaWorkersPath, C.videoSocketAddress, p, Lt, u, d, _, !1, g, !0, !0)), !0 === (null === (s = this.constraints) || void 0 === s ? void 0 : s.screen) && (E ? (null === (M = this.instance) || void 0 === M || M.initSharingDecode(this.mediaWorkersPath, C.sharingSocketAddress, p, Lt, u, d, _), !A || h && c || null === (k = this.instance) || void 0 === k || k.initSharingEncode(this.mediaWorkersPath, C.sharingSocketAddress, p, Lt, u, d, _)) : null === (L = this.instance) || void 0 === L || L.initSharingDecode(C.sharingSocketAddress)), this.inProgress = !0;
        }
        async destroy() {
            var e;
            this.callbackList = [], [
                ua.AudioDecode,
                ua.AudioEncode,
                ua.VideoDecode,
                ua.VideoEncode
            ].forEach((e)=>{
                var t1;
                null === (t1 = this.instance) || void 0 === t1 || t1.updateQosSubscription(!1, e);
            });
            const t1 = null === (e = this.instance) || void 0 === e ? void 0 : e.destroy.bind(this.instance);
            this.instance = null, this.inProgress = !1, await (null == t1 ? void 0 : t1());
        }
        disconnect() {
            var e, t1;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(17, {}), null === (t1 = this.instance) || void 0 === t1 || t1.JsMediaSDK_UnInit();
        }
        muteAudio() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(8, {
                ssrc: 0
            });
        }
        unmuteAudio() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(7, {
                ssrc: 0,
                AudioSelectValue: 0
            });
        }
        joinComputerAudio(e, t1, o, r, i, n, s) {
            var a;
            const d = s ? {
                ...s,
                enableHID: !0
            } : {
                enableHID: !1
            };
            return null === (a = this.instance) || void 0 === a ? void 0 : a.Notify_MeidaSDK(22, {
                CaptureAudio: r,
                CaptureAudioInfo: {
                    ssrc: e,
                    AudioSelectValue: "default" === t1 ? null : t1,
                    ...d,
                    audioProfile: i
                },
                speakerInfo: {
                    defaultDeviceId: o
                },
                ...n ? {
                    useAudioBridge: !0,
                    audioBridge: n
                } : {}
            });
        }
        leaveComputerAudio() {
            var e;
            return null === (e = this.instance) || void 0 === e ? void 0 : e.Notify_MeidaSDK(21, null);
        }
        joinSharingAudio(e) {
            var t1;
            let { ssrc: o, microphoneDeviceId: r, speakerDeviceId: i, isCaptureAudio: n, audioBridge: s } = e;
            return null === (t1 = this.instance) || void 0 === t1 ? void 0 : t1.Notify_MeidaSDK(72, {
                CaptureAudio: n,
                CaptureAudioInfo: {
                    ssrc: o,
                    AudioSelectValue: "default" === r ? null : r
                },
                speakerInfo: {
                    defaultDeviceId: i
                },
                checkAutoplay: !1,
                ...s ? {
                    useAudioBridge: !0,
                    audioBridge: s
                } : {}
            });
        }
        leaveSharingAudio(e) {
            var t1;
            return null === (t1 = this.instance) || void 0 === t1 ? void 0 : t1.Notify_MeidaSDK(73, {
                isPause: e ? 1 : 0
            });
        }
        changeSpeaker(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(11, {
                ssrc: 0,
                AudioSelectValue: e
            });
        }
        changeMicrophone(e, t1, o) {
            var r;
            null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(18, {
                ssrc: 0,
                AudioSelectValue: "default" === e ? null : e,
                microphoneLabel: null != t1 ? t1 : "default",
                defaultMuted: o
            });
        }
        restoreWebRTC(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(19, {
                ssrc: 0,
                AudioSelectValue: "default" === e ? null : e
            });
        }
        renderVideo(e, t1, o, r, i, n, s, a, d, u, l) {
            var c;
            const p = {
                userId: t1,
                width: r,
                height: i,
                x: n,
                y: s,
                quality: a,
                isMyself: d,
                canvas: e,
                enableWaterMark: l,
                waterMarkText: u,
                zone: o
            };
            e instanceof HTMLVideoElement && Object.assign(p, {
                videodom: e
            }), null === (c = this.instance) || void 0 === c || c.Notify_MeidaSDK(1, p);
        }
        stopRenderVideo(e, t1, o, r) {
            var i;
            let n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            null === (i = this.instance) || void 0 === i || i.Notify_MeidaSDK(2, {
                canvas: e,
                userId: t1,
                RGBA: r,
                doNotClean: n,
                zone: o
            });
        }
        startCaptureVideo(e, t1, o, r, i, n) {
            var s;
            let a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], d = arguments.length > 8 ? arguments[8] : void 0;
            const u = (arguments.length > 7 ? arguments[7] : void 0) ? ca.getPTZCapability() : void 0;
            null === (s = this.instance) || void 0 === s || s.Notify_MeidaSDK(3, {
                ssid: e,
                width: o,
                height: r,
                fps: d,
                video: i,
                usingFacingMode: n,
                VideoSelectValue: "default" === t1 ? null : t1,
                disableOriginalRatio: a,
                ...u
            });
        }
        stopCaptureVideo() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(4, {
                ssrc: 0
            });
        }
        changeCamera(e, t1, o) {
            var r;
            null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(12, {
                VideoSelectValue: "default" === e ? null : e,
                usingFacingMode: !!t1,
                ...o || {}
            });
        }
        switchCanvasForVideoCapture(e) {
            var t1;
            let o = e;
            "string" == typeof e && (o = [
                e
            ]), null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(25, o);
        }
        renderSharing(e, t1) {
            var o;
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "", n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            this.receivedSharingCanvas = t1, null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(23, {
                width: 0,
                height: 0,
                ssrc: e,
                canvas: t1,
                enableWaterMark: r,
                waterMarkText: i,
                isFromMainSession: n
            });
        }
        stopRenderSharing() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(24, {});
        }
        switchSharingSource(e) {
            var t1;
            let o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(36, {
                ssrc: e,
                isFromMainSession: Number(o)
            });
        }
        ajustmentReceivedSharingCanvas(e, t1) {
            if (this.receivedSharingCanvas && e && t1) try {
                if (gs.isAndroidOrIOSBrowser) {
                    const [o, r] = [
                        1280,
                        720
                    ], i = Math.max(e / o, t1 / r, 1);
                    this.receivedSharingCanvas.width = Math.floor(e / i), this.receivedSharingCanvas.height = Math.floor(t1 / i);
                } else this.receivedSharingCanvas.width = e, this.receivedSharingCanvas.height = t1;
            } catch (e) {}
        }
        startRemoteControl(e, t1, o) {
            var r;
            null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(26, {
                socketURL: `wss://${this.svcUrl}`,
                meetingID: this.meetingNumber,
                condID: this.confId,
                os: t1,
                dom: e,
                ...o
            });
        }
        stopRemoteControl() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(28);
        }
        resendRemoteControlPositionPDU() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(41);
        }
        updateRemoteControlProperties(e) {
            var t1;
            const { dimension: o, ...r } = e;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(27, {
                ...o,
                ...r
            });
        }
        startDesktopSharing(e, t1, o, r) {
            var i;
            let n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], s = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 ? arguments[6] : void 0, d = arguments.length > 7 ? arguments[7] : void 0;
            this.sharingCanvas = t1;
            const u = {};
            r && Object.assign(u, {
                share2ndCamera: !0,
                share2ndCameraParams: {
                    VideoSelectValue: "default" === r.cameraId ? null : r.cameraId,
                    width: r.width,
                    height: r.height
                }
            }), void 0 !== s && Object.assign(u, {
                videoParams: {
                    displaySurface: s
                }
            }), void 0 !== d && Object.assign(u, {
                otherParams: {
                    ...d
                }
            }), null === (i = this.instance) || void 0 === i || i.Notify_MeidaSDK(30, {
                ssid: e,
                canvas: t1,
                video: o,
                ...u,
                showShareAudioOption: n,
                sourceId: a
            });
        }
        stopDesktopSharing() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(31, {});
        }
        pauseDesktopSharing() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(32, {});
        }
        resumeDesktopSharing() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(33, {});
        }
        selectLanguageChannelForNewLTT(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(57, {
                lang: e
            });
        }
        changeSharingSecondCamera(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(49, {
                VideoSelectValue: e
            });
        }
        ajustmentSharingCanvas(e, t1) {
            if (this.sharingCanvas) try {
                this.sharingCanvas.width = e, this.sharingCanvas.height = t1;
            } catch (e) {}
        }
        checkChromeSharingExtension() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(34, {});
        }
        enableAudioEncode() {
            var e, t1;
            null === (e = this.instance) || void 0 === e || e.initAudioEncode(this.mediaWorkersPath, this.mediaSocketAddress.audioSocketAddress, this.currentUserId, Lt, this.confId, this.meetingNumber, Ss(null === (t1 = this.mediaOptions) || void 0 === t1 ? void 0 : t1.enableMultiDecodeVideoWithoutSAB));
        }
        sendUserNodeList(e, t1) {
            var o;
            null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(43, {
                userList: e,
                encryptKey: t1
            });
        }
        updateRenderedSharingDimension(e, t1) {
            var o;
            null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(44, {
                width: e,
                height: t1
            });
        }
        pauseOrResumeAudio(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(45, {
                bPause: e
            });
        }
        updateRenderedVideoCanvasDimension(e, t1, o) {
            var r;
            null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(46, {
                canvas: e,
                width: t1,
                height: o
            });
        }
        clearVideoCanvas(e, t1) {
            var o;
            null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(47, {
                id: e,
                RGBA: t1
            });
        }
        adjustRenderedVideoPosition(e, t1, o, r, i, n, s, a) {
            var d;
            null === (d = this.instance) || void 0 === d || d.Notify_MeidaSDK(48, {
                userId: t1,
                x: r,
                y: i,
                width: n,
                height: s,
                canvas: e,
                zone: o,
                RGBA: a
            });
        }
        mirrorVideo(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(75, {
                isMirrorMyVideo: e
            });
        }
        updateUserMediaSN(e) {
            var t1, o, r;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(80, {
                isFromMainSession: Number(e.isFromMainSession),
                mediaActionType: e.iVType,
                body: {
                    add: null !== (o = e.added) && void 0 !== o ? o : [],
                    remove: null !== (r = e.removed) && void 0 !== r ? r : []
                }
            });
        }
        updateMediaParams(e) {
            var t1;
            const { iVType: o, isFromMainSession: r, updateParams: i } = e;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(81, {
                mediaActionType: o,
                isFromMainSession: Number(r),
                updateParams: i
            });
        }
        createMainSessionChannel(e, t1) {
            var o, r;
            "sharing" === e ? null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(84, t1) : null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(85, t1);
        }
        addReceivedSharingChannelType(e) {
            var t1;
            const { isFromMainSession: o, ...r } = e;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(82, {
                isFromMainSession: Number(o),
                ...r
            });
        }
        removeReceivedSharingChannelType(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(83, {
                isFromMainSession: Number(e.isFromMainSession),
                ssrc: e.ssrc
            });
        }
        enableHardwareAccelerationForVideoDecode(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(70, {
                enable: e
            });
        }
        enableHardwareAccelerationForVideoEncode(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(71, {
                enable: e
            });
        }
        setSharingAudioVolume(e, t1, o) {
            var r;
            null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(74, {
                userid: e >> 10,
                shareVolume: t1 ? 0 : 100,
                isFromMainSession: o
            });
        }
        subscribeToQos(e, t1) {
            e.forEach((e)=>{
                var o;
                null === (o = this.instance) || void 0 === o || o.updateQosSubscription(!0, e, t1);
            });
        }
        unsubscribeFromQos(e) {
            e.forEach((e)=>{
                var t1;
                null === (t1 = this.instance) || void 0 === t1 || t1.updateQosSubscription(!1, e);
            });
        }
        passThroughRWGMessage(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(40, e);
        }
        startVirtualBackgroundSetting(e, t1, o, r, i, n) {
            var s;
            let a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
            null === (s = this.instance) || void 0 === s || s.Notify_MeidaSDK(91, {
                canvas: e,
                bgdom: t1,
                width: i,
                height: n,
                ssid: o,
                VideoSelectValue: "default" === r ? null : r,
                disableOriginalRatio: a
            });
        }
        updateVirtualBackgroundImage(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(92, {
                bgdom: e
            });
        }
        stopVirtualBackgroundSetting() {
            var e;
            let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(93, {
                isSwitch: t1
            });
        }
        startMaskSetting(e, t1, o, r, i, n, s, a, d) {
            var u;
            null === (u = this.instance) || void 0 === u || u.Notify_MeidaSDK(62, {
                canvas: e,
                maskdom: o,
                bgdom: t1,
                dx: 0,
                dy: 0,
                dWidth: n,
                dHeight: s,
                width: a,
                height: d,
                ssid: r,
                VideoSelectValue: "default" === i ? null : i
            });
        }
        updateMaskBackgroundImage(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(63, {
                bgdom: e
            });
        }
        updateMaskClip(e, t1, o) {
            var r;
            null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(64, {
                maskdom: e,
                dx: 0,
                dy: 0,
                dWidth: t1,
                dHeight: o
            });
        }
        stopMaskSetting() {
            var e;
            let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(65, {
                isSwitch: t1
            });
        }
        enableVideoObserver(e) {
            var t1;
            let o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(99, {
                enable: e,
                fpsdisbale: o
            });
        }
        enableShareAudioToBreakoutRoom(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(86, {
                enable: e
            });
        }
        sendUserAudioStatus(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(51, e);
        }
        muteOrUnmuteOtherAudio(e, t1) {
            var o;
            null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(50, {
                userId: e,
                volume: t1 ? 0 : 100
            });
        }
        adjustOtherAudioVolume(e, t1) {
            var o;
            null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(50, {
                userId: e,
                volume: t1
            });
        }
        notifySDKMeetingReady() {
            var e;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(113);
        }
        movePTZCamera(e) {
            var t1;
            return null === (t1 = window.JsMediaSDK_Instance) || void 0 === t1 || null === (t1 = t1.util) || void 0 === t1 ? void 0 : t1.queryPTZPermisson().then((t1)=>{
                var o;
                return t1 ? (null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(53, e), Promise.resolve("")) : Promise.reject("Cannot move camera without permission granted");
            });
        }
        switchSharingMode(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(101, {
                mode: e
            });
        }
        updateVideoHDValue(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK("update_videohd_value", {
                videohd: e
            });
        }
        updateVideoFullhdValue(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK("update_videofullhd_value", {
                videofullhd: e
            });
        }
        changeAudioProfile(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(126, e);
        }
        enableSyncButtonsOnHeadset(e, t1, o) {
            var r;
            null === (r = this.instance) || void 0 === r || r.Notify_MeidaSDK(100, {
                enable: e,
                microphoneLabel: t1,
                defaultMuted: o
            });
        }
        stopAllIncomingAudio(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(123, e);
        }
        isSharingEntireScreen() {
            var e, t1;
            const o = null === (e = this.instance) || void 0 === e || null === (t1 = e.getShareStreamInfo) || void 0 === t1 ? void 0 : t1.call(e);
            if (o) {
                const { displaySurface: e } = o;
                return !e || "monitor" === e;
            }
            return !1;
        }
        getShareStreamInfo() {
            var e, t1;
            const o = null === (e = this.instance) || void 0 === e || null === (t1 = e.getShareStreamInfo) || void 0 === t1 ? void 0 : t1.call(e);
            if (o) {
                const { deviceId: e, width: t1, height: r } = o;
                return {
                    deviceId: e,
                    width: t1,
                    height: r
                };
            }
            return {};
        }
        preInitAudioBridge(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.previewInit({
                audioBridge: {
                    ...e
                }
            });
        }
        prefetchVideoSsrc(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(110, {
                ssrc: e
            });
        }
        cancelPrefetchVideoSsrc(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(112, {
                ssrc: e,
                haddata: !1
            });
        }
        setMobileRotateMode(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(124, {
                isLandScape: e
            });
        }
        changeActiveVideoSsrc(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(13, {
                ssrc: e
            });
        }
        setAudioCodecMode(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(122, {
                mode: e
            });
        }
        startRemoteControlQRCheck(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(54, {
                enable: e
            });
        }
        broadcastVoiceToBreakoutRoom(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(87, {
                enable: e
            });
        }
        share2ndAudio(e, t1) {
            var o;
            const r = {
                audioOnly: !0,
                deviceId: "default" === e ? null : e
            };
            t1 && Object.assign(r, t1), null === (o = this.instance) || void 0 === o || o.Notify_MeidaSDK(129, r);
        }
        enablePlayAudioFileLocally(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(138, e);
        }
        bypassMediaMessage(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(128, e);
        }
    }
    ca.agentInstance = void 0;
    const pa = "ADD_CURRENT_USER_PARTICIPANT_ATTRIBUTE", ha = "UPDATE_CURRENT_USER_PARTICIPANT_ATTRIBUTE", ma = "ADD_USER_PARTICIPANT_ATTRIBUTE", ga = "UPDATE_USER_PARTICIPANT_ATTRIBUTE", va = "REMOVE_USER_PARTICIPANT_ATTRIBUTE", fa = "UPDATE_WEBINAR_PARTICIPANT_ATTRIBUTE", ya = "REMOVE_WEBINAR_ATTENDEE_ATTRIBUTE", Sa = "JOIN_MEETING_SUCCESS", ba = "JOIN_MEETING_FAILED", Ea = "RECONNECTING_MEETING", Ia = "LEAVING_MEETING", Aa = "MEETING_IN_WAITING_ROOM", Ca = "UPDATE_MEETING_ATTRIBUTE", _a = "SHARE_PRONOUN_TYPE_UPDATE", Ra = "MEETING_RLB_TP_READY_STATUS_CHANGE";
    var wa = function(e) {
        return e.ConnectionChange = "connection-change", e.OnHoldChange = "on-hold-change", e.UserAdd = "user-added", e.UserUpdate = "user-updated", e.UserRemove = "user-removed", e.AttendeeUpdate = "attendee-updated", e.MeetingAttributeUpdate = "meeting-attribute-updated", e.PromoteAttendeeConsent = "promote-attendee-consent", e.ActiveAppsUpdate = "active-apps-updated", e.SharePronounTypeUpdate = "share-pronoun-type-update", e;
    }(wa || {});
    const Ta = {
        JoinMeeting: {
            success: pa,
            fail: [
                ba
            ]
        }
    }, Oa = {
        [wa.ConnectionChange]: [
            {
                event: Sa,
                payload: ()=>({
                        state: Yn.Connected
                    })
            },
            {
                event: ba,
                payload: (e)=>({
                        state: Yn.Fail,
                        ...e
                    })
            },
            {
                event: Ea,
                payload: (e)=>({
                        state: Yn.Reconnecting,
                        ...e
                    })
            },
            {
                event: Ia,
                payload: (e)=>({
                        state: Yn.Closed,
                        ...e
                    })
            }
        ],
        [wa.OnHoldChange]: [
            {
                event: Aa,
                payload: (e)=>({
                        isOnHold: e
                    })
            }
        ],
        [wa.UserAdd]: [
            {
                event: pa,
                payload: (e)=>[
                        e
                    ]
            },
            {
                event: ma,
                payload: (e)=>e
            }
        ],
        [wa.UserUpdate]: [
            {
                event: ha,
                payload: (e)=>[
                        e
                    ]
            },
            {
                event: ga,
                payload: (e)=>e
            }
        ],
        [wa.UserRemove]: [
            {
                event: va,
                payload: (e)=>e
            }
        ],
        [wa.AttendeeUpdate]: [
            {
                event: fa,
                payload: (e)=>e
            },
            {
                event: ya,
                payload: (e)=>e
            }
        ],
        [wa.MeetingAttributeUpdate]: [
            {
                event: Ca,
                payload: (e)=>"bNoHostTimeOut" in e ? {
                        isHostLost: e.bNoHostTimeOut
                    } : null
            }
        ],
        [wa.PromoteAttendeeConsent]: [
            {
                event: "MEETING_WEBINAR_PROMOTE_CONSENT_REQ",
                payload: (e)=>{
                    let { req_id: t1, sender_id: o } = e;
                    return {
                        reqId: t1,
                        senderId: o
                    };
                }
            }
        ],
        [wa.ActiveAppsUpdate]: [
            {
                event: "ACTIVE_APPS_UPDATE",
                payload: ()=>{}
            }
        ],
        [wa.SharePronounTypeUpdate]: [
            {
                event: _a,
                payload: (e)=>e
            }
        ]
    }, Da = "LIVE_TRANSCRIPTION_RECEIVE_MESSAGE", Pa = "LIVE_TRANSCRIPTION_CAPTION_STATUS_CHANGE_RESPONSE", Ma = "LIVE_TRANSCRIPTION_STATUS_CHANGE", ka = "LIVE_TRANSCRIPTION_HOST_DISABLE_CHANGE", La = {
        "caption-message": [
            {
                event: Da,
                payload: (e)=>e
            }
        ],
        "caption-status": [
            {
                event: Pa,
                payload: (e)=>e
            }
        ],
        "caption-enable": [
            {
                event: Ma,
                payload: (e)=>e
            }
        ],
        "caption-host-disable": [
            {
                event: ka,
                payload: (e)=>e
            }
        ]
    }, Na = "CHAT_RECEIVE_MESSAGE_EVENTS", Va = "CHAT_PRIVILEGE_CHANGE", Ua = "CHAT_MESSAGE_RESPONSE", ja = "CHAT_DELETE_MESSAGE_REPONSE", xa = "CHAT_FILE_CHAT_UPLOAD_PROGRESS", Ba = "CHAT_FILE_CHAT_DOWNLOAD_PROGRESS";
    let Fa = function(e) {
        return e.ChatOnMessage = "chat-on-message", e.ChatPrivilegeChange = "chat-privilege-change", e.ChatDeleteMessage = "chat-delete-message", e.ChatFileUploadProgress = "chat-file-upload-progress", e.ChatFileDownloadProgress = "chat-file-download-progress", e;
    }({});
    const Ha = {
        [Fa.ChatOnMessage]: [
            {
                event: Na,
                payload: (e)=>e
            }
        ],
        [Fa.ChatPrivilegeChange]: [
            {
                event: Va,
                payload: (e)=>e
            }
        ],
        [Fa.ChatDeleteMessage]: [
            {
                event: ja,
                payload: (e)=>e
            }
        ],
        [Fa.ChatFileUploadProgress]: [
            {
                event: xa,
                payload: (e)=>e
            }
        ],
        [Fa.ChatFileDownloadProgress]: [
            {
                event: Ba,
                payload: (e)=>e
            }
        ]
    }, $a = "COMMAND_RECEIVE_MESSAGE_EVENTS", Wa = "COMMAND_STATUS_EVENTS";
    let Ga = function(e) {
        return e.CommandChannelStatus = "command-channel-status", e.CommandChannelMessage = "command-channel-message", e;
    }({});
    const Ka = {
        [Ga.CommandChannelStatus]: [
            {
                event: Wa,
                payload: (e)=>e
            }
        ],
        [Ga.CommandChannelMessage]: [
            {
                event: $a,
                payload: (e)=>e
            }
        ]
    };
    let za = function(e) {
        return e.Recording = "Recording", e.Paused = "Paused", e.Stopped = "Stopped", e.Ask = "Ask", e.Accept = "Accept", e.Decline = "Decline", e;
    }({}), qa = function(e) {
        return e[e.None = 0] = "None", e[e.Init = 1] = "Init", e[e.Start = 2] = "Start", e[e.Pause = 3] = "Pause", e[e.Stop = 4] = "Stop", e;
    }({}), Ja = function(e) {
        return e[e.Stop = 0] = "Stop", e[e.Start = 1] = "Start", e[e.Pause = 2] = "Pause", e;
    }({}), Qa = function(e) {
        return e[e.None = 0] = "None", e[e.Deny = 1] = "Deny", e[e.Allow = 2] = "Allow", e;
    }({}), Za = function(e) {
        return e[e.None = 0] = "None", e[e.DenyAllRequest = 1] = "DenyAllRequest", e[e.AllowAllRequest = 2] = "AllowAllRequest", e;
    }({});
    const Ya = "CLOUD_RECORDING_STATUS_CHANGE", Xa = "CLOUD_RECORDING_ISO_STATUS_CHANGE", ed = "LOCAL_RECORDING_CHANGE", td = "LOCAL_RECORDING_PERMISSION_CHANGE", od = "RECORDING_FOR_IQ_STATUS_CHANGE", rd = "RECORDING_FOR_IQ_OPERATION_CHANGE";
    let id = function(e) {
        return e.RecordingChange = "recording-change", e.IndividualRecordingChange = "individual-recording-change", e.LocalRecordingChange = "local-recording-change", e.LocalRecordingPermissionChange = "local-recording-permission-change", e.MediaCaptureStatusChange = "media-capture-status-change", e.MediaCapturePermissionChange = "media-capture-permission-change", e.RecordingIqChange = "recording-iq-change", e;
    }({});
    const nd = {
        [id.RecordingChange]: [
            {
                event: Ya,
                payload: (e)=>{
                    const { cmrServerStatus: t1 } = e;
                    return t1 === qa.Start ? za.Recording : t1 === qa.Pause ? za.Paused : za.Stopped;
                }
            }
        ],
        [id.IndividualRecordingChange]: [
            {
                event: Xa,
                payload: (e)=>e
            }
        ],
        [id.LocalRecordingChange]: [
            {
                event: ed,
                payload: (e)=>e
            }
        ],
        [id.LocalRecordingPermissionChange]: [
            {
                event: td,
                payload: (e)=>e
            }
        ],
        [id.MediaCaptureStatusChange]: [
            {
                event: ed,
                payload: (e)=>e
            }
        ],
        [id.MediaCapturePermissionChange]: [
            {
                event: td,
                payload: (e)=>e
            }
        ],
        [id.RecordingIqChange]: [
            {
                event: od,
                payload: (e)=>e
            }
        ]
    };
    let sd = function(e) {
        return e[e.InitSuccess = 1] = "InitSuccess", e[e.InitSuccessVideo = 1.1] = "InitSuccessVideo", e[e.InitSuccessAudio = 1.2] = "InitSuccessAudio", e[e.InitSuccessSharing = 1.3] = "InitSuccessSharing", e[e.UserGrantCaptureAudio = 2] = "UserGrantCaptureAudio", e[e.CurrentVideoResolution = 3] = "CurrentVideoResolution", e[e.JpegDecThreadOk = 4] = "JpegDecThreadOk", e[e.JpegData = 5] = "JpegData", e[e.SharingPara = 6] = "SharingPara", e[e.VideoDecodeMaxSize = 7] = "VideoDecodeMaxSize", e[e.CurrentCaptureVideoWidthHeight = 8] = "CurrentCaptureVideoWidthHeight", e[e.StartVideoCaptureSuccess = 9] = "StartVideoCaptureSuccess", e[e.StopVideoCaptureSuccess = 10] = "StopVideoCaptureSuccess", e[e.StartRemoteControlSuccess = 11] = "StartRemoteControlSuccess", e[e.CancelRemoteControlSuccess = 12] = "CancelRemoteControlSuccess", e[e.RemoteControlCopiedTextNotify = 13] = "RemoteControlCopiedTextNotify", e[e.MonitorLog = 14] = "MonitorLog", e[e.CurrentDesktopSharingWidthHeight = 15] = "CurrentDesktopSharingWidthHeight", e[e.DesktopSharingCaptureSuccess = 16] = "DesktopSharingCaptureSuccess", e[e.CheckChromeSharingExtensionResponse = 17] = "CheckChromeSharingExtensionResponse", e[e.SharingDecodeMaxSize = 18] = "SharingDecodeMaxSize", e[e.DataChannelOffer = 19] = "DataChannelOffer", e[e.AesGcmIvResponse = 21] = "AesGcmIvResponse", e[e.SharingDesktopStreamHaveAudio = 23] = "SharingDesktopStreamHaveAudio", e[e.JoinComputerAudioComplete = 24] = "JoinComputerAudioComplete", e[e.JoinSharingAudioComplete = 25] = "JoinSharingAudioComplete", e[e.LeaveComputerAudioComplete = 26] = "LeaveComputerAudioComplete", e[e.LeaveSharingAudioComplete = 27] = "LeaveSharingAudioComplete", e[e.HidStatusMute = 28] = "HidStatusMute", e[e.AudioStreamFailed = 31] = "AudioStreamFailed", e[e.VideoStreamFailed = 32] = "VideoStreamFailed", e[e.AudioSpeakerSetSuccess = 33] = "AudioSpeakerSetSuccess", e[e.AudiobridgeSetCcLangSuccess = 36] = "AudiobridgeSetCcLangSuccess", e[e.AudioLevelIndicator = 38] = "AudioLevelIndicator", e[e.SyncRendererTypeResponse = 39] = "SyncRendererTypeResponse", e[e.SendRemoteControlQrCode = 55] = "SendRemoteControlQrCode", e[e.StartVideoStreamInMaskSettingSuccess = 66] = "StartVideoStreamInMaskSettingSuccess", e[e.CurrentDecodeVideoQuality = 66.5] = "CurrentDecodeVideoQuality", e[e.CurrentDecodeVideoFps = 66.6] = "CurrentDecodeVideoFps", e[e.SharingFirstDecodeFrameReceivedSsrc = 70] = "SharingFirstDecodeFrameReceivedSsrc", e[e.StartVideoStreamInVbSettingSuccess = 94] = "StartVideoStreamInVbSettingSuccess", e[e.VbModelPreloading_3S = 96] = "VbModelPreloading_3S", e[e.VbModelPreloading_10S = 97] = "VbModelPreloading_10S", e[e.VbModelPreloadingOk = 98] = "VbModelPreloadingOk", e[e.NewActiveSpeakerFirstFrameCallback = 111] = "NewActiveSpeakerFirstFrameCallback", e[e.AudioBridgeFirstRecvData = 114] = "AudioBridgeFirstRecvData", e[e.AudioBridgeCanSendData = 115] = "AudioBridgeCanSendData", e[e.InitFailed = -1] = "InitFailed", e[e.InitFailedVideo = -1.1] = "InitFailedVideo", e[e.InitFailedAudio = -1.2] = "InitFailedAudio", e[e.InitFailedSharing = -1.3] = "InitFailedSharing", e[e.UserForbiddedCaptureAudio = -2] = "UserForbiddedCaptureAudio", e[e.AudioWebsocketBroken = -3] = "AudioWebsocketBroken", e[e.VideoWebsocketBroken = -4] = "VideoWebsocketBroken", e[e.SharingDecThreadFailed = -5] = "SharingDecThreadFailed", e[e.AudioZeroData = -6] = "AudioZeroData", e[e.AudioCtxSamplerate = -7] = "AudioCtxSamplerate", e[e.UserForbiddedCaptureVideo = -8] = "UserForbiddedCaptureVideo", e[e.UserCameraIsTakenByOtherPrograms = -9] = "UserCameraIsTakenByOtherPrograms", e[e.StopVideoCaptureFailed = -10] = "StopVideoCaptureFailed", e[e.StartRemoteControlFailed = -11] = "StartRemoteControlFailed", e[e.CancelRemoteControlFailed = -12] = "CancelRemoteControlFailed", e[e.RemoteControlPasteTextLengthOverflow = -14] = "RemoteControlPasteTextLengthOverflow", e[e.UserStopDesktopSharing = -15] = "UserStopDesktopSharing", e[e.UserCancelPermissionRequest = -16] = "UserCancelPermissionRequest", e[e.DesktopSharingChromeExtensionUninstalled = -17] = "DesktopSharingChromeExtensionUninstalled", e[e.DesktopSharingPermissionDenied = -18] = "DesktopSharingPermissionDenied", e[e.DesktopSharingTimeOut = -19] = "DesktopSharingTimeOut", e[e.DesktopSharingError = -20] = "DesktopSharingError", e[e.AudioSpeakerSetError = -21] = "AudioSpeakerSetError", e[e.DesktopSharingSystemError = -22] = "DesktopSharingSystemError", e[e.SharingDesktopStreamHaveNoAudio = -27] = "SharingDesktopStreamHaveNoAudio", e.AudioQosData = "AUDIO_QOS_DATA", e.VideoQosData = "VIDEO_QOS_DATA", e.ShareQosData = "VIDEOSHARE_QOS_DATA", e.NetworkQualityChange = "NETWORK_QUALITY_CHANGE", e.NetworkQualityChangeAudio = "NETWORK_QUALITY_CHANGE_AUDIO", e[e.AudioBridgeReconnectStart = -29] = "AudioBridgeReconnectStart", e[e.AudioBridgeReconnectEnd = -31] = "AudioBridgeReconnectEnd", e[e.WebglLostInMultiView = -32] = "WebglLostInMultiView", e[e.MaskSettingParaError = -33] = "MaskSettingParaError", e[e.VbSettingParaError = -34] = "VbSettingParaError", e[e.NotifyUIFailover = -35] = "NotifyUIFailover", e[e.AudiobridgeSetCcLangFailure = -39] = "AudiobridgeSetCcLangFailure", e[e.RecoverWebrtcAudio = -44] = "RecoverWebrtcAudio", e[e.SharingHealthCheckFailed = -129] = "SharingHealthCheckFailed", e[e.VideoHealthCheckFailed = -130] = "VideoHealthCheckFailed", e[e.AudioHealthCheckFailed = -131] = "AudioHealthCheckFailed", e.AudioStreamMuted = "AUDIO_STREAM_MUTED", e.AudioStreamUnmuted = "AUDIO_STREAM_UNMUTED", e;
    }({}), ad = function(e) {
        return e[e.EncodeSuccess = 1] = "EncodeSuccess", e[e.DecodeSuccess = 2] = "DecodeSuccess", e[e.EncodeFailed = -1] = "EncodeFailed", e[e.DecodeFailed = -2] = "DecodeFailed", e;
    }({}), dd = function(e) {
        return e.Spotlight = "Spotlight", e.Unmute = "Unmute", e.AllowToTalk = "Allow to talk", e;
    }({}), ud = function(e) {
        return e.Inherited = "inherited", e.Active = "active", e.PassiveByMuteOne = "passive(mute one)", e.PassiveByMuteAll = "passive(mute all)", e.SharingAudio = "sharing audio", e;
    }({}), ld = function(e) {
        return e.Inherited = "inherited", e.Active = "active", e.Passive = "passive", e.SharingAudio = "sharing audio", e;
    }({}), cd = function(e) {
        return e.Active = "active", e.Failover = "failover", e.EndedBySystem = "audio stream is ended by system", e.Pstn = "pstn", e.MicrophoneError = "microphone error", e;
    }({}), pd = function(e) {
        return e.Join = "join", e.Leave = "leave", e.Muted = "muted", e.Unmuted = "unmuted", e;
    }({}), hd = function(e) {
        return e[e.Calling = 1] = "Calling", e[e.Ringing = 2] = "Ringing", e[e.Accepted = 3] = "Accepted", e[e.Busy = 4] = "Busy", e[e.NotAvailable = 5] = "NotAvailable", e[e.HangUp = 6] = "HangUp", e[e.Fail = 7] = "Fail", e[e.Success = 8] = "Success", e[e.Timeout = 9] = "Timeout", e[e.Canceling = 10] = "Canceling", e[e.Canceled = 11] = "Canceled", e[e.CancelFailed = 12] = "CancelFailed", e;
    }({});
    const md = (()=>{
        const e = new ArrayBuffer(684), t1 = new Uint32Array(e);
        return t1.set([
            1179011410,
            676,
            1163280727,
            544501094,
            16,
            65539,
            16e3,
            64e3,
            2097156,
            1635017060,
            640
        ], 0), new Blob([
            t1
        ], {
            type: "audio/wav"
        });
    })(), gd = new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        4,
        1,
        96,
        0,
        0,
        3,
        2,
        1,
        0,
        5,
        4,
        1,
        3,
        1,
        1,
        10,
        11,
        1,
        9,
        0,
        65,
        0,
        254,
        16,
        2,
        0,
        26,
        11
    ]), vd = new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        4,
        1,
        96,
        0,
        0,
        3,
        2,
        1,
        0,
        10,
        9,
        1,
        7,
        0,
        65,
        0,
        253,
        15,
        26,
        11
    ]);
    let fd = function(e) {
        return e[e.HostGrab = 0] = "HostGrab", e[e.OnlyHost = 1] = "OnlyHost", e[e.AnyoneGrab = 2] = "AnyoneGrab", e[e.MultipleShare = 3] = "MultipleShare", e;
    }({}), yd = function(e) {
        return e.Sharing = "sharing", e.Paused = "paused", e.End = "ended", e;
    }({}), Sd = function(e) {
        return e[e.Video_90P = 0] = "Video_90P", e[e.Video_180P = 1] = "Video_180P", e[e.Video_360P = 2] = "Video_360P", e[e.Video_720P = 3] = "Video_720P", e[e.Video_1080P = 4] = "Video_1080P", e;
    }({}), bd = function(e) {
        return e.Active = "Active", e.Inactive = "Inactive", e;
    }({}), Ed = function(e) {
        return e.Muted = "Muted", e.Unmuted = "Unmuted", e;
    }({}), Id = function(e) {
        return e.Started = "Started", e.Stopped = "Stopped", e.Failed = "Failed", e;
    }({}), Ad = function(e) {
        return e.Approved = "Approved", e.Rejected = "Rejected", e;
    }({}), Cd = function(e) {
        return e.PrivilegeChange = "PrivilegeChange", e.StopScreenCapture = "StopScreenCapture", e.ShareFromMainSession = "ShareFromMainSession", e;
    }({}), _d = function(e) {
        return e[e.ImageNotMatch = 2] = "ImageNotMatch", e[e.CanvasNotMatch = 3] = "CanvasNotMatch", e[e.VBModelNotMatch = 4] = "VBModelNotMatch", e;
    }({});
    const Rd = "blur";
    let wd = function(e) {
        return e.User = "user", e.Environment = "environment", e.Left = "left", e.Right = "right", e;
    }({});
    const Td = Object.values(wd), Od = 1e3, Dd = "__ZOOM_SDK_SHARING_VIDEO__", Pd = "__ZOOM_SDK_VIDEO_ZONE__", Md = "__ZOOM_SDK_MEDIA_PLAYBACK_SOURCE_VIDEO__", kd = "__ZOOM_SDK_DYMMY_VIDEO_PLAYER_CANVAS_ID__", Ld = "__ZOOM_SDK_DUMMY_HIDDEN_SELF_VIEW_VIDEO_ID__", Nd = {
        data: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            rate: 0,
            bandwidth: 0
        }
    }, Vd = {
        data: {
            sample_rate: 0,
            rtt: 0,
            jitter: 0,
            avg_loss: 0,
            max_loss: 0,
            width: 0,
            height: 0,
            fps: 0,
            rate: 0,
            bandwidth: 0
        }
    };
    let Ud = function(e) {
        return e[e.Request = 11] = "Request", e[e.Decline = 12] = "Decline", e[e.Approve = 13] = "Approve", e[e.GiveUp = 14] = "GiveUp", e[e.StartControl = 15] = "StartControl", e[e.ContinueControl = 16] = "ContinueControl", e[e.StopControl = 17] = "StopControl", e[e.SwitchCamera = 20] = "SwitchCamera", e;
    }({}), jd = function(e) {
        return e[e.Bk = 0] = "Bk", e[e.Center = 1] = "Center", e[e.ZoomIn = 2] = "ZoomIn", e[e.ZoomOut = 3] = "ZoomOut", e[e.Left = 4] = "Left", e[e.Right = 5] = "Right", e[e.Up = 6] = "Up", e[e.Down = 7] = "Down", e[e.SwitchCamera = 8] = "SwitchCamera", e;
    }({}), xd = function(e) {
        return e[e.Pan = 192] = "Pan", e[e.Tilt = 48] = "Tilt", e[e.Zoom = 12] = "Zoom", e[e.Focus = 3] = "Focus", e;
    }({}), Bd = function(e) {
        return e[e.ZoomIn = 2] = "ZoomIn", e[e.ZoomOut = 3] = "ZoomOut", e[e.Left = 4] = "Left", e[e.Right = 5] = "Right", e[e.Up = 6] = "Up", e[e.Down = 7] = "Down", e[e.SwitchCamera = 8] = "SwitchCamera", e;
    }({}), Fd = function(e) {
        return e[e.None = 0] = "None", e[e.ApproveAnother = 3] = "ApproveAnother", e[e.Stop = 5] = "Stop", e;
    }({}), Hd = function(e) {
        return e[e.Null = 0] = "Null", e[e.Normal = 1] = "Normal", e[e.VideoMode = 2] = "VideoMode", e;
    }({}), $d = function(e) {
        return e[e.Null = 0] = "Null", e[e.VirtualBackground = 1] = "VirtualBackground", e[e.Mask = 2] = "Mask", e;
    }({}), Wd = function(e) {
        return e.Computer = "computer", e.Phone = "phone", e;
    }({}), Gd = function(e) {
        return e[e.Decline = 0] = "Decline", e[e.Approve = 1] = "Approve", e[e.CacheClean = 2] = "CacheClean", e;
    }({}), Kd = function(e) {
        return e.Unknown = "unknown", e.Uninstalled = "uninstalled", e.Installed = "installed", e;
    }({}), zd = function(e) {
        return e.Unlaunched = "unlaunched", e.Launched = "launched", e;
    }({}), qd = function(e) {
        return e.Started = "started", e.Ended = "ended", e;
    }({}), Jd = function(e) {
        return e[e.Max = 30] = "Max", e[e.Min = 10] = "Min", e[e.Default = 24] = "Default", e;
    }({}), Qd = function(e) {
        return e[e.Loading = 1] = "Loading", e[e.Done = 2] = "Done", e;
    }({}), Zd = function(e) {
        return e.Browser = "Browser", e.Zoom = "Zoom", e;
    }({}), Yd = function(e) {
        return e.Denoise = "backgroundNoiseSuppression", e.OriginalSound = "originalSound", e;
    }({}), Xd = function(e) {
        return e[e.Undefined = 0] = "Undefined", e[e.WebGL = 1] = "WebGL", e[e.WebGPU = 2] = "WebGPU", e[e.WebGL2 = 3] = "WebGL2", e;
    }({}), eu = function(e) {
        return e[e.H323 = 1] = "H323", e[e.SIP = 2] = "SIP", e;
    }({}), tu = function(e) {
        return e[e.Success = 0] = "Success", e[e.Ringing = 1] = "Ringing", e[e.Timeout = 2] = "Timeout", e[e.Busy = 101] = "Busy", e[e.Fail = 104] = "Fail", e;
    }({}), ou = function(e) {
        return e[e.AudioConnectionFailed = 101] = "AudioConnectionFailed", e[e.AudioStreamEnded = 102] = "AudioStreamEnded", e[e.MicrophonePermissionReset = 103] = "MicrophonePermissionReset", e[e.AudioStreamFailed = 104] = "AudioStreamFailed", e[e.MicrophoneMuted = 105] = "MicrophoneMuted", e[e.AudioStreamMuted = 106] = "AudioStreamMuted", e[e.AudioPlaybackInterrupted = 107] = "AudioPlaybackInterrupted", e[e.VideoConnectionFailed = 201] = "VideoConnectionFailed", e[e.VideoStreamEnded = 202] = "VideoStreamEnded", e[e.CameraPermissionReset = 203] = "CameraPermissionReset", e[e.WebGlContextInvalid = 204] = "WebGlContextInvalid", e[e.WasmOutOfMemory = 205] = "WasmOutOfMemory", e[e.VideoStreamFailed = 206] = "VideoStreamFailed", e[e.SharingStreamFailed = 301] = "SharingStreamFailed", e;
    }({});
    const ru = "RECEIVE_VIDEO_ACTIVE_INDICATION", iu = "RECEIVE_VIDEO_MUTE_INDICATION", nu = "ASK_FOR_START_VIDEO_CONSENT", su = "RECEIVE_VIDEO_DIMENSION_CHANGE", au = "CAPTURED_VIDEO_DIMENSION_CHANGE", du = "CAN_NOT_DETECT_CAMERA", uu = "CAN_NOT_FIND_CAMERA", lu = "VIDEO_USER_FORBIDDEN_CAPTURE", cu = "VIDEO_CAMERA_IS_TAKEN", pu = "VIDEO_BACKGROUND_FAILED", hu = "VIDEO_ESTABLISH_STREAM_ERROR", mu = "VIDEO_CAPTURE_START_SUCCESS", gu = "VIDEO_CAPTURE_STOP_RESULT", vu = "VIDEO_SPOTLIGHT_CHANGE", fu = "VIDEO_FOLLOW_HOST_ORDER_CHANGE", yu = "VIDEO_HOST_DRAG_LAYOUT_CHANGE", Su = "VIDEO_NEW_USER_START", bu = "VIDEO_OLD_USER_STOP", Eu = "VIDEO_VIRTUAL_BACKGROUND_PRELOAD_READY", Iu = "VIDEO_VIRTUAL_BACKGROUND_SETTING_SUCCESS", Au = "VIDEO_STATISTIC_DATA", Cu = "VIDEO_CELL_DETAILED_DATA", _u = "VIDEO_NETWORK_QUALITY_CHANGE", Ru = "VIDEO_FAR_END_CAMERA_CONTROL_REQUEST", wu = "VIDEO_FAR_END_CAMERA_CONTROL_RESPONSE", Tu = "VIDEO_FAR_END_CAMERA_IN_CONTROL_CHANGE", Ou = "VIDEO_FAR_END_CAMERA_CAPABILITY_CHANGE", Du = "VIDEO_MASK_SETTING_SUCCESS", Pu = "VIDEO_CAPTURE_SDK_SUCCESS", Mu = "VIDEO_PREFETCH_VIDEO_FRAME_CALLBACK", ku = "VIDEO_CURRENT_USER_SSRC", Lu = "VIDEO_RENDER_ASPECT_RATIO_CHANGE", Nu = "VIDEO_LEADERSHIP_USER_CHANGE", Vu = {
        startCaptureVideo: {
            success: mu,
            fail: [
                du,
                uu,
                lu,
                hu,
                cu,
                pu
            ]
        },
        switchCameraVideo: {
            success: Pu,
            fail: [
                du,
                uu,
                lu,
                cu
            ]
        }
    };
    let Uu = function(e) {
        return e.VideoActiveChange = "video-active-change", e.PeerVideoStateChange = "peer-video-state-change", e.VideoSpotlightChange = "video-spotlight-change", e.VideoMutedChange = "video-muted-change", e.VideoCapturingChange = "video-capturing-change", e.AskForStartVideoConsent = "ask-for-start-video-consent", e.VideoDimensionChange = "video-dimension-change", e.VideoFollowHostOrder = "video-follow-host-order-change", e.VideoHostLayoutChange = "video-host-layout-change", e.VideoVBPreloadChange = "video-virtual-background-preload-change", e.VideoStatisticDataChange = "video-statistic-data-change", e.VideoDetailedDataChange = "video-detailed-data-change", e.VideoAspectRatioChange = "video-aspect-ratio-change", e.NetworkQualityChange = "network-quality-change", e.FarEndCameraRequestControl = "far-end-camera-request-control", e.FarEndCameraResponseControl = "far-end-camera-response-control", e.FarEndCameraInControlChange = "far-end-camera-in-control-change", e.FarEndCameraCapabilityChange = "far-end-camera-capability-change", e;
    }({});
    const ju = {
        [Uu.VideoActiveChange]: [
            {
                event: ru,
                payload: (e)=>({
                        state: e.bVideoOn ? bd.Active : bd.Inactive,
                        userId: e.userId
                    })
            }
        ],
        [Uu.VideoCapturingChange]: [
            {
                event: mu,
                payload: ()=>({
                        state: Id.Started
                    })
            },
            {
                event: gu,
                payload: (e)=>({
                        state: null != e && e.failed ? Id.Failed : Id.Stopped
                    })
            }
        ],
        [Uu.VideoMutedChange]: [
            {
                event: iu,
                payload: (e)=>({
                        state: e.isVideoMuted ? Ed.Muted : Ed.Unmuted,
                        userId: e.id
                    })
            }
        ],
        [Uu.AskForStartVideoConsent]: [
            {
                event: nu,
                payload: (e)=>({
                        state: e.isVideoMuted ? Ed.Muted : Ed.Unmuted,
                        userId: e.id
                    })
            }
        ],
        [Uu.VideoSpotlightChange]: [
            {
                event: vu,
                payload: (e)=>({
                        spotlightList: e.spotlightList && e.spotlightList.map((e)=>({
                                userId: e
                            }))
                    })
            },
            {
                event: Nu,
                payload: (e)=>{
                    var t1;
                    return {
                        spotlightList: null === (t1 = e.spotlightList) || void 0 === t1 ? void 0 : t1.map((e)=>({
                                userId: e
                            }))
                    };
                }
            }
        ],
        [Uu.VideoDimensionChange]: [
            {
                event: su,
                payload: (e)=>({
                        type: "received",
                        width: e.width,
                        height: e.height
                    })
            },
            {
                event: au,
                payload: (e)=>({
                        type: "captured",
                        width: e.width,
                        height: e.height
                    })
            }
        ],
        [Uu.VideoFollowHostOrder]: [
            {
                event: fu,
                payload: (e)=>({
                        isFollowHostOrder: e.bOn
                    })
            }
        ],
        [Uu.VideoHostLayoutChange]: [
            {
                event: yu,
                payload: (e)=>Array.isArray(e.layout) ? e.layout.map((e)=>({
                            userId: e
                        })) : []
            }
        ],
        [Uu.PeerVideoStateChange]: [
            {
                event: Su,
                payload: (e)=>({
                        action: "Start",
                        ...e
                    })
            },
            {
                event: bu,
                payload: (e)=>({
                        action: "Stop",
                        ...e
                    })
            }
        ],
        [Uu.VideoVBPreloadChange]: [
            {
                event: Eu,
                payload: (e)=>({
                        isReady: e
                    })
            }
        ],
        [Uu.VideoStatisticDataChange]: [
            {
                event: Au,
                payload: (e)=>{
                    const { data: { rate: t1, ...o }, ...r } = null != e ? e : {
                        data: {}
                    };
                    return {
                        data: {
                            bitrate: t1,
                            ...o
                        },
                        ...r
                    };
                }
            }
        ],
        [Uu.VideoDetailedDataChange]: [
            {
                event: Cu,
                payload: (e)=>e
            }
        ],
        [Uu.VideoAspectRatioChange]: [
            {
                event: Lu,
                payload: (e)=>e
            }
        ],
        [Uu.NetworkQualityChange]: [
            {
                event: _u,
                payload: (e)=>e
            }
        ],
        [Uu.FarEndCameraRequestControl]: [
            {
                event: Ru,
                payload: (e)=>e
            }
        ],
        [Uu.FarEndCameraResponseControl]: [
            {
                event: wu,
                payload: (e)=>e
            }
        ],
        [Uu.FarEndCameraInControlChange]: [
            {
                event: Tu,
                payload: (e)=>e
            }
        ],
        [Uu.FarEndCameraCapabilityChange]: [
            {
                event: Ou,
                payload: (e)=>e
            }
        ]
    }, xu = "AUDIO_ACTIVE_SPEAKER", Bu = "AUDIO_UNMUTE_CONSENT", Fu = "AUDIO_CURRENT_USER_JOIN_BY_VOIP", Hu = "AUDIO_CURRENT_USER_JOIN_BY_PHONE", $u = "AUDIO_CURRENT_USER_LEAVE_AUDIO", Wu = "AUDIO_CURRENT_USER_MUTED", Gu = "AUDIO_CURRENT_USER_UNMUTED", Ku = "AUDIO_PARTICIPANT_AUDIO_UPDATE", zu = "AUDIO_DIALOUT_RESULT_CODE", qu = "AUDIO_DIALOUT_RESULT_SUCCESS", Ju = "AUDIO_DIALOUT_RESULT_FAIL", Qu = "AUDIO_DIALOUT_CANCEL_SUCCESS", Zu = "DIALOUT_CANCEL_FAIL", Yu = "AUDIO_MERGE_AUDIO_INDICATION", Xu = "USER_FORBIDDEN_MICROPHONE", el = "ESTABLISH_AUDIO_STREAM_ERROR", tl = "AUDIO_AUTO_PLAY_FAILED", ol = "INVALID_DEVICE_ID", rl = "AUDIO_ALLOW_TALK_CHANGE", il = "SHARE_AUDIO_STATE_CHANGE", nl = "AUDIO_STATISTIC_DATA", sl = "AUDIO_CURRENT_USER_SSRC", al = "AUDIO_SET_SPEAKER_RESULT", dl = "AUDIO_SHARE_SECONDARY_AUDIO_SUCCESS", ul = "AUDIO_CRC_CALL_OUT_RESULT_CODE", ll = "AUDIO_CRC_CALL_OUT_RESULT_SUCCESS", cl = "AUDIO_CRC_CALL_OUT_RESULT_FAIL", pl = "AUDIO_CURRENT_AUDIO_LEVEL_CHANGE";
    let hl = function(e) {
        return e.ActiveSpeaker = "active-speaker", e.UnmuteAudioConsent = "unmute-audio-consent", e.CurrentAudioChange = "current-audio-change", e.CurrentAudioLevelChange = "current-audio-level-change", e.DialoutStateChange = "dialout-state-change", e.MergeAudio = "merged-audio", e.AutoPlayFailed = "auto-play-audio-failed", e.AllowTalkChange = "allow-talk-change", e.ShareAudioChange = "share-audio-change", e.AudioStatisticDataChange = "audio-statistic-data-change", e.CrcCallOutStateChange = "crc-call-out-state-change", e;
    }({});
    const ml = {
        JoinComputerAudio: {
            success: Fu,
            fail: [
                Xu,
                el
            ]
        },
        JoinAudioByCallMe: {
            success: qu,
            fail: [
                Ju
            ]
        },
        cancelDialOut: {
            success: Qu,
            fail: [
                Zu
            ]
        },
        hangup: {
            success: $u
        },
        crcCallOut: {
            success: ll,
            fail: [
                cl
            ]
        }
    }, gl = {
        [hl.ActiveSpeaker]: [
            {
                event: xu,
                payload: (e)=>e
            }
        ],
        [hl.UnmuteAudioConsent]: [
            {
                event: Bu,
                payload: (e)=>({
                        reason: e
                    })
            }
        ],
        [hl.CurrentAudioChange]: [
            {
                event: Hu,
                payload: ()=>({
                        action: pd.Join,
                        type: Wd.Phone
                    })
            },
            {
                event: Fu,
                payload: ()=>({
                        action: pd.Join,
                        type: Wd.Computer
                    })
            },
            {
                event: $u,
                payload: (e)=>{
                    let { source: t1 } = e;
                    return {
                        action: pd.Leave,
                        source: t1
                    };
                }
            },
            {
                event: Wu,
                payload: (e)=>{
                    let { source: t1 } = e;
                    return {
                        action: pd.Muted,
                        source: t1
                    };
                }
            },
            {
                event: Gu,
                payload: (e)=>{
                    let { source: t1 } = e;
                    return {
                        action: pd.Unmuted,
                        source: t1
                    };
                }
            }
        ],
        [hl.DialoutStateChange]: [
            {
                event: zu,
                payload: (e)=>e
            }
        ],
        [hl.MergeAudio]: [
            {
                event: Yu,
                payload: (e)=>e
            }
        ],
        [hl.AutoPlayFailed]: [
            {
                event: tl,
                payload: ()=>{}
            }
        ],
        [hl.AllowTalkChange]: [
            {
                event: rl,
                payload: (e)=>({
                        enabled: e
                    })
            }
        ],
        [hl.ShareAudioChange]: [
            {
                event: il,
                payload: (e)=>e
            }
        ],
        [hl.AudioStatisticDataChange]: [
            {
                event: nl,
                payload: (e)=>{
                    const { data: { rate: t1, ...o }, ...r } = null != e ? e : {
                        data: {}
                    };
                    return {
                        data: {
                            bitrate: t1,
                            ...o
                        },
                        ...r
                    };
                }
            }
        ],
        [hl.CrcCallOutStateChange]: [
            {
                event: ul,
                payload: (e)=>e
            }
        ],
        [hl.CurrentAudioLevelChange]: [
            {
                event: pl,
                payload: (e)=>e
            }
        ]
    }, vl = "SHARE_ACTIVE_INDICATION", fl = "SHARE_CHECK_CHROME_SHARING_EXTENSION", yl = "SHARE_START_DESKTOP_SHARE_FAILED", Sl = "SHARE_DIMENSION_CHANGE", bl = "SHARE_RECEIVED_DIMENSION_CHANGE", El = "SHARE_VIDEO_STREAMS_END", Il = "SHARE_PASSIVE_STOP_SHARE", Al = "SHARE_PASSIVE_BO_STOP", Cl = "SHARE_NEW_USER_ADD", _l = "SHARE_USER_REMOVE", Rl = "SHARE_USER_PAUSED", wl = "SHARE_USER_RESUMED", Tl = "SHARE_AUTO_CHANGE_SOURCE", Ol = "SHARE_REMOTE_CONTROL_APPROVE", Dl = "SHARE_GRAB_REMOTE_CONTROL_CHANGE", Pl = "SHARE_REMOTE_CONTROL_CLIPBOARD_CHANGE", Ml = "SHARE_REMOTE_CONTROL_SUCCESS", kl = "SHARE_REMOTE_CONTROL_FAILED", Ll = "SHARE_PRIVILEGE_CHANGE", Nl = "SHARE_READ_RECEIPT", Vl = "SHARE_STATISTIC_DATA", Ul = "SHARE_REMOTE_CONTROL_REQUEST", jl = "SHARE_REMOTE_CONTROL_APP_STATUS", xl = "SHARE_REMOTE_CONTROL_SESSION_STATUS", Bl = "SHARE_REMOTE_CONTROL_APP_SCHEME";
    let Fl = function(e) {
        return e.ShareActiveChange = "active-share-change", e.ShareDimensionChange = "share-content-dimension-change", e.SharePassiveStop = "passively-stop-share", e.SharePeerStateChange = "peer-share-state-change", e.ShareContentChange = "share-content-change", e.SharePrivilegeChange = "share-privilege-change", e.ShareReadReceipt = "share-can-see-screen", e.ShareStatisticDataChange = "share-statistic-data-change", e.RemoteControlApprovedChange = "remote-control-approved-change", e.RemoteControlInControlChange = "remote-control-in-control-change", e.RemoteControlClipboardChange = "remote-control-clipboard-change", e.RemoteControlRequestChange = "remote-control-request-change", e.RemoteControlAppStatusChange = "remote-control-app-status-change", e.RemoteControlControlledStatusChange = "remote-control-controlled-status-change", e;
    }({});
    const Hl = {
        [Fl.ShareActiveChange]: [
            {
                event: vl,
                payload: (e)=>{
                    const { isActive: t1, activeUserId: o, ...r } = e;
                    return {
                        state: t1 ? "Active" : "Inactive",
                        userId: o,
                        ...r
                    };
                }
            }
        ],
        [Fl.ShareDimensionChange]: [
            {
                event: Sl,
                payload: (e)=>({
                        type: "sended",
                        width: e.width,
                        height: e.height
                    })
            },
            {
                event: bl,
                payload: (e)=>({
                        type: "received",
                        width: e.width,
                        height: e.height
                    })
            }
        ],
        [Fl.SharePassiveStop]: [
            {
                event: El,
                payload: ()=>({
                        reason: Cd.StopScreenCapture
                    })
            },
            {
                event: Il,
                payload: ()=>({
                        reason: Cd.PrivilegeChange
                    })
            },
            {
                event: Al,
                payload: ()=>({
                        reason: Cd.ShareFromMainSession
                    })
            }
        ],
        [Fl.SharePeerStateChange]: [
            {
                event: Cl,
                payload: (e)=>({
                        userId: e.id,
                        action: "Start"
                    })
            },
            {
                event: _l,
                payload: (e)=>({
                        userId: e.id,
                        action: "Stop"
                    })
            },
            {
                event: Rl,
                payload: (e)=>({
                        userId: e.id,
                        action: "Pause"
                    })
            },
            {
                event: wl,
                payload: (e)=>({
                        userId: e.id,
                        action: "Resume"
                    })
            }
        ],
        [Fl.ShareContentChange]: [
            {
                event: Tl,
                payload: (e)=>e
            }
        ],
        [Fl.SharePrivilegeChange]: [
            {
                event: Ll,
                payload: (e)=>({
                        privilege: e
                    })
            }
        ],
        [Fl.ShareReadReceipt]: [
            {
                event: Nl,
                payload: ()=>{}
            }
        ],
        [Fl.ShareStatisticDataChange]: [
            {
                event: Vl,
                payload: (e)=>{
                    const { data: { rate: t1, ...o }, ...r } = null != e ? e : {
                        data: {}
                    };
                    return {
                        data: {
                            bitrate: t1,
                            ...o
                        },
                        ...r
                    };
                }
            }
        ],
        [Fl.RemoteControlApprovedChange]: [
            {
                event: Ol,
                payload: (e)=>({
                        state: e ? Ad.Approved : Ad.Rejected
                    })
            }
        ],
        [Fl.RemoteControlInControlChange]: [
            {
                event: Dl,
                payload: (e)=>({
                        isControlling: e
                    })
            }
        ],
        [Fl.RemoteControlClipboardChange]: [
            {
                event: Pl,
                payload: (e)=>e
            }
        ],
        [Fl.RemoteControlRequestChange]: [
            {
                event: Ul,
                payload: (e)=>e
            }
        ],
        [Fl.RemoteControlAppStatusChange]: [
            {
                event: jl,
                payload: (e)=>e
            }
        ],
        [Fl.RemoteControlControlledStatusChange]: [
            {
                event: xl,
                payload: (e)=>e
            }
        ]
    };
    let $l = function(e) {
        return e.Question = "question", e.UpdateQuestion = "updateQuestion", e.Answer = "answer", e.DeleteComment = "deleteComment", e.DeleteQuestion = "deleteQuestion", e.Dismiss = "dismiss", e.Reopen = "reopen", e.Upvote = "upvote", e.AnswerLive = "answerLive", e;
    }({}), Wl = function(e) {
        return e.QaSettingChange = "qa-setting-change", e.QaActionChange = "qa-action-change", e;
    }({});
    const Gl = {
        [Wl.QaSettingChange]: [
            {
                event: "QA_SETTING_OPTION_CHANGE",
                payload: (e)=>e
            }
        ],
        [Wl.QaActionChange]: [
            {
                event: "QA_NEW_ASK_QUESTION",
                payload: (e)=>({
                        action: $l.Question,
                        data: e
                    })
            },
            {
                event: "QA_UPDATE_ANONYMOUS_QUESTION",
                payload: (e)=>({
                        action: $l.UpdateQuestion,
                        data: e
                    })
            },
            {
                event: "QA_ANSWER_QUESTION",
                payload: (e)=>({
                        action: $l.Answer,
                        data: e
                    })
            },
            {
                event: "QA_ANSWER_REMOVE_COMMENT",
                payload: (e)=>({
                        action: $l.DeleteComment,
                        data: e
                    })
            },
            {
                event: "QA_ANSWER_REMOVE_QUESTION",
                payload: (e)=>({
                        action: $l.DeleteQuestion,
                        data: e
                    })
            },
            {
                event: "QA_ANSWER_DISMISS_QUESTION",
                payload: (e)=>({
                        action: $l.Dismiss,
                        data: e
                    })
            },
            {
                event: "QA_ANSWER_REOPEN_QUESTION",
                payload: (e)=>({
                        action: $l.Reopen,
                        data: e
                    })
            },
            {
                event: "QA_ANSWER_VOTE_QUESTION",
                payload: (e)=>({
                        action: $l.Upvote,
                        data: e
                    })
            },
            {
                event: "QA_ANSWER_QUESTION_LIVE",
                payload: (e)=>({
                        action: $l.AnswerLive,
                        data: e
                    })
            }
        ]
    }, Kl = "INVALID_OPERATION", zl = "INTERNAL_ERROR", ql = "OPERATION_TIMEOUT", Jl = "INSUFFICIENT_PRIVILEGES", Ql = "IMPROPER_MEETING_STATE", Zl = "INVALID_PARAMETERS", Yl = "AUDIO_ENCODE_SUCCESS", Xl = "AUDIO_DECODE_SUCCESS", ec = "VIDEO_ENCODE_SUCCESS", tc = "VIDEO_DECODE_SUCCESS", oc = "SHARING_ENCODE_SUCCESS", rc = "SHARING_DECODE_SUCCESS", ic = "AUDIO_ENCODE_FAIL", nc = "AUDIO_DECODE_FAIL", sc = "VIDEO_ENCODE_FAIL", ac = "VIDEO_DECODE_FAIL", dc = "SHARING_ENCODE_FAIL", uc = "SHARING_DECODE_FAIL", lc = "MEDIA_DEVICE_CHANGE", cc = "MEDIS_SDK_PATHCH_LOADED", pc = "AUDIO_BRIDGE_PEER_CONNECTION_RECEIVE_READY", hc = "AUDIO_BRIDGE_PEER_CONNECTION_SEND_READY", mc = "DEVICE_PERMISSION_CHANGE", gc = "MEDIA_HEALTH_CHECK_FAILED";
    let vc = function(e) {
        return e.DeviceChange = "device-change", e.MediaSDKChange = "media-sdk-change", e.DevicePermissionChange = "device-permission-change", e.MediaInternalError = "media-internal-error", e;
    }({});
    const fc = {
        [vc.DeviceChange]: [
            {
                event: lc,
                payload: ()=>({})
            }
        ],
        [vc.MediaSDKChange]: [
            {
                event: Yl,
                payload: ()=>({
                        type: "audio",
                        action: "encode",
                        result: "success"
                    })
            },
            {
                event: ic,
                payload: ()=>({
                        type: "audio",
                        action: "encode",
                        result: "fail"
                    })
            },
            {
                event: Xl,
                payload: ()=>({
                        type: "audio",
                        action: "decode",
                        result: "success"
                    })
            },
            {
                event: nc,
                payload: ()=>({
                        type: "audio",
                        action: "decode",
                        result: "fail"
                    })
            },
            {
                event: ec,
                payload: ()=>({
                        type: "video",
                        action: "encode",
                        result: "success"
                    })
            },
            {
                event: sc,
                payload: ()=>({
                        type: "video",
                        action: "encode",
                        result: "fail"
                    })
            },
            {
                event: tc,
                payload: ()=>({
                        type: "video",
                        action: "decode",
                        result: "success"
                    })
            },
            {
                event: ac,
                payload: ()=>({
                        type: "video",
                        action: "decode",
                        result: "fail"
                    })
            },
            {
                event: oc,
                payload: ()=>({
                        type: "share",
                        action: "encode",
                        result: "success"
                    })
            },
            {
                event: dc,
                payload: ()=>({
                        type: "share",
                        action: "encode",
                        result: "fail"
                    })
            },
            {
                event: rc,
                payload: ()=>({
                        type: "share",
                        action: "decode",
                        result: "success"
                    })
            },
            {
                event: uc,
                payload: ()=>({
                        type: "share",
                        action: "decode",
                        result: "fail"
                    })
            }
        ],
        [vc.DevicePermissionChange]: [
            {
                event: mc,
                payload: (e)=>e
            }
        ],
        [vc.MediaInternalError]: [
            {
                event: gc,
                payload: (e)=>e
            }
        ]
    }, yc = "BREAKOUT_ROOM_ADD_TOKEN", Sc = "BREAKOUT_ROOM_INVITE_TO_JOIN_NOTIFICATION", bc = "BREAKOUT_ROOM_ROOM_CLOSING_COUNTDOWN", Ec = "BREAKOUT_ROOM_ROOM_COUTDOWN", Ic = "BREAKOUT_ROOM_BROADCAST_MESSAGE", Ac = "BREAKOUT_ROOM_ASK_HELP_REQUEST", Cc = "BREAKOUT_ROOM_ASK_HELP_RESPONSE", _c = "BREAKOUT_ROOM_ATTRIBUTE_INDICATION", Rc = "BREAKOUT_ROOM_JOIN_BO_RESPONSE", wc = "BREAKOUT_ROOM_ROOM_COUNTDOWN_TIME_UP", Tc = "BREAKOUT_ROOM_CURRENT_USER_PARTICIPANT_ROLE", Oc = "BREAKOUT_ROOM_LOAD_PRE_ASSIGNED_ROOMS", Dc = "BREAKOUT_ROOM_MAIN_SESSION_USER_UPDATE", Pc = "BREAKOUT_ROOM_INVITE_TO_BACK_NOTIFICATION", Mc = "BREAKOUT_ROOM_IN_ROOM_USER_STATUS_UPDATE", kc = "BREAKOUT_ROOM_BROADCAST_VOICE";
    let Lc = function(e) {
        return e.InviteToJoin = "invite-to-join", e.RoomCountdown = "room-countdown", e.RoomTimeUp = "room-time-up", e.ClosingRoomCountdown = "closing-room-countdown", e.BroadcastMessage = "broadcast-message", e.AskForHelp = "ask-for-help", e.AskForHelpResponse = "ask-for-help-response", e.RoomStateChange = "room-state-change", e.MainSessionUserUpdate = "main-session-user-updated", e.InviteToBack = "invite-back-to-main-session", e.RoomUserUpdate = "room-user-update", e.BroadcastVoice = "broadcast-voice", e;
    }({});
    const Nc = {
        [Lc.InviteToJoin]: [
            {
                event: Sc,
                payload: (e)=>e
            }
        ],
        [Lc.RoomCountdown]: [
            {
                event: Ec,
                payload: (e)=>e
            }
        ],
        [Lc.RoomTimeUp]: [
            {
                event: wc,
                payload: (e)=>e
            }
        ],
        [Lc.ClosingRoomCountdown]: [
            {
                event: bc,
                payload: (e)=>e
            }
        ],
        [Lc.BroadcastMessage]: [
            {
                event: Ic,
                payload: (e)=>e
            }
        ],
        [Lc.AskForHelp]: [
            {
                event: Ac,
                payload: (e)=>e
            }
        ],
        [Lc.AskForHelpResponse]: [
            {
                event: Cc,
                payload: (e)=>e
            }
        ],
        [Lc.RoomStateChange]: [
            {
                event: _c,
                payload: (e)=>({
                        status: e.controlStatus
                    })
            }
        ],
        [Lc.MainSessionUserUpdate]: [
            {
                event: Dc,
                payload: ()=>({})
            }
        ],
        [Lc.InviteToBack]: [
            {
                event: Pc,
                payload: (e)=>e
            }
        ],
        [Lc.RoomUserUpdate]: [
            {
                event: Mc,
                payload: (e)=>e
            }
        ],
        [Lc.BroadcastVoice]: [
            {
                event: kc,
                payload: (e)=>e
            }
        ]
    };
    var Vc = function(e) {
        return e.StatusUpdate = "archiving-status-update", e.OptionsUpdate = "archiving-options-update", e;
    }(Vc || {});
    const Uc = {
        [Vc.StatusUpdate]: [
            {
                event: "ARCHIVING_STATUS_UPDATE",
                payload: (e)=>e
            }
        ],
        [Vc.OptionsUpdate]: [
            {
                event: "ARCHIVING_OPTIONS_UPDATE",
                payload: (e)=>e
            }
        ]
    };
    let jc = function(e) {
        return e.PollDataChange = "poll-data-change", e.PollSizeUpdate = "poll-size-update", e.PollStatusUpdate = "poll-status-update", e;
    }({});
    const xc = {
        [jc.PollDataChange]: [
            {
                event: "POLL_DATA_CHANGE",
                payload: (e)=>e
            }
        ],
        [jc.PollSizeUpdate]: [
            {
                event: "POLL_SIZE_UPDATE",
                payload: (e)=>e
            }
        ],
        [jc.PollStatusUpdate]: [
            {
                event: "POLL_STATUS_UPDATE",
                payload: (e)=>e
            }
        ]
    };
    let Bc = function(e) {
        return e.ReactionReceived = "reaction-received", e.ReactionRemoved = "reaction-removed", e;
    }({});
    const Fc = {
        [Bc.ReactionReceived]: [
            {
                event: "REACTION_RECEIVED",
                payload: (e)=>e
            }
        ],
        [Bc.ReactionRemoved]: [
            {
                event: "REACTION_REMOVED",
                payload: (e)=>e
            }
        ]
    }, Hc = "SMART_SUMMARY_STATUS_CHANGE", $c = "MEETING_QUERY_STATUS_CHANGE";
    let Wc = function(e) {
        return e.SummaryChange = "summary-status-change", e.MeetingQueryChang = "meeting-query-status-change", e;
    }({});
    const Gc = {
        [Wc.SummaryChange]: [
            {
                event: Hc,
                payload: (e)=>e
            }
        ],
        [Wc.MeetingQueryChang]: [
            {
                event: $c,
                payload: (e)=>e
            }
        ]
    }, Kc = "LIVE_STREAM_STATUS_CHANGE", zc = {
        "live-stream-status": [
            {
                event: Kc,
                payload: (e)=>e
            }
        ]
    }, qc = {
        ...Oa,
        ...La,
        ...Ha,
        ...Ka,
        ...nd,
        ...gl,
        ...ju,
        ...Gl,
        ...Hl,
        ...fc,
        ...Nc,
        ...Uc,
        "closed-caption-message": [
            {
                event: "CC_RECEIVE_MESSAGE",
                payload: (e)=>e
            }
        ],
        "closed-caption-lt-status": [
            {
                event: "LT_STATUS_CHANGE",
                payload: (e)=>e
            }
        ],
        "closed-caption-lt-message": [
            {
                event: "LT_RECEIVE_MESSAGE",
                payload: (e)=>e
            }
        ],
        "closed-caption-status": [
            {
                event: "CC_ASSIGN_CC_EDITOR_SUCCESS",
                payload: (e)=>e
            },
            {
                event: "CC_STATUS_CHANGE",
                payload: (e)=>e
            }
        ],
        ...xc,
        ...Fc,
        ...Gc,
        ...zc
    }, Jc = function(e) {
        return {
            all: e = e || new Map,
            on: function(t1, o) {
                var r = e.get(t1);
                r ? r.push(o) : e.set(t1, [
                    o
                ]);
            },
            off: function(t1, o) {
                var r = e.get(t1);
                r && (o ? r.splice(r.indexOf(o) >>> 0, 1) : e.set(t1, []));
            },
            emit: function(t1, o) {
                var r = e.get(t1);
                r && r.slice().map(function(e) {
                    e(o);
                }), (r = e.get("*")) && r.slice().map(function(e) {
                    e(t1, o);
                });
            }
        };
    }(), Qc = new Map, Zc = new Array, Yc = [
        Ia,
        ba,
        Ea
    ];
    let Xc, ep;
    const tp = function(e) {
        let t1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
        Jc.emit(e, t1);
    };
    function op(e) {
        return Yc.includes(e) ? qe(Jc, e) : (Xc && ep || (Xc = new j, ep = Xe(...Yc.map((e)=>qe(Jc, e))).subscribe(Xc)), qe(Jc, e).pipe(mt(Xc)));
    }
    const rp = (e)=>new Promise((t1, o)=>{
            e.fail && e.fail.length > 0 ? rt(op(e.success).pipe(nt(1)), Xe(...e.fail.map((e)=>op(e).pipe(nt(1), Fe((t1)=>we({
                        type: e,
                        payload: t1
                    })))))).subscribe({
                next: (e)=>t1(e),
                error (e) {
                    "object" == typeof e.payload ? o({
                        type: e.type,
                        ...e.payload
                    }) : void 0 === e.payload ? o({
                        type: e.type
                    }) : o(e);
                }
            }) : op(e.success).pipe(nt(1)).subscribe((e)=>t1(e));
        }), ip = function(e, t1) {
        let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e4;
        return new Promise((r, i)=>{
            let n = ne;
            "string" == typeof e ? n = op(e).pipe(nt(1)) : (n = op(e.event), e.operations && (n = e.operations.reduce((e, t1)=>e.pipe(t1), n))), rt(n, Ze(o).pipe(Fe(()=>we("timeout")))).subscribe({
                next (e) {
                    if (t1) {
                        const o = t1(e);
                        "boolean" == typeof o ? o ? r("") : i({
                            type: zl
                        }) : 0 === o.ret ? r(o.body) : i({
                            type: zl,
                            reason: o.body
                        });
                    } else r(e);
                },
                error () {
                    i({
                        type: ql
                    });
                }
            });
        });
    }, np = (e, t1)=>void 0 !== t1 ? op(e).pipe(nt(t1)) : op(e);
    function sp(e) {
        return rt(...Yc.map((e)=>np(e, 1)));
    }
    const ap = ()=>{
        var e;
        Zc.forEach((e)=>{
            e.unsubscribe();
        }), Zc.length = 0, Qc.clear(), Xc && (Xc.complete(), null === (e = ep) || void 0 === e || e.unsubscribe(), Xc = void 0);
    }, dp = "SET_ATTENDEES_LIST", up = "SET_ASSISTANT_LIST", lp = "RESET_PARTICIPANTS", cp = "SET_IS_ADMIT_ALL_SILENT_USERS", pp = "SET_CLEAR_RAISE_HAND", hp = "SET_CLEAR_ATTENDEE_FEEDBACK", mp = "ADD_FAILOVER_ATTENDEES", gp = "REMOVE_FAILOVER_ATTENDEES", vp = "UPDATE_ATTENDEE_DISPLAY_NAME", fp = "REMOVE_XMPP_ATTENDEE_USER", yp = "UPDATE_XMPP_ATTENDEE_LIST", Sp = "SET_ATTENDEE_EXTRA_KEY", { setAttendeesList: bp, setAssistantList: Ep, setIsAdmitAllSilentUsers: Ip, resetParticipants: Ap, addFailoverAttendees: Cp, removeFailoverAttendees: _p, setClearRaiseHand: Rp, setClearAttendeeFeedback: wp, updateAttendeeDisplayName: Tp, removeXmppAttendeeUser: Op, updateXmppAttendeeList: Dp, setAttendeeExtraKey: Pp } = go({
        [dp]: (e)=>e,
        [up]: (e)=>e,
        [yp]: (e)=>e,
        [lp]: ()=>({}),
        [cp]: (e)=>e,
        [gp]: (e)=>e,
        [mp]: (e)=>e,
        [pp]: ()=>({}),
        [hp]: ()=>({}),
        [vp]: (e)=>e,
        [fp]: (e)=>e,
        [Sp]: (e)=>e
    });
    var Mp = "NOT_FOUND", kp = function(e, t1) {
        return e === t1;
    };
    function Lp(e, t1) {
        var o, r, i = "object" == typeof t1 ? t1 : {
            equalityCheck: t1
        }, n = i.equalityCheck, s = void 0 === n ? kp : n, a = i.maxSize, d = void 0 === a ? 1 : a, u = i.resultEqualityCheck, l = function(e) {
            return function(t1, o) {
                if (null === t1 || null === o || t1.length !== o.length) return !1;
                for(var r = t1.length, i = 0; i < r; i++)if (!e(t1[i], o[i])) return !1;
                return !0;
            };
        }(s), c = 1 === d ? (o = l, {
            get: function(e) {
                return r && o(r.key, e) ? r.value : Mp;
            },
            put: function(e, t1) {
                r = {
                    key: e,
                    value: t1
                };
            },
            getEntries: function() {
                return r ? [
                    r
                ] : [];
            },
            clear: function() {
                r = void 0;
            }
        }) : function(e, t1) {
            var o = [];
            function r(e) {
                var r = o.findIndex(function(o) {
                    return t1(e, o.key);
                });
                if (r > -1) {
                    var i = o[r];
                    return r > 0 && (o.splice(r, 1), o.unshift(i)), i.value;
                }
                return Mp;
            }
            return {
                get: r,
                put: function(t1, i) {
                    r(t1) === Mp && (o.unshift({
                        key: t1,
                        value: i
                    }), o.length > e && o.pop());
                },
                getEntries: function() {
                    return o;
                },
                clear: function() {
                    o = [];
                }
            };
        }(d, l);
        function p() {
            var t1 = c.get(arguments);
            if (t1 === Mp) {
                if (t1 = e.apply(null, arguments), u) {
                    var o = c.getEntries().find(function(e) {
                        return u(e.value, t1);
                    });
                    o && (t1 = o.value);
                }
                c.put(arguments, t1);
            }
            return t1;
        }
        return p.clearCache = function() {
            return c.clear();
        }, p;
    }
    function Np(e) {
        for(var t1 = arguments.length, o = new Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
        return function() {
            for(var t1 = arguments.length, r = new Array(t1), i = 0; i < t1; i++)r[i] = arguments[i];
            var n, s = 0, a = {
                memoizeOptions: void 0
            }, d = r.pop();
            if ("object" == typeof d && (a = d, d = r.pop()), "function" != typeof d) throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof d + "]");
            var u = a.memoizeOptions, l = void 0 === u ? o : u, c = Array.isArray(l) ? l : [
                l
            ], p = function(e) {
                var t1 = Array.isArray(e[0]) ? e[0] : e;
                if (!t1.every(function(e) {
                    return "function" == typeof e;
                })) {
                    var o = t1.map(function(e) {
                        return "function" == typeof e ? "function " + (e.name || "unnamed") + "()" : typeof e;
                    }).join(", ");
                    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + o + "]");
                }
                return t1;
            }(r), h = e.apply(void 0, [
                function() {
                    return s++, d.apply(null, arguments);
                }
            ].concat(c)), m = e(function() {
                for(var e = [], t1 = p.length, o = 0; o < t1; o++)e.push(p[o].apply(null, arguments));
                return n = h.apply(null, e);
            });
            return Object.assign(m, {
                resultFunc: d,
                memoizedResultFunc: h,
                dependencies: p,
                lastResult: function() {
                    return n;
                },
                recomputations: function() {
                    return s;
                },
                resetRecomputations: function() {
                    return s = 0;
                }
            }), m;
        };
    }
    var Vp = Np(Lp);
    const Up = (e)=>{
        let { participants: { attendeesList: t1 } } = e;
        return t1;
    }, jp = (e)=>{
        let { meeting: { userId: t1 } } = e;
        return t1;
    }, xp = (e)=>{
        let { participants: { xmppAttendeeList: t1 } } = e;
        return t1;
    };
    let Bp = function(e) {
        return e[e.Attendee = 0] = "Attendee", e[e.Host = 1] = "Host", e[e.Owner = 4] = "Owner", e[e.ViewOnly = 8] = "ViewOnly", e[e.HostOwner = 5] = "HostOwner", e[e.ViewOnlyCanTalk = 24] = "ViewOnlyCanTalk", e;
    }({}), Fp = function(e) {
        return e[e.Host = 10] = "Host", e[e.Panelist = 20] = "Panelist", e[e.Attendee = 30] = "Attendee", e;
    }({}), Hp = function(e) {
        return e[e.Client = 9] = "Client", e[e.Phone = 5] = "Phone", e[e.H323 = 15] = "H323", e[e.Assitant = 51] = "Assitant", e;
    }({});
    const $p = (e)=>(e & Bp.Host) === Bp.Host, Wp = (e)=>(e & Hp.Phone) === Hp.Phone, Gp = (e)=>e === Bp.ViewOnlyCanTalk, Kp = (e)=>(e & Bp.ViewOnly) === Bp.ViewOnly;
    let zp = function(e) {
        return e[e.Automatically = 1] = "Automatically", e[e.Manually = 2] = "Manually", e[e.SelfSelect = 3] = "SelfSelect", e;
    }({}), qp = function(e) {
        return e[e.NotStarted = 1] = "NotStarted", e[e.InProgress = 2] = "InProgress", e[e.Closing = 3] = "Closing", e[e.Closed = 4] = "Closed", e;
    }({}), Jp = function(e) {
        return e[e.NoToken = 1] = "NoToken", e[e.GotToken = 2] = "GotToken", e[e.Started = 3] = "Started", e[e.Closing = 4] = "Closing", e[e.Closed = 5] = "Closed", e;
    }({}), Qp = function(e) {
        return e.Initial = "initial", e.Invited = "invited", e.Joining = "joining", e.InRoom = "in room", e.Leaving = "leaving", e.TimeUp = "time up", e.MainSession = "main session", e;
    }({}), Zp = function(e) {
        return e.Join = "joinRequest", e.Switch = "switchRequest", e.Leave = "leaveRequest", e.Broadcast = "messageText", e.HelpReq = "helpRequest", e.HelpRes = "helpResponse", e.CoHostWantJoinThisBo = "wantJoinThisBO", e.BOActivity = "BOActivity", e;
    }({});
    const Yp = "Subsession";
    let Xp = function(e) {
        return e[e.Received = 0] = "Received", e[e.Busy = 1] = "Busy", e[e.Ignore = 2] = "Ignore", e[e.AlreadyInRoom = 3] = "AlreadyInRoom", e;
    }({}), eh = function(e) {
        return e[e.AskToLeave = 0] = "AskToLeave", e[e.ClosingRoom = 1] = "ClosingRoom", e;
    }({}), th = function(e) {
        return e[e.Active = 0] = "Active", e[e.Ask = 1] = "Ask", e;
    }({}), oh = function(e) {
        return e[e.Connect = 1] = "Connect", e[e.Muted = 2] = "Muted", e[e.Voip = 4] = "Voip", e;
    }({}), rh = function(e) {
        return e[e.Connect = 8] = "Connect", e[e.On = 16] = "On", e;
    }({}), ih = function(e) {
        return e[e.Share = 32] = "Share", e[e.ShareAudio = 64] = "ShareAudio", e;
    }({});
    const nh = (e)=>{
        let { breakoutRoom: t1 } = e;
        return t1 && t1.controlStatus;
    }, sh = (e)=>{
        let { breakoutRoom: t1 } = e;
        return t1 && t1.currentRoom.status;
    }, ah = Vp([
        jp,
        Up
    ], (e, t1)=>t1.find((t1)=>t1.userId === e)), dh = Vp([
        ah
    ], (e)=>(null == e ? void 0 : e.isHost) || (null == e ? void 0 : e.bCoHost)), uh = Vp([
        ah
    ], (e)=>null == e ? void 0 : e.isHost), lh = Vp([
        xp
    ], (e)=>e.filter((e)=>e.userRole === Fp.Attendee)), ch = Vp([
        Up
    ], (e)=>e.filter((e)=>e.bHold && !e.bid)), ph = Vp([
        Up,
        nh,
        sh
    ], (e, t1, o)=>t1 !== qp.InProgress && t1 !== qp.Closing || o !== Qp.InRoom ? e.filter((e)=>!e.bHold && !e.bid) : e.filter((e)=>!e.bHold)), hh = Vp([
        (e)=>{
            let { participants: { assistantList: t1 } } = e;
            return t1;
        }
    ], (e)=>e), mh = Vp([
        ph
    ], (e)=>e.find((e)=>e.isHost)), gh = Vp([
        ph
    ], (e)=>e.filter((e)=>e.bCoHost)), vh = Vp([
        ah,
        ph
    ], (e, t1)=>t1.filter((t1)=>t1.userId !== (null == e ? void 0 : e.userId)));
    Vp([
        xp
    ], (e)=>e.reduce((e, t1)=>{
            const { jid: o } = t1;
            return Object.assign(e, {
                [o]: t1
            }), e;
        }, {})), Vp([
        xp,
        (e)=>{
            let { meeting: { jid: t1 } } = e;
            return t1;
        }
    ], (e, t1)=>{
        var o;
        return null === (o = e.find((e)=>e.jid === t1)) || void 0 === o ? void 0 : o.userId;
    });
    const fh = Vp([
        Up
    ], function() {
        return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).some((e)=>(null == e ? void 0 : e.bLocalRecord) === Ja.Start);
    }), yh = Vp([
        nh,
        (e)=>{
            let { meeting: t1 } = e;
            return t1 && t1.meetingOptions;
        },
        Up,
        uh
    ], (e, t1, o, r)=>{
        const i = o.filter((e)=>e.bCoHost), { moveToWRIfHostLeave: n } = t1, s = e === qp.InProgress;
        return r && !!n && i.length <= 0 && !s && o.length > 1;
    });
    Vp([
        Up,
        sh,
        (e)=>{
            let { breakoutRoom: t1 } = e;
            return t1 && t1.mainSessionAttendeeList;
        }
    ], (e, t1, o)=>(t1 === Qp.InRoom ? o : e).filter((e)=>{
            return !(e.bHold || e.isHost || e.audio === Wd.Phone || Wp(null == e ? void 0 : e.userType) || (t1 = null == e ? void 0 : e.caps, o = null == e ? void 0 : e.bMultiStreamVideoUser, ((e, t1)=>((e)=>!!(128 & e))(e) && void 0 !== t1)(t1, o) && o));
            "TURBOPACK unreachable";
            var t1, o;
        }));
    let Sh = function(e) {
        return e.Closed = "closed", e.Connecting = "connecting", e.Connected = "connected", e;
    }({});
    function bh(e) {
        return 1 << e - 1;
    }
    let Eh = function(e) {
        return e[e.SupportASL = bh(1)] = "SupportASL", e[e.SidecarPhase2 = bh(2)] = "SidecarPhase2", e[e.SupportBroadcastVoice = bh(4)] = "SupportBroadcastVoice", e[e.SendMeetingTokenSeparately = bh(5)] = "SendMeetingTokenSeparately", e[e.SupportPreview = bh(6)] = "SupportPreview", e[e.WebCameraIndication = bh(7)] = "WebCameraIndication", e[e.SupportFarEndCameraControl = bh(9)] = "SupportFarEndCameraControl", e[e.SupportVideoShare = bh(10)] = "SupportVideoShare", e[e.UnifyErrorType = bh(11)] = "UnifyErrorType", e[e.WhiteBoard = bh(12)] = "WhiteBoard", e[e.RequestRemoteControl = bh(14)] = "RequestRemoteControl", e[e.SmartSummary = bh(15)] = "SmartSummary", e[e.LocalRecording = bh(16)] = "LocalRecording", e[e.LocalRecordingGrantPermission = bh(17)] = "LocalRecordingGrantPermission", e[e.ShareMultiStream = bh(18)] = "ShareMultiStream", e[e.VideoLTR = bh(19)] = "VideoLTR", e[e.WebrtcAudioRtcpTime = bh(20)] = "WebrtcAudioRtcpTime", e[e.SupportSend1080PVideo = bh(29)] = "SupportSend1080PVideo", e[e.SupportSend1080PVideoShare = bh(30)] = "SupportSend1080PVideoShare", e;
    }({});
    const { setAsnIds: Ih, setIsCanUnmute: Ah, setDialoutSequence: Ch, setDialoutResultCode: _h, setIsAllowToTalk: Rh, setAudioSsrc: wh, setIsMutedUponEntry: Th, setIsUserGrantCaptureAudio: Oh, setIsMicrophoneForbidden: Dh, setWebrtcRestartCount: Ph, setMicrophoneList: Mh, setSpeakerList: kh, setActiveMicrophone: Lh, setActiveSpeaker: Nh, setCanPlayAudio: Vh, resetAudio: Uh, setIsComputerAudioLoading: jh, setIsAllowToTalkAttendeeConnected: xh, setIsMuteBeforeSharingAudio: Bh, addLocalShareAudioUser: Fh, updateLocalShareAudioUser: Hh, setIsJoinComputerAudioBeforeSharingAudio: $h, setIsShareAudioEnabled: Wh, setIsShareAudioMuted: Gh, setIsSharingAudio: Kh, setAudioDataEncoding: zh, setAudioDataDecoding: qh, addLocallyMutedAudio: Jh, removeLocallyMutedAudio: Qh, updateUserAudioVolumeLocally: Zh, removeLocalUserAudioVolume: Yh, setCustomizedAudioOption: Xh, setIsBackgroundNoiseSuppression: em, setIsHidEnabled: tm, setAudioMediaPlaybackFile: om, setIsStopAllIncomingAudio: rm, setIsVerifiedAudioPermissionOnIosMobile: im, setIsAudioBridgeSignalReconnecting: nm, setAudioMutedSource: sm, setAudioUnmutedSource: am, setAudioOriginalSound: dm, setLeaveAudioSource: um, setSecondaryAudioMicrophoneId: lm, setCrcCallOutSequence: cm, setCrcCallOutReturnCode: pm } = go("SET_ASN_IDS", "SET_IS_CAN_UNMUTE", "SET_DIALOUT_SEQUENCE", "SET_DIALOUT_RESULT_CODE", "SET_IS_ALLOW_TO_TALK", "SET_AUDIO_SSRC", "SET_IS_MUTED_UPON_ENTRY", "SET_IS_USER_GRANT_CAPTURE_AUDIO", "SET_IS_MICROPHONE_FORBIDDEN", "SET_WEBRTC_RESTART_COUNT", "SET_MICROPHONE_LIST", "SET_SPEAKER_LIST", "SET_ACTIVE_MICROPHONE", "SET_ACTIVE_SPEAKER", "SET_CAN_PLAY_AUDIO", "RESET_AUDIO", "SET_IS_COMPUTER_AUDIO_LOADING", "SET_IS_ALLOW_TO_TALK_ATTENDEE_CONNECTED", "SET_IS_MUTE_BEFORE_SHARING_AUDIO", "SET_IS_SHARING_AUDIO", "ADD_LOCAL_SHARE_AUDIO_USER", "UPDATE_LOCAL_SHARE_AUDIO_USER", "SET_IS_JOIN_COMPUTER_AUDIO_BEFORE_SHARING_AUDIO", "SET_IS_SHARE_AUDIO_ENABLED", "SET_IS_SHARE_AUDIO_MUTED", "SET_AUDIO_DATA_ENCODING", "SET_AUDIO_DATA_DECODING", "ADD_LOCALLY_MUTED_AUDIO", "REMOVE_LOCALLY_MUTED_AUDIO", "UPDATE_USER_AUDIO_VOLUME_LOCALLY", "REMOVE_LOCAL_USER_AUDIO_VOLUME", "SET_CUSTOMIZED_AUDIO_OPTION", "SET_IS_BACKGROUND_NOISE_SUPPRESSION", "SET_IS_HID_ENABLED", "SET_AUDIO_MEDIA_PLAYBACK_FILE", "SET_IS_STOP_ALL_INCOMING_AUDIO", "SET_IS_VERIFIED_AUDIO_PERMISSION_ON_IOS_MOBILE", "SET_IS_AUDIO_BRIDGE_SIGNAL_RECONNECTING", "SET_AUDIO_MUTED_SOURCE", "SET_AUDIO_UNMUTED_SOURCE", "SET_AUDIO_ORIGINAL_SOUND", "SET_LEAVE_AUDIO_SOURCE", "SET_SECONDARY_AUDIO_MICROPHONE_ID", "SET_CRC_CALL_OUT_SEQUENCE", "SET_CRC_CALL_OUT_RETURN_CODE"), { setSharePrivilege: hm, setShareActiveNode: mm, setIsReceiveSharing: gm, setIsChromeExtensionInstalled: vm, setIsScreenShareForbidden: fm, setShareDimension: ym, setShareStatus: Sm, setShareSsrc: bm, setShareQuality: Em, setReceivedShareDimension: Im, setIsGrabRemoteControl: Am, setIsSdkGrabControl: Cm, setIsReceiveSharingFromMainSession: _m, setIsSharingToBreakoutRoom: Rm, setIsSharingWithSecondCamera: wm, setShringSecondCameraId: Tm, setIsRequireReadReceipt: Om, setIsOptimizedForSharedVideo: Dm, setShareDataEncoding: Pm, setShareDataDecoding: Mm, addShareCapturedEnsuredCanvas: km, addShareRenderedEnsuredCanvas: Lm, setRemoteControlCurrentSsrc: Nm, setRemoteControllingSsrc: Vm, setApprovedRemoteControlSsrc: Um, setRemoteControlAppDownloadUrl: jm, setRemoteControlAppInstallStatus: xm, remoteControlAppStatusFallbackCheck: Bm, remoteControlAppLaunchedCheck: Fm, setIsEnableAutoDeleteRcApp: Hm, setRemoteControlAppLaunchSheme: $m, addSharingUserIdSsrcMapping: Wm, addRemoteControlledUser: Gm, removeRemoteControlledUser: Km, setRemoteControlSetting: zm, setRemoteControlViewportDomSelector: qm, setIsFullHdVideoShareEnabled: Jm, resetShare: Qm } = go("SET_SHARE_PRIVILEGE", "SET_SHARE_ACTIVE_NODE", "SET_IS_RECEIVE_SHARING", "SET_IS_CHROME_EXTENSION_INSTALLED", "SET_IS_SCREEN_SHARE_FORBIDDEN", "SET_SHARE_DIMENSION", "SET_SHARE_STATUS", "SET_SHARE_SSRC", "SET_SHARE_QUALITY", "SET_RECEIVED_SHARE_DIMENSION", "SET_IS_GRAB_REMOTE_CONTROL", "SET_IS_SDK_GRAB_CONTROL", "SET_IS_RECEIVE_SHARING_FROM_MAIN_SESSION", "SET_IS_SHARING_TO_BREAKOUT_ROOM", "SET_IS_SHARING_WITH_SECOND_CAMERA", "SET_SHRING_SECOND_CAMERA_ID", "SET_IS_REQUIRE_READ_RECEIPT", "SET_IS_OPTIMIZED_FOR_SHARED_VIDEO", "SET_SHARE_DATA_ENCODING", "SET_SHARE_DATA_DECODING", "ADD_SHARE_CAPTURED_ENSURED_CANVAS", "ADD_SHARE_RENDERED_ENSURED_CANVAS", "SET_REMOTE_CONTROL_CURRENT_SSRC", "SET_REMOTE_CONTROLLING_SSRC", "SET_APPROVED_REMOTE_CONTROL_SSRC", "SET_REMOTE_CONTROL_APP_DOWNLOAD_URL", "SET_REMOTE_CONTROL_APP_INSTALL_STATUS", "REMOTE_CONTROL_APP_STATUS_FALLBACK_CHECK", "REMOTE_CONTROL_APP_LAUNCHED_CHECK", "SET_IS_ENABLE_AUTO_DELETE_RC_APP", "SET_REMOTE_CONTROL_APP_LAUNCH_SHEME", "ADD_SHARING_USER_ID_SSRC_MAPPING", "ADD_REMOTE_CONTROLLED_USER", "REMOVE_REMOTE_CONTROLLED_USER", "SET_REMOTE_CONTROL_SETTING", "SET_REMOTE_CONTROL_VIEWPORT_DOM_SELECTOR", "SET_IS_FULL_HD_VIDEO_SHARE_ENABLED", "RESET_SHARE"), { setVideoSsrc: Zm, setActiveVideoId: Ym, setCameraList: Xm, setActiveCamera: eg, setIsCurrentUserStartedVideo: tg, setSpotlightVideo: og, setIsCaptureForbidden: rg, setVideoMaxQuality: ig, setIsVideoMuted: ng, setIsCaptureCameraLoading: sg, setIsCameraTaken: ag, resetVideo: dg, setReceivedVideoDimension: ug, addSubscribedVideoId: lg, removeSubscribedVideoId: cg, setIsFollowHostVideoLayout: pg, setHostDragLayout: hg, addRenderedVideoId: mg, removeRenderedVideoId: gg, setIsSupportHdVideo: vg, setMaximumNumbeOfHdSubscriptions: fg, setIsCanUnmuteVideo: yg, setIsVbPreloadReady: Sg, setIsVbConfiged: bg, setVbImageSrc: Eg, setVideoDataEncoding: Ig, setVideoDataDecoding: Ag, setHardwareAccelerationState: Cg, setVideoCaptureCustomizedOption: _g, setNetworkQuality: Rg, setVideoCameraPtzCapabilities: wg, setIsCurrentUserRequestCameraControlled: Tg, setIsCurrentUserCameraInControl: Og, addVideoFarEndCameraControlUser: Dg, removeVideoFarEndCameraControlUser: Pg, setVideoPtzCameraMoving: Mg, setVideoPtzCameraValue: kg, setIsControllingFarEndCamera: Lg, setNetworkQualityBroadcastTime: Ng, setIsMaskConfiged: Vg, setVideoBackgroundMode: Ug, setVideoMask: jg, setVideoCapturedDimension: xg, addVideoRenderedEnsuredCanvas: Bg, setVideoMediaPlaybackFile: Fg, setPrefetchedVideoUser: Hg, setVideoQosSubscriptionStatus: $g, setIsSupportFullHdVideo: Wg, addVideoPlayerAttachment: Gg, removeVideoPlayerAttachment: Kg, setIsWebGl2RendererType: zg, setIsWebGpuRendererType: qg, setVideoRendererType: Jg, setIsVideoMirrored: Qg, addSelfPreviewVideoTag: Zg, removeSelfPreviewVideoTag: Yg, setVideoLeadershipUserId: Xg } = go("SET_VIDEO_SSRC", "SET_ACTIVE_VIDEO_ID", "SET_CAMERA_LIST", "SET_ACTIVE_CAMERA", "SET_IS_CURRENT_USER_STARTED_VIDEO", "SET_SPOTLIGHT_VIDEO", "SET_IS_CAPTURE_FORBIDDEN", "SET_VIDEO_MAX_QUALITY", "SET_IS_VIDEO_MUTED", "SET_IS_CAPTURE_CAMERA_LOADING", "SET_IS_CAMERA_TAKEN", "RESET_VIDEO", "SET_RECEIVED_VIDEO_DIMENSION", "ADD_SUBSCRIBED_VIDEO_ID", "REMOVE_SUBSCRIBED_VIDEO_ID", "SET_IS_FOLLOW_HOST_VIDEO_LAYOUT", "SET_HOST_DRAG_LAYOUT", "ADD_RENDERED_VIDEO_ID", "REMOVE_RENDERED_VIDEO_ID", "SET_IS_SUPPORT_HD_VIDEO", "SET_MAXIMUM_NUMBE_OF_HD_SUBSCRIPTIONS", "SET_IS_CAN_UNMUTE_VIDEO", "SET_IS_VB_PRELOAD_READY", "SET_IS_VB_CONFIGED", "SET_VB_IMAGE_SRC", "SET_VIDEO_DATA_ENCODING", "SET_VIDEO_DATA_DECODING", "SET_HARDWARE_ACCELERATION_STATE", "SET_VIDEO_CAPTURE_CUSTOMIZED_OPTION", "SET_NETWORK_QUALITY", "SET_VIDEO_CAMERA_PTZ_CAPABILITIES", "SET_IS_CURRENT_USER_REQUEST_CAMERA_CONTROLLED", "SET_IS_CURRENT_USER_CAMERA_IN_CONTROL", "ADD_VIDEO_FAR_END_CAMERA_CONTROL_USER", "REMOVE_VIDEO_FAR_END_CAMERA_CONTROL_USER", "SET_VIDEO_PTZ_CAMERA_MOVING", "SET_VIDEO_PTZ_CAMERA_VALUE", "SET_IS_CONTROLLING_FAR_END_CAMERA", "SET_NETWORK_QUALITY_BROADCAST_TIME", "SET_IS_MASK_CONFIGED", "SET_VIDEO_BACKGROUND_MODE", "SET_VIDEO_MASK", "SET_VIDEO_CAPTURED_DIMENSION", "ADD_VIDEO_RENDERED_ENSURED_CANVAS", "SET_VIDEO_MEDIA_PLAYBACK_FILE", "SET_PREFETCHED_VIDEO_USER", "SET_VIDEO_QOS_SUBSCRIPTION_STATUS", "SET_IS_SUPPORT_FULL_HD_VIDEO", "ADD_VIDEO_PLAYER_ATTACHMENT", "REMOVE_VIDEO_PLAYER_ATTACHMENT", "SET_IS_WEB_GL2_RENDERER_TYPE", "SET_IS_WEB_GPU_RENDERER_TYPE", "SET_VIDEO_RENDERER_TYPE", "SET_IS_VIDEO_MIRRORED", "ADD_SELF_PREVIEW_VIDEO_TAG", "REMOVE_SELF_PREVIEW_VIDEO_TAG", "SET_VIDEO_LEADERSHIP_USER_ID"), { setQaSetting: ev, addQaQuestion: tv, addQaAnswer: ov, removeQaComment: rv, removeQaQuestion: iv, dismissQaQuestion: nv, reopenQaQuestion: sv, voteQaQuestion: av, answerQaQuestionLive: dv, updateAttendeeAnonymousQuestion: uv, setQaEnabled: lv, resetQa: cv } = go("SET_QA_SETTING", "ADD_QA_QUESTION", "ADD_QA_ANSWER", "REMOVE_QA_COMMENT", "REMOVE_QA_QUESTION", "DISMISS_QA_QUESTION", "REOPEN_QA_QUESTION", "VOTE_QA_QUESTION", "ANSWER_QA_QUESTION_LIVE", "UPDATE_ATTENDEE_ANONYMOUS_QUESTION", "SET_QA_ENABLED", "RESET_QA"), { setChatPrivilege: pv, setPanelistChatPrivilege: hv, addChatMessageHistory: mv, resetChat: gv, setIsAllowAttendeeChat: vv, setLatestChatMessageId: fv, removeChatMessage: yv, setFileChatSetting: Sv, addChatFileRecord: bv, updateChatFileRecord: Ev, cancelSendFileChat: Iv, addFailedChatFileTransfer: Av, setChatFileMessageId: Cv, cancelDownloadFileChat: _v } = go("SET_CHAT_PRIVILEGE", "SET_PANELIST_CHAT_PRIVILEGE", "ADD_CHAT_MESSAGE_HISTORY", "RESET_CHAT", "SET_IS_ALLOW_ATTENDEE_CHAT", "SET_LATEST_CHAT_MESSAGE_ID", "REMOVE_CHAT_MESSAGE", "SET_FILE_CHAT_SETTING", "ADD_CHAT_FILE_RECORD", "UPDATE_CHAT_FILE_RECORD", "CANCEL_SEND_FILE_CHAT", "ADD_FAILED_CHAT_FILE_TRANSFER", "SET_CHAT_FILE_MESSAGE_ID", "CANCEL_DOWNLOAD_FILE_CHAT"), { setCcEditorInfo: Rv, setTempSendCcText: wv, setCcLtMessage: Tv, setTempReceiveLtText: Ov, setTempReceiveCcText: Dv, setGatewayInfoList: Pv, setLtEnable: Mv, setIsListenClosedCaption: kv, setCcEnable: Lv, allowParticipantAskLt: Nv, receiveAskStartLt: Vv, setMeetingEnabledLtFeature: Uv, updateLtStatus: jv, deleteMessage: xv, updateMessage: Bv, resetClosedCaption: Fv } = go("SET_CC_EDITOR_INFO", "SET_CC_LT_MESSAGE", "SET_TEMP_SEND_CC_TEXT", "SET_TEMP_RECEIVE_LT_TEXT", "SET_TEMP_RECEIVE_CC_TEXT", "SET_GATEWAY_INFO_LIST", "SET_LT_ENABLE", "SET_IS_LISTEN_CLOSED_CAPTION", "SET_CC_ENABLE", "ALLOW_PARTICIPANT_ASK_LT", "RECEIVE_ASK_START_LT", "SET_MEETING_ENABLED_LT_FEATURE", "UPDATE_LT_STATUS", "DELETE_MESSAGE", "UPDATE_MESSAGE", "RESET_CLOSED_CAPTION"), { addBreakoutRooms: Hv, setBreakoutRoomAllocationPattern: $v, setBreakoutRoomSequenceId: Wv, setMeetingElapsedTime: Gv, setStartRoomElapsedTime: Kv, setBreakoutRoomOptions: zv, setBreakoutRoomControlStatus: qv, setBreakoutRooms: Jv, setCurrentBreakoutRoom: Qv, setBreakoutRoomAttendeeStatus: Zv, setBreakoutRoomConfId: Yv, setBreakoutRoomToken: Xv, resetBreakoutRoom: ef, setBreakoutRoomClosingRoomTime: tf, setBreakoutRoomBroadcastMessage: of, setBreakoutRoomHostReplyType: rf, setBreakoutRoomHostReplyRequestId: nf, setMainSessionAttendeeList: sf, setIsHugeBreakoutRoom: af, setBreakoutRoomPreAssignedRoomList: df, setBreakoutRoomUserRoleUpdated: uf, setBreakoutRoomMeetingOptions: lf, setBreakoutRoomUserActivityStatus: cf, setBreakoutRoomIsBroadcastVoice: pf } = go("ADD_BREAKOUT_ROOMS", "SET_BREAKOUT_ROOM_ALLOCATION_PATTERN", "SET_BREAKOUT_ROOM_SEQUENCE_ID", "SET_MEETING_ELAPSED_TIME", "SET_START_ROOM_ELAPSED_TIME", "SET_BREAKOUT_ROOM_OPTIONS", "SET_BREAKOUT_ROOM_CONTROL_STATUS", "SET_BREAKOUT_ROOMS", "SET_CURRENT_BREAKOUT_ROOM", "SET_BREAKOUT_ROOM_ATTENDEE_STATUS", "SET_BREAKOUT_ROOM_CONF_ID", "SET_BREAKOUT_ROOM_TOKEN", "RESET_BREAKOUT_ROOM", "SET_BREAKOUT_ROOM_CLOSING_ROOM_TIME", "SET_BREAKOUT_ROOM_BROADCAST_MESSAGE", "SET_BREAKOUT_ROOM_HOST_REPLY_TYPE", "SET_BREAKOUT_ROOM_HOST_REPLY_REQUEST_ID", "SET_MAIN_SESSION_ATTENDEE_LIST", "SET_IS_HUGE_BREAKOUT_ROOM", "SET_BREAKOUT_ROOM_PRE_ASSIGNED_ROOM_LIST", "SET_BREAKOUT_ROOM_USER_ROLE_UPDATED", "SET_BREAKOUT_ROOM_MEETING_OPTIONS", "SET_BREAKOUT_ROOM_USER_ACTIVITY_STATUS", "SET_BREAKOUT_ROOM_IS_BROADCAST_VOICE"), { setCloudRecordingStatus: hf, setCloudRecordingEnable: mf, setCloudIsoRecordingEnable: gf, setAllowStopAutoRecording: vf, setAutomaticCloudRecordingEnable: ff, setIsZoomIQ: yf, setZoomIQChanging: Sf, setLocalRecordStatus: bf, setSupportLocalRecording: Ef, setLocalGrantPermissionOption: If, setLocalPermissionUserList: Af, resetRecording: Cf } = go("SET_CLOUD_RECORDING_STATUS", "SET_CLOUD_RECORDING_ENABLE", "SET_CLOUD_ISO_RECORDING_ENABLE", "SET_ALLOW_STOP_AUTO_RECORDING", "SET_AUTOMATIC_CLOUD_RECORDING_ENABLE", "SET_IS_ZOOM_I_Q", "SET_ZOOM_I_Q_CHANGING", "SET_LOCAL_RECORD_STATUS", "SET_SUPPORT_LOCAL_RECORDING", "SET_LOCAL_GRANT_PERMISSION_OPTION", "SET_LOCAL_PERMISSION_USER_LIST", "RESET_RECORDING"), { updateCmdJid: _f, removeCmdJid: Rf, setCmdChannelConnectionStatus: wf, resetCmdChannel: Tf } = go("UPDATE_CMD_JID", "REMOVE_CMD_JID", "SET_CMD_CHANNEL_CONNECTION_STATUS", "RESET_CMD_CHANNEL"), Of = "SET_ARCHIVING_STATUS", Df = "SET_ARCHIVING_SESSION_READY", Pf = "SET_ARCHIVING_OPTIONS", Mf = "RESET_ARCHIVING", { setArchivingStatus: kf, setArchivingSessionReady: Lf, setArchivingOptions: Nf, resetArchiving: Vf } = go({
        [Of]: (e)=>e,
        [Df]: (e)=>e,
        [Pf]: (e)=>e,
        [Mf]: ()=>{}
    }), { setIsLiveTranscriptionEnabled: Uf, setLiveTranscriptionMeetingOptions: jf, setIsLiveTranscriptionManualCaptionerEnabled: xf, setLiveTranscriptionGatewayId: Bf, setLiveTranscriptionSupportedLanguage: Ff, setIsLiveTranscriptionSubscribed: Hf, setCurrentTranscriptionLang: $f, setCurrentTranslationLang: Wf, addLiveTranscriptionMessage: Gf, updateLiveTranscriptionMessage: Kf, reduceLiveTranscriptionMessages: zf, setLiveTranscriptionEngineType: qf, removeLiveTranscriptionFailoverState: Jf, setLiveTranscriptionLastCaptionMessage: Qf, resetLiveTranscription: Zf, setIsHostDisableCaptions: Yf } = go("SET_IS_LIVE_TRANSCRIPTION_ENABLED", "SET_LIVE_TRANSCRIPTION_MEETING_OPTIONS", "SET_IS_LIVE_TRANSCRIPTION_MANUAL_CAPTIONER_ENABLED", "SET_LIVE_TRANSCRIPTION_GATEWAY_ID", "SET_LIVE_TRANSCRIPTION_SUPPORTED_LANGUAGE", "SET_IS_LIVE_TRANSCRIPTION_SUBSCRIBED", "SET_CURRENT_TRANSCRIPTION_LANG", "SET_CURRENT_TRANSLATION_LANG", "ADD_LIVE_TRANSCRIPTION_MESSAGE", "UPDATE_LIVE_TRANSCRIPTION_MESSAGE", "REDUCE_LIVE_TRANSCRIPTION_MESSAGES", "SET_LIVE_TRANSCRIPTION_ENGINE_TYPE", "REMOVE_LIVE_TRANSCRIPTION_FAILOVER_STATE", "SET_LIVE_TRANSCRIPTION_LAST_CAPTION_MESSAGE", "RESET_LIVE_TRANSCRIPTION", " SET_IS_HOST_DISABLE_CAPTIONS"), { setPollData: Xf, setPollingId: ey, setPollingWebLinks: ty, setPollingDocMaxSize: oy, setPollingDocSize: ry, setPollingDocLibraryMaxSize: iy, setPollingDocLibrarySize: ny, setIsRwgEnablePolling: sy, setHasPollingInMeeting: ay, resetPoll: dy } = go("SET_POLL_DATA", "SET_POLLING_ID", "SET_POLLING_WEB_LINKS", "SET_POLLING_DOC_MAX_SIZE", "SET_POLLING_DOC_SIZE", "SET_POLLING_DOC_LIBRARY_MAX_SIZE", "SET_POLLING_DOC_LIBRARY_SIZE", "SET_IS_RWG_ENABLE_POLLING", "SET_HAS_POLLING_IN_MEETING", "RESET_POLL"), { setLoggerInitOptions: uy, setIsLaplaceInitialized: ly, resetLogger: cy } = go("SET_LOGGER_INIT_OPTIONS", "SET_IS_LAPLACE_INITIALIZED", "RESET_LOGGER"), { setIsLiveStreamEnable: py, setLiveStreamStatus: hy, resetLiveStream: my } = go("SET_IS_LIVE_STREAM_ENABLE", "SET_LIVE_STREAM_STATUS", "RESET_LIVE_STREAM");
    var gy, vy, fy = {
        exports: {}
    }, yy = {
        exports: {}
    }, Sy = xt(Object.freeze({
        __proto__: null,
        default: {},
        loadAsync: function() {}
    }));
    var by = (vy || (vy = 1, function(e, t1) {
        var o = function(e, t1) {
            return o = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t1) {
                e.__proto__ = t1;
            } || function(e, t1) {
                for(var o in t1)t1.hasOwnProperty(o) && (e[o] = t1[o]);
            }, o(e, t1);
        };
        function r(e, t1) {
            function r() {
                this.constructor = e;
            }
            o(e, t1), e.prototype = null === t1 ? Object.create(t1) : (r.prototype = t1.prototype, new r);
        }
        var i, n = function() {
            return n = Object.assign || function(e) {
                for(var t1, o = 1, r = arguments.length; o < r; o++)for(var i in t1 = arguments[o])Object.prototype.hasOwnProperty.call(t1, i) && (e[i] = t1[i]);
                return e;
            }, n.apply(this, arguments);
        };
        function s() {}
        function a() {
            a.init.call(this);
        }
        function d(e) {
            return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners;
        }
        function u(e, t1, o, r) {
            var i, n, a;
            if ("function" != typeof o) throw new TypeError('"listener" argument must be a function');
            if ((n = e._events) ? (n.newListener && (e.emit("newListener", t1, o.listener ? o.listener : o), n = e._events), a = n[t1]) : (n = e._events = new s, e._eventsCount = 0), a) {
                if ("function" == typeof a ? a = n[t1] = r ? [
                    o,
                    a
                ] : [
                    a,
                    o
                ] : r ? a.unshift(o) : a.push(o), !a.warned && (i = d(e)) && i > 0 && a.length > i) {
                    a.warned = !0;
                    var u = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + t1 + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t1, u.count = a.length, function(e) {
                        "function" == typeof console.warn ? console.warn(e) : console.log(e);
                    }(u);
                }
            } else a = n[t1] = o, ++e._eventsCount;
            return e;
        }
        function l(e, t1, o) {
            var r = !1;
            function i() {
                e.removeListener(t1, i), r || (r = !0, o.apply(e, arguments));
            }
            return i.listener = o, i;
        }
        function c(e) {
            var t1 = this._events;
            if (t1) {
                var o = t1[e];
                if ("function" == typeof o) return 1;
                if (o) return o.length;
            }
            return 0;
        }
        function p(e, t1) {
            for(var o = new Array(t1); t1--;)o[t1] = e[t1];
            return o;
        }
        s.prototype = Object.create(null), a.EventEmitter = a, a.usingDomains = !1, a.prototype.domain = void 0, a.prototype._events = void 0, a.prototype._maxListeners = void 0, a.defaultMaxListeners = 10, a.init = function() {
            this.domain = null, a.usingDomains && i.active && i.Domain, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new s, this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, a.prototype.setMaxListeners = function(e) {
            if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number');
            return this._maxListeners = e, this;
        }, a.prototype.getMaxListeners = function() {
            return d(this);
        }, a.prototype.emit = function(e) {
            var t1, o, r, i, n, s, a, d = "error" === e;
            if (s = this._events) d = d && null == s.error;
            else if (!d) return !1;
            if (a = this.domain, d) {
                if (t1 = arguments[1], !a) {
                    if (t1 instanceof Error) throw t1;
                    var u = new Error('Uncaught, unspecified "error" event. (' + t1 + ")");
                    throw u.context = t1, u;
                }
                return t1 || (t1 = new Error('Uncaught, unspecified "error" event')), t1.domainEmitter = this, t1.domain = a, t1.domainThrown = !1, a.emit("error", t1), !1;
            }
            if (!(o = s[e])) return !1;
            var l = "function" == typeof o;
            switch(r = arguments.length){
                case 1:
                    !function(e, t1, o) {
                        if (t1) e.call(o);
                        else for(var r = e.length, i = p(e, r), n = 0; n < r; ++n)i[n].call(o);
                    }(o, l, this);
                    break;
                case 2:
                    !function(e, t1, o, r) {
                        if (t1) e.call(o, r);
                        else for(var i = e.length, n = p(e, i), s = 0; s < i; ++s)n[s].call(o, r);
                    }(o, l, this, arguments[1]);
                    break;
                case 3:
                    !function(e, t1, o, r, i) {
                        if (t1) e.call(o, r, i);
                        else for(var n = e.length, s = p(e, n), a = 0; a < n; ++a)s[a].call(o, r, i);
                    }(o, l, this, arguments[1], arguments[2]);
                    break;
                case 4:
                    !function(e, t1, o, r, i, n) {
                        if (t1) e.call(o, r, i, n);
                        else for(var s = e.length, a = p(e, s), d = 0; d < s; ++d)a[d].call(o, r, i, n);
                    }(o, l, this, arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    for(i = new Array(r - 1), n = 1; n < r; n++)i[n - 1] = arguments[n];
                    !function(e, t1, o, r) {
                        if (t1) e.apply(o, r);
                        else for(var i = e.length, n = p(e, i), s = 0; s < i; ++s)n[s].apply(o, r);
                    }(o, l, this, i);
            }
            return !0;
        }, a.prototype.addListener = function(e, t1) {
            return u(this, e, t1, !1);
        }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(e, t1) {
            return u(this, e, t1, !0);
        }, a.prototype.once = function(e, t1) {
            if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
            return this.on(e, l(this, e, t1)), this;
        }, a.prototype.prependOnceListener = function(e, t1) {
            if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
            return this.prependListener(e, l(this, e, t1)), this;
        }, a.prototype.removeListener = function(e, t1) {
            var o, r, i, n, a;
            if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
            if (!(r = this._events)) return this;
            if (!(o = r[e])) return this;
            if (o === t1 || o.listener && o.listener === t1) 0 == --this._eventsCount ? this._events = new s : (delete r[e], r.removeListener && this.emit("removeListener", e, o.listener || t1));
            else if ("function" != typeof o) {
                for(i = -1, n = o.length; n-- > 0;)if (o[n] === t1 || o[n].listener && o[n].listener === t1) {
                    a = o[n].listener, i = n;
                    break;
                }
                if (i < 0) return this;
                if (1 === o.length) {
                    if (o[0] = void 0, 0 == --this._eventsCount) return this._events = new s, this;
                    delete r[e];
                } else !function(e, t1) {
                    for(var o = t1, r = o + 1, i = e.length; r < i; o += 1, r += 1)e[o] = e[r];
                    e.pop();
                }(o, i);
                r.removeListener && this.emit("removeListener", e, a || t1);
            }
            return this;
        }, a.prototype.removeAllListeners = function(e) {
            var t1, o;
            if (!(o = this._events)) return this;
            if (!o.removeListener) return 0 === arguments.length ? (this._events = new s, this._eventsCount = 0) : o[e] && (0 == --this._eventsCount ? this._events = new s : delete o[e]), this;
            if (0 === arguments.length) {
                for(var r, i = Object.keys(o), n = 0; n < i.length; ++n)"removeListener" !== (r = i[n]) && this.removeAllListeners(r);
                return this.removeAllListeners("removeListener"), this._events = new s, this._eventsCount = 0, this;
            }
            if ("function" == typeof (t1 = o[e])) this.removeListener(e, t1);
            else if (t1) do {
                this.removeListener(e, t1[t1.length - 1]);
            }while (t1[0])
            return this;
        }, a.prototype.listeners = function(e) {
            var t1, o = this._events;
            return o && (t1 = o[e]) ? "function" == typeof t1 ? [
                t1.listener || t1
            ] : function(e) {
                for(var t1 = new Array(e.length), o = 0; o < t1.length; ++o)t1[o] = e[o].listener || e[o];
                return t1;
            }(t1) : [];
        }, a.listenerCount = function(e, t1) {
            return "function" == typeof e.listenerCount ? e.listenerCount(t1) : c.call(e, t1);
        }, a.prototype.listenerCount = c, a.prototype.eventNames = function() {
            return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        var h = "ZipInfo:";
        function m(e) {
            var t1;
            return null === (t1 = null == e ? void 0 : e.path) || void 0 === t1 ? void 0 : t1.startsWith(h);
        }
        function g(e) {
            return "string" == typeof e && e.startsWith(h);
        }
        function v(e, t1) {
            return (Array.isArray(e) ? e : [
                e
            ]).some(function(e) {
                if ("number" != typeof e.version) throw new Error("file version must be an int number");
                return e.version < t1;
            });
        }
        function f(e, t1) {
            return e.reduce(function(e, o) {
                return e.then(function(e) {
                    return t1(e, o);
                }).catch(function() {
                    return t1(void 0, o);
                });
            }, Promise.resolve(void 0));
        }
        var y, S = function(e) {
            function t1() {
                return null !== e && e.apply(this, arguments) || this;
            }
            return r(t1, e), t1;
        }(a), b = "resource", E = function(e) {
            function o(t1) {
                var o = e.call(this) || this;
                if (o.ready = !1, o.openError = !1, o.isEnable()) {
                    var r = t1 || {}, i = r.nameSpaceId, n = r.indexDbVersion;
                    o.dbName = function(e) {
                        return "resource-manager" + (e ? "-" + e : "");
                    }(i);
                    var s = indexedDB.open(o.dbName, n || 1);
                    s.addEventListener("error", function() {
                        o.openError = !0, o.checkReady(), o.emit("error", new Error("failed to open indexedDB"));
                    }), s.addEventListener("success", function() {
                        o.db = s.result, o.checkReady();
                    }), s.addEventListener("upgradeneeded", function() {
                        o.db = s.result, o.handleSuccess();
                    }), setTimeout(function() {
                        o.checkReady();
                    }, 5e3);
                } else o.checkReady();
                return o;
            }
            return r(o, e), o.prototype.checkReady = function() {
                this.ready || (this.ready = !0, this.emit("ready"));
            }, o.prototype.handleSuccess = function() {
                if (!this.db.objectStoreNames || 0 === this.db.objectStoreNames.length || !this.db.objectStoreNames.contains(b)) {
                    var e = this.db.createObjectStore(b, {
                        keyPath: "path",
                        autoIncrement: !1
                    });
                    e.createIndex("path", "path"), e.createIndex("sourceURL", "sourceURL", {
                        unique: !1
                    });
                }
            }, o.prototype.createAction = function(e) {
                var t1 = this.db.transaction([
                    b
                ], e || "readonly");
                return {
                    trans: t1,
                    store: t1.objectStore(b)
                };
            }, o.prototype.handleAction = function(e, t1) {
                return new Promise(function(o, r) {
                    var i = t1();
                    e.addEventListener("complete", function() {
                        o(i.result);
                    }), e.addEventListener("error", function() {
                        r(e.error || new Error("transaction error"));
                    }), e.addEventListener("abort", function() {
                        r(e.error || new Error("transaction aborted"));
                    });
                });
            }, o.prototype.put = function() {
                for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
                var o = this.createAction("readwrite"), r = o.trans, i = o.store;
                return this.handleAction(r, function() {
                    return i.put.apply(i, e);
                });
            }, o.prototype.getAllKeysFromIndex = function(e) {
                for(var t1 = [], o = 1; o < arguments.length; o++)t1[o - 1] = arguments[o];
                if (IDBObjectStore.prototype.getAllKeys) {
                    var r = this.createAction(), i = r.trans, n = r.store;
                    return this.handleAction(i, function() {
                        var o;
                        return (o = n.index(e)).getAllKeys.apply(o, t1);
                    });
                }
                return this.openKeyCursor(e);
            }, o.prototype.getAllFromIndex = function(e) {
                for(var t1 = [], o = 1; o < arguments.length; o++)t1[o - 1] = arguments[o];
                var r = this.createAction(), i = r.trans, n = r.store;
                return IDBObjectStore.prototype.getAll ? this.handleAction(i, function() {
                    var o;
                    return (o = n.index(e)).getAll.apply(o, t1);
                }) : this.openCursor(e);
            }, o.prototype.getFromIndex = function(e) {
                for(var t1 = [], o = 1; o < arguments.length; o++)t1[o - 1] = arguments[o];
                var r = this.createAction(), i = r.trans, n = r.store;
                return this.handleAction(i, function() {
                    var o;
                    return (o = n.index(e)).get.apply(o, t1);
                });
            }, o.prototype.deleteKey = function() {
                for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
                var o = this.createAction("readwrite"), r = o.trans, i = o.store;
                return this.handleAction(r, function() {
                    return i.delete.apply(i, e);
                });
            }, o.prototype.handleCursorAction = function(e, t1, o, r) {
                return new Promise(function(i, n) {
                    t1.addEventListener("success", function() {
                        t1.result ? (o(r, t1.result), t1.result.continue()) : i(r);
                    }), t1.addEventListener("error", function() {
                        n(e.error || new Error("transaction error"));
                    });
                });
            }, o.prototype.openKeyCursor = function(e) {
                for(var t1, o = [], r = 1; r < arguments.length; r++)o[r - 1] = arguments[r];
                var i = this.createAction("readwrite"), n = i.trans, s = i.store;
                return this.handleCursorAction(n, (t1 = s.index(e)).openKeyCursor.apply(t1, o), function(e, t1) {
                    return e.push(t1.key), e;
                }, []);
            }, o.prototype.openCursor = function(e) {
                for(var t1, o = [], r = 1; r < arguments.length; r++)o[r - 1] = arguments[r];
                var i = this.createAction("readwrite"), n = i.trans, s = i.store;
                return this.handleCursorAction(n, (t1 = s.index(e)).openCursor.apply(t1, o), function(e, t1) {
                    return e.push(t1.value), e;
                }, []);
            }, o.prototype.isEnable = function() {
                return !!window.indexedDB && !this.openError;
            }, o.prototype.saveFile = function(e) {
                return this.db ? this.put(e).then(function() {
                    return !0;
                }) : Promise.resolve(!1);
            }, o.prototype.removeFile = function(e) {
                var o = this;
                return this.db ? "string" == typeof e ? this.getAllKeysFromIndex("path").then(function(r) {
                    var i = (r || []).filter(function(o) {
                        return o === e || o.startsWith("" + e + t1.sep);
                    });
                    return Promise.all(i.map(function(e) {
                        return o.deleteKey(e);
                    }));
                }).then(function() {
                    return !0;
                }) : this.deleteKey(e.path).then(function() {
                    return !0;
                }) : Promise.resolve(!1);
            }, o.prototype.clear = function() {
                if (!this.db) return Promise.resolve(!1);
                var e = this.createAction("readwrite"), t1 = e.trans, o = e.store;
                return this.handleAction(t1, function() {
                    return o.clear();
                }).then(function() {
                    return !0;
                });
            }, o.prototype.findFileByPath = function(e) {
                return this.db && e ? this.getFromIndex("path", e) : Promise.resolve(void 0);
            }, o.prototype.findFileBySourceURL = function(e) {
                return this.db && e ? this.getAllFromIndex("sourceURL", e) : Promise.resolve([]);
            }, o.prototype.isDirectory = function(e) {
                var o = this;
                return this.db ? new Promise(function(r) {
                    g(e) ? r(!1) : o.getAllKeysFromIndex("path").then(function(o) {
                        return (o || []).some(function(o) {
                            return o.startsWith("" + e + t1.sep);
                        });
                    }).then(r).catch(function() {
                        return r(!1);
                    });
                }) : Promise.resolve(!1);
            }, o.prototype.ls = function(e) {
                var o = this;
                return this.db ? this.getAllKeysFromIndex("path").then(function(r) {
                    var i = [];
                    return Promise.all((r || []).map(function(r) {
                        if (g(r)) return Promise.resolve(void 0);
                        if (e) {
                            if (r.startsWith("" + e + t1.sep)) {
                                var n = r.split("" + e + t1.sep)[1] || "";
                                if (n.includes(t1.sep)) {
                                    var s = "" + e + t1.sep + n.split(t1.sep)[0];
                                    return s && !i.includes(s) ? (i.push(s), Promise.resolve(s)) : Promise.resolve(void 0);
                                }
                                return o.getFromIndex("path", r);
                            }
                            return Promise.resolve(void 0);
                        }
                        if (r.includes(t1.sep)) {
                            var a = r.split(t1.sep)[0] || "";
                            return a && !i.includes(a) ? (i.push(a), Promise.resolve(a)) : Promise.resolve(void 0);
                        }
                        return o.getFromIndex("path", r);
                    })).then(function(e) {
                        return e.filter(function(e) {
                            return !!e;
                        });
                    });
                }) : Promise.resolve([]);
            }, o;
        }(S), I = function(e) {
            function o() {
                var t1 = null !== e && e.apply(this, arguments) || this;
                return t1.memoryFiles = [], t1;
            }
            return r(o, e), o.prototype.isEnable = function() {
                return !0;
            }, o.prototype.saveFile = function(e) {
                var t1 = this;
                return new Promise(function(o) {
                    t1.memoryFiles.some(function(o, r) {
                        return o.path === e.path && (t1.memoryFiles.splice(r, 1, e), !0);
                    }) || t1.memoryFiles.push(e), o(!0);
                });
            }, o.prototype.removeFile = function(e) {
                var o = this;
                return new Promise(function(r) {
                    for(var i = o.memoryFiles.length - 1; i >= 0; i--){
                        var n = o.memoryFiles[i];
                        ("string" == typeof e && (n.path === e || n.path.startsWith("" + e + t1.sep)) || e.path === n.path) && o.memoryFiles.splice(i, 1);
                    }
                    r(!0);
                });
            }, o.prototype.clear = function() {
                var e = this;
                return new Promise(function(t1) {
                    e.memoryFiles = [], t1(!0);
                });
            }, o.prototype.findFileByPath = function(e) {
                var t1 = this;
                return new Promise(function(o) {
                    o(t1.memoryFiles.filter(function(t1) {
                        return t1.path === e;
                    })[0]);
                });
            }, o.prototype.findFileBySourceURL = function(e) {
                var t1 = this;
                return new Promise(function(o) {
                    o(t1.memoryFiles.filter(function(t1) {
                        return t1.sourceURL === e;
                    }));
                });
            }, o.prototype.isDirectory = function(e) {
                var o = this;
                return new Promise(function(r) {
                    g(e) ? r(!1) : r(o.memoryFiles.some(function(o) {
                        return o.path.startsWith("" + e + t1.sep);
                    }));
                });
            }, o.prototype.ls = function(e) {
                var o = this;
                return new Promise(function(r) {
                    var i = [];
                    o.memoryFiles.forEach(function(o) {
                        if (!m(o)) if (e) {
                            if (o.path.startsWith("" + e + t1.sep)) {
                                var r = o.path.split("" + e + t1.sep)[1] || "";
                                if (r.includes(t1.sep)) {
                                    var n = "" + e + t1.sep + r.split(t1.sep)[0];
                                    return void (n && !i.includes(n) && i.push(n));
                                }
                                i.push(o);
                            }
                        } else if (o.path.includes(t1.sep)) {
                            var s = o.path.split(t1.sep)[0] || "";
                            s && !i.includes(s) && i.push(s);
                        } else i.push(o);
                    }), r(i);
                });
            }, o;
        }(S), A = function(e) {
            function o(t1) {
                var o = e.call(this) || this;
                if (o.isLocalAvaliable = void 0, o.isEnable()) {
                    var r = (t1 || {}).nameSpaceId;
                    o.storageName = function(e) {
                        return "resource-manager" + (e ? "-" + e : "");
                    }(r);
                }
                return o;
            }
            return r(o, e), o.prototype.isEnable = function() {
                if (void 0 !== this.isLocalAvaliable) return this.isLocalAvaliable;
                try {
                    this.isLocalAvaliable = !0, localStorage.setItem("privateTest", "");
                } catch (e) {
                    this.isLocalAvaliable = !1;
                }
                return this.isLocalAvaliable;
            }, o.prototype.saveFile = function(e) {
                var t1 = this;
                return this.isEnable() ? new Promise(function(o) {
                    var r = t1.getLocalFile();
                    r.some(function(t1, o) {
                        return t1.path === e.path && (r.splice(o, 1, e), !0);
                    }) || r.push(e), localStorage.setItem(t1.storageName, JSON.stringify(r)), o(!0);
                }) : Promise.resolve(!1);
            }, o.prototype.getLocalFile = function() {
                var e = localStorage.getItem(this.storageName), t1 = [];
                if (e) try {
                    t1 = JSON.parse(e) || "[]";
                } catch (e) {
                    console.log(e);
                }
                return t1;
            }, o.prototype.removeFile = function(e) {
                var o = this;
                return this.isEnable() ? new Promise(function(r) {
                    for(var i = o.getLocalFile(), n = i.length - 1; n >= 0; n--){
                        var s = i[n];
                        ("string" == typeof e && (s.path === e || s.path.startsWith("" + e + t1.sep)) || e.path === s.path) && i.splice(n, 1);
                    }
                    localStorage.setItem(o.storageName, JSON.stringify(i)), r(!0);
                }) : Promise.resolve(!1);
            }, o.prototype.clear = function() {
                var e = this;
                return this.isEnable() ? new Promise(function(t1) {
                    localStorage.removeItem(e.storageName), t1(!0);
                }) : Promise.resolve(!1);
            }, o.prototype.findFileByPath = function(e) {
                var t1 = this;
                return this.isEnable() ? new Promise(function(o) {
                    o(t1.getLocalFile().filter(function(t1) {
                        return t1.path === e;
                    })[0]);
                }) : Promise.resolve(void 0);
            }, o.prototype.findFileBySourceURL = function(e) {
                var t1 = this;
                return this.isEnable() ? new Promise(function(o) {
                    o(t1.getLocalFile().filter(function(t1) {
                        return t1.sourceURL === e;
                    }));
                }) : Promise.resolve([]);
            }, o.prototype.isDirectory = function(e) {
                var o = this;
                return this.isEnable() ? new Promise(function(r) {
                    g(e) ? r(!1) : r(o.getLocalFile().some(function(o) {
                        return o.path.startsWith("" + e + t1.sep);
                    }));
                }) : Promise.resolve(!1);
            }, o.prototype.ls = function(e) {
                var o = this;
                return this.isEnable() ? new Promise(function(r) {
                    var i = [];
                    o.getLocalFile().forEach(function(o) {
                        if (!m(o)) if (e) {
                            if (o.path.startsWith("" + e + t1.sep)) {
                                var r = o.path.split("" + e + t1.sep)[1] || "";
                                if (r.includes(t1.sep)) {
                                    var n = "" + e + t1.sep + r.split(t1.sep)[0];
                                    return void (n && !i.includes(n) && i.push(n));
                                }
                                i.push(o);
                            }
                        } else if (o.path.includes(t1.sep)) {
                            var s = o.path.split(t1.sep)[0] || "";
                            s && !i.includes(s) && i.push(s);
                        } else i.push(o);
                    }), r(i);
                }) : Promise.resolve([]);
            }, o;
        }(S);
        (y = e.FileStoreEnum || (e.FileStoreEnum = {})).MEMORY = "memoryStore", y.INDEX_DB = "indexedDBStore", y.STORAGE = "storageStore";
        var C = function(o) {
            function i(e) {
                var t1 = o.call(this) || this;
                return t1.indexedDBStore = new E(e), t1.memoryStore = new I, t1.storageStore = new A(e), t1;
            }
            return r(i, o), i.prototype.saveFile = function(t1, o, r) {
                var i = this;
                void 0 === o && (o = !0);
                var s = (r || {}).forceSpecifyStore;
                return (o ? this.findFileByPath(t1.path, r) : Promise.resolve(void 0)).then(function(o) {
                    if ((null == o ? void 0 : o.version) && v(t1, o.version)) throw new Error("there is an higher version file existed already");
                    var r = n(n({}, t1), {
                        createTime: o && o.createTime || Date.now(),
                        updateTime: Date.now()
                    });
                    return s && i[s] && i[s].isEnable() && (s !== e.FileStoreEnum.STORAGE || i.isLocalStorageAvaliable(r)) ? i[s].saveFile(r) : i[i.saveToTargetStoreRule(r)].saveFile(r);
                });
            }, i.prototype.isLocalStorageAvaliable = function(e) {
                var o = e.data;
                return "string" === t1.getDataFormat(o) && o.length <= 102400 && this.storageStore.isEnable();
            }, i.prototype.saveToTargetStoreRule = function(t1) {
                return this.indexedDBStore.isEnable() ? e.FileStoreEnum.INDEX_DB : this.isLocalStorageAvaliable(t1) ? e.FileStoreEnum.STORAGE : e.FileStoreEnum.MEMORY;
            }, i.prototype.removeFile = function(e, t1) {
                var o = (t1 || {}).forceSpecifyStore;
                return o && this[o] ? this[o].removeFile(e) : Promise.all([
                    this.indexedDBStore.removeFile(e),
                    this.storageStore.removeFile(e),
                    this.memoryStore.removeFile(e)
                ]).then(function() {
                    return !0;
                });
            }, i.prototype.clear = function(e) {
                var t1 = (e || {}).forceSpecifyStore;
                return t1 && this[t1] ? this[t1].clear() : Promise.all([
                    this.indexedDBStore.clear(),
                    this.storageStore.clear(),
                    this.memoryStore.clear()
                ]).then(function() {
                    return !0;
                });
            }, i.prototype.findFileByPath = function(e, t1) {
                var o = this, r = (t1 || {}).forceSpecifyStore;
                return r && this[r] ? this[r].findFileByPath(e) : f(this.searchInTargetStoreRule(), function(t1, r) {
                    return t1 ? Promise.resolve(t1) : o[r].findFileByPath(e);
                });
            }, i.prototype.findFileBySourceURL = function(e, t1) {
                var o = this, r = (t1 || {}).forceSpecifyStore;
                return r && this[r] ? this[r].findFileBySourceURL(e) : f(this.searchInTargetStoreRule(), function(t1, r) {
                    return o[r].findFileBySourceURL(e).then(function(e) {
                        return t1 ? t1.filter(function(t1) {
                            return !e.some(function(e) {
                                return e.path === t1.path;
                            });
                        }).concat(e || []) : e || [];
                    });
                });
            }, i.prototype.searchInTargetStoreRule = function() {
                return [
                    e.FileStoreEnum.INDEX_DB,
                    e.FileStoreEnum.STORAGE,
                    e.FileStoreEnum.MEMORY
                ];
            }, i.prototype.isDirectory = function(e) {
                var t1 = this;
                return e ? f(this.searchInTargetStoreRule(), function(o, r) {
                    return o ? Promise.resolve(!0) : t1[r].isDirectory(e);
                }) : Promise.resolve(!0);
            }, i.prototype.ls = function(e) {
                var t1 = this;
                return this.isDirectory(e).then(function(o) {
                    if (!o) throw new Error("path: " + e + " is an invalid directory path");
                    return f(t1.searchInTargetStoreRule(), function(o, r) {
                        return t1[r].ls(e).then(function(e) {
                            return o ? (e || []).concat(o.filter(function(t1) {
                                return !e.some(function(e) {
                                    return "string" == typeof t1 ? e === t1 : "string" != typeof e && e.path === t1.path;
                                });
                            })) : e;
                        });
                    });
                });
            }, i;
        }(a), _ = function(e) {
            function t1() {
                return null !== e && e.apply(this, arguments) || this;
            }
            return r(t1, e), t1;
        }(a), R = function(e) {
            function o(o) {
                var r = e.call(this) || this, i = o || {}, n = i.storeOptions, s = i.downloadManagerOptions;
                return r.downloadManager = new t1.IDownloadManager(s), r.store = new C(n), r.store.indexedDBStore.on("ready", function() {
                    return r.emit("ready");
                }), r;
            }
            return r(o, e), o.prototype.getFile = function(e, t1, o) {
                var r = this, i = new _, n = Promise.resolve(void 0), s = t1 || {}, a = s.downloadOptions, d = s.forceDownload, u = s.saveRootPath;
                d ? n = Promise.resolve(void 0) : "string" == typeof e ? n = this.store.findFileByPath(e, o) : (null == e ? void 0 : e.sourceURL) ? n = this.store.findFileBySourceURL(e.sourceURL) : a && (a.domParams || a.socketParams || a.xhrParams) && (n = this.store.findFileBySourceURL(this.genSourceURL(a)));
                var l = null, c = new Promise(function(e) {
                    l = e;
                });
                return i.getDownloadTask = function() {
                    return c;
                }, n = n.then(function(e) {
                    if (e && (!Array.isArray(e) || e.length)) {
                        var t1 = e;
                        if (Array.isArray(t1)) {
                            var r = t1.find(function(e) {
                                return m(e);
                            });
                            if (!r) return;
                            t1 = t1.filter(function(e) {
                                return !m(e);
                            });
                            var n = r.data;
                            if ("string" != typeof n) return;
                            if (!JSON.parse(n || "[]").every(function(e) {
                                return t1.some(function(t1) {
                                    return t1.path === e;
                                });
                            })) return;
                        }
                        if (!(null == o ? void 0 : o.targetVersion) || !v(t1, o.targetVersion)) return i.emit("checkExpire", !1), t1;
                        i.emit("checkExpire", !0);
                    }
                }).then(function(t1) {
                    if (!t1 && a) {
                        var n = r.downloadManager.download(a);
                        return l(n), new Promise(function(t1, s) {
                            n.on("complete", function(n) {
                                setTimeout(function() {
                                    var s = Array.isArray(n) ? n.map(function(e) {
                                        var t1 = e.data, i = e.path, n = e.extName;
                                        return {
                                            path: r.genFilePath(u, i),
                                            sourceURL: r.genSourceURL(a),
                                            data: t1,
                                            fileFormat: n || r.getFileFormat(a),
                                            version: (null == o ? void 0 : o.targetVersion) || 1
                                        };
                                    }) : {
                                        path: r.genFilePath(u, void 0),
                                        sourceURL: r.genSourceURL(a),
                                        data: n,
                                        fileFormat: r.getFileFormat(a),
                                        version: (null == o ? void 0 : o.targetVersion) || 1
                                    };
                                    if (Array.isArray(s) && "string" == typeof e && e) {
                                        var d = s.find(function(t1) {
                                            return t1.path === e;
                                        });
                                        t1(d || s);
                                    } else t1(s);
                                    i.emit("beforeSet", s), r.beforeWrite(s, o).then(function() {
                                        i.emit("afterSet");
                                    }).catch(function(e) {
                                        return i.emit("afterSet", e);
                                    });
                                }, 0);
                            }), n.on("abort", s), n.on("error", s), n.on("timeout", function() {
                                return s(new Error("download timeout"));
                            });
                        });
                    }
                    return l(void 0), t1;
                }).catch(function(e) {
                    return l(void 0), Promise.reject(e);
                }), i.getResult = function() {
                    return n;
                }, i;
            }, o.prototype.genSourceURL = function(e) {
                var o = e.domParams, r = e.type, i = e.xhrParams;
                if (r === t1.DownloaderType.SOCKET) return null;
                var n = (r === t1.DownloaderType.DOM ? o : i) || {}, s = n.url, a = void 0 === s ? "" : s, d = n.body;
                return d && Object.keys(d).length ? a + (a.includes("?") ? "&" : "?") + "downloadBodyParams=" + JSON.stringify(d) : a;
            }, o.prototype.updateFile = function(e, t1) {
                return this.saveStore(e, !0, t1);
            }, o.prototype.beforeWrite = function(e, t1) {
                var o = this;
                return Array.isArray(e) ? Promise.all(e.concat(function(e) {
                    var t1 = e[0].sourceURL || "";
                    return {
                        path: "" + h + t1,
                        sourceURL: t1,
                        data: JSON.stringify(e.map(function(e) {
                            return e.path;
                        }))
                    };
                }(e)).map(function(e) {
                    return o.saveStore(e, !1, t1);
                })).then(function(e) {
                    return e.filter(function(e) {
                        return !m(e);
                    });
                }) : this.saveStore(e, !0, t1);
            }, o.prototype.getFileFormat = function(e) {
                var o = e || {}, r = o.xhrParams, i = o.domParams, n = o.socketParams, s = o.type;
                return s === t1.DownloaderType.DOM && (null == i ? void 0 : i.fileFormat) ? i.fileFormat : s === t1.DownloaderType.SOCKET && (null == n ? void 0 : n.fileFormat) ? n.fileFormat : (null == r ? void 0 : r.fileFormat) ? r.fileFormat : "unknow";
            }, o.prototype.genFilePath = function(e, o) {
                return o ? "" + (e || "") + (e ? t1.sep : "") + o : e || "";
            }, o.prototype.saveStore = function(e, t1, o) {
                return void 0 === t1 && (t1 = !0), this.store.saveFile(e, t1, o).then(function(t1) {
                    if (t1) return e;
                    throw new Error("fail to save file in local store");
                });
            }, o.prototype.remove = function(e, t1) {
                return this.store.removeFile(e, t1);
            }, o.prototype.clear = function(e) {
                return this.store.clear(e);
            }, o.prototype.list = function(e) {
                return this.store.ls(e);
            }, o.prototype.updateVersion = function(e, t1) {
                var o = this;
                return this.store.findFileByPath(e).then(function(r) {
                    if (r) return o.saveStore(n(n({}, r), {
                        version: t1
                    })).then(function() {});
                    throw new Error("the target path: " + e + " isn't existed");
                });
            }, o.prototype.updateSourceURL = function(e, t1) {
                var o = this;
                return this.store.findFileByPath(e).then(function(r) {
                    if (r) return o.saveStore(n(n({}, r), {
                        sourceURL: t1
                    })).then(function() {});
                    throw new Error("the target path: " + e + " isn't existed");
                });
            }, o;
        }(a);
        e.IResourceManager = R, Object.defineProperty(e, "__esModule", {
            value: !0
        });
    }(fy.exports, (gy || (gy = 1, function(e, t1) {
        var o = function(e, t1) {
            return o = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t1) {
                e.__proto__ = t1;
            } || function(e, t1) {
                for(var o in t1)t1.hasOwnProperty(o) && (e[o] = t1[o]);
            }, o(e, t1);
        };
        function r(e, t1) {
            function r() {
                this.constructor = e;
            }
            o(e, t1), e.prototype = null === t1 ? Object.create(t1) : (r.prototype = t1.prototype, new r);
        }
        var i, n = function() {
            return n = Object.assign || function(e) {
                for(var t1, o = 1, r = arguments.length; o < r; o++)for(var i in t1 = arguments[o])Object.prototype.hasOwnProperty.call(t1, i) && (e[i] = t1[i]);
                return e;
            }, n.apply(this, arguments);
        }, s = function(e, t1) {
            var o = new Uint8Array(e.byteLength + t1.byteLength);
            return o.set(new Uint8Array(e), 0), o.set(new Uint8Array(t1), e.byteLength), o.buffer;
        }, a = "/";
        (i = e.TransformDataFormat || (e.TransformDataFormat = {})).STRING = "string", i.BLOB = "blob", i.ARRAY_BUFFER = "arraybuffer";
        var d, u = function(e) {
            return Blob && e instanceof Blob ? "blob" : ArrayBuffer && e instanceof ArrayBuffer ? "arrayBuffer" : typeof e;
        }, l = [], c = function() {
            for(var e = [
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z"
            ], t1 = "", o = 0; o < 32; o++)t1 += e[Math.round(61 * Math.random())];
            return -1 !== l.indexOf(t1) ? c() : (l.push(t1), t1);
        }, p = function(e) {
            return e.arrayBuffer ? e.arrayBuffer() : new Promise(function(t1, o) {
                var r = new FileReader;
                r.readAsArrayBuffer(e), r.onload = function(e) {
                    t1(e.target && e.target.result);
                }, r.onerror = function(e) {
                    o(e);
                };
            });
        }, h = function(e) {
            return e.text ? e.text() : new Promise(function(t1, o) {
                var r = new FileReader;
                r.readAsText(e), r.onload = function(e) {
                    t1(e.target && e.target.result);
                }, r.onerror = function(e) {
                    o(e);
                };
            });
        }, m = function(e, t1) {
            return Promise.resolve(new Blob([
                new Uint8Array(e)
            ], {
                type: t1
            }));
        }, g = function(e, t1) {
            var o = new Blob([
                e
            ], {
                type: t1 || "text/plain"
            });
            return h(o);
        }, v = function(e, t1) {
            return Promise.resolve(new Blob([
                e
            ], {
                type: t1 || "text/plain"
            }));
        }, f = function(e, t1) {
            return p(new Blob([
                e
            ], {
                type: t1 || "text/plain"
            }));
        };
        function y(e) {
            var t1 = (e || "").split(".");
            return t1[t1.length - 1] || "";
        }
        function S(e) {
            var t1 = (e || "").lastIndexOf(a);
            return t1 < 0 ? "" : e.slice(0, t1);
        }
        function b(e) {
            var t1 = (e || "").lastIndexOf(a), o = t1 < 0 ? e : e.slice(t1 + 1), r = (o || "").lastIndexOf(".");
            return r < 0 ? o : o.slice(0, r);
        }
        function E(e) {
            return [
                "png",
                "jpg",
                "jpeg",
                "svg"
            ].includes(y(e));
        }
        function I(e) {
            return "json" === y(e);
        }
        function A(e) {
            return "version" === y(e);
        }
        function C(e, t1) {
            return e.reduce(function(e, o) {
                var r, i = o.data, n = o.file, s = y(n.name), d = S(n.name), u = b(n.name), l = ((null == t1 ? void 0 : t1.combineExtNames) || []).includes(s) && "string" == typeof i, c = l ? "" + (d ? "" + d + a + s : s) : n.name;
                return l && e.some(function(e) {
                    return e.path === c && (e.data[u] = i, !0);
                }) || e.push({
                    path: c,
                    extName: s,
                    data: l ? (r = {}, r[u] = i, r) : i,
                    shouldCombine: l
                }), e;
            }, []).map(function(e) {
                var t1 = e.data, o = e.shouldCombine, r = function(e, t1) {
                    var o = {};
                    for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && t1.indexOf(r) < 0 && (o[r] = e[r]);
                    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                        var i = 0;
                        for(r = Object.getOwnPropertySymbols(e); i < r.length; i++)t1.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (o[r[i]] = e[r[i]]);
                    }
                    return o;
                }(e, [
                    "data",
                    "shouldCombine"
                ]);
                return n(n({}, r), {
                    data: o ? JSON.stringify(t1) : t1
                });
            });
        }
        function _(e, o) {
            return t1.loadAsync(e).then(function(e) {
                return Promise.all(e.filter(function(e, t1) {
                    return !t1.dir;
                }).map(function(e) {
                    var t1 = function(e) {
                        return I(e.name) ? "string" : E(e.name) ? "base64" : A(e.name) ? "text" : "blob";
                    }(e);
                    return (null == o ? void 0 : o.setUnZipFormat) && (t1 = o.setUnZipFormat(e) || t1), e.async(t1).then(function(o) {
                        var r = o, i = y(e.name), n = "svg" === i ? "svg+xml" : i;
                        return "base64" === t1 && E(e.name) && !o.startsWith("data") && (r = "data:image/" + n + ";base64," + r), {
                            data: r,
                            file: e
                        };
                    });
                }));
            }).then(function(e) {
                return C(e, o);
            });
        }
        function R(t1, o) {
            var r = o || {}, i = r.encoding, n = r.blobType, s = r.unZipOptions;
            if (function(e) {
                return "blob" === u(e) && (e.type.includes("compressed") || e.type.includes("zip"));
            }(t1) && !(null == s ? void 0 : s.disableUnZip)) return _(t1, s);
            if (!i) return Promise.resolve(t1);
            var a = u(t1), d = "string" === a, l = "blob" === a, c = "arrayBuffer" === a;
            if (i === e.TransformDataFormat.BLOB) {
                var y = t1;
                if (d) return h(y);
                if (c) return p(y);
            } else if (i === e.TransformDataFormat.ARRAY_BUFFER) {
                var S = t1;
                if (d) return g(S, n);
                if (l) return m(S, n);
            } else if (i === e.TransformDataFormat.STRING) {
                var b = t1;
                if (l) return v(b, n);
                if (c) return f(b, n);
            }
            return Promise.resolve(t1);
        }
        function w(e) {
            var t1 = 0, o = !1, r = function() {
                t1 > 90 || o || (e(t1 += (100 - t1) / 50), requestAnimationFrame(r));
            };
            return r(), {
                finish: function() {
                    100 === t1 || o || (t1 = 100, e(100));
                },
                abort: function() {
                    100 === t1 || o || (o = !0);
                },
                get curProgress () {
                    return t1;
                }
            };
        }
        function T() {}
        function O() {
            O.init.call(this);
        }
        function D(e) {
            return void 0 === e._maxListeners ? O.defaultMaxListeners : e._maxListeners;
        }
        function P(e, t1, o, r) {
            var i, n, s;
            if ("function" != typeof o) throw new TypeError('"listener" argument must be a function');
            if ((n = e._events) ? (n.newListener && (e.emit("newListener", t1, o.listener ? o.listener : o), n = e._events), s = n[t1]) : (n = e._events = new T, e._eventsCount = 0), s) {
                if ("function" == typeof s ? s = n[t1] = r ? [
                    o,
                    s
                ] : [
                    s,
                    o
                ] : r ? s.unshift(o) : s.push(o), !s.warned && (i = D(e)) && i > 0 && s.length > i) {
                    s.warned = !0;
                    var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + t1 + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t1, a.count = s.length, function(e) {
                        "function" == typeof console.warn ? console.warn(e) : console.log(e);
                    }(a);
                }
            } else s = n[t1] = o, ++e._eventsCount;
            return e;
        }
        function M(e, t1, o) {
            var r = !1;
            function i() {
                e.removeListener(t1, i), r || (r = !0, o.apply(e, arguments));
            }
            return i.listener = o, i;
        }
        function k(e) {
            var t1 = this._events;
            if (t1) {
                var o = t1[e];
                if ("function" == typeof o) return 1;
                if (o) return o.length;
            }
            return 0;
        }
        function L(e, t1) {
            for(var o = new Array(t1); t1--;)o[t1] = e[t1];
            return o;
        }
        T.prototype = Object.create(null), O.EventEmitter = O, O.usingDomains = !1, O.prototype.domain = void 0, O.prototype._events = void 0, O.prototype._maxListeners = void 0, O.defaultMaxListeners = 10, O.init = function() {
            this.domain = null, O.usingDomains && d.active && d.Domain, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new T, this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, O.prototype.setMaxListeners = function(e) {
            if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number');
            return this._maxListeners = e, this;
        }, O.prototype.getMaxListeners = function() {
            return D(this);
        }, O.prototype.emit = function(e) {
            var t1, o, r, i, n, s, a, d = "error" === e;
            if (s = this._events) d = d && null == s.error;
            else if (!d) return !1;
            if (a = this.domain, d) {
                if (t1 = arguments[1], !a) {
                    if (t1 instanceof Error) throw t1;
                    var u = new Error('Uncaught, unspecified "error" event. (' + t1 + ")");
                    throw u.context = t1, u;
                }
                return t1 || (t1 = new Error('Uncaught, unspecified "error" event')), t1.domainEmitter = this, t1.domain = a, t1.domainThrown = !1, a.emit("error", t1), !1;
            }
            if (!(o = s[e])) return !1;
            var l = "function" == typeof o;
            switch(r = arguments.length){
                case 1:
                    !function(e, t1, o) {
                        if (t1) e.call(o);
                        else for(var r = e.length, i = L(e, r), n = 0; n < r; ++n)i[n].call(o);
                    }(o, l, this);
                    break;
                case 2:
                    !function(e, t1, o, r) {
                        if (t1) e.call(o, r);
                        else for(var i = e.length, n = L(e, i), s = 0; s < i; ++s)n[s].call(o, r);
                    }(o, l, this, arguments[1]);
                    break;
                case 3:
                    !function(e, t1, o, r, i) {
                        if (t1) e.call(o, r, i);
                        else for(var n = e.length, s = L(e, n), a = 0; a < n; ++a)s[a].call(o, r, i);
                    }(o, l, this, arguments[1], arguments[2]);
                    break;
                case 4:
                    !function(e, t1, o, r, i, n) {
                        if (t1) e.call(o, r, i, n);
                        else for(var s = e.length, a = L(e, s), d = 0; d < s; ++d)a[d].call(o, r, i, n);
                    }(o, l, this, arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    for(i = new Array(r - 1), n = 1; n < r; n++)i[n - 1] = arguments[n];
                    !function(e, t1, o, r) {
                        if (t1) e.apply(o, r);
                        else for(var i = e.length, n = L(e, i), s = 0; s < i; ++s)n[s].apply(o, r);
                    }(o, l, this, i);
            }
            return !0;
        }, O.prototype.addListener = function(e, t1) {
            return P(this, e, t1, !1);
        }, O.prototype.on = O.prototype.addListener, O.prototype.prependListener = function(e, t1) {
            return P(this, e, t1, !0);
        }, O.prototype.once = function(e, t1) {
            if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
            return this.on(e, M(this, e, t1)), this;
        }, O.prototype.prependOnceListener = function(e, t1) {
            if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
            return this.prependListener(e, M(this, e, t1)), this;
        }, O.prototype.removeListener = function(e, t1) {
            var o, r, i, n, s;
            if ("function" != typeof t1) throw new TypeError('"listener" argument must be a function');
            if (!(r = this._events)) return this;
            if (!(o = r[e])) return this;
            if (o === t1 || o.listener && o.listener === t1) 0 == --this._eventsCount ? this._events = new T : (delete r[e], r.removeListener && this.emit("removeListener", e, o.listener || t1));
            else if ("function" != typeof o) {
                for(i = -1, n = o.length; n-- > 0;)if (o[n] === t1 || o[n].listener && o[n].listener === t1) {
                    s = o[n].listener, i = n;
                    break;
                }
                if (i < 0) return this;
                if (1 === o.length) {
                    if (o[0] = void 0, 0 == --this._eventsCount) return this._events = new T, this;
                    delete r[e];
                } else !function(e, t1) {
                    for(var o = t1, r = o + 1, i = e.length; r < i; o += 1, r += 1)e[o] = e[r];
                    e.pop();
                }(o, i);
                r.removeListener && this.emit("removeListener", e, s || t1);
            }
            return this;
        }, O.prototype.removeAllListeners = function(e) {
            var t1, o;
            if (!(o = this._events)) return this;
            if (!o.removeListener) return 0 === arguments.length ? (this._events = new T, this._eventsCount = 0) : o[e] && (0 == --this._eventsCount ? this._events = new T : delete o[e]), this;
            if (0 === arguments.length) {
                for(var r, i = Object.keys(o), n = 0; n < i.length; ++n)"removeListener" !== (r = i[n]) && this.removeAllListeners(r);
                return this.removeAllListeners("removeListener"), this._events = new T, this._eventsCount = 0, this;
            }
            if ("function" == typeof (t1 = o[e])) this.removeListener(e, t1);
            else if (t1) do {
                this.removeListener(e, t1[t1.length - 1]);
            }while (t1[0])
            return this;
        }, O.prototype.listeners = function(e) {
            var t1, o = this._events;
            return o && (t1 = o[e]) ? "function" == typeof t1 ? [
                t1.listener || t1
            ] : function(e) {
                for(var t1 = new Array(e.length), o = 0; o < t1.length; ++o)t1[o] = e[o].listener || e[o];
                return t1;
            }(t1) : [];
        }, O.listenerCount = function(e, t1) {
            return "function" == typeof e.listenerCount ? e.listenerCount(t1) : k.call(e, t1);
        }, O.prototype.listenerCount = k, O.prototype.eventNames = function() {
            return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        var N = function(e) {
            function t1(t1) {
                var o = e.call(this) || this;
                return o.timeout = (null == t1 ? void 0 : t1.timeout) || 3e4, o;
            }
            return r(t1, e), t1.prototype.clearTimeoutCheck = function() {
                this.timeoutTimer && (clearTimeout(this.timeoutTimer), this.timeoutTimer = null);
            }, t1.prototype.startTimeoutCheck = function() {
                var e = this;
                !this.timeoutTimer && !this.finished && this.timeout > 0 && (this.timeoutTimer = setTimeout(function() {
                    e.finished || (e.finished = !0, e.data = null, e.emit("timeout")), e.clearTimeoutCheck();
                }, this.timeout));
            }, t1;
        }(O), V = function(e) {
            function t1(t1) {
                var o = e.call(this, t1) || this;
                return o.uuid = c(), o.domParams = t1 || {}, o;
            }
            return r(t1, e), t1.prototype.jsonp = function() {
                var e = this;
                if (!this.finished) {
                    var t1 = this.domParams, o = t1.url, r = t1.jsonpCallbackName, i = void 0 === r ? "callback" : r, n = t1.body, s = t1.integrity;
                    this.script = document.createElement("script"), s && (this.script.integrity = s, this.script.crossOrigin = "anonymous");
                    var a = "";
                    n && Object.entries(n).forEach(function(e) {
                        var t1 = e[0], o = e[1];
                        a += (a ? "&" : "") + t1 + "=" + o;
                    }), a += (a ? "&" : "") + i + "=" + this.uuid, this.script.src = o + (o.includes("?") ? "" : "?") + a, this.jsonpCallback(), this.progressMonitory = w(function(t1) {
                        e.finished || e.emit("progressUpdated", t1);
                    }), document.body.appendChild(this.script);
                }
            }, t1.prototype.clearSideEffect = function(e) {
                if (void 0 === e && (e = !1), document.body.removeChild(this.script), e) {
                    var t1 = this.uuid;
                    window[this.uuid] = function() {
                        window[t1] && delete window[t1];
                    };
                } else delete window[this.uuid];
                this.script = null, this.uuid = null, this.finished = !0, this.data = null, this.clearTimeoutCheck();
            }, t1.prototype.jsonpCallback = function() {
                var e = this;
                this.script.onerror = function(t1) {
                    var o;
                    e.finished || (e.clearSideEffect(), null === (o = e.progressMonitory) || void 0 === o || o.abort(), e.emit("error", new Error("string" == typeof t1 ? t1 : "load jsonp script failed")));
                }, window[this.uuid] = function(t1) {
                    var o;
                    if (!e.finished) {
                        var r = e.domParams, i = r.encoding, n = r.blobType, s = r.unZipOptions, a = r.beforeTransformData, d = r.afterTransformData;
                        null === (o = e.progressMonitory) || void 0 === o || o.finish(), e.clearSideEffect(), (a ? a(t1 || "") : Promise.resolve(t1 || "")).then(function(t1) {
                            return R(t1, {
                                encoding: i,
                                blobType: n,
                                unZipOptions: s
                            }).then(function(t1) {
                                return (d ? d(t1) : Promise.resolve(t1)).then(function(t1) {
                                    return e.emit("finished", t1);
                                });
                            });
                        }).catch(function(t1) {
                            return e.emit("error", t1);
                        });
                    }
                };
            }, t1.prototype.abort = function() {
                this.clearSideEffect(!0);
            }, t1;
        }(N), U = function(e) {
            function t1(t1) {
                var o = e.call(this, t1) || this;
                return o.socketParams = t1 || {}, o;
            }
            return r(t1, e), t1.prototype.write = function(e, t1) {
                e && !this.finished && (e instanceof Error ? this.handleError(e) : (this.data ? this.appendData(e) : this.data = e, this.handlePerCentUpdate(t1)));
            }, t1.prototype.handlePerCentUpdate = function(e) {
                void 0 === e || this.finished || this.emit("progressUpdated", e);
            }, t1.prototype.handleError = function(e) {
                this.data = null, this.finished = !0, this.clearTimeoutCheck(), this.emit("error", e);
            }, t1.prototype.appendData = function(e) {
                u(e) === u(this.data) ? "string" == typeof e ? this.data += e : Blob && e instanceof Blob ? this.data = new Blob([
                    this.data,
                    e
                ], {
                    type: e.type
                }) : ArrayBuffer && e instanceof ArrayBuffer && (this.data = s(this.data, e)) : this.handleError(new Error("every piece of the data format must be the same"));
            }, t1.prototype.end = function(e) {
                var t1 = this;
                if (!this.finished) {
                    this.handlePerCentUpdate(100), e && this.write(e);
                    var o = this.socketParams, r = o.encoding, i = o.blobType, n = o.unZipOptions, s = o.beforeTransformData, a = o.afterTransformData;
                    (s ? s(this.data) : Promise.resolve(this.data)).then(function(e) {
                        return R(e, {
                            encoding: r,
                            blobType: i,
                            unZipOptions: n
                        }).then(function(e) {
                            return (a ? a(e) : Promise.resolve(e)).then(function(e) {
                                return t1.emit("finished", e);
                            });
                        });
                    }).catch(function(e) {
                        return t1.emit("error", e);
                    }), this.data = null, this.finished = !0, this.clearTimeoutCheck();
                }
            }, t1.prototype.abort = function() {
                this.data = null, this.finished = !0, this.clearTimeoutCheck();
            }, t1;
        }(N), j = function(t1) {
            function o(e) {
                var o = t1.call(this, e) || this;
                return o.xhrParams = e || {}, o.xhrParams.headers = n({}, o.xhrParams.headers || {}), o;
            }
            return r(o, t1), o.prototype.supportFetch = function() {
                return !!window.fetch && window.AbortController && window.Request;
            }, o.prototype.ajax = function() {
                var t1 = this;
                if (!this.finished) if (this.xhrParams.url) {
                    var o = this.xhrParams, r = o.headers, i = void 0 === r ? {} : r, s = o.url, a = o.body, d = void 0 === a ? {} : a, u = o.method, l = void 0 === u ? "POST" : u, c = o.encoding, p = o.integrity;
                    this.controller = this.supportFetch() ? new AbortController : new XMLHttpRequest;
                    var h = this.supportFetch() ? w(function(e) {
                        t1.finished || t1.emit("progressUpdated", e);
                    }) : null;
                    (this.supportFetch() ? fetch(new Request(s, n({
                        method: l,
                        headers: i,
                        body: "GET" === l ? void 0 : JSON.stringify(d),
                        signal: this.controller.signal
                    }, p ? {
                        integrity: p,
                        mode: "cors"
                    } : {}))).then(function(t1) {
                        return t1.ok ? c === e.TransformDataFormat.STRING ? t1.text() : c === e.TransformDataFormat.ARRAY_BUFFER ? t1.arrayBuffer() : t1.blob() : Promise.reject(new Error("xhr download " + s + " failed!"));
                    }) : new Promise(function(o, r) {
                        var n = new XMLHttpRequest;
                        t1.controller = n, n.open(l, s), n.responseType = c === e.TransformDataFormat.STRING ? "text" : c === e.TransformDataFormat.ARRAY_BUFFER ? "arraybuffer" : "blob", Object.entries(i).forEach(function(e) {
                            var t1 = e[0], o = e[1];
                            n.setRequestHeader(t1, o);
                        }), n.onload = function() {
                            var e = n.status, t1 = n.response, i = n.statusText;
                            e >= 200 && e < 300 || 304 === e ? o(t1) : r(new Error(e + ": " + i));
                        }, n.onprogress = function(e) {
                            var o = e || {}, r = o.total, i = o.loaded;
                            void 0 === i || t1.finished || (r ? t1.emit("progressUpdated", i / r * 100) : i && !h && (h = w(function(e) {
                                t1.finished || t1.emit("progressUpdated", e);
                            })));
                        }, n.onerror = function() {
                            r(new Error("xhr download " + s + " failed!"));
                        }, n.send(JSON.stringify(d));
                    })).then(function(e) {
                        if (!t1.finished) {
                            var o = t1.xhrParams, r = o.encoding, i = o.blobType, n = o.unZipOptions, s = o.beforeTransformData, a = o.afterTransformData;
                            null == h || h.finish(), t1.finished = !0, t1.clearTimeoutCheck(), (s ? s(e) : Promise.resolve(e)).then(function(e) {
                                return R(e, {
                                    encoding: r,
                                    blobType: i,
                                    unZipOptions: n
                                }).then(function(e) {
                                    return (a ? a(e) : Promise.resolve(e)).then(function(e) {
                                        return t1.emit("finished", e);
                                    });
                                });
                            }).catch(function(e) {
                                return t1.emit("error", e);
                            });
                        }
                    }).catch(function(e) {
                        t1.finished || (t1.finished = !0, t1.clearTimeoutCheck(), null == h || h.abort(), t1.emit("error", e));
                    });
                } else this.emit("error", new Error("xhrDownloader url params invalid!"));
            }, o.prototype.abort = function() {
                this.data = null, this.finished = !0, this.clearTimeoutCheck(), this.controller.abort();
            }, o;
        }(N), x = 0;
        O.defaultMaxListeners = 500;
        var B, F = new O, H = "ThreadPoolReady", $ = function() {
            x -= 1, F.emit(H);
        };
        (B = e.DownloaderType || (e.DownloaderType = {})).XHR = "xhr", B.DOM = "dom", B.SOCKET = "socket";
        var W = function(t1) {
            function o(o) {
                var r = t1.call(this) || this;
                return r.aborted = !1, r.downloadParmas = n({
                    type: e.DownloaderType.XHR
                }, o), r.id = c(), r;
            }
            return r(o, t1), o.prototype.start = function() {
                var t1 = this;
                x += 1, this.progress = 0, this.emit("downloadStart"), this.onDownloadStartCallback && this.onDownloadStartCallback();
                var o = this.downloadParmas, r = o.type, i = o.xhrParams, n = o.domParams, s = o.socketParams;
                switch(r){
                    case e.DownloaderType.DOM:
                        this.downloader = new V(n), this.downloader.jsonp();
                        break;
                    case e.DownloaderType.SOCKET:
                        this.downloader = new U(s);
                        break;
                    default:
                        this.downloader = new j(i), this.downloader.ajax();
                }
                return this.downloader.startTimeoutCheck(), this.downloader.on("error", function(e) {
                    t1.emit("error", e), t1.onErrorCallback && t1.onErrorCallback(e), $();
                }).on("finished", function(e) {
                    t1.emit("complete", e), t1.onCompleteCallback && t1.onCompleteCallback(e), $();
                }).on("progressUpdated", function(e) {
                    t1.progress = e, t1.emit("progressUpdated", e), t1.onProgressUpdatedCallback && t1.onProgressUpdatedCallback(e);
                }).on("timeout", function() {
                    t1.emit("timeout"), t1.onTimeoutCallback && t1.onTimeoutCallback(), $();
                }), this;
            }, o.prototype.abort = function() {
                if (this.aborted) return this;
                this.aborted = !0, this.downloader && !this.downloader.finished && this.downloader.abort();
                var e = new Error("file download has been aborted");
                return this.emit("abort", e), this.onAbortCallback && this.onAbortCallback(e), $(), this;
            }, o.prototype.onDownloadStart = function(e) {
                return this.onDownloadStartCallback = e, this;
            }, o.prototype.onProgressUpdated = function(e) {
                return this.onProgressUpdatedCallback = e, this;
            }, o.prototype.onError = function(e) {
                return this.onErrorCallback = e, this;
            }, o.prototype.onComplete = function(e) {
                return this.onCompleteCallback = e, this;
            }, o.prototype.onAbort = function(e) {
                return this.onAbortCallback = e, this;
            }, o.prototype.onTimeout = function(e) {
                return this.onTimeoutCallback = e, this;
            }, o.prototype.isInProgress = function() {
                return void 0 !== this.progress;
            }, o.prototype.isFinished = function() {
                return 100 === this.progress;
            }, o;
        }(O), G = function() {
            function e(e) {
                this.taskList = [], this.options = e || {};
                var t1 = this.options.threadLimit;
                if ((void 0 === t1 ? 6 : t1) > 6) throw new Error("threadLimit must be lower than 6");
                F.on(H, this.startNextTask.bind(this));
            }
            return e.prototype.download = function(e) {
                var t1 = new W(e), o = this.removeTask.bind(this, t1);
                return t1.on("abort", o), this.taskList.push(t1), this.checkTaskReady(t1), t1;
            }, e.prototype.startNextTask = function() {
                var e = this.taskList.find(function(e) {
                    return !e.isInProgress();
                });
                e && this.checkTaskReady(e);
            }, e.prototype.checkTaskReady = function(e) {
                var t1 = this.options.threadLimit, o = void 0 === t1 ? 6 : t1;
                if (!(this.taskList.findIndex(function(e) {
                    return !e.isInProgress();
                }) >= o || x + 1 > 6)) {
                    var r = this.removeTask.bind(this, e);
                    e.on("complete", r), e.on("error", r), e.on("timeout", r), setTimeout(function() {
                        return e.start();
                    }, 0);
                }
            }, e.prototype.removeTask = function(e) {
                var t1 = this;
                this.taskList.some(function(o, r) {
                    return o === e && (setTimeout(function() {
                        return e.removeAllListeners();
                    }, 0), t1.taskList.splice(r, 1), !0);
                });
            }, e;
        }();
        e.DownloadTask = W, e.IDownloadManager = G, e.appendBuffer = s, e.arrayBufferToBlob = m, e.arrayBufferToString = g, e.blobToArrayBuffer = p, e.blobToText = h, e.genUuid = c, e.getDataFormat = u, e.getExtName = y, e.getFileName = b, e.getFullPathName = S, e.isImgFile = E, e.isJsonFile = I, e.isVersionFile = A, e.monitorProgress = w, e.sep = a, e.stringToArrayBuffer = f, e.stringToBlob = v, e.transformData = R, Object.defineProperty(e, "__esModule", {
            value: !0
        });
    }(yy.exports, Sy)), yy.exports))), fy.exports);
    class Ey {
        constructor(e){
            this._cancelError = new Error("request for lock canceled"), this._locked = void 0, this._queue = [], this._waiters = [], this._currentReleaser = void 0, e && (this._cancelError = e), this._locked = !1;
        }
        acquire() {
            const e = this.isLocked(), t1 = new Promise((e, t1)=>this._queue.push({
                    resolve: e,
                    reject: t1
                }));
            return e || this._dispatch(), t1;
        }
        async runExclusive(e) {
            const t1 = await this.acquire();
            try {
                return await e();
            } finally{
                t1();
            }
        }
        async waitForUnlock() {
            return this.isLocked() ? new Promise((e)=>this._waiters.push({
                    resolve: e
                })) : Promise.resolve();
        }
        isLocked() {
            return this._locked;
        }
        release() {
            if (this._currentReleaser) {
                const e = this._currentReleaser;
                this._currentReleaser = void 0, e();
            }
        }
        cancel() {
            this._queue.forEach((e)=>e.reject(this._cancelError)), this._queue = [];
        }
        _dispatch() {
            const e = this._queue.shift();
            if (!e) return;
            let t1 = !1;
            this._currentReleaser = ()=>{
                t1 || (t1 = !0, this._locked = !1, this._resolveWaiters(), this._dispatch());
            }, this._locked = !0, e.resolve(this._currentReleaser);
        }
        _resolveWaiters() {
            this._waiters.forEach((e)=>e.resolve()), this._waiters = [];
        }
    }
    const Iy = (e, t1, o)=>We([
            t1,
            o
        ].map((t1, o)=>{
            if ("initial" !== t1) return _e([
                "success" === t1
            ]);
            {
                const t1 = 0 === o ? "ENCODE" : "DECODE";
                return rt(np(`${e.toUpperCase()}_${t1}_SUCCESS`, 1).pipe(Le(()=>!0)), np(`${e.toUpperCase()}_${t1}_FAIL`, 1).pipe(Le(()=>!1)));
            }
        })), Ay = (e)=>{
        const t1 = ah(e.value);
        return t1 ? Re(t1) : np(pa, 1).pipe(Ie(ee), ft(e), Le((e)=>{
            let [, t1] = e;
            return ah(t1);
        }));
    };
    function Cy(e, t1) {
        var o, r;
        const i = "audio" === e ? null === (o = t1.audio) || void 0 === o ? void 0 : o.audioSsrc : null === (r = t1.video) || void 0 === r ? void 0 : r.videoSsrc, n = "audio" === e ? sl : ku;
        return "audio" === e && vs() || i ? Promise.resolve() : ip(n);
    }
    const _y = ()=>_e(navigator.mediaDevices.enumerateDevices()).pipe(Le((e)=>{
            const t1 = [], o = [], r = [];
            return e.forEach((e)=>{
                const { kind: i, deviceId: n, label: s } = e, a = s.replace(/\([\w,\d]+:[\w,\d]+\)/i, "").trim();
                switch(i){
                    case "audioinput":
                        "communications" === n || /ZoomAudioDevice/i.test(a) || /Zoom-\S*/.test(a) || /CubebAggregateDevice\S*/.test(a) || /Microsoft Teams Audio/i.test(a) || t1.push({
                            deviceId: n,
                            label: a
                        });
                        break;
                    case "audiooutput":
                        "communications" === n || /ZoomAudioDevice/i.test(a) || /Microsoft Teams Audio/i.test(a) || o.push({
                            deviceId: n,
                            label: a
                        });
                        break;
                    case "videoinput":
                        r.push({
                            deviceId: n,
                            label: a
                        });
                }
            }), {
                microphones: t1,
                speakers: o,
                cameras: r
            };
        }));
    function Ry(e) {
        const { x: t1, y: o, width: r, height: i } = e.getBoundingClientRect();
        return {
            scaleWidth: r,
            scaleHeight: i,
            srcOffsetX: t1,
            srcOffsetY: o
        };
    }
    function wy(e) {
        if (e) {
            let o = e;
            try {
                const t1 = e.width;
                e.width = t1;
            } catch (r) {
                var t1;
                o = e.cloneNode(!0), null === (t1 = e.parentNode) || void 0 === t1 || t1.replaceChild(o, e);
            }
            return o;
        }
        return e;
    }
    function Ty() {
        try {
            return "undefined" != typeof MessageChannel && (new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(gd);
        } catch (e) {
            return !1;
        }
    }
    function Oy() {
        var e;
        return null === (e = WebAssembly) || void 0 === e ? void 0 : e.validate(vd);
    }
    const Dy = (()=>{
        const e = new Ey;
        return {
            withAudioAction: (t1)=>function() {
                    for(var o = arguments.length, r = new Array(o), i = 0; i < o; i++)r[i] = arguments[i];
                    return new Promise(async (o, i)=>{
                        let n = !1;
                        const s = setTimeout(()=>{
                            n = !0, e.release();
                        }, 3e4);
                        try {
                            await e.acquire(), n || clearTimeout(s), o(t1(...r));
                        } catch (e) {
                            n || (clearTimeout(s), i(e));
                        }
                    });
                },
            processAudioAction: (t1)=>e.acquire().then(()=>t1()),
            completeAudioAction: ()=>{
                e.release();
            },
            cancelAllAudioAction: ()=>{
                e.cancel();
            }
        };
    })();
    function Py(e) {
        const t1 = [
            "joinComputerAudio",
            "joinSharingAudio",
            "leaveComputerAudio",
            "leaveSharingAudio"
        ];
        return new Proxy(e, {
            get: (e, o)=>"string" == typeof o && t1.includes(o) ? function() {
                    return Dy.withAudioAction(e[o].bind(e))(...arguments);
                } : Reflect.get(e, o)
        });
    }
    function My(e) {
        var t1;
        const { browserVersion: o, isChrome: r, isFirefox: i, isSafari: n, isAndroidOrIOSBrowser: s, isSupportMediaStreamTrackProcessor: a, isSupportOffscreenCanvas: d } = gs, u = Number(null == o || null === (t1 = o.match(/^\d+/)) || void 0 === t1 ? void 0 : t1[0]), l = r && u >= 91, c = i && u >= 89, p = n && Jr(o, "17.4") >= 0, h = navigator.hardwareConcurrency > 2;
        let m = ys();
        return e && !m && (m = d && a), !s && m && (l || c || p) && h;
    }
    const ky = (e, t1)=>{
        const o = document.createElement("link");
        return o.rel = "preload", o.href = e, o.as = t1, o.crossOrigin = "anonymous", o;
    }, Ly = (e, t1, o)=>{
        const r = [], i = [], n = Array.isArray(e) ? e : [
            e
        ];
        return sa.filter((e)=>{
            var o;
            return n.includes(e.category) && (e.tag === t1 || (null === (o = e.tag) || void 0 === o ? void 0 : o.split(",").includes(t1)));
        }).forEach((e)=>{
            "worker" === e.type ? r.push(`${o}${e.name}`) : "wasm" === e.type && i.push(`${o}${e.name}`);
        }), {
            workers: r,
            wasms: i
        };
    };
    function Ny(e, t1, o) {
        const r = {};
        if ("function" != typeof window.SharedArrayBuffer) {
            const { isIOSMobile: e, isSafari: i, isSupportOffscreenCanvas: n, isSupportMediaStreamTrackProcessor: s } = gs, a = e || i || n && s;
            Object.assign(r, {
                enableMultiDecodeVideoWithoutSAB: !!t1 && a
            }), n && s && Object.assign(r, {
                enableVirtualBackgroundWithoutSAB: !!o
            });
        }
        return My(o) && Object.assign(r, {
            resourceManager: by.IResourceManager,
            file: [
                {
                    path: `${e}/vb-resource/dualModel.bin`,
                    type: "bin"
                },
                {
                    path: `${e}/vb-resource/tf.min.js`,
                    type: "js"
                }
            ]
        }), r;
    }
    function Vy(e, t1) {
        const { media: { isAudioBridgeReceiveReady: o, isAudioBridgeSendReady: r }, audio: { customizeAudioOption: i } } = e, n = void 0 !== t1 ? t1 : !(null == i || !i.speakerOnly);
        return We([
            o ? _e([
                !0
            ]) : np(pc, 1).pipe(at(!0)),
            r || n ? _e([
                !0
            ]) : np(hc, 1).pipe(at(!0))
        ]);
    }
    function Uy(e, t1, o) {
        if (e.deviceId === t1) return !0;
        if ("default" === t1) {
            const r = o.find((e)=>e.deviceId === t1);
            if (r) return r.label.indexOf(e.label) > -1;
        }
        return !1;
    }
    function jy(e) {
        return e.find((e)=>"default" === e.deviceId);
    }
    const xy = (()=>{
        let e, t1 = !1;
        return {
            watch: function(o) {
                t1 = !0, e = Promise.race([
                    o,
                    Xr(()=>!0, 1e4)
                ]).then(()=>{
                    e = void 0, t1 = !1;
                }).finally(()=>{
                    e = void 0, t1 = !1;
                });
            },
            acquire: function() {
                return t1 && e ? e : Promise.resolve();
            }
        };
    })(), By = (e, t1)=>ip({
            event: Ca,
            operations: [
                ot((t1)=>void 0 !== t1[`${e}`]),
                nt(1)
            ]
        }, (o)=>o[`${e}`] === t1);
    function Fy(e, t1, o, r) {
        const i = {
            play: ()=>e.play(),
            pause: ()=>e.pause(),
            get paused () {
                return e.paused;
            },
            get muted () {
                return e.muted;
            },
            set muted (t){
                e.muted = t;
            },
            get currentTime () {
                return e.currentTime;
            },
            set currentTime (t){
                e.currentTime = t;
            },
            get loop () {
                return e.loop;
            },
            set loop (t){
                e.loop = t;
            }
        };
        if ("audio" === t1) {
            const { audio: { mediaPlaybackFile: t1 } } = o;
            Object.defineProperty(i, "playback", {
                get () {
                    const o = e.dataset.playback;
                    return void 0 !== o ? "1" === o : !(null == t1 || !t1.playback);
                },
                set (t1) {
                    r.enablePlayAudioFileLocally(t1), e.dataset.playback = t1 ? "1" : "0";
                }
            });
        }
        return i;
    }
    function Hy() {
        var e, t1;
        return "orientation" in window.screen ? null === (e = screen.orientation.type) || void 0 === e ? void 0 : e.startsWith("landscape") : "orientation" in window ? 90 === Math.abs(window.orientation) : "matchMedia" in window ? !(null === (t1 = window.matchMedia("(orientation: landscape)")) || void 0 === t1 || !t1.matches) : screen.availWidth > screen.availHeight;
    }
    function $y() {
        return "orientation" in window.screen ? qe(screen.orientation, "change").pipe(mt(sp()), Le(()=>{
            var e;
            return null === (e = screen.orientation.type) || void 0 === e ? void 0 : e.startsWith("landscape");
        })) : qe(window, "orientationchange").pipe(mt(sp()), Le((e)=>{
            var t1;
            const o = null === (t1 = e.target) || void 0 === t1 || null === (t1 = t1.screen) || void 0 === t1 || null === (t1 = t1.orientation) || void 0 === t1 ? void 0 : t1.angle;
            return 90 === Math.abs(o);
        }));
    }
    class Wy {
        constructor(){
            this.audioPlaybackUrl = void 0, this.videoPlaybackUrl = void 0, this._audioElement = void 0, this._videoElement = void 0, this.videoSrc = void 0, this.isUsingSameFile = void 0;
        }
        static getInstance() {
            return void 0 === this.instance && (this.instance = new Wy), this.instance;
        }
        static destroyInstance() {
            if (this.instance) {
                this.instance.stopAudioElement(), this.instance.stopVideoElement();
                const t1 = document.getElementById(Md);
                var e;
                t1 && (null === (e = t1.parentNode) || void 0 === e || e.removeChild(t1)), this.instance = void 0;
            }
        }
        setAudioElement(e) {
            return void 0 === this._audioElement && (this._audioElement = new Audio), new Promise((t1, o)=>{
                if (this.videoSrc === e.url) this._audioElement.pause(), this.isUsingSameFile = !0, this._videoElement.muted = !1, (i = this._videoElement).currentTime > 0 && !i.paused && !i.ended && i.readyState > 2 ? t1("") : this._videoElement.play().then(()=>{
                    t1("");
                }).catch(()=>{
                    o();
                });
                else {
                    var r;
                    this.isUsingSameFile = !1;
                    const i = gs.isFirefox ? "canplay" : "canplaythrough", n = ()=>{
                        this._audioElement.play().then(()=>{
                            this._audioElement.removeEventListener(i, n), t1("");
                        });
                    }, s = ()=>{
                        this._audioElement.removeEventListener(i, n), this._audioElement.removeEventListener("error", s), o();
                    };
                    this._audioElement.addEventListener(i, n), this._audioElement.addEventListener("error", s), this._audioElement.src = e.url, this._audioElement.loop = !!e.loop, ti(e.url) && this._audioElement.setAttribute("crossorigin", ""), this._audioElement.currentTime = Math.max(null !== (r = e.currentTime) && void 0 !== r ? r : 0, 1e-4), gs.isIOSMobile && this._audioElement.load();
                }
                var i;
            });
        }
        setVideoElement(e) {
            return void 0 === this._videoElement && (this._videoElement = document.createElement("video")), new Promise((t1, o)=>{
                var r;
                this.videoSrc = e.url;
                const i = gs.isFirefox ? "canplay" : "canplaythrough", n = ()=>{
                    this._videoElement.play().then(()=>{
                        this._videoElement.removeEventListener(i, n), t1("");
                    });
                }, s = ()=>{
                    this._videoElement.removeEventListener(i, n), this._videoElement.removeEventListener("error", s), o();
                };
                this._videoElement.addEventListener(i, n), this._videoElement.addEventListener("error", s), this._videoElement.src = e.url, this.isUsingSameFile || (this._videoElement.muted = !0), this._videoElement.loop = !!e.loop, this._videoElement.currentTime = Math.max(null !== (r = e.currentTime) && void 0 !== r ? r : 0, 1e-4), this._videoElement.playsInline = !0, ti(e.url) && this._videoElement.setAttribute("crossorigin", ""), gs.isSafari && !document.getElementById(Md) && (this._videoElement.id = Md, this._videoElement.setAttribute("style", "position:fixed;top:-10000px;left:-10000px"), document.body.appendChild(this._videoElement)), gs.isIOSMobile && this._videoElement.load();
            });
        }
        get audioElement() {
            return this.isUsingSameFile ? this._videoElement : this._audioElement;
        }
        get videoElement() {
            return this._videoElement;
        }
        stopAudioElement() {
            this.isUsingSameFile || this._audioElement && (this._audioElement.currentTime = 0, this._audioElement.pause());
        }
        stopVideoElement() {
            this._videoElement && this._videoElement.pause(), this.videoSrc = void 0;
        }
    }
    Wy.instance = void 0;
    const Gy = function(e) {
        let t1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const { socket: { zoomSocketStatus: o, xmppSocketStatus: r, mainSessionSocketStatus: i }, meeting: { meetingStatus: n } } = e, s = [];
        if (n === Xn.Joined) {
            var a;
            const t1 = ca.getInstance(), o = ia.createAgent();
            if ((null === (a = ah(e)) || void 0 === a ? void 0 : a.audio) === Wd.Computer && t1.leaveComputerAudio(), t1.disconnect(), xy.watch(t1.destroy()), e.video && (e.video.subscribedVideoList.length > 0 && e.video.subscribedVideoList.forEach((e)=>{
                o.unsubscribeVideo(e);
            }), e.video.isCurrentUserStartedVideo && tp(gu)), e.share && e.share.isReceiveSharing) {
                const t1 = e.share.activeNodeId;
                e.share.remoteControlledUserList.length > 0 && e.share.remoteControlledUserList.forEach((e)=>{
                    o.sharingRequestRemoteControl(e, !1);
                }), o.unsubscribeSharing(t1);
            }
            Wy.destroyInstance();
        }
        if (t1 || (ns.clearSession(), [
            ss.WebclientTk,
            ss.WebclientZsk,
            ss.WebclientZtk,
            ss.WebclientRecordingToken
        ].forEach((e)=>{
            sessionStorage.removeItem(e);
        }), Ts.destroy()), o !== Sh.Closed && s.push(Ao()), r !== Sh.Closed && s.push(Co()), i !== Sh.Closed && s.push(Oo()), t1) {
            const o = ah(e);
            s.push(In({
                audio: null == o ? void 0 : o.audio,
                muted: null == o ? void 0 : o.muted,
                video: null == o ? void 0 : o.bVideoOn,
                isFailover: t1
            }));
        } else s.push(In({
            audio: !1,
            muted: void 0,
            video: !1,
            isFailover: t1
        }));
        return s.push(Vo(), tr(), Ap(), Uh(t1), Qm(), dg(t1), cv(), gv(), Cf(), Fv(), ef(), Tf(), Vf(), Zf(t1), dy(), cy(t1), my(t1), Dn(Xn.Closed)), s;
    }, Ky = function(e) {
        for(var t1 = arguments.length, o = new Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
        return ip({
            event: ga,
            operations: [
                Le((t1)=>t1.find((t1)=>t1.userId === e.userId && (!e.key || void 0 !== t1[`${e.key}`]))),
                ot((e)=>!!e),
                nt(1)
            ]
        }, ...o);
    }, zy = {
        [`${es.AudioBridgeEnable}`]: {
            mask: 240,
            action: Un
        },
        [`${es.AudioDecodeInWorklet}`]: {
            mask: 15,
            action: zo
        },
        [`${es.VideoFullHD}`]: {
            mask: 15,
            action: Wg
        },
        [`${es.VideoShareFullHD}`]: {
            mask: 15,
            action: Jm
        },
        [`${es.WebGL2Render}`]: {
            mask: 15,
            action: zg
        },
        [`${es.WebGPURender}`]: {
            mask: 15,
            action: qg
        },
        [`${es.ZMKFromRWG}`]: {
            mask: 15,
            action: Kn
        }
    };
    function qy(e) {
        if (!e) return "";
        const t1 = e.match(/rid=(.*)/);
        return t1 ? t1[1] : "";
    }
    function Jy(e) {
        return O(Le((t1, o)=>e(t1, o)), ot((e)=>null != e));
    }
    function Qy(e) {
        return O(Fe((t1, o)=>e(t1, o) || ne));
    }
    function Zy(e) {
        return O(Fe((t1, o)=>e(t1, o)), Fe((e)=>Array.isArray(e) ? _e(e) : Re(e)));
    }
    const Yy = {
        period: 500,
        rules: [
            {
                peak: 50,
                throttle: 300
            },
            {
                peak: 60,
                throttle: 400
            }
        ]
    }, Xy = {
        [`${Ps}`]: ()=>({
                payloads: {
                    add: [],
                    update: [],
                    remove: []
                },
                onThrottle (e) {
                    e.add && this.payloads.add.push(...e.add), e.update && this.payloads.update.push(...e.update), e.remove && this.payloads.remove.push(...e.remove);
                }
            })
    };
    function eS() {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yy;
        return (t1)=>new P((o)=>{
                const r = new Map;
                let i = 0, n = null;
                const { period: s, rules: a } = e;
                let d = null;
                n || (n = ((e, t1)=>{
                    const o = performance.now();
                    let r = 0, i = !1;
                    return setTimeout(function n() {
                        r += t1, e();
                        const s = performance.now() - o - r, a = setTimeout(n, Math.max(t1 - s, 0));
                        i && clearTimeout(a);
                    }, t1), ()=>{
                        i = !0;
                    };
                })(()=>{
                    i = 0;
                }, s));
                const u = Object.keys(Xy), l = t1.subscribe({
                    next (e) {
                        if (e && e.evt && null !== n) {
                            i += 1;
                            const { evt: t1, body: n } = e, s = String(t1);
                            if (u.indexOf(s) >= 0) if (d) {
                                const e = r.get(s);
                                if (e) e.onThrottle(n);
                                else {
                                    const e = Xy[s]();
                                    e.onThrottle(n), r.set(s, e);
                                }
                            } else {
                                let t1 = 0;
                                if (a.forEach((e)=>{
                                    i > e.peak && (t1 = e.throttle);
                                }), t1 > 0) {
                                    const e = Xy[s]();
                                    e.onThrottle(n), r.set(s, e), d = setTimeout(()=>{
                                        r.forEach((e, t1)=>{
                                            const r = {
                                                evt: Number(t1),
                                                body: e.payloads
                                            };
                                            o.next(r);
                                        }), r.clear(), d = null;
                                    }, t1);
                                } else o.next(e);
                            }
                            else o.next(e);
                        } else o.next(e);
                    },
                    error (e) {
                        o.error(e);
                    },
                    complete () {
                        o.complete();
                    }
                });
                return ()=>{
                    l.unsubscribe(), n && (n(), n = null), i = 0;
                };
            });
    }
    let tS = function(e) {
        return e[e.Unknown = 0] = "Unknown", e[e.Windows = 1] = "Windows", e[e.Mac = 2] = "Mac", e[e.Pad = 3] = "Pad", e[e.Mobile = 4] = "Mobile", e[e.CallIn = 5] = "CallIn", e[e.Linux = 6] = "Linux", e[e.WebClient = 7] = "WebClient", e[e.ChromeOs = 8] = "ChromeOs", e;
    }({});
    const oS = 262144, rS = 1048576, iS = (e)=>!(4 & ~e), nS = (e)=>(e & rS) === rS, sS = (e)=>{
        let { share: { isReceiveSharing: t1 } } = e;
        return t1;
    }, aS = (e)=>{
        let { share: { activeNodeId: t1 } } = e;
        return t1;
    }, dS = Vp([
        ph,
        sS,
        aS
    ], function() {
        let e = arguments.length > 2 ? arguments[2] : void 0;
        if (arguments.length > 1 ? arguments[1] : void 0) {
            const t1 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).find((t1)=>t1.userId === e && !0 === t1.sharerOn);
            if (t1) {
                let { os: e } = t1;
                const { pwaOS: o } = t1;
                return "mac" === o ? e = tS.Mac : "win" === o && (e = tS.Windows), {
                    ...t1,
                    os: e
                };
            }
        }
        return null;
    }), uS = Vp([
        ph
    ], (e)=>e.filter((e)=>e.sharerOn)), lS = Vp([
        uS
    ], (e)=>e.some((e)=>!!e.bVideoShare)), cS = Vp([
        (e)=>{
            let { share: { remoteControlledUserList: t1 } } = e;
            return t1;
        },
        sS,
        aS
    ], (e, t1, o)=>!!t1 && e.some((e)=>Yr(e, o)));
    var pS, hS = new Uint8Array(16);
    function mS() {
        if (!pS && !(pS = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return pS(hS);
    }
    for(var gS = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, vS = [], fS = 0; fS < 256; ++fS)vS.push((fS + 256).toString(16).substr(1));
    function yS(e, t1, o) {
        var r = (e = e || {}).random || (e.rng || mS)();
        return r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, function(e) {
            var t1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, o = (vS[e[t1 + 0]] + vS[e[t1 + 1]] + vS[e[t1 + 2]] + vS[e[t1 + 3]] + "-" + vS[e[t1 + 4]] + vS[e[t1 + 5]] + "-" + vS[e[t1 + 6]] + vS[e[t1 + 7]] + "-" + vS[e[t1 + 8]] + vS[e[t1 + 9]] + "-" + vS[e[t1 + 10]] + vS[e[t1 + 11]] + vS[e[t1 + 12]] + vS[e[t1 + 13]] + vS[e[t1 + 14]] + vS[e[t1 + 15]]).toLowerCase();
            if (!function(e) {
                return "string" == typeof e && gS.test(e);
            }(o)) throw TypeError("Stringified UUID is invalid");
            return o;
        }(r);
    }
    function SS(e) {
        var t1 = typeof e;
        return null != e && ("object" == t1 || "function" == t1);
    }
    var bS = "object" == typeof global && global && global.Object === Object && global, ES = "object" == typeof self && self && self.Object === Object && self, IS = bS || ES || Function("return this")(), AS = function() {
        return IS.Date.now();
    }, CS = /\s/, _S = /^\s+/;
    var RS = IS.Symbol, wS = Object.prototype, TS = wS.hasOwnProperty, OS = wS.toString, DS = RS ? RS.toStringTag : void 0, PS = Object.prototype.toString, MS = RS ? RS.toStringTag : void 0;
    function kS(e) {
        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : MS && MS in Object(e) ? function(e) {
            var t1 = TS.call(e, DS), o = e[DS];
            try {
                e[DS] = void 0;
                var r = !0;
            } catch (e) {}
            var i = OS.call(e);
            return r && (t1 ? e[DS] = o : delete e[DS]), i;
        }(e) : function(e) {
            return PS.call(e);
        }(e);
    }
    function LS(e) {
        return null != e && "object" == typeof e;
    }
    var NS = /^[-+]0x[0-9a-f]+$/i, VS = /^0b[01]+$/i, US = /^0o[0-7]+$/i, jS = parseInt;
    function xS(e) {
        if ("number" == typeof e) return e;
        if (function(e) {
            return "symbol" == typeof e || LS(e) && "[object Symbol]" == kS(e);
        }(e)) return NaN;
        if (SS(e)) {
            var t1 = "function" == typeof e.valueOf ? e.valueOf() : e;
            e = SS(t1) ? t1 + "" : t1;
        }
        if ("string" != typeof e) return 0 === e ? e : +e;
        e = function(e) {
            return e ? e.slice(0, function(e) {
                for(var t1 = e.length; t1-- && CS.test(e.charAt(t1)););
                return t1;
            }(e) + 1).replace(_S, "") : e;
        }(e);
        var o = VS.test(e);
        return o || US.test(e) ? jS(e.slice(2), o ? 2 : 8) : NS.test(e) ? NaN : +e;
    }
    var BS, FS, HS, $S, WS = Math.max, GS = Math.min;
    !function(e) {
        e[e.PLAIN = 0] = "PLAIN", e[e.RSA = 1] = "RSA", e[e.AESGCM256 = 2] = "AESGCM256";
    }(BS || (BS = {})), function(e) {
        e[e.info = 0] = "info", e[e.debug = 1] = "debug", e[e.log = 2] = "log", e[e.warn = 3] = "warn", e[e.error = 4] = "error";
    }(FS || (FS = {})), function(e) {
        e[e.PROTECT_LOCAL_KEY = 0] = "PROTECT_LOCAL_KEY";
    }(HS || (HS = {})), function(e) {
        e.beforeInit = "beforeInit", e.afterInit = "afterInit", e.beforeLog = "beforeLog", e.hitSizeLimit = "hitSizeLimit", e.afterLog = "afterLog", e.beforeReport = "beforeReport", e.afterReport = "afterReport";
    }($S || ($S = {}));
    class KS {
        constructor(){}
    }
    var zS, qS, JS = {
        exports: {}
    }, QS = {
        exports: {}
    }, ZS = xt(Object.freeze({
        __proto__: null,
        default: {}
    }));
    function YS() {
        return zS || (zS = 1, QS.exports = (e = e || function(e) {
            var t1;
            if ("undefined" != typeof window && window.crypto && (t1 = window.crypto), "undefined" != typeof self && self.crypto && (t1 = self.crypto), "undefined" != typeof globalThis && globalThis.crypto && (t1 = globalThis.crypto), !t1 && "undefined" != typeof window && window.msCrypto && (t1 = window.msCrypto), !t1 && void 0 !== Ut && Ut.crypto && (t1 = Ut.crypto), !t1) try {
                t1 = ZS;
            } catch (e) {}
            var o = function() {
                if (t1) {
                    if ("function" == typeof t1.getRandomValues) try {
                        return t1.getRandomValues(new Uint32Array(1))[0];
                    } catch (e) {}
                    if ("function" == typeof t1.randomBytes) try {
                        return t1.randomBytes(4).readInt32LE();
                    } catch (e) {}
                }
                throw new Error("Native crypto module could not be used to get secure random number.");
            }, r = Object.create || function() {
                function e() {}
                return function(t1) {
                    var o;
                    return e.prototype = t1, o = new e, e.prototype = null, o;
                };
            }(), i = {}, n = i.lib = {}, s = n.Base = {
                extend: function(e) {
                    var t1 = r(this);
                    return e && t1.mixIn(e), t1.hasOwnProperty("init") && this.init !== t1.init || (t1.init = function() {
                        t1.$super.init.apply(this, arguments);
                    }), t1.init.prototype = t1, t1.$super = this, t1;
                },
                create: function() {
                    var e = this.extend();
                    return e.init.apply(e, arguments), e;
                },
                init: function() {},
                mixIn: function(e) {
                    for(var t1 in e)e.hasOwnProperty(t1) && (this[t1] = e[t1]);
                    e.hasOwnProperty("toString") && (this.toString = e.toString);
                },
                clone: function() {
                    return this.init.prototype.extend(this);
                }
            }, a = n.WordArray = s.extend({
                init: function(e, t1) {
                    e = this.words = e || [], this.sigBytes = null != t1 ? t1 : 4 * e.length;
                },
                toString: function(e) {
                    return (e || u).stringify(this);
                },
                concat: function(e) {
                    var t1 = this.words, o = e.words, r = this.sigBytes, i = e.sigBytes;
                    if (this.clamp(), r % 4) for(var n = 0; n < i; n++){
                        var s = o[n >>> 2] >>> 24 - n % 4 * 8 & 255;
                        t1[r + n >>> 2] |= s << 24 - (r + n) % 4 * 8;
                    }
                    else for(var a = 0; a < i; a += 4)t1[r + a >>> 2] = o[a >>> 2];
                    return this.sigBytes += i, this;
                },
                clamp: function() {
                    var t1 = this.words, o = this.sigBytes;
                    t1[o >>> 2] &= 4294967295 << 32 - o % 4 * 8, t1.length = e.ceil(o / 4);
                },
                clone: function() {
                    var e = s.clone.call(this);
                    return e.words = this.words.slice(0), e;
                },
                random: function(e) {
                    for(var t1 = [], r = 0; r < e; r += 4)t1.push(o());
                    return new a.init(t1, e);
                }
            }), d = i.enc = {}, u = d.Hex = {
                stringify: function(e) {
                    for(var t1 = e.words, o = e.sigBytes, r = [], i = 0; i < o; i++){
                        var n = t1[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        r.push((n >>> 4).toString(16)), r.push((15 & n).toString(16));
                    }
                    return r.join("");
                },
                parse: function(e) {
                    for(var t1 = e.length, o = [], r = 0; r < t1; r += 2)o[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4;
                    return new a.init(o, t1 / 2);
                }
            }, l = d.Latin1 = {
                stringify: function(e) {
                    for(var t1 = e.words, o = e.sigBytes, r = [], i = 0; i < o; i++){
                        var n = t1[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        r.push(String.fromCharCode(n));
                    }
                    return r.join("");
                },
                parse: function(e) {
                    for(var t1 = e.length, o = [], r = 0; r < t1; r++)o[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8;
                    return new a.init(o, t1);
                }
            }, c = d.Utf8 = {
                stringify: function(e) {
                    try {
                        return decodeURIComponent(escape(l.stringify(e)));
                    } catch (e) {
                        throw new Error("Malformed UTF-8 data");
                    }
                },
                parse: function(e) {
                    return l.parse(unescape(encodeURIComponent(e)));
                }
            }, p = n.BufferedBlockAlgorithm = s.extend({
                reset: function() {
                    this._data = new a.init, this._nDataBytes = 0;
                },
                _append: function(e) {
                    "string" == typeof e && (e = c.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes;
                },
                _process: function(t1) {
                    var o, r = this._data, i = r.words, n = r.sigBytes, s = this.blockSize, d = n / (4 * s), u = (d = t1 ? e.ceil(d) : e.max((0 | d) - this._minBufferSize, 0)) * s, l = e.min(4 * u, n);
                    if (u) {
                        for(var c = 0; c < u; c += s)this._doProcessBlock(i, c);
                        o = i.splice(0, u), r.sigBytes -= l;
                    }
                    return new a.init(o, l);
                },
                clone: function() {
                    var e = s.clone.call(this);
                    return e._data = this._data.clone(), e;
                },
                _minBufferSize: 0
            });
            n.Hasher = p.extend({
                cfg: s.extend(),
                init: function(e) {
                    this.cfg = this.cfg.extend(e), this.reset();
                },
                reset: function() {
                    p.reset.call(this), this._doReset();
                },
                update: function(e) {
                    return this._append(e), this._process(), this;
                },
                finalize: function(e) {
                    return e && this._append(e), this._doFinalize();
                },
                blockSize: 16,
                _createHelper: function(e) {
                    return function(t1, o) {
                        return new e.init(o).finalize(t1);
                    };
                },
                _createHmacHelper: function(e) {
                    return function(t1, o) {
                        return new h.HMAC.init(e, o).finalize(t1);
                    };
                }
            });
            var h = i.algo = {};
            return i;
        }(Math), e)), QS.exports;
        "TURBOPACK unreachable";
        var e;
    }
    var XS, eb, tb = qS ? JS.exports : (qS = 1, JS.exports = YS().enc.Utf8), ob = {
        exports: {}
    }, rb = (XS || (XS = 1, ob.exports = (eb = YS(), function() {
        var e = eb, t1 = e.lib.WordArray;
        function o(e, o, r) {
            for(var i = [], n = 0, s = 0; s < o; s++)if (s % 4) {
                var a = r[e.charCodeAt(s - 1)] << s % 4 * 2 | r[e.charCodeAt(s)] >>> 6 - s % 4 * 2;
                i[n >>> 2] |= a << 24 - n % 4 * 8, n++;
            }
            return t1.create(i, n);
        }
        e.enc.Base64 = {
            stringify: function(e) {
                var t1 = e.words, o = e.sigBytes, r = this._map;
                e.clamp();
                for(var i = [], n = 0; n < o; n += 3)for(var s = (t1[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 16 | (t1[n + 1 >>> 2] >>> 24 - (n + 1) % 4 * 8 & 255) << 8 | t1[n + 2 >>> 2] >>> 24 - (n + 2) % 4 * 8 & 255, a = 0; a < 4 && n + .75 * a < o; a++)i.push(r.charAt(s >>> 6 * (3 - a) & 63));
                var d = r.charAt(64);
                if (d) for(; i.length % 4;)i.push(d);
                return i.join("");
            },
            parse: function(e) {
                var t1 = e.length, r = this._map, i = this._reverseMap;
                if (!i) {
                    i = this._reverseMap = [];
                    for(var n = 0; n < r.length; n++)i[r.charCodeAt(n)] = n;
                }
                var s = r.charAt(64);
                if (s) {
                    var a = e.indexOf(s);
                    -1 !== a && (t1 = a);
                }
                return o(e, t1, i);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
    }(), eb.enc.Base64)), ob.exports), ib = function(e, t1, o, r) {
        return new (o || (o = Promise))(function(i, n) {
            function s(e) {
                try {
                    d(r.next(e));
                } catch (e) {
                    n(e);
                }
            }
            function a(e) {
                try {
                    d(r.throw(e));
                } catch (e) {
                    n(e);
                }
            }
            function d(e) {
                var t1;
                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                    e(t1);
                })).then(s, a);
            }
            d((r = r.apply(e, t1 || [])).next());
        });
    };
    const nb = (e)=>{
        try {
            const t1 = rb.parse(e);
            return tb.stringify(t1);
        } catch (t1) {
            return e;
        }
    }, sb = (e)=>{
        for(var t1 = e.length, o = e.length - 1; o >= 0; o--){
            var r = e.charCodeAt(o);
            r > 127 && r <= 2047 ? t1++ : r > 2047 && r <= 65535 && (t1 += 2), r >= 56320 && r <= 57343 && o--;
        }
        return t1;
    }, ab = ()=>ib(void 0, void 0, void 0, function*() {
            return yield self.crypto.subtle.generateKey({
                name: "AES-GCM",
                length: 256
            }, !0, [
                "encrypt",
                "decrypt"
            ]);
        }), db = (e, t1, o)=>ib(void 0, void 0, void 0, function*() {
            try {
                return yield self.crypto.subtle.encrypt({
                    name: "AES-GCM",
                    iv: o
                }, t1, e);
            } catch (e) {
                throw e;
            }
        }), ub = (e, t1)=>{
        const o = "string" == typeof e ? function(e) {
            const t1 = new ArrayBuffer(e.length), o = new Uint8Array(t1);
            for(let t1 = 0, r = e.length; t1 < r; t1++)o[t1] = e.charCodeAt(t1);
            return t1;
        }(e) : e;
        return self.crypto.subtle.encrypt({
            name: "RSA-OAEP"
        }, t1, o);
    }, lb = {}, cb = (e, t1)=>{
        lb[t1] = e;
    }, pb = lb, hb = (e)=>{
        try {
            return JSON.stringify(e);
        } catch (e) {
            return "json stringify failed";
        }
    }, mb = (e)=>{
        try {
            return JSON.parse(e);
        } catch (t1) {
            return e;
        }
    };
    const gb = (e)=>{
        let t1 = 0;
        return t1 += sb(e.message), e.tags.forEach((e)=>{
            t1 += sb(e);
        }), t1;
    };
    class vb {
        constructor(e){
            this.uuid = "randomUUID" in self.crypto ? self.crypto.randomUUID() : "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (e)=>(e ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e / 4).toString(16));
            const { databaseName: t1, maxSize: o, publicKey: r, reportUrl: i, plugins: n, idbManager: s, logManager: a, currentSize: d, externalKeys: u, codecWorkerFilePath: l } = e;
            this.databaseName = t1, this.maxSize = o, this.publicKey = null != r ? r : "", this.reportUrl = null != i ? i : "", this.plugins = null != n ? n : [], this.idbManager = s, this.logManager = a, this.currentSize = null != d ? d : 0, this.externalKeys = u, this.commonMethods = Object.assign({}, pb);
        }
        getLocalAESGCM256Key() {
            var e;
            return function(e, t1, o, r) {
                return new (o || (o = Promise))(function(i, n) {
                    function s(e) {
                        try {
                            d(r.next(e));
                        } catch (e) {
                            n(e);
                        }
                    }
                    function a(e) {
                        try {
                            d(r.throw(e));
                        } catch (e) {
                            n(e);
                        }
                    }
                    function d(e) {
                        var t1;
                        e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                            e(t1);
                        })).then(s, a);
                    }
                    d((r = r.apply(e, t1 || [])).next());
                });
            }(this, void 0, void 0, function*() {
                if (this.localAESGCM256Key) return this.localAESGCM256Key;
                this.localAESGCM256Key = yield ab();
                const t1 = this.externalKeys ? null === (e = this.externalKeys.filter((e)=>e.usage === HS.PROTECT_LOCAL_KEY)[0]) || void 0 === e ? void 0 : e.key : void 0;
                return yield this.idbManager.saveAESGCM256Key(this.uuid, this.localAESGCM256Key, t1), this.localAESGCM256Key;
            });
        }
        updateCurrentSize(e) {
            var t1;
            let o = null !== (t1 = this.currentSize) && void 0 !== t1 ? t1 : 0;
            if (e instanceof Map) for (const [t1, r] of e)o += gb(r);
            else o += gb(e);
            return this.currentSize = o, o >= this.maxSize;
        }
    }
    const fb = (...e)=>{
        const t1 = {}, o = [];
        for (const r of e)r.forEach((e)=>{
            t1[e.id] || (t1[e.id] = !0, o.push(e));
        });
        const r = new Map;
        return o.sort((e, t1)=>(null == e ? void 0 : e.id) - (null == t1 ? void 0 : t1.id)).forEach((e)=>{
            r.set(e.id, e);
        }), r;
    }, yb = (e, t1)=>{
        const o = new Map;
        return t1.forEach((t1)=>{
            e(t1) && o.set(t1.id, t1);
        }), o;
    };
    class Sb {
        constructor(){
            this.getStore = ()=>({
                    byTag: Object.assign({}, this.store.byTag),
                    byTime: new Map(this.store.byTime)
                }), this.pushByTime = (e)=>{
                for (const t1 of e)this.store.byTime.set(t1.id, t1);
            }, this.pushByTag = (e)=>{
                e.forEach((e)=>{
                    const t1 = e.tags;
                    Array.isArray(t1) && t1.forEach((t1)=>{
                        this.store.byTag[t1] || (this.store.byTag[t1] = new Map), this.store.byTag[t1].set(e.id, e);
                    });
                });
            }, this.addLog = (e)=>{
                let t1 = e;
                Array.isArray(e) || (t1 = [
                    e
                ]), this.pushByTime(t1), this.pushByTag(t1);
            }, this.syncFromIDB = (e)=>(function(e, t1, o, r) {
                    return new (o || (o = Promise))(function(i, n) {
                        function s(e) {
                            try {
                                d(r.next(e));
                            } catch (e) {
                                n(e);
                            }
                        }
                        function a(e) {
                            try {
                                d(r.throw(e));
                            } catch (e) {
                                n(e);
                            }
                        }
                        function d(e) {
                            var t1;
                            e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                                e(t1);
                            })).then(s, a);
                        }
                        d((r = r.apply(e, t1 || [])).next());
                    });
                })(this, void 0, void 0, function*() {
                    const t1 = yield e.getAllLogs();
                    this.addLog(t1);
                }), this.reset = ()=>{
                this.store = {
                    byTag: {},
                    byTime: new Map
                };
            }, this.deleteLogs = (e)=>{
                for (const t1 of e){
                    const e = this.store.byTime.get(t1);
                    if (!e) continue;
                    const { tags: o } = e;
                    for (const e of o)this.store.byTag[e].delete(t1);
                    this.store.byTime.delete(t1);
                }
            }, this.filterStore = (e)=>{
                const t1 = ((e, t1)=>{
                    if (!t1) return e.byTime;
                    if ("string" == typeof t1) return e.byTag[t1] || new Map;
                    if (Array.isArray(t1)) {
                        if (t1.every((e)=>"string" == typeof e)) return fb(...t1.map((t1)=>e.byTag[t1]).filter((e)=>Boolean(e)));
                    } else {
                        if ("function" == typeof t1) return yb(t1, e.byTime);
                        if ("object" == typeof t1) if (t1.tags && t1.filter) {
                            if ("string" == typeof t1.tags) return yb(t1.filter, e.byTag[t1.tags]);
                            if (Array.isArray(t1.tags) && t1.tags.every((e)=>"string" == typeof e)) return fb(...t1.tags.map((o)=>{
                                const r = e.byTag[o];
                                return r ? yb(t1.filter, r) : new Map;
                            }));
                        } else {
                            if (t1.filter) return yb(t1.filter, e.byTime);
                            if (t1.tags) {
                                if ("string" == typeof t1) return e.byTag[t1] || new Map;
                                if (Array.isArray(t1) && t1.every((e)=>"string" == typeof e)) return fb(...t1.map((t1)=>e.byTag[t1]));
                            }
                        }
                        else console.error("Wrong filter type");
                    }
                    return new Map;
                })(this.store, e), o = new Map;
                for (const [e, r] of t1){
                    const t1 = Object.assign(Object.assign({}, r), {
                        message: mb(nb(r.message))
                    });
                    o.set(e, t1);
                }
                return o;
            }, this.store = {
                byTag: {},
                byTime: new Map
            };
        }
    }
    function bb(e, t1, o) {
        const r = e.plugins;
        if (!Array.isArray(r)) return o;
        let i = o;
        return r.forEach((o)=>{
            const r = o[t1];
            if ("function" == typeof r) {
                const t1 = r(e, i);
                t1 && (i = t1);
            }
        }), i;
    }
    const Eb = (e, t1, o, r, i, n = {})=>(function(e, t1, o, r) {
            return new (o || (o = Promise))(function(i, n) {
                function s(e) {
                    try {
                        d(r.next(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function a(e) {
                    try {
                        d(r.throw(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function d(e) {
                    var t1;
                    e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                        e(t1);
                    })).then(s, a);
                }
                d((r = r.apply(e, t1 || [])).next());
            });
        })(void 0, void 0, void 0, function*() {
            const { noCache: s, extraProperties: a = {} } = n, d = ((e, t1, o, r, i, n)=>{
                const s = Array.isArray(t1) ? t1 : [
                    t1
                ], a = Date.now();
                return Object.assign({
                    message: e,
                    logLevel: o,
                    tags: s,
                    encryptMode: r,
                    timestamp: a,
                    laplaceSessionId: i
                }, n);
            })(`${t1}`, o, r, i, e.uuid, a), u = bb(e, $S.beforeLog, d);
            if (s) bb(e, $S.afterLog, d);
            else {
                const { idbManager: t1, logManager: o } = e, r = yield t1.makeNextId();
                u.message = ((e)=>{
                    try {
                        const t1 = tb.parse(e);
                        return rb.stringify(t1);
                    } catch (t1) {
                        return e;
                    }
                })(u.message);
                const i = Object.assign(Object.assign({}, u), {
                    id: r
                });
                e.updateCurrentSize(i) && bb(e, $S.hitSizeLimit, i), o.addLog(i), yield t1.addLog(i), bb(e, $S.afterLog, i);
            }
        });
    cb(Eb, "commonLog");
    const Ib = (e)=>new Promise((t1)=>{
            const o = new XMLHttpRequest;
            o.open(e.type || "GET", e.url, !0), o.withCredentials = e.withCredentials, o.onerror = (o)=>{
                t1({
                    error: o,
                    report: e.reportItem
                });
            }, o.onreadystatechange = function() {
                if (4 === o.readyState) {
                    const r = o.status;
                    t1(r >= 200 && r < 300 ? {
                        report: e.reportItem
                    } : {
                        error: `Request failed, status: ${r}, responseText: ${o.responseText}`,
                        report: e.reportItem
                    });
                }
            }, Object.entries(e.headers).forEach(([e, t1])=>{
                t1 && e && o.setRequestHeader(e, t1);
            }), o.send(e.data);
        });
    const Ab = (e, t1 = 2)=>{
        let o = `${e}`;
        for(; o.length < t1;)o = `0${o}`;
        return o;
    }, Cb = (e)=>{
        const t1 = new Date(e);
        return `${t1.getUTCFullYear()}-${Ab(t1.getUTCMonth() + 1)}-${Ab(t1.getUTCDate())} ${Ab(t1.getUTCHours())}:${Ab(t1.getUTCMinutes())}:${Ab(t1.getUTCSeconds())}.${Ab(t1.getUTCMilliseconds(), 3)}`;
    }, _b = {
        version: "000001",
        flag: "0"
    }, Rb = (e, t1)=>Array.from(e.values()).reduce((e, o)=>{
            const r = ((e, t1)=>{
                const { message: o, logLevel: r, tags: i, timestamp: n, encryptMode: s, id: a } = e, d = function(e, t1) {
                    var o = {};
                    for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && t1.indexOf(r) < 0 && (o[r] = e[r]);
                    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                        var i = 0;
                        for(r = Object.getOwnPropertySymbols(e); i < r.length; i++)t1.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (o[r[i]] = e[r[i]]);
                    }
                    return o;
                }(e, [
                    "message",
                    "logLevel",
                    "tags",
                    "timestamp",
                    "encryptMode",
                    "id"
                ]), u = Object.assign(Object.assign({
                    time: Cb(n),
                    logLevel: FS[r],
                    message: o,
                    tags: i
                }, t1), d);
                return hb(u);
            })(o, t1), i = sb(r), n = e[e.length - 1];
            return n.currentSize + i > 30720 ? e.push({
                messages: [
                    r
                ],
                ids: [
                    o.id
                ],
                currentSize: i
            }) : (n.messages.push(r), n.ids.push(o.id), n.currentSize += i), e;
        }, [
            {
                messages: [],
                ids: [],
                currentSize: 0
            }
        ]).filter((e)=>e.currentSize > 0).map((e)=>({
                messages: e.messages.join("\n"),
                ids: e.ids,
                meta: _b
            })), wb = (e, t1, o)=>((e, t1, o)=>Promise.all(e.map((e)=>Object.assign({
                    url: t1 || "",
                    type: "POST",
                    withCredentials: !1,
                    headers: {},
                    data: hb({
                        messages: e.messages,
                        meta: e.meta
                    }),
                    reportItem: e
                }, o)).map(Ib)))(e, t1.reportUrl, o).then((e)=>{
            e.forEach((e)=>{
                var o;
                bb(t1, $S.afterReport, {
                    report: e.report,
                    error: null !== (o = e.error) && void 0 !== o ? o : null
                });
            });
        }), Tb = (e, t1, o)=>(function(e, t1, o, r) {
            return new (o || (o = Promise))(function(i, n) {
                function s(e) {
                    try {
                        d(r.next(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function a(e) {
                    try {
                        d(r.throw(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function d(e) {
                    var t1;
                    e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                        e(t1);
                    })).then(s, a);
                }
                d((r = r.apply(e, t1 || [])).next());
            });
        })(void 0, void 0, void 0, function*() {
            const r = e.logManager.filterStore(t1);
            if (!r || 0 === (null == r ? void 0 : r.size) || !o) return;
            const { xhrOptions: i = {}, additionalContext: n } = o, s = bb(e, $S.beforeReport, r), a = Rb(s, n);
            wb(a, e, i);
        });
    cb(Tb, "commonReport");
    var Ob = function(e, t1, o, r) {
        return new (o || (o = Promise))(function(i, n) {
            function s(e) {
                try {
                    d(r.next(e));
                } catch (e) {
                    n(e);
                }
            }
            function a(e) {
                try {
                    d(r.throw(e));
                } catch (e) {
                    n(e);
                }
            }
            function d(e) {
                var t1;
                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                    e(t1);
                })).then(s, a);
            }
            d((r = r.apply(e, t1 || [])).next());
        });
    };
    const Db = (e, t1, o)=>Ob(void 0, void 0, void 0, function*() {
            const { idbManager: r, logManager: i } = e;
            if (Array.isArray(o) && (yield r.deleteLogs(o), i.deleteLogs(o), !t1)) return;
            const n = e.logManager.filterStore(t1), s = [];
            for (const [e, t1] of n)s.push(t1.id);
            let a = s;
            Array.isArray(s) || (a = [
                s
            ]), yield r.deleteLogs(a), i.deleteLogs(a);
        }), Pb = (e)=>Ob(void 0, void 0, void 0, function*() {
            const { idbManager: t1, logManager: o } = e;
            yield t1.reset(), o.reset();
        });
    function Mb(e) {
        return new Promise((t1, o)=>{
            e.oncomplete = e.onsuccess = ()=>t1(e.result), e.onabort = e.onerror = ()=>o(e.error);
        });
    }
    function kb(e, t1) {
        const o = indexedDB.open(e);
        o.onupgradeneeded = ()=>o.result.createObjectStore(t1);
        const r = Mb(o);
        return (e, o)=>r.then((r)=>o(r.transaction(t1, e).objectStore(t1)));
    }
    let Lb;
    function Nb() {
        return Lb || (Lb = kb("keyval-store", "keyval")), Lb;
    }
    function Vb(e, t1 = Nb()) {
        return t1("readwrite", (t1)=>(e.forEach((e)=>t1.delete(e)), Mb(t1.transaction)));
    }
    function Ub(e = Nb()) {
        return e("readonly", (t1)=>{
            if (t1.getAll && t1.getAllKeys) return Promise.all([
                Mb(t1.getAllKeys()),
                Mb(t1.getAll())
            ]).then(([e, t1])=>e.map((e, o)=>[
                        e,
                        t1[o]
                    ]));
            const o = [];
            return e("readonly", (e)=>(function(e) {
                    return e.openCursor().onsuccess = function() {
                        this.result && (((e)=>{
                            o.push([
                                e.key,
                                e.value
                            ]);
                        })(this.result), this.result.continue());
                    }, Mb(e.transaction);
                })(e).then(()=>o));
        });
    }
    cb(Db, "commonDelete"), cb(Pb, "commonReset");
    const jb = {
        default: {
            queue: [],
            isRunning: !1,
            listeners: []
        }
    }, xb = (e)=>{
        let t1 = jb[e];
        return t1 || (t1 = {
            queue: [],
            isRunning: !1,
            listeners: []
        }, jb[e] = t1), t1;
    };
    function Bb(e) {
        return function(e, t1, o, r) {
            return new (o || (o = Promise))(function(i, n) {
                function s(e) {
                    try {
                        d(r.next(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function a(e) {
                    try {
                        d(r.throw(e));
                    } catch (e) {
                        n(e);
                    }
                }
                function d(e) {
                    var t1;
                    e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                        e(t1);
                    })).then(s, a);
                }
                d((r = r.apply(e, t1 || [])).next());
            });
        }(this, void 0, void 0, function*() {
            const t1 = xb(e), { queue: o, listeners: r } = t1;
            for(; o.length > 0 && !t1.isRunning;){
                const r = o.shift();
                t1.isRunning = !0;
                try {
                    const e = yield r.task();
                    r.resolution(e);
                } catch (e) {
                    r.rejection(e);
                }
                t1.isRunning = !1, Bb(e);
            }
            r.length && r.forEach((e)=>{
                e();
            });
        });
    }
    function Fb(e, t1 = "default") {
        const o = xb(t1);
        try {
            return new Promise((r, i)=>{
                o.queue.push({
                    task: e,
                    resolution: r,
                    rejection: i
                }), Bb(t1);
            });
        } catch (e) {
            return Promise.reject(e);
        }
    }
    const Hb = (e, t1)=>{
        xb(e).listeners.push(t1);
    };
    var $b = function(e, t1, o, r) {
        return new (o || (o = Promise))(function(i, n) {
            function s(e) {
                try {
                    d(r.next(e));
                } catch (e) {
                    n(e);
                }
            }
            function a(e) {
                try {
                    d(r.throw(e));
                } catch (e) {
                    n(e);
                }
            }
            function d(e) {
                var t1;
                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                    e(t1);
                })).then(s, a);
            }
            d((r = r.apply(e, t1 || [])).next());
        });
    };
    const Wb = "change_meta", Gb = "change_log", Kb = ()=>Promise.resolve();
    class zb {
        constructor(e){
            this.waitingForReset = !1, this.resetting = !1, this.isChangingMeta = !1, this.isChangingLog = !1, this.dbFailCount = {
                read: 0,
                write: 0
            }, this.get = (e)=>(function(e, t1 = Nb()) {
                    return t1("readonly", (t1)=>Mb(t1.get(e)));
                })(e, this.store), this.set = (e, t1)=>$b(this, void 0, void 0, function*() {
                    try {
                        return !(this.dbFailCount.write > 3) && (yield function(e, t1, o = Nb()) {
                            return o("readwrite", (o)=>(o.put(t1, e), Mb(o.transaction)));
                        }(e, t1, this.store));
                    } catch (o) {
                        o instanceof DOMException && (o && "QuotaExceededError" === o.name ? (yield this.deleteOldLogsForSetNewOne(), yield this.set(e, t1)) : this.dbFailCount.write += 1), console.error(o);
                    }
                }), this.deleteOldLogsForSetNewOne = ()=>$b(this, void 0, void 0, function*() {
                    var e;
                    const t1 = yield this.getAllLogs(), o = [];
                    for(let r = 0; r < 13; r++){
                        const i = null === (e = t1[r]) || void 0 === e ? void 0 : e.id;
                        (i || 0 === i) && o.push(`${i}`);
                    }
                    return Vb(o, this.store);
                }), this.adjustMaxId = ()=>$b(this, void 0, void 0, function*() {
                    return this.resetting ? Kb() : (this.isChangingMeta = !0, yield Fb(()=>$b(this, void 0, void 0, function*() {
                            var e;
                            const t1 = yield this.getAllLogs(), o = t1[t1.length - 1], r = null !== (e = null == o ? void 0 : o.id) && void 0 !== e ? e : 0;
                            return yield this.set("maxId", r), r;
                        }), Wb));
                }), this.makeNextId = ()=>$b(this, void 0, void 0, function*() {
                    return this.resetting ? Kb() : (this.isChangingMeta = !0, yield Fb(()=>$b(this, void 0, void 0, function*() {
                            const e = yield this.get("maxId");
                            if (!e && 0 !== e) return yield this.set("maxId", 0), 0;
                            const t1 = e + 1;
                            return yield this.set("maxId", t1), t1;
                        }), Wb));
                }), this.addLog = (e)=>$b(this, void 0, void 0, function*() {
                    if (this.resetting) return Kb();
                    this.isChangingLog = !0, yield Fb(()=>$b(this, void 0, void 0, function*() {
                            const { id: t1 } = e;
                            return this.set(`${t1}`, e);
                        }), Gb);
                }), this.getAllLogs = ()=>$b(this, void 0, void 0, function*() {
                    return (yield Ub(this.store)).filter(([e])=>"maxId" !== e).sort((e, t1)=>{
                        var o, r;
                        return (null === (o = e[1]) || void 0 === o ? void 0 : o.id) - (null === (r = t1[1]) || void 0 === r ? void 0 : r.id);
                    }).map(([, e])=>e);
                }), this.deleteLogs = (e)=>$b(this, void 0, void 0, function*() {
                    if (this.resetting) return Kb();
                    this.isChangingLog = !0, yield Fb(()=>$b(this, void 0, void 0, function*() {
                            return Vb(e.map((e)=>`${e}`), this.store);
                        }), Gb), yield this.adjustMaxId();
                }), this.saveAESGCM256Key = (e, t1, o)=>$b(this, void 0, void 0, function*() {
                    if (o) {
                        const r = yield self.crypto.subtle.exportKey("raw", t1), i = yield ((e, t1, o)=>ib(void 0, void 0, void 0, function*() {
                                return new Promise((r, i)=>{
                                    requestAnimationFrame(()=>ib(void 0, void 0, void 0, function*() {
                                            var i;
                                            const n = null === (i = null == t1 ? void 0 : t1.algorithm) || void 0 === i ? void 0 : i.name;
                                            let s;
                                            if ("RSA-OAEP" === n ? s = ub : "AES-GCM" === n && (s = db), !s) throw new Error("Unsupported encrypt key type");
                                            if ("string" == typeof e) {
                                                const i = new TextEncoder, n = yield s(i.encode(e), t1, o);
                                                r(n);
                                            } else {
                                                const i = yield s(e, t1, o);
                                                r(i);
                                            }
                                        }));
                                });
                            }))(r, o, new Uint8Array(16));
                        yield this.set(`aes-gcm-256-${e}`, i);
                    } else yield this.set(`aes-gcm-256-${e}`, t1);
                }), this.reset = ()=>$b(this, void 0, void 0, function*() {
                    return this.resetting ? Kb() : (this.waitingForReset = !0, this.isChangingLog || this.isChangingMeta ? Kb() : (this.resetting = !0, yield function(e = Nb()) {
                        return e("readwrite", (e)=>(e.clear(), Mb(e.transaction)));
                    }(this.store), this.resetting = !1, void (this.waitingForReset = !1)));
                }), this.store = kb(e, e + "-store"), Hb(Wb, ()=>{
                if (this.isChangingMeta = !1, this.waitingForReset) return this.reset();
            }), Hb(Gb, ()=>{
                if (this.isChangingLog = !1, this.waitingForReset) return this.reset();
            });
        }
    }
    var qb = function(e, t1, o, r) {
        return new (o || (o = Promise))(function(i, n) {
            function s(e) {
                try {
                    d(r.next(e));
                } catch (e) {
                    n(e);
                }
            }
            function a(e) {
                try {
                    d(r.throw(e));
                } catch (e) {
                    n(e);
                }
            }
            function d(e) {
                var t1;
                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                    e(t1);
                })).then(s, a);
            }
            d((r = r.apply(e, t1 || [])).next());
        });
    };
    const Jb = {
        databaseName: "laplace-default-db",
        maxSize: 49283072
    };
    class Qb {
        constructor(e){
            this.commonLogWithContext = (e, t1, o, r, i)=>qb(this, void 0, void 0, function*() {
                    yield Eb(this.runtimeMetaManager, e, t1, o, r, i);
                }), this.commonReportWithContext = (e, t1)=>qb(this, void 0, void 0, function*() {
                    yield Tb(this.runtimeMetaManager, e, t1);
                }), this.commonDeleteWithContext = (e)=>qb(this, void 0, void 0, function*() {
                    yield Db(this.runtimeMetaManager, e);
                }), this.resetWithContext = ()=>qb(this, void 0, void 0, function*() {
                    yield Pb(this.runtimeMetaManager);
                }), this.initLocalAESGCM256Key = ()=>qb(this, void 0, void 0, function*() {
                    return yield ab();
                }), this.doNotUseDirtyGetStore = ()=>this.runtimeMetaManager.logManager.getStore(), this.log = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.log, BS.PLAIN, {
                        extraProperties: o
                    });
                }), this.info = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.info, BS.PLAIN, {
                        extraProperties: o
                    });
                }), this.warn = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.warn, BS.PLAIN, {
                        extraProperties: o
                    });
                }), this.debug = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.debug, BS.PLAIN, {
                        extraProperties: o
                    });
                }), this.error = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.error, BS.PLAIN, {
                        extraProperties: o
                    });
                }), this.logWithEncryption = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.log, BS.AESGCM256, {
                        extraProperties: o
                    });
                }), this.infoWithEncryption = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.info, BS.AESGCM256, {
                        extraProperties: o
                    });
                }), this.debugWithEncryption = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.debug, BS.AESGCM256, {
                        extraProperties: o
                    });
                }), this.warnWithEncryption = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.warn, BS.AESGCM256, {
                        extraProperties: o
                    });
                }), this.errorWithEncryption = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.error, BS.AESGCM256, {
                        extraProperties: o
                    });
                }), this.logWithoutCache = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.log, BS.PLAIN, {
                        extraProperties: o,
                        noCache: !0
                    });
                }), this.infoWithoutCache = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.info, BS.PLAIN, {
                        extraProperties: o,
                        noCache: !0
                    });
                }), this.warnWithoutCache = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.warn, BS.PLAIN, {
                        extraProperties: o,
                        noCache: !0
                    });
                }), this.debugWithoutCache = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.debug, BS.PLAIN, {
                        extraProperties: o,
                        noCache: !0
                    });
                }), this.errorWithoutCache = (e, t1, o)=>qb(this, void 0, void 0, function*() {
                    yield this.commonLogWithContext(e, t1, FS.error, BS.PLAIN, {
                        extraProperties: o,
                        noCache: !0
                    });
                }), this.getLogs = (e)=>{
                const t1 = this.runtimeMetaManager.logManager;
                return t1 ? t1.filterStore(e) : new Map;
            }, this.report = (...e)=>((e, t1, o = {})=>(function(e, t1, o, r) {
                        return new (o || (o = Promise))(function(i, n) {
                            function s(e) {
                                try {
                                    d(r.next(e));
                                } catch (e) {
                                    n(e);
                                }
                            }
                            function a(e) {
                                try {
                                    d(r.throw(e));
                                } catch (e) {
                                    n(e);
                                }
                            }
                            function d(e) {
                                var t1;
                                e.done ? i(e.value) : (t1 = e.value, t1 instanceof o ? t1 : new o(function(e) {
                                    e(t1);
                                })).then(s, a);
                            }
                            d((r = r.apply(e, t1 || [])).next());
                        });
                    })(void 0, void 0, void 0, function*() {
                        var r, i;
                        const n = null !== (r = o.sampleRate) && void 0 !== r ? r : 1;
                        if (Math.random() > n) return;
                        if (sb(t1) > 30720) throw new Error("ERROR: Laplace .report(strMsg) size bigger than 30KB is NOT allowed.");
                        const s = Object.assign({
                            message: Object.assign({
                                strMsg: t1
                            }, o.extraMsg),
                            time: Cb(Date.now())
                        }, o.extraData);
                        return (null === (i = null == o ? void 0 : o.tags) || void 0 === i ? void 0 : i.length) && (s.tags = null == o ? void 0 : o.tags), wb([
                            {
                                messages: JSON.stringify(s),
                                meta: _b
                            }
                        ], e, o.xhrOptions);
                    }))(this.runtimeMetaManager, ...e), this.reportByHttps = (e, t1)=>qb(this, void 0, void 0, function*() {
                    yield this.commonReportWithContext(e, t1);
                }), this.deleteLog = (e)=>qb(this, void 0, void 0, function*() {
                    yield this.commonDeleteWithContext(e);
                }), this.deleteAll = ()=>qb(this, void 0, void 0, function*() {
                    yield this.resetWithContext();
                });
            const { runtimeMetaManager: t1 } = e;
            this.runtimeMetaManager = t1;
        }
    }
    Qb.init = (e)=>qb(void 0, void 0, void 0, function*() {
            const { databaseName: t1 = "laplace-default-db" } = e, o = new zb(t1), r = new Sb, i = new vb(Object.assign(Object.assign(Object.assign({}, Jb), e), {
                idbManager: o,
                logManager: r
            }));
            bb(i, $S.beforeInit), yield r.syncFromIDB(i.idbManager);
            const n = new Qb({
                runtimeMetaManager: i
            });
            return bb(i, $S.afterInit), n;
        });
    class Zb extends KS {
        constructor(e){
            super(), this.config = {
                verbose: !1
            }, this.beforeLog = (e, t1)=>{
                const { verbose: o } = this.config;
                switch(o && console.log("beforeLog, ", "state: ", t1, "meta: ", e), t1.logLevel){
                    case FS.error:
                        console.error(t1.message);
                        break;
                    case FS.warn:
                        console.warn(t1.message);
                        break;
                    case FS.log:
                        console.log(t1.message);
                        break;
                    case FS.debug:
                        console.debug(t1.message);
                        break;
                    case FS.info:
                        console.info(t1.message);
                }
            }, this.afterLog = (e, t1)=>{
                const { verbose: o } = this.config;
                o && console.log("afterLog, ", "state: ", t1, "meta: ", e);
            }, this.beforeReport = (e, t1)=>{
                const { verbose: o } = this.config;
                o && console.log("beforeReport, ", "pluginParams: ", t1, "meta: ", e);
            }, this.afterReport = (e, t1)=>{
                const { verbose: o } = this.config;
                o && console.log("afterReport, ", "pluginParams: ", t1, "runtimeMetaManager: ", e);
            }, e && (this.config = e);
        }
    }
    const Yb = (e)=>{
        const t1 = [];
        for (const [o, r] of e)t1.push(r);
        return t1;
    };
    class Xb extends KS {
        constructor(e){
            super(), this.config = {
                debug: !1
            }, this.debugLog = (e)=>{
                const { debug: t1 } = this.config;
                t1 && console.log(`[AutoCleanLogPlugin]: ${e}`);
            }, this.afterInit = (e)=>{
                const { expireBefore: t1 } = this.config;
                if (!t1) return void this.debugLog("early return on beforeInit because expireBefore is falsy");
                const { logManager: o, commonMethods: { commonDelete: r } } = e, i = o.getStore().byTime, n = ("function" == typeof t1 ? Yb(i).filter(t1) : Yb(i).filter((e)=>e.timestamp < t1)).map((e)=>e.id);
                r(e, void 0, n), this.debugLog(`afterInit, clean log id: ${n}`);
            }, this.afterReport = (e, { report: t1, error: o })=>{
                if (o) return this.debugLog("error"), void console.error(o);
                const { cleanAfterReport: r } = this.config;
                if (!r) return void this.debugLog("early return on afterReport because cleanAfterReport is falsy");
                const { commonMethods: { commonDelete: i } } = e;
                i(e, void 0, t1.ids), this.debugLog(`afterReport, clean log id: ${t1.ids}`);
            }, e && (this.config = e);
        }
    }
    var eE, tE, oE = function() {
        if (tE) return eE;
        tE = 1;
        var e = "Expected a function", t1 = /^\s+|\s+$/g, o = /^[-+]0x[0-9a-f]+$/i, r = /^0b[01]+$/i, i = /^0o[0-7]+$/i, n = parseInt, s = "object" == typeof Ut && Ut && Ut.Object === Object && Ut, a = "object" == typeof self && self && self.Object === Object && self, d = s || a || Function("return this")(), u = Object.prototype.toString, l = Math.max, c = Math.min, p = function() {
            return d.Date.now();
        };
        function h(e) {
            var t1 = typeof e;
            return !!e && ("object" == t1 || "function" == t1);
        }
        function m(e) {
            if ("number" == typeof e) return e;
            if (function(e) {
                return "symbol" == typeof e || function(e) {
                    return !!e && "object" == typeof e;
                }(e) && "[object Symbol]" == u.call(e);
            }(e)) return NaN;
            if (h(e)) {
                var s = "function" == typeof e.valueOf ? e.valueOf() : e;
                e = h(s) ? s + "" : s;
            }
            if ("string" != typeof e) return 0 === e ? e : +e;
            e = e.replace(t1, "");
            var a = r.test(e);
            return a || i.test(e) ? n(e.slice(2), a ? 2 : 8) : o.test(e) ? NaN : +e;
        }
        return eE = function(t1, o, r) {
            var i = !0, n = !0;
            if ("function" != typeof t1) throw new TypeError(e);
            return h(r) && (i = "leading" in r ? !!r.leading : i, n = "trailing" in r ? !!r.trailing : n), function(t1, o, r) {
                var i, n, s, a, d, u, g = 0, v = !1, f = !1, y = !0;
                if ("function" != typeof t1) throw new TypeError(e);
                function S(e) {
                    var o = i, r = n;
                    return i = n = void 0, g = e, a = t1.apply(r, o);
                }
                function b(e) {
                    var t1 = e - u;
                    return void 0 === u || t1 >= o || t1 < 0 || f && e - g >= s;
                }
                function E() {
                    var e = p();
                    if (b(e)) return I(e);
                    d = setTimeout(E, function(e) {
                        var t1 = o - (e - u);
                        return f ? c(t1, s - (e - g)) : t1;
                    }(e));
                }
                function I(e) {
                    return d = void 0, y && i ? S(e) : (i = n = void 0, a);
                }
                function A() {
                    var e = p(), t1 = b(e);
                    if (i = arguments, n = this, u = e, t1) {
                        if (void 0 === d) return function(e) {
                            return g = e, d = setTimeout(E, o), v ? S(e) : a;
                        }(u);
                        if (f) return d = setTimeout(E, o), S(u);
                    }
                    return void 0 === d && (d = setTimeout(E, o)), a;
                }
                return o = m(o) || 0, h(r) && (v = !!r.leading, s = (f = "maxWait" in r) ? l(m(r.maxWait) || 0, o) : s, y = "trailing" in r ? !!r.trailing : y), A.cancel = function() {
                    void 0 !== d && clearTimeout(d), g = 0, i = u = n = d = void 0;
                }, A.flush = function() {
                    return void 0 === d ? a : I(p());
                }, A;
            }(t1, o, {
                leading: i,
                maxWait: o,
                trailing: n
            });
        };
    }(), rE = jt(oE);
    const iE = [
        "RESOURCE_ERROR",
        "JS_ERROR",
        "UNHANDLED_PROMISE_REJECTION"
    ];
    class nE extends KS {
        constructor(e){
            super(), this.config = {
                debug: !1,
                publicTags: []
            }, this.errorCount = 0, this.hashErrors = {}, this.runtimeMetaManager = null, this.addPublicTags = (e)=>{
                var t1;
                return null === (t1 = this.config.publicTags) || void 0 === t1 ? void 0 : t1.concat(e).filter((e)=>e);
            }, this.debugLog = (e)=>{
                const { debug: t1 } = this.config;
                t1 && console.log("[AutoLogErrorPlugin]:", e);
            }, this.ignore = (e)=>{
                var t1, o, r, i, n;
                return void 0 !== (null === (t1 = this.config) || void 0 === t1 ? void 0 : t1.maxErrorCount) && this.errorCount >= (null === (o = this.config) || void 0 === o ? void 0 : o.maxErrorCount) || !!(null === (r = this.config) || void 0 === r ? void 0 : r.ignoredErrorMsgKeywords) && e && (null === (n = null === (i = this.config) || void 0 === i ? void 0 : i.ignoredErrorMsgKeywords) || void 0 === n ? void 0 : n.some((t1)=>null == e ? void 0 : e.includes(t1)));
            }, this.report = rE(()=>{
                if (null === this.runtimeMetaManager) return;
                const { autoReport: e } = this.config, { commonMethods: { commonReport: t1 } } = this.runtimeMetaManager;
                return t1(this.runtimeMetaManager, iE, e);
            }, 600, {
                trailing: !0,
                leading: !1
            }), this.afterInit = (e)=>{
                if (this.runtimeMetaManager = e, !self.addEventListener) return;
                const { commonMethods: { commonLog: t1 } } = e, o = (o, r, i)=>{
                    this.debugLog(i), this.errorCount += 1;
                    try {
                        return (function(e) {
                            const t1 = (new TextEncoder).encode(e);
                            return crypto.subtle.digest("SHA-1", t1).then((e)=>Array.from(new Uint8Array(e)).map((e)=>e.toString(16).padStart(2, "0")).join(""));
                        })(o).then((i)=>this.hashErrors[i] ? "dismissed" : (this.hashErrors[i] = !0, t1(e, o, this.addPublicTags([].concat(r)), FS.error, BS.PLAIN, {
                                extraProperties: {
                                    messageHash: i
                                }
                            }).then(this.report))).catch(console.error);
                    } catch (e) {
                        return console.error(e), Promise.resolve(e);
                    }
                };
                try {
                    self.addEventListener("error", (e)=>{
                        var t1, r, i, n, s, a, d;
                        if (!this.ignore(null == e ? void 0 : e.message)) {
                            if ((null == e ? void 0 : e.target) && ((null === (t1 = null == e ? void 0 : e.target) || void 0 === t1 ? void 0 : t1.src) || (null === (r = null == e ? void 0 : e.target) || void 0 === r ? void 0 : r.href))) {
                                const t1 = `Load Resource Error in ${null === (i = null == e ? void 0 : e.target) || void 0 === i ? void 0 : i.tagName} element: ${(null === (n = null == e ? void 0 : e.target) || void 0 === n ? void 0 : n.src) || (null === (s = null == e ? void 0 : e.target) || void 0 === s ? void 0 : s.href)}`;
                                return o(t1, "RESOURCE_ERROR", e);
                            }
                            {
                                const t1 = `Javascript Runtime Error in ${null == e ? void 0 : e.filename} (${null == e ? void 0 : e.lineno}:${null == e ? void 0 : e.colno}): ${null == e ? void 0 : e.message}\nStack: ${null !== (d = null === (a = null == e ? void 0 : e.error) || void 0 === a ? void 0 : a.stack) && void 0 !== d ? d : null == e ? void 0 : e.stack}`;
                                return o(t1, "JS_ERROR", e);
                            }
                        }
                    }), self.addEventListener("unhandledrejection", (e)=>{
                        var t1;
                        if (this.ignore(null === (t1 = null == e ? void 0 : e.reason) || void 0 === t1 ? void 0 : t1.message)) return;
                        let r;
                        const i = null == e ? void 0 : e.reason;
                        return r = "string" == typeof i ? `Promise Error: ${i}` : i instanceof Error ? `Promise Error: ${i.message} ${i.name} ${i.stack}` : "object" == typeof i ? `Promise Error with reason: ${hb(i)}` : `Promise Error with unrecognized reason: ${i}`, o(r, "UNHANDLED_PROMISE_REJECTION", e);
                    });
                } catch (e) {
                    console.error(e);
                }
                this.debugLog("afterInit, add listener");
            }, e && (this.config = e), this.config.publicTags = [].concat(null == e ? void 0 : e.publicTags);
        }
    }
    let sE = function(e) {
        return e.DeviceAudioStreamCaptured = "device audio stream captured", e.AudioJoinComplete = "audio join complete", e.AudioLeaveComplete = "audio leave complete", e.SharingAudioStartComplete = "sharing audio start complete", e.SharingAudioStopComplete = "sharing audio stop complete", e.AudioBridgeReconnectStart = "audio bridge reconnect start", e.AudioBridgeReconnectEnd = "audio bridge reconnect end", e;
    }({}), aE = function(e) {
        return e.VBSettingSuccess = "video VB setting success", e.VBSettingFailed = "init video VB failed", e.VBPreloadSuccess = "preload video VB success", e.VBPreloading3S = "preload video VB 3s", e.VBPreloading10S = "preload video VB 10s", e.StartCaptureVideoSuccess = "start capture video success", e.StopCaptureVideoSuccess = "stop capture video success", e;
    }({});
    function dE(e) {
        return `{E}${e}{/E}`;
    }
    const uE = [
        "exception flow",
        "MEDIA SDK"
    ], lE = {
        enable: !1,
        enableReport: !1,
        gatewayEndPoint: "",
        newGatewayEndPoint: "",
        logLevel: {
            debug: !1,
            log: !1,
            info: !1,
            print: !1,
            warn: !1,
            error: !1
        },
        performanceReportRatio: .25,
        trackingCount: 7
    }, cE = [
        "debug",
        "log",
        "info",
        "print",
        "warn",
        "error"
    ], pE = (e, t1)=>[
            ...e,
            ...t1
        ].filter((e)=>!!e);
    class hE {
        static getInstance() {
            return this.agentInstance || (this.agentInstance = new hE), this.agentInstance;
        }
        constructor(){
            var e = this;
            this.laplace = void 0, this.trackingId = void 0, this.logConfig = void 0, this.reportUrl = void 0, this.publicTags = void 0, this.accountId = void 0, this.disableAutoReport = void 0, this.debouncedReport = void 0, this.initConfig = async (e)=>{
                let t1, o = lE;
                try {
                    e.logConfig && (o = JSON.parse(e.logConfig), o.gatewayEndPoint && (this.reportUrl = o.gatewayEndPoint), o.newGatewayEndPoint && (this.reportUrl = o.newGatewayEndPoint));
                    const { enable: r, enableReport: i, reportUrl: n, logLevel: s, encryptKeys: a, trackingId: d, accountId: u } = e;
                    if (void 0 !== r && (o = {
                        ...o,
                        enable: !!r
                    }), void 0 !== i && (o = {
                        ...o,
                        enableReport: !!i
                    }), n && (this.reportUrl = n), "string" == typeof s) {
                        const e = cE.indexOf(s), t1 = cE.reduce((t1, o, r)=>r < e ? {
                                ...t1,
                                [`${o}`]: !1
                            } : {
                                ...t1,
                                [`${o}`]: !0
                            }, {});
                        o = {
                            ...o,
                            logLevel: t1
                        };
                    } else void 0 !== s && (o = {
                        ...o,
                        logLevel: s
                    });
                    if (d && (this.trackingId = d, o = {
                        ...o,
                        enable: !0,
                        enableReport: !0
                    }), void 0 !== a) {
                        const e = Array.isArray(a) ? a : [
                            a
                        ];
                        t1 = await Promise.all(e.map((e)=>(function(e) {
                                return window.crypto.subtle.importKey("raw", (new TextEncoder).encode(e.slice(0, 32)), "AES-GCM", !1, [
                                    "encrypt",
                                    "decrypt"
                                ]);
                            })(e).then((e)=>({
                                    usage: HS.PROTECT_LOCAL_KEY,
                                    key: e
                                }))));
                    }
                    void 0 !== u && (this.accountId = u);
                } catch (e) {
                    console.error("parse log config error", e);
                }
                const r = (new Date).getTime() - 6048e5, i = o.enableReport && this.reportUrl ? {
                    gzip: !1,
                    encrypt: !1,
                    additionalContext: {
                        trackingId: this.trackingId
                    }
                } : void 0;
                this.publicTags = [
                    "VideoSDK",
                    this.trackingId
                ];
                const n = [
                    e.debugMode && new Zb({
                        verbose: !1
                    }),
                    new Xb({
                        debug: !1,
                        cleanAfterReport: !0,
                        expireBefore: r
                    }),
                    new nE({
                        debug: !1,
                        autoReport: i,
                        ignoredErrorMsgKeywords: [
                            "table index is out of bounds"
                        ],
                        maxErrorCount: 223,
                        publicTags: this.accountId ? [
                            ...this.publicTags,
                            dE(this.accountId)
                        ] : this.publicTags
                    })
                ].filter(Boolean);
                return {
                    laplaceConfig: {
                        databaseName: "ZM-VSDK-LOG-DATABASE",
                        maxSize: 49283072,
                        publicKey: e.logEncryptionPubKey,
                        reportUrl: this.reportUrl,
                        externalKeys: t1,
                        plugins: n
                    },
                    logConfig: o
                };
            }, this.handleInitLaplaceSuccess = (e, t1)=>{
                var o;
                this.laplace = e;
                const r = ns.get(as.VSDKLogTrackingId);
                let i = [];
                try {
                    i = JSON.parse(r ? window.atob(r) : "[]");
                } catch (e) {}
                i.length >= (null !== (o = null == t1 ? void 0 : t1.trackingCount) && void 0 !== o ? o : 7) && i.shift();
                const n = i.reduce((e, t1)=>({
                        ...e,
                        [`${t1}`]: !0
                    }), {});
                e.deleteLog((e)=>{
                    var t1;
                    return !(null !== (t1 = e.tags) && void 0 !== t1 && t1.some((e)=>n[e]));
                }), i.push(this.trackingId), ns.set(as.VSDKLogTrackingId, window.btoa(JSON.stringify(i)), rs.LocalStorage), this.debouncedReport = function(e) {
                    const t1 = [];
                    let o;
                    const r = function(e, t1, o) {
                        var r, i, n, s, a, d, u = 0, l = !1, c = !1, p = !0;
                        if ("function" != typeof e) throw new TypeError("Expected a function");
                        function h(t1) {
                            var o = r, n = i;
                            return r = i = void 0, u = t1, s = e.apply(n, o);
                        }
                        function m(e) {
                            var o = e - d;
                            return void 0 === d || o >= t1 || o < 0 || c && e - u >= n;
                        }
                        function g() {
                            var e = AS();
                            if (m(e)) return v(e);
                            a = setTimeout(g, function(e) {
                                var o = t1 - (e - d);
                                return c ? GS(o, n - (e - u)) : o;
                            }(e));
                        }
                        function v(e) {
                            return a = void 0, p && r ? h(e) : (r = i = void 0, s);
                        }
                        function f() {
                            var e = AS(), o = m(e);
                            if (r = arguments, i = this, d = e, o) {
                                if (void 0 === a) return function(e) {
                                    return u = e, a = setTimeout(g, t1), l ? h(e) : s;
                                }(d);
                                if (c) return clearTimeout(a), a = setTimeout(g, t1), h(d);
                            }
                            return void 0 === a && (a = setTimeout(g, t1)), s;
                        }
                        return t1 = xS(t1) || 0, SS(o) && (l = !0, n = (c = "maxWait" in o) ? WS(xS(o.maxWait) || 0, t1) : n, p = "trailing" in o || p), f.cancel = function() {
                            void 0 !== a && clearTimeout(a), u = 0, r = d = i = a = void 0;
                        }, f.flush = function() {
                            return void 0 === a ? s : v(AS());
                        }, f;
                    }((o, r)=>{
                        const i = e(o, r);
                        return t1.length = 0, i;
                    }, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3, {
                        leading: !0,
                        trailing: !0,
                        maxWait: 1e4
                    });
                    return window.addEventListener("beforeunload", ()=>{
                        r.cancel && r.cancel(), t1.length > 0 && e(t1, o);
                    }), (e, i)=>(Array.isArray(e) ? t1.push(...e) : "string" == typeof e && t1.push(e), o = i, r(t1, i));
                }(this.laplace.reportByHttps.bind(this.laplace));
            }, this.init = async (e)=>{
                const { laplaceConfig: t1, logConfig: o } = await this.initConfig(e);
                return o.enable ? (this.logConfig = o, Qb.init(t1).then((e)=>{
                    this.handleInitLaplaceSuccess(e, o);
                }).catch((e)=>{
                    throw {
                        type: zl,
                        reason: "Logger init failed.",
                        error: e
                    };
                })) : Promise.reject({
                    type: Kl,
                    reason: "Logger feature is not enabled."
                });
            }, this.check = (e)=>{
                var t1;
                return !(!this.checkLaplace() || (null === (t1 = this.logConfig) || void 0 === t1 || null === (t1 = t1.logLevel) || void 0 === t1 || !t1[e]) && (console.warn(`Logger ${e} is not enabled.`), 1));
            }, this.log = (e, t1, o)=>{
                if (this.check("log")) try {
                    var r;
                    return null === (r = this.laplace.logWithEncryption(e, pE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
                } catch (e) {
                    return;
                }
            }, this.logWithExtraProperties = (e, t1, o)=>{
                if (this.check("log")) try {
                    var r;
                    return null === (r = this.laplace.log(e, t1, o)) || void 0 === r ? void 0 : r.catch(()=>{});
                } catch (e) {
                    return;
                }
            }, this.warn = (e, t1, o)=>{
                if (this.check("warn")) try {
                    var r;
                    return null === (r = this.laplace.warnWithEncryption(e, pE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
                } catch (e) {
                    return;
                }
            }, this.info = (e, t1, o)=>{
                if (this.check("info")) try {
                    var r;
                    return null === (r = this.laplace.infoWithEncryption(e, pE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
                } catch (e) {
                    return;
                }
            }, this.debug = (e, t1, o)=>{
                if (this.check("debug")) try {
                    var r;
                    return null === (r = this.laplace.debugWithEncryption(e, pE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
                } catch (e) {
                    return;
                }
            }, this.error = (e, t1, o)=>{
                if (this.check("error")) try {
                    var r;
                    return null === (r = this.laplace.errorWithEncryption(e, pE(t1, o))) || void 0 === r ? void 0 : r.catch(()=>{});
                } catch (e) {
                    return;
                }
            }, this.checkLaplace = ()=>{
                var e;
                return !(null === (e = this.laplace) || void 0 === e || !e.log);
            }, this.makeLogger = (e)=>{
                var t1;
                const o = pE(null !== (t1 = this.publicTags) && void 0 !== t1 ? t1 : [], e);
                return {
                    log: (e, t1)=>this.log(e, o, null != t1 ? t1 : []),
                    logWithExtraProperties: (e, t1)=>this.logWithExtraProperties(e, o, t1),
                    warn: (e, t1)=>this.warn(e, o, null != t1 ? t1 : []),
                    info: (e, t1)=>this.info(e, o, null != t1 ? t1 : []),
                    debug: (e, t1)=>this.debug(e, o, null != t1 ? t1 : []),
                    error: (e, t1)=>this.error(e, o, null != t1 ? t1 : []),
                    directReport: (e, t1)=>{
                        const o = "string" != typeof e ? JSON.stringify(e) : e, r = (Array.isArray(t1) ? t1 : [
                            t1
                        ]).filter(Boolean);
                        r.push("MEDIA SDK Direct"), this.report(o, r, "info");
                    }
                };
            }, this.reportToGlobalTracing = function(t1) {
                var o;
                let r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (!e.checkLaplace()) return Promise.reject({
                    type: Kl,
                    reason: "Logger has not been enabled or initialized."
                });
                if (null === (o = e.logConfig) || void 0 === o || !o.enableReport || !e.reportUrl) return Promise.reject({
                    type: Kl,
                    reason: "Please use getLogs to obtain log data and report by yourself."
                });
                if (function() {
                    try {
                        return !!ns.get(ds.DisableAutoReportLogs);
                    } catch (e) {
                        return !1;
                    }
                }() && !r) return Promise.resolve();
                const i = function(e) {
                    let t1 = !0;
                    return e && (t1 = !(Array.isArray(e) ? e : [
                        e
                    ]).some((e)=>uE.some((t1)=>`${e}`.indexOf(t1) > -1))), t1;
                }(t1);
                return (r || i ? e.laplace.reportByHttps.bind(e.laplace) : e.debouncedReport)(t1, {
                    gzip: !1,
                    encrypt: !1,
                    xhrOptions: {
                        url: e.reportUrl
                    },
                    additionalContext: {
                        trackingId: e.trackingId
                    }
                });
            }, this.report = function(t1, o) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "warn";
                if (e.checkLaplace() && e.logConfig.enableReport && e.reportUrl) {
                    var i, n;
                    const s = Array.isArray(o) ? o : [
                        o
                    ], a = e.accountId ? [
                        ...s,
                        dE(e.accountId)
                    ] : s;
                    null === (i = (n = e.makeLogger(a))[`${r}`]) || void 0 === i || null === (i = i.call(n, t1)) || void 0 === i || i.then(()=>{
                        e.reportToGlobalTracing(s);
                    });
                }
            }, this.getLogs = (e, t1)=>{
                if (!this.checkLaplace()) return console.warn("Logger has not been enabled or initialized."), [];
                const o = e.getState(), { meeting: { meetingNumber: r, userId: i, userEmail: n, userName: s } } = o, a = {
                    meetingNumber: r,
                    userId: i,
                    userEmail: n,
                    userName: s
                }, d = this.laplace.getLogs(t1), u = [];
                for (const [, e] of d)u.push({
                    ...e,
                    ...a
                });
                return u;
            }, this.doNotUseDirtyGetStore = ()=>this.checkLaplace() ? this.laplace.doNotUseDirtyGetStore() : (console.warn("Logger has not been enabled or initialized."), {
                    byTag: {},
                    byTime: new Map
                }), this.trackingId = yS();
        }
    }
    hE.agentInstance = void 0;
    const mE = hE.getInstance(), gE = [
        {
            type: "MediaMeta",
            methods: [
                "sendUserNodeList",
                "updateUserMediaSN",
                "updateMediaParams",
                "subscribeToQos",
                "unsubscribeFromQos",
                "sendUserAudioStatus",
                "destroy",
                "createMainSessionChannel",
                "notifySDKMeetingReady"
            ]
        },
        {
            type: "Audio",
            methods: [
                "joinComputerAudio",
                "leaveComputerAudio",
                "joinSharingAudio",
                "leaveSharingAudio",
                "changeSpeaker",
                "changeMicrophone",
                "enableAudioEncode",
                "pauseOrResumeAudio",
                "setSharingAudioVolume",
                "enableShareAudioToBreakoutRoom",
                "enableAudioDenoise",
                "enableSyncButtonsOnHeadset",
                "stopAllIncomingAudio",
                "preInitAudioBridge",
                "setAudioCodecMode",
                "muteOrUnmuteOtherAudio",
                "adjustOtherAudioVolume",
                "changeAudioProfile",
                "unmuteAudio",
                "muteAudio"
            ]
        },
        {
            type: "Video",
            methods: [
                "startCaptureVideo",
                "stopCaptureVideo",
                "renderVideo",
                "stopRenderVideo",
                "changeCamera",
                "updateRenderedVideoCanvasDimension",
                "adjustRenderedVideoPosition",
                "mirrorVideo",
                "enableHardwareAccelerationForVideoDecode",
                "enableHardwareAccelerationForVideoEncode",
                "startVirtualBackgroundSetting",
                "updateVirtualBackgroundImage",
                "stopVirtualBackgroundSetting",
                "startMaskSetting",
                "updateMaskBackgroundImage",
                "updateMaskClip",
                "stopMaskSetting",
                "enableVideoObserver",
                "prefetchVideoSsrc",
                "cancelPrefetchVideoSsrc",
                "setMobileRotateMode",
                "changeActiveVideoSsrc",
                "updateVideoHDValue",
                "updateVideoFullhdValue",
                "clearVideoCanvas"
            ]
        },
        {
            type: "Sharing",
            methods: [
                "stopDesktopSharing",
                "startDesktopSharing",
                "pauseDesktopSharing",
                "resumeDesktopSharing",
                "renderSharing",
                "stopRenderSharing",
                "switchSharingSource",
                "ajustmentReceivedSharingCanvas",
                "changeSharingSecondCamera",
                "updateRenderedSharingDimension",
                "addReceivedSharingChannelType",
                "removeReceivedSharingChannelType",
                "switchSharingMode",
                "ajustmentSharingCanvas"
            ]
        },
        {
            type: "RemoteControl",
            methods: [
                "startRemoteControl",
                "stopRemoteControl",
                "resendRemoteControlPositionPDU",
                "updateRemoteControlProperties",
                "ajustmentReceivedSharingCanvas",
                "startRemoteControlQRCheck"
            ]
        },
        {
            type: "LiveTranscription",
            methods: [
                "selectLanguageChannelForNewLTT"
            ]
        },
        {
            type: "RemoteCamera",
            methods: [
                "movePTZCamera"
            ]
        }
    ].reduce((e, t1)=>{
        const { type: o, methods: r } = t1;
        return [
            ...e,
            ...r.map((e)=>({
                    name: e,
                    type: o
                }))
        ];
    }, []), vE = gE.map((e)=>e.name), fE = function(e) {
        const t1 = gE.find((t1)=>t1.name === e);
        if (t1) {
            const { type: n } = t1;
            for(var o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)r[i - 1] = arguments[i];
            const s = null == r ? void 0 : r.map((e)=>ai(e));
            mE.makeLogger([
                n,
                `${n} Media SDK`
            ]).info(`${e},params:${JSON.stringify(s)}`);
        }
    };
    function yE(e) {
        return new Proxy(e, {
            get: (e, t1)=>"string" == typeof t1 && vE.includes(t1) ? function() {
                    for(var o = arguments.length, r = new Array(o), i = 0; i < o; i++)r[i] = arguments[i];
                    try {
                        Reflect.apply(fE, void 0, [
                            t1,
                            ...r
                        ]);
                    } catch (e) {}
                    return Reflect.apply(Reflect.get(e, t1), e, r);
                } : Reflect.get(e, t1)
        });
    }
    const SE = hE.getInstance().makeLogger([
        "Remote Control"
    ]), bE = yE(ca.getInstance());
    function EE(e, t1, o, r) {
        let { share: { activeNodeId: i, shareQuality: n } } = t1;
        const { share: { isReceiveSharingFromMainSession: s } } = t1;
        o && (i = o), void 0 !== r && (n = r);
        const a = lS(t1);
        e.subscribeSharing(i, n, s, a);
    }
    class IE {
        constructor(){
            this.checkerSubject = void 0, this.checkerSubscription = void 0;
        }
        startCheck(e) {
            return this.checkerSubject && this.stopCheck(), this.checkerSubject = new j, this.checkerSubscription = Ze(e).subscribe(this.checkerSubject), this.checkerSubject;
        }
        stopCheck() {
            var e;
            this.checkerSubject && (this.checkerSubject.complete(), null === (e = this.checkerSubscription) || void 0 === e || e.unsubscribe(), this.checkerSubject = void 0);
        }
    }
    const AE = new IE, CE = new IE;
    function _E() {
        return AE.stopCheck();
    }
    function RE() {
        return CE.stopCheck();
    }
    function wE(e, t1) {
        _E(), RE();
        const { share: { remoteControllingSsrc: o }, meeting: { userId: r } } = e;
        o && (OE(), t1.takeBackRemoteControlPermission(r, o));
    }
    async function TE(e, t1, o, r, i) {
        const { share: { isSDKGrabControl: n, isGrabRemoteControl: s } } = o;
        if (!s) {
            r.subscribeGrabRemoteControl(e, !0);
            try {
                await Oe(np(Dl, 1).pipe(ot((e)=>!!e)));
            } catch (e) {}
        }
        const a = dS(o);
        a && (n ? (i.resendRemoteControlPositionPDU(), i.updateRemoteControlProperties({
            os: a.os,
            isControllerNow: !0,
            dimension: t1 && Ry(t1)
        })) : t1 && i.startRemoteControl(t1, a.os, Ry(t1)));
    }
    function OE() {
        SE.log("qr scanning stop"), bE.startRemoteControlQRCheck(!1);
    }
    function DE(e, t1, o) {
        var r;
        const { audio: i, share: { isReceiveSharingFromMainSession: n } } = t1;
        if ((null == i || null === (r = i.localShareAudioUserMutedList) || void 0 === r ? void 0 : r.length) > 0) {
            const { localShareAudioUserMutedList: t1 } = i, r = t1.find((t1)=>t1.userId === e);
            t1.filter((t1)=>t1.userId !== e).forEach((e)=>{
                o.setSharingAudioVolume(e.userId, !0, e.isFromMainSession);
            }), o.setSharingAudioVolume(e, !(null == r || !r.muted), !!n);
        }
    }
    const PE = ia.createAgent(), ME = yE(ca.getInstance()), kE = ia.createAgent(), LE = yE(ca.getInstance());
    function NE(e) {
        for(var t1 = arguments.length, o = Array(t1 > 1 ? t1 - 1 : 0), r = 1; r < t1; r++)o[r - 1] = arguments[r];
        throw Error("[Immer] minified error nr: " + e + (o.length ? " " + o.map(function(e) {
            return "'" + e + "'";
        }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function VE(e) {
        return !!e && !!e[bI];
    }
    function UE(e) {
        var t1;
        return !!e && (function(e) {
            if (!e || "object" != typeof e) return !1;
            var t1 = Object.getPrototypeOf(e);
            if (null === t1) return !0;
            var o = Object.hasOwnProperty.call(t1, "constructor") && t1.constructor;
            return o === Object || "function" == typeof o && Function.toString.call(o) === EI;
        }(e) || Array.isArray(e) || !!e[SI] || !!(null === (t1 = e.constructor) || void 0 === t1 ? void 0 : t1[SI]) || HE(e) || $E(e));
    }
    function jE(e, t1, o) {
        void 0 === o && (o = !1), 0 === xE(e) ? (o ? Object.keys : II)(e).forEach(function(r) {
            o && "symbol" == typeof r || t1(r, e[r], e);
        }) : e.forEach(function(o, r) {
            return t1(r, o, e);
        });
    }
    function xE(e) {
        var t1 = e[bI];
        return t1 ? t1.i > 3 ? t1.i - 4 : t1.i : Array.isArray(e) ? 1 : HE(e) ? 2 : $E(e) ? 3 : 0;
    }
    function BE(e, t1) {
        return 2 === xE(e) ? e.has(t1) : Object.prototype.hasOwnProperty.call(e, t1);
    }
    function FE(e, t1, o) {
        var r = xE(e);
        2 === r ? e.set(t1, o) : 3 === r ? e.add(o) : e[t1] = o;
    }
    function HE(e) {
        return gI && e instanceof Map;
    }
    function $E(e) {
        return vI && e instanceof Set;
    }
    function WE(e) {
        return e.o || e.t;
    }
    function GE(e) {
        if (Array.isArray(e)) return Array.prototype.slice.call(e);
        var t1 = AI(e);
        delete t1[bI];
        for(var o = II(t1), r = 0; r < o.length; r++){
            var i = o[r], n = t1[i];
            !1 === n.writable && (n.writable = !0, n.configurable = !0), (n.get || n.set) && (t1[i] = {
                configurable: !0,
                writable: !0,
                enumerable: n.enumerable,
                value: e[i]
            });
        }
        return Object.create(Object.getPrototypeOf(e), t1);
    }
    function KE(e, t1) {
        return void 0 === t1 && (t1 = !1), qE(e) || VE(e) || !UE(e) || (xE(e) > 1 && (e.set = e.add = e.clear = e.delete = zE), Object.freeze(e), t1 && jE(e, function(e, t1) {
            return KE(t1, !0);
        }, !0)), e;
    }
    function zE() {
        NE(2);
    }
    function qE(e) {
        return null == e || "object" != typeof e || Object.isFrozen(e);
    }
    function JE(e) {
        var t1 = CI[e];
        return t1 || NE(18, e), t1;
    }
    function QE() {
        return hI;
    }
    function ZE(e, t1) {
        t1 && (JE("Patches"), e.u = [], e.s = [], e.v = t1);
    }
    function YE(e) {
        XE(e), e.p.forEach(tI), e.p = null;
    }
    function XE(e) {
        e === hI && (hI = e.l);
    }
    function eI(e) {
        return hI = {
            p: [],
            l: hI,
            h: e,
            m: !0,
            _: 0
        };
    }
    function tI(e) {
        var t1 = e[bI];
        0 === t1.i || 1 === t1.i ? t1.j() : t1.g = !0;
    }
    function oI(e, t1) {
        t1._ = t1.p.length;
        var o = t1.p[0], r = void 0 !== e && e !== o;
        return t1.h.O || JE("ES5").S(t1, e, r), r ? (o[bI].P && (YE(t1), NE(4)), UE(e) && (e = rI(t1, e), t1.l || nI(t1, e)), t1.u && JE("Patches").M(o[bI].t, e, t1.u, t1.s)) : e = rI(t1, o, []), YE(t1), t1.u && t1.v(t1.u, t1.s), e !== yI ? e : void 0;
    }
    function rI(e, t1, o) {
        if (qE(t1)) return t1;
        var r = t1[bI];
        if (!r) return jE(t1, function(i, n) {
            return iI(e, r, t1, i, n, o);
        }, !0), t1;
        if (r.A !== e) return t1;
        if (!r.P) return nI(e, r.t, !0), r.t;
        if (!r.I) {
            r.I = !0, r.A._--;
            var i = 4 === r.i || 5 === r.i ? r.o = GE(r.k) : r.o, n = i, s = !1;
            3 === r.i && (n = new Set(i), i.clear(), s = !0), jE(n, function(t1, n) {
                return iI(e, r, i, t1, n, o, s);
            }), nI(e, i, !1), o && e.u && JE("Patches").N(r, o, e.u, e.s);
        }
        return r.o;
    }
    function iI(e, t1, o, r, i, n, s) {
        if (VE(i)) {
            var a = rI(e, i, n && t1 && 3 !== t1.i && !BE(t1.R, r) ? n.concat(r) : void 0);
            if (FE(o, r, a), !VE(a)) return;
            e.m = !1;
        } else s && o.add(i);
        if (UE(i) && !qE(i)) {
            if (!e.h.D && e._ < 1) return;
            rI(e, i), t1 && t1.A.l || nI(e, i);
        }
    }
    function nI(e, t1, o) {
        void 0 === o && (o = !1), !e.l && e.h.D && e.m && KE(t1, o);
    }
    function sI(e, t1) {
        var o = e[bI];
        return (o ? WE(o) : e)[t1];
    }
    function aI(e, t1) {
        if (t1 in e) for(var o = Object.getPrototypeOf(e); o;){
            var r = Object.getOwnPropertyDescriptor(o, t1);
            if (r) return r;
            o = Object.getPrototypeOf(o);
        }
    }
    function dI(e) {
        e.P || (e.P = !0, e.l && dI(e.l));
    }
    function uI(e) {
        e.o || (e.o = GE(e.t));
    }
    function lI(e, t1, o) {
        var r = HE(t1) ? JE("MapSet").F(t1, o) : $E(t1) ? JE("MapSet").T(t1, o) : e.O ? function(e, t1) {
            var o = Array.isArray(e), r = {
                i: o ? 1 : 0,
                A: t1 ? t1.A : QE(),
                P: !1,
                I: !1,
                R: {},
                l: t1,
                t: e,
                k: null,
                o: null,
                j: null,
                C: !1
            }, i = r, n = _I;
            o && (i = [
                r
            ], n = RI);
            var s = Proxy.revocable(i, n), a = s.revoke, d = s.proxy;
            return r.k = d, r.j = a, d;
        }(t1, o) : JE("ES5").J(t1, o);
        return (o ? o.A : QE()).p.push(r), r;
    }
    function cI(e, t1) {
        switch(t1){
            case 2:
                return new Map(e);
            case 3:
                return Array.from(e);
        }
        return GE(e);
    }
    var pI, hI, mI = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), gI = "undefined" != typeof Map, vI = "undefined" != typeof Set, fI = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, yI = mI ? Symbol.for("immer-nothing") : ((pI = {})["immer-nothing"] = !0, pI), SI = mI ? Symbol.for("immer-draftable") : "__$immer_draftable", bI = mI ? Symbol.for("immer-state") : "__$immer_state", EI = "" + Object.prototype.constructor, II = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : Object.getOwnPropertyNames, AI = Object.getOwnPropertyDescriptors || function(e) {
        var t1 = {};
        return II(e).forEach(function(o) {
            t1[o] = Object.getOwnPropertyDescriptor(e, o);
        }), t1;
    }, CI = {}, _I = {
        get: function(e, t1) {
            if (t1 === bI) return e;
            var o = WE(e);
            if (!BE(o, t1)) return function(e, t1, o) {
                var r, i = aI(t1, o);
                return i ? "value" in i ? i.value : null === (r = i.get) || void 0 === r ? void 0 : r.call(e.k) : void 0;
            }(e, o, t1);
            var r = o[t1];
            return e.I || !UE(r) ? r : r === sI(e.t, t1) ? (uI(e), e.o[t1] = lI(e.A.h, r, e)) : r;
        },
        has: function(e, t1) {
            return t1 in WE(e);
        },
        ownKeys: function(e) {
            return Reflect.ownKeys(WE(e));
        },
        set: function(e, t1, o) {
            var r = aI(WE(e), t1);
            if (null == r ? void 0 : r.set) return r.set.call(e.k, o), !0;
            if (!e.P) {
                var i = sI(WE(e), t1), n = null == i ? void 0 : i[bI];
                if (n && n.t === o) return e.o[t1] = o, e.R[t1] = !1, !0;
                if (function(e, t1) {
                    return e === t1 ? 0 !== e || 1 / e == 1 / t1 : e != e && t1 != t1;
                }(o, i) && (void 0 !== o || BE(e.t, t1))) return !0;
                uI(e), dI(e);
            }
            return e.o[t1] === o && (void 0 !== o || t1 in e.o) || Number.isNaN(o) && Number.isNaN(e.o[t1]) || (e.o[t1] = o, e.R[t1] = !0), !0;
        },
        deleteProperty: function(e, t1) {
            return void 0 !== sI(e.t, t1) || t1 in e.t ? (e.R[t1] = !1, uI(e), dI(e)) : delete e.R[t1], e.o && delete e.o[t1], !0;
        },
        getOwnPropertyDescriptor: function(e, t1) {
            var o = WE(e), r = Reflect.getOwnPropertyDescriptor(o, t1);
            return r ? {
                writable: !0,
                configurable: 1 !== e.i || "length" !== t1,
                enumerable: r.enumerable,
                value: o[t1]
            } : r;
        },
        defineProperty: function() {
            NE(11);
        },
        getPrototypeOf: function(e) {
            return Object.getPrototypeOf(e.t);
        },
        setPrototypeOf: function() {
            NE(12);
        }
    }, RI = {};
    jE(_I, function(e, t1) {
        RI[e] = function() {
            return arguments[0] = arguments[0][0], t1.apply(this, arguments);
        };
    }), RI.deleteProperty = function(e, t1) {
        return RI.set.call(this, e, t1, void 0);
    }, RI.set = function(e, t1, o) {
        return _I.set.call(this, e[0], t1, o, e[0]);
    };
    var wI = function() {
        function e(e) {
            var t1 = this;
            this.O = fI, this.D = !0, this.produce = function(e, o, r) {
                if ("function" == typeof e && "function" != typeof o) {
                    var i = o;
                    o = e;
                    var n = t1;
                    return function(e) {
                        var t1 = this;
                        void 0 === e && (e = i);
                        for(var r = arguments.length, s = Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)s[a - 1] = arguments[a];
                        return n.produce(e, function(e) {
                            var r;
                            return (r = o).call.apply(r, [
                                t1,
                                e
                            ].concat(s));
                        });
                    };
                }
                var s;
                if ("function" != typeof o && NE(6), void 0 !== r && "function" != typeof r && NE(7), UE(e)) {
                    var a = eI(t1), d = lI(t1, e, void 0), u = !0;
                    try {
                        s = o(d), u = !1;
                    } finally{
                        u ? YE(a) : XE(a);
                    }
                    return "undefined" != typeof Promise && s instanceof Promise ? s.then(function(e) {
                        return ZE(a, r), oI(e, a);
                    }, function(e) {
                        throw YE(a), e;
                    }) : (ZE(a, r), oI(s, a));
                }
                if (!e || "object" != typeof e) {
                    if (void 0 === (s = o(e)) && (s = e), s === yI && (s = void 0), t1.D && KE(s, !0), r) {
                        var l = [], c = [];
                        JE("Patches").M(e, s, l, c), r(l, c);
                    }
                    return s;
                }
                NE(21, e);
            }, this.produceWithPatches = function(e, o) {
                if ("function" == typeof e) return function(o) {
                    for(var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)i[n - 1] = arguments[n];
                    return t1.produceWithPatches(o, function(t1) {
                        return e.apply(void 0, [
                            t1
                        ].concat(i));
                    });
                };
                var r, i, n = t1.produce(e, o, function(e, t1) {
                    r = e, i = t1;
                });
                return "undefined" != typeof Promise && n instanceof Promise ? n.then(function(e) {
                    return [
                        e,
                        r,
                        i
                    ];
                }) : [
                    n,
                    r,
                    i
                ];
            }, "boolean" == typeof (null == e ? void 0 : e.useProxies) && this.setUseProxies(e.useProxies), "boolean" == typeof (null == e ? void 0 : e.autoFreeze) && this.setAutoFreeze(e.autoFreeze);
        }
        var t1 = e.prototype;
        return t1.createDraft = function(e) {
            UE(e) || NE(8), VE(e) && (e = function(e) {
                return VE(e) || NE(22, e), function e(t1) {
                    if (!UE(t1)) return t1;
                    var o, r = t1[bI], i = xE(t1);
                    if (r) {
                        if (!r.P && (r.i < 4 || !JE("ES5").K(r))) return r.t;
                        r.I = !0, o = cI(t1, i), r.I = !1;
                    } else o = cI(t1, i);
                    return jE(o, function(t1, i) {
                        r && function(e, t1) {
                            return 2 === xE(e) ? e.get(t1) : e[t1];
                        }(r.t, t1) === i || FE(o, t1, e(i));
                    }), 3 === i ? new Set(o) : o;
                }(e);
            }(e));
            var t1 = eI(this), o = lI(this, e, void 0);
            return o[bI].C = !0, XE(t1), o;
        }, t1.finishDraft = function(e, t1) {
            var o = (e && e[bI]).A;
            return ZE(o, t1), oI(void 0, o);
        }, t1.setAutoFreeze = function(e) {
            this.D = e;
        }, t1.setUseProxies = function(e) {
            e && !fI && NE(20), this.O = e;
        }, t1.applyPatches = function(e, t1) {
            var o;
            for(o = t1.length - 1; o >= 0; o--){
                var r = t1[o];
                if (0 === r.path.length && "replace" === r.op) {
                    e = r.value;
                    break;
                }
            }
            o > -1 && (t1 = t1.slice(o + 1));
            var i = JE("Patches").$;
            return VE(e) ? i(e, t1) : this.produce(e, function(e) {
                return i(e, t1);
            });
        }, e;
    }(), TI = new wI, OI = TI.produce;
    TI.produceWithPatches.bind(TI), TI.setAutoFreeze.bind(TI), TI.setUseProxies.bind(TI), TI.applyPatches.bind(TI), TI.createDraft.bind(TI), TI.finishDraft.bind(TI);
    const DI = {
        ssrc: 0,
        status: yd.End,
        shareDimension: {
            width: 0,
            height: 0
        },
        receivedShareDimension: {
            width: 1920,
            height: 1080,
            logicWidth: 1920,
            logicHeight: 1080
        },
        sharePrivilege: fd.OnlyHost,
        activeNodeId: 0,
        activeSsrc: 0,
        shareQuality: 1,
        isRemoteSharingActive: !1,
        isReceiveSharing: !1,
        isGrabRemoteControl: !1,
        isSDKGrabControl: !1,
        isChromeExtensionInstalled: !1,
        isScreenShareForbidden: !1,
        isReceiveSharingFromMainSession: !1,
        isSharingToBreakoutRoom: !1,
        isSharingWithSecondCamera: !1,
        secondCameraId: "default",
        isRequireReadReceipt: !1,
        capturedEnsuredCanvas: [],
        renderedEnsuredCanvas: [],
        remoteControllingSsrc: 0,
        remoteControlApprovedSsrc: 0,
        remoteControlAppDownloadUrl: "",
        remoteControlAppInstallStatus: Kd.Unknown,
        isEnableAutoDeleteRcApp: !1,
        remoteControlledUserList: [],
        isRemoteControlEnabled: !1,
        isFullHDVideoShareEnabled: !1,
        userSsrcMapping: {},
        statistic: {
            encode: {
                sample_rate: 0,
                rtt: 0,
                jitter: 0,
                avg_loss: 0,
                max_loss: 0,
                width: 0,
                height: 0,
                fps: 0,
                bandwidth: 0,
                bitrate: 0
            },
            decode: {
                sample_rate: 0,
                rtt: 0,
                jitter: 0,
                avg_loss: 0,
                max_loss: 0,
                width: 0,
                height: 0,
                fps: 0,
                bandwidth: 0,
                bitrate: 0
            }
        }
    }, PI = bo({
        [`${hm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.sharePrivilege = o;
        }),
        [`${mm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isRemoteSharingActive = 1 === o.bStatus, e.activeNodeId = o.activeNodeID, e.activeSsrc = o.ssrc;
        }),
        [`${gm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isReceiveSharing = o;
        }),
        [`${vm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isChromeExtensionInstalled = o;
        }),
        [`${ym}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.shareDimension = {
                ...o
            };
        }),
        [`${Sm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.status = o;
        }),
        [`${bm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.ssrc = o;
        }),
        [`${Em}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.shareQuality = o;
        }),
        [`${Im}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.receivedShareDimension = {
                ...o
            };
        }),
        [`${Gm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.remoteControlledUserList.includes(o) || e.remoteControlledUserList.push(o);
        }),
        [`${Km}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.remoteControlledUserList.indexOf(o);
            r >= 0 && e.remoteControlledUserList.splice(r, 1);
        }),
        [`${Am}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isGrabRemoteControl = o, !1 === o && (e.remoteControlViewportDomSelector = void 0);
        }),
        [`${Cm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isSDKGrabControl = o;
        }),
        [`${_m}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isReceiveSharingFromMainSession = o;
        }),
        [`${Rm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isSharingToBreakoutRoom = o;
        }),
        [`${wm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isSharingWithSecondCamera = o;
        }),
        [`${Tm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.secondCameraId = o;
        }),
        [`${Om}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isRequireReadReceipt = o;
        }),
        [`${Dm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isOptimizedForSharedVideo = o;
        }),
        [`${Pm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { data: { encoding: r, rate: i, ...n } } = o;
            e.statistic.encode = {
                bitrate: i,
                ...n
            };
        }),
        [`${Mm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { data: { encoding: r, rate: i, ...n } } = o;
            e.statistic.decode = {
                bitrate: i,
                ...n
            };
        }),
        [`${km}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.capturedEnsuredCanvas.includes(o) || e.capturedEnsuredCanvas.push(o);
        }),
        [`${Lm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.renderedEnsuredCanvas.includes(o) || e.renderedEnsuredCanvas.push(o);
        }),
        [`${Vm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.remoteControllingSsrc = o;
        }),
        [`${Um}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.remoteControlApprovedSsrc = o;
        }),
        [`${jm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.remoteControlAppDownloadUrl = o;
        }),
        [`${xm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            (e.remoteControlAppInstallStatus !== Kd.Installed || Kd.Unknown) && (e.remoteControlAppInstallStatus = o);
        }),
        [`${$m}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.remoteControlAppLaunchSheme = o;
        }),
        [`${Wm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { userId: r, ssrc: i } = o;
            Object.assign(e.userSsrcMapping, {
                [`${r}`]: i
            });
        }),
        [`${zm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            Object.assign(e, o);
        }),
        [`${qm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.remoteControlViewportDomSelector = o;
        }),
        [`${Jm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isFullHDVideoShareEnabled = o;
        }),
        [`${Qm}`]: ()=>({
                ...DI
            })
    }, DI), MI = {
        remoteControlEpics0: (e)=>e.pipe(Dt(`${pn}`), Le((e)=>{
                const { payload: { meetingOptions: t1, rcAutoDelete: o, jwtRc: r, opRc: i } } = e, n = (null == t1 ? void 0 : t1.isRemoteControlEnbaled) && i && 1 === r;
                return zm({
                    isRemoteControlEnabled: n,
                    isEnableAutoDeleteRcApp: 1 === o
                });
            })),
        remoteControlEpics1: (e, t1)=>nr(e, 16391).pipe(Fe((e)=>{
                const { payload: { body: { bOn: o, sendID: r, receiveID: i } } } = e, { meeting: { userId: n }, share: { status: s, activeNodeId: a, isGrabRemoteControl: d } } = t1.value, u = [];
                if (s === yd.End && u.push(Vm(0)), s !== yd.End) if (Yr(n, r)) if (o) {
                    _E(), RE(), s === yd.Paused && (kE.resumeSharing(), LE.resumeDesktopSharing(), u.push(Sm(yd.Sharing))), u.push(Vm(i));
                    const e = ph(t1.value).find((e)=>Yr(e.userId, i));
                    e && u.push(Wm({
                        userId: e.userId,
                        ssrc: i
                    }));
                } else u.push(Vm(0));
                else {
                    var l;
                    const e = null === (l = ph(t1.value)) || void 0 === l ? void 0 : l.find((e)=>Yr(e.userId, r));
                    e && (u.push(Wm({
                        userId: e.userId,
                        ssrc: r
                    })), tp(Ul, {
                        userId: e.userId,
                        displayName: e.displayName,
                        isSharingEntireScreen: LE.isSharingEntireScreen()
                    }));
                }
                else if (!i || Yr(i, n)) {
                    const e = ah(t1.value);
                    if (!Kp(e.userRole) && !gs.isAndroidOrIOSBrowser) {
                        const e = r && Yr(a, r);
                        o ? (u.push(Gm(a)), e && (d || kE.subscribeGrabRemoteControl(a, !0))) : (u.push(Km(a)), e && (d && (kE.subscribeGrabRemoteControl(a, !1), u.push(Am(!1)), tp(Dl, !1)), LE.updateRemoteControlProperties({
                            isControllerNow: !1
                        }))), tp(Ol, o);
                    }
                }
                return _e(u);
            })),
        remoteControlEpics2: (e, t1)=>nr(e, 16395).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                return t1.payload.body.id === o.meeting.userId;
            }), Le((e)=>{
                let [t1] = e;
                const { payload: { body: { bOn: o } } } = t1;
                return LE.updateRemoteControlProperties({
                    isControllerNow: o
                }), tp(Dl, o), Am(o);
            })),
        remoteControlEpics3: (e)=>ur(e, [
                sd.StartRemoteControlSuccess,
                sd.StartRemoteControlFailed,
                sd.CancelRemoteControlSuccess
            ]).pipe(Jy((e)=>e.payload.type === sd.StartRemoteControlSuccess ? (tp(Ml), Cm(!0)) : e.payload.type === sd.CancelRemoteControlSuccess ? Cm(!1) : void (e.payload.type === sd.StartRemoteControlFailed && tp(kl)))),
        remoteControlEpics4: (e)=>ur(e, [
                sd.RemoteControlCopiedTextNotify,
                sd.RemoteControlPasteTextLengthOverflow
            ]).pipe(vt((e)=>{
                if (e.payload.type === sd.RemoteControlCopiedTextNotify) {
                    const { payload: { data: t1 } } = e;
                    tp(Pl, {
                        content: t1.data,
                        x: t1.x,
                        y: t1.y
                    });
                } else tp(Pl, {
                    error: "length of pasted text is too long"
                });
            }), ut(ne)),
        remoteControlEpics5: (e, t1)=>nr(e, 4342).pipe(ot((e)=>0 === e.payload.body.result), Fe((e)=>{
                const { payload: { body: { downloadUrl: o, ssrc: r, urlScheme: i } } } = e, { share: { remoteControlApprovedSsrc: n, status: s } } = t1.value, a = [], { isMacOS: d } = gs;
                if (s !== yd.End) {
                    if (!n || n === r) {
                        _E();
                        try {
                            const e = JSON.parse(o || "{}"), t1 = d ? e.macDownloadUrl : e.winDownloadUrl;
                            a.push(jm(t1));
                        } catch (e) {
                            console.warn("unsupported JSON string", e);
                        }
                    }
                    const s = {}, u = ph(t1.value).find((e)=>Yr(e.userId, r));
                    u && Object.assign(s, {
                        controllerName: $r(u.displayName)
                    }), Object.assign(s, {
                        ssrc: r
                    });
                    const { deviceId: l } = LE.getShareStreamInfo();
                    l && Object.assign(s, {
                        DeviceID: l
                    });
                    const c = `${i}&${new URLSearchParams(s).toString()}`;
                    a.push($m(c), xm(Kd.Unknown)), tp(Bl, c);
                }
                return _e(a);
            })),
        remoteControlEpics6: (e)=>e.pipe(Dt(`${Bm}`), Fe(()=>AE.startCheck(1e4).pipe(Le(()=>(tp(jl, Kd.Unknown), xm(Kd.Unknown)))))),
        remoteControlEpics7: (e, t1)=>e.pipe(Dt(`${Fm}`), ot(()=>{
                const { share: { remoteControlAppInstallStatus: e } } = t1.value;
                return e === Kd.Installed;
            }), Fe(()=>CE.startCheck(12e4).pipe(Fe(()=>{
                    tp(jl, zd.Unlaunched);
                    const { share: { remoteControlApprovedSsrc: e, isEnableAutoDeleteRcApp: o }, meeting: { userId: r } } = t1.value, i = [], { isMacOS: n } = gs;
                    return e && (kE.remoteControlConsent(Gd.CacheClean, e, r, {
                        ...LE.getShareStreamInfo(),
                        platform: n ? "mac" : "win"
                    }, o), i.push($m(""), Um(0))), _e(i);
                })))),
        remoteControlEpics8: (e, t1)=>e.pipe(Dt(`${$m}`), ot((e)=>!!e.payload), Fe((e)=>{
                const { payload: o } = e, r = [];
                let i;
                if (o) {
                    !function(e) {
                        if (!e.startsWith("zoomprc://")) return;
                        const t1 = ei("__ZOOM_SDK_RC_APP_SCHEME_@__");
                        let o = document.getElementById(t1);
                        o || (o = document.createElement("iframe"), o.id = t1, o.style.display = "none", document.body.appendChild(o)), o.contentWindow.location.href = e;
                    }(o), r.push(Fm());
                    const e = performance.now();
                    document.hasFocus() ? i = Ye(25).pipe(gt(()=>{
                        const o = performance.now() - e < 500;
                        return o || tp(jl, Kd.Uninstalled), o && t1.value.share.remoteControlAppInstallStatus === Kd.Unknown;
                    }), ht(()=>{
                        const t1 = performance.now() - e, o = [];
                        return document.hasFocus() || (t1 > 75 ? o.push(Bm()) : _E(), tp(jl, Kd.Installed), o.push(xm(Kd.Installed), Fm())), _e(o);
                    }), function() {
                        for(var e = [], t1 = 0; t1 < arguments.length; t1++)e[t1] = arguments[t1];
                        return function(t1) {
                            return $e(t1, Re.apply(void 0, a([], s(e))));
                        };
                    }(xm(Kd.Uninstalled))) : (tp(jl, Kd.Unknown), r.push(xm(Kd.Unknown)));
                }
                return i ? Xe(i, _e(r)) : _e(r);
            })),
        remoteControlEpics9: (e, t1)=>nr(e, js).pipe(Fe(()=>(tp(xl, qd.Ended), wE(t1.value, kE), _e([
                    $m(""),
                    Um(0)
                ])))),
        remoteControlEpics10: (e, t1)=>e.pipe(Dt(`${Sm}`), ot((e)=>{
                const { share: { remoteControllingSsrc: o, remoteControlApprovedSsrc: r } } = t1.value;
                return !(e.payload !== yd.End || !o && !r);
            }), vt(()=>{
                const { share: { remoteControllingSsrc: e, remoteControlApprovedSsrc: o, isEnableAutoDeleteRcApp: r }, meeting: { userId: i } } = t1.value, { isMacOS: n } = gs;
                e && wE(t1.value, kE), o !== e && kE.remoteControlConsent(Gd.Decline, o, i, {
                    ...LE.getShareStreamInfo(),
                    platform: n ? "mac" : "win"
                }, r);
            }), ut(ne)),
        remoteControlEpics11: (e, t1)=>nr(e, 16430).pipe(Fe(()=>(_E(), RE(), tp(jl, zd.Launched), t1.value.share.status !== yd.End && function(e, t1) {
                    (async function(e) {
                        const { media: { assetsPath: t1 } } = e, o = `${t1}/qrscanner.min.js`;
                        return "WebQrscanner" in window ? Promise.resolve("") : new Promise((e, t1)=>{
                            SE.log(`load qr scanner script start. url:${o}`), cr(o, ()=>{
                                SE.log("load qr scanner script done."), e("");
                            }, t1);
                        });
                    })(e).then(()=>{
                        SE.log("qr scanning start"), t1.startRemoteControlQRCheck(!0);
                    });
                }(t1.value, LE), _e([
                    $m(""),
                    Um(0)
                ])))),
        remoteControlEpics12: (e)=>ur(e, sd.CurrentDesktopSharingWidthHeight).pipe(vt(()=>{
                kE.syncSharedContentMetaWithRcApp(LE.getShareStreamInfo());
            }), ut(ne)),
        remoteControlEpics13: (e, t1)=>ur(e, sd.SendRemoteControlQrCode).pipe(vt((e)=>{
                const { payload: { data: o } } = e, { share: { status: r } } = t1.value;
                r !== yd.End && Array.isArray(o) && o.length > 0 && o.forEach((e)=>{
                    null != e && e.startsWith("zrc_") && kE.sendRemoteControlAuth(e);
                });
            }), ut(ne)),
        remoteControlEpics14: (e)=>nr(e, 16434).pipe(vt((e)=>{
                const { payload: { body: { result: t1 } } } = e;
                0 === t1 && (OE(), tp(xl, qd.Started));
            }), ut(ne)),
        remoteControlEpics15: (e, t1)=>nr(e, Ps).pipe(ot((e)=>{
                var o, r;
                const { meeting: { userId: i }, share: { remoteControlledUserList: n } } = t1.value, { payload: { body: s } } = e;
                return n.length > 0 && ((null === (o = s.update) || void 0 === o ? void 0 : o.some((e)=>e.id !== i && !1 === e.bShareOn)) || (null === (r = s.remove) || void 0 === r ? void 0 : r.some((e)=>e.id !== i)));
            }), Fe((e)=>{
                var o, r, i, n;
                const { payload: { body: s } } = e, { share: { remoteControlledUserList: a, activeNodeId: d, isGrabRemoteControl: u }, meeting: { userId: l } } = t1.value, c = (null !== (o = null === (r = s.update) || void 0 === r ? void 0 : r.filter((e)=>e.id !== l && !1 === e.bShareOn)) && void 0 !== o ? o : []).concat(null !== (i = null === (n = s.remove) || void 0 === n ? void 0 : n.filter((e)=>e.id !== l)) && void 0 !== i ? i : []), p = [];
                return a.forEach((e)=>{
                    c.find((t1)=>t1.id === e) && (p.push(Km(e)), e === d && u && (p.push(Am(!1)), tp(Dl, !1)));
                }), _e(p);
            })),
        remoteControlEpics16: (e, t1)=>e.pipe(Dt(`${sn}`), vt(()=>{
                const { share: { remoteControllingSsrc: e, status: o } } = t1.value;
                o === yd.Sharing && e && tp(xl, qd.Ended);
            }), ut(ne))
    }, kI = {
        epics0: (e, t1)=>nr(e, Ms).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.lockShare);
            }), ft(t1), vt((e)=>{
                let [t1, o] = e;
                const { share: { sharePrivilege: r } } = o, { payload: { body: { lockShare: i } } } = t1;
                r !== i && tp(Ll, i);
            }), Le((e)=>{
                let [t1] = e;
                return hm(t1.payload.body.lockShare);
            })),
        epics1: (e)=>nr(e, 20227).pipe(Le((e)=>bm(e.payload.body.ssrc))),
        epics2: (e, t1)=>nr(e, Os).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                const { payload: { body: r } } = t1, { share: { isReceiveSharingFromMainSession: i } } = o;
                return !i || i && r.fromMainSession;
            }), Le((e)=>{
                let [o, r] = e;
                const { share: { isReceiveSharing: i, activeNodeId: n, isReceiveSharingFromMainSession: s }, breakoutRoom: a } = r, { payload: { body: d } } = o;
                if (i && 1 === d.bStatus) {
                    let e = !1;
                    (null == a ? void 0 : a.currentRoom.status) === Qp.InRoom && a.mainSessionAttendeeList.length > 0 && (e = a.mainSessionAttendeeList.findIndex((e)=>e.userId === n) > -1), PE.unsubscribeSharing(n, e), EE(PE, r, d.activeNodeID), ME.switchSharingSource(d.ssrc, s), DE(d.activeNodeID, t1.value, ME), tp(Tl, {
                        userId: d.activeNodeID
                    });
                } else if (1 === d.bStatus) {
                    const e = {
                        activeUserId: d.activeNodeID,
                        isActive: !0
                    };
                    s && Object.assign(e, {
                        isFromMainSession: !0
                    }), tp(vl, e);
                } else if (i) {
                    const e = {
                        activeUserId: d.activeNodeID,
                        isActive: !1
                    };
                    s && Object.assign(e, {
                        isFromMainSession: !0
                    }), tp(vl, e);
                }
                return mm(d);
            })),
        epics3: (e)=>ur(e, sd.CheckChromeSharingExtensionResponse).pipe(Le((e)=>(tp(fl, e.payload.data), vm(e.payload.data)))),
        epics4: (e, t1)=>ur(e, [
                sd.SharingDesktopStreamHaveAudio,
                sd.SharingDesktopStreamHaveNoAudio
            ]).pipe(ot((e)=>e.payload.type !== sd.SharingDesktopStreamHaveAudio || !t1.value.audio.secondaryAudioMicrophoneId), ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { meeting: { userId: r }, share: { isSharingToBreakoutRoom: i, isOptimizedForSharedVideo: n } } = o, { payload: { type: s } } = t1, a = s === sd.SharingDesktopStreamHaveAudio;
                return PE.startSharing(r, {
                    bShareToBO: i,
                    bShareAudio: a,
                    bShareVideo: !!n
                }), ME.switchSharingMode(n ? Hd.VideoMode : Hd.Normal), fm(!1);
            })),
        epics5: (e)=>ur(e, [
                sd.DesktopSharingError,
                sd.DesktopSharingChromeExtensionUninstalled,
                sd.DesktopSharingPermissionDenied,
                sd.DesktopSharingSystemError
            ]).pipe(Fe((e)=>{
                const t1 = [];
                let o = "";
                return [
                    sd.DesktopSharingPermissionDenied,
                    sd.DesktopSharingSystemError
                ].includes(e.payload.type) && (t1.push(fm(!0)), e.payload.type === sd.DesktopSharingSystemError ? gs.isMacOS && (o = "To use screen share on Chrome, please allow screen recording access in system setting.") : o = "To use screen share, please allow the permission request."), tp(yl, {
                    reason: o
                }), _e(t1);
            })),
        epics6: (e)=>ur(e, sd.CurrentDesktopSharingWidthHeight).pipe(ot((e)=>!!e.payload.data), Le((e)=>{
                tp(Sl, e.payload.data);
                const { payload: { data: { width: t1, height: o } } } = e;
                return ME.ajustmentSharingCanvas(t1, o), ym(e.payload.data);
            })),
        epics7: (e, t1)=>ur(e, sd.SharingDecodeMaxSize).pipe(ot((e)=>!!e.payload.data), ft(t1), Jy((e)=>{
                let [t1, o] = e;
                const { share: { shareQuality: r, activeNodeId: i } } = o, { payload: { data: { fps: n } } } = t1, s = Number(n);
                if (r !== s) return EE(PE, o, i, s), Em(s);
            })),
        epics8: (e)=>nr(e, 20226).pipe(vt((e)=>{
                var t1, o;
                if (tp(bl, null === (t1 = e.payload) || void 0 === t1 ? void 0 : t1.body), null !== (o = e.payload) && void 0 !== o && o.body) {
                    const { payload: { body: { width: t1, height: o } } } = e;
                    ME.ajustmentReceivedSharingCanvas(t1, o);
                }
            }), Le((e)=>Im(e.payload.body))),
        epics9: (e)=>ur(e, sd.SharingPara).pipe(vt((e)=>{
                var t1, o;
                if (tp(bl, null === (t1 = e.payload.data) || void 0 === t1 ? void 0 : t1.body), null !== (o = e.payload.data) && void 0 !== o && o.body) {
                    const { payload: { data: { body: { width: t1, height: o } } } } = e;
                    ME.ajustmentReceivedSharingCanvas(t1, o);
                }
            }), Le((e)=>{
                var t1;
                return Im(null === (t1 = e.payload.data) || void 0 === t1 ? void 0 : t1.body);
            })),
        epics10: (e, t1)=>ur(e, sd.UserStopDesktopSharing).pipe(ft(t1), Le((e)=>{
                let [, t1] = e;
                const { meeting: { userId: o }, share: { status: r } } = t1;
                return r !== yd.End && (PE.stopSharing(o), ME.stopDesktopSharing(), tp(El)), Sm(yd.End);
            })),
        epics11: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                const { meeting: { userId: r } } = o, i = t1.payload.body.update;
                return i && i.length > 0 && i.findIndex((e)=>e.id === r && void 0 !== e.bShareOn) > -1;
            }), Fe((e)=>{
                let [t1, o] = e;
                const { meeting: { userId: r }, share: { status: i, isReceiveSharing: n, activeNodeId: s } } = o, { payload: { body: { update: a } } } = t1, d = a.find((e)=>e.id === r && !1 === e.bShareOn), u = a.find((e)=>e.id === r && !0 === e.bShareOn), l = [];
                return d && i !== yd.End && (PE.stopSharing(r), ME.stopDesktopSharing(), l.push(Sm(yd.End)), tp(Il)), u && i === yd.End && (n && (ME.stopRenderSharing(), PE.unsubscribeSharing(s), l.push(gm(!1))), l.push(Sm(yd.Sharing))), _e(l);
            })),
        epics12: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                const { meeting: { userId: r } } = o, i = t1.payload.body.update;
                return i && i.length > 0 && i.findIndex((e)=>e.id !== r && void 0 !== e.bShareOn) > -1;
            }), Fe((o)=>{
                let [r, i] = o;
                const { payload: { body: { update: n } } } = r, { share: { activeNodeId: s, isReceiveSharing: a } } = i, d = uS(i), u = n.filter((e)=>!0 === e.bShareOn && !1 === e.bSharePause), l = n.filter((e)=>!0 === e.bShareOn && !0 === e.bSharePause), c = n.filter((e)=>!1 === e.bShareOn);
                return u.length > 0 && u.forEach((e)=>{
                    -1 === d.findIndex((t1)=>t1.userId === e.id) ? tp(Cl, e) : tp(wl, e);
                }), l.length > 0 && l.forEach((e)=>{
                    tp(Rl, e);
                }), c.length > 0 && (c.forEach((e)=>{
                    tp(_l, e);
                }), a && c.some((e)=>e.id === s)) ? rt(nr(e, Os).pipe(nt(1), ut(ne)), Ze(50).pipe(ut(we("timeout")))).pipe(it(()=>{
                    const { share: { activeNodeId: e, isReceiveSharingFromMainSession: o } } = t1.value, r = d.filter((t1)=>t1.userId !== e);
                    if (r.length > 0) {
                        const i = r[0], { userId: n } = i;
                        return PE.unsubscribeSharing(e, o), EE(PE, t1.value, n), ME.switchSharingSource(n, o), DE(n, t1.value, ME), tp(Tl, {
                            userId: n
                        }), Re(mm({
                            activeNodeID: n,
                            bStatus: 1,
                            ssrc: n
                        }));
                    }
                    return ne;
                })) : ne;
            })),
        epics13: (e, t1)=>nr(e, Ds).pipe(ft(t1), ht((e)=>{
                let [o, r] = e;
                const { payload: { body: { encryptKey: i, additionalType: n } } } = o, { media: { sharingDecodeStatus: s, sharingEncodeStatus: a }, meeting: { confId: d, userId: u, zoomId: l, meetingId: c, meetingNumber: p, isWebinar: h } } = r;
                return Ay(t1).pipe(ht((e)=>{
                    let o = a;
                    return (!gs.isSupportSendScreenSharing || h && e && Kp(e.userRole)) && (o = "failed"), Iy("sharing", o, s).pipe(vt((e)=>{
                        let [o, r] = e;
                        const s = {
                            userId: u,
                            sn: zr(l),
                            confId: d,
                            encryptKey: zr(i),
                            encryptType: n,
                            meetingId: c,
                            meetingNumber: p
                        };
                        if (o && (null == ME || ME.updateMediaParams({
                            iVType: Is.SHARING_ENCODE,
                            isFromMainSession: !1,
                            updateParams: s
                        })), r) {
                            ME.updateMediaParams({
                                iVType: Is.SHARING_DECODE,
                                isFromMainSession: !1,
                                updateParams: s
                            });
                            const { participants: { attendeesList: e } } = t1.value;
                            if (e.length > 0) {
                                const t1 = e.map((e)=>({
                                        userid: e.userId,
                                        sn: e.zoomID && zr(e.zoomID)
                                    }));
                                ME.updateUserMediaSN({
                                    added: t1,
                                    isFromMainSession: !1,
                                    iVType: Is.SHARING_DECODE
                                });
                            }
                        }
                    }), ut(ne));
                }));
            })),
        epics14: (e, t1)=>dr(e, 20235).pipe(ft(t1), vt((e)=>{
                let [t1, o] = e;
                const { media: { sharingDecodeStatus: r } } = o, { type: i, payload: { body: n } } = t1, s = i === `${Do}`;
                Iy("sharing", "success", r).subscribe((e)=>{
                    let [, t1] = e;
                    t1 && ME.addReceivedSharingChannelType({
                        isFromMainSession: s,
                        ...n
                    });
                });
            }), ut(ne)),
        epics15: (e, t1)=>dr(e, 20236).pipe(ft(t1), vt((e)=>{
                let [t1, o] = e;
                const { media: { sharingDecodeStatus: r } } = o, { type: i, payload: { body: { ssrc: n } } } = t1, s = i === `${Do}`;
                Iy("sharing", "success", r).subscribe((e)=>{
                    let [, t1] = e;
                    t1 && ME.removeReceivedSharingChannelType({
                        isFromMainSession: s,
                        ssrc: n
                    });
                });
            }), ut(ne)),
        epics16: (e)=>ur(e, sd.SharingFirstDecodeFrameReceivedSsrc).pipe(ot((e)=>!!e.payload.data), vt((e)=>{
                const { payload: { data: { ssrc: t1 } } } = e;
                PE.sendReceivingSharingReady(t1);
            }), ut(ne)),
        epics17: (e, t1)=>nr(e, 20233).pipe(ot(()=>!!t1.value.share.isRequireReadReceipt), vt((e)=>{
                const { payload: { body: { bReceiveOk: t1 } } } = e;
                t1 && tp(Nl);
            }), ut(ne)),
        epics18: (e, t1)=>nr(e, Ms).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.lockShare);
            }), Fe((e)=>{
                const { payload: { body: { lockShare: o } } } = e, { share: { isOptimizedForSharedVideo: r, isSharingToBreakoutRoom: i }, audio: { isSharingAudio: n }, meeting: { userId: s } } = t1.value, a = [];
                return o === fd.MultipleShare && r && (PE.startSharing(s, {
                    bShareAudio: n,
                    bShareToBO: i,
                    bShareVideo: !1
                }), ME.switchSharingMode(Hd.Normal), a.push(Dm(!1))), _e(a);
            })),
        epics19: (e, t1)=>ur(e, sd.ShareQosData).pipe(ft(t1), Le((e)=>{
                var t1;
                let [o, r] = e;
                const { meeting: { isWebinar: i }, media: { sharingEncodeStatus: n, sharingDecodeStatus: s }, share: { status: a, isReceiveSharing: d }, participants: { xmppAttendeeList: u } } = r;
                let l = vh(r).length > 0;
                i && (l = l || Boolean(u.length));
                const c = a !== yd.End && "success" === n && l, p = d && "success" === s;
                return null !== (t1 = o.payload.data) && void 0 !== t1 && t1.encoding ? c ? (tp(Vl, o.payload), Pm(o.payload)) : Pm(Vd) : p ? (tp(Vl, o.payload), Mm(o.payload)) : Mm(Vd);
            }))
    }, LI = ir(kI, MI), NI = ia.createAgent();
    let VI = function(e) {
        return e.Add = "add", e.List = "list", e.Remove = "memberremove", e.rename = "rename", e.update = "UPDATE", e;
    }({}), UI = function(e) {
        return e.Open = "open", e.Message = "message", e.Error = "error", e.Close = "close", e;
    }({});
    class jI {
        constructor(){
            this.eventHandlers = void 0, this.websocket = void 0, this.seq = void 0, this.eventHandlers = new Map, this.websocket = null, this.seq = 1;
        }
        static getInstance() {
            return this.xmppInstance || (this.xmppInstance = new jI), this.xmppInstance;
        }
        on(e, t1) {
            let o = this.eventHandlers.get(e);
            o || (o = []), o.push(t1), this.eventHandlers.set(e, o);
        }
        off(e, t1) {
            const o = this.eventHandlers.get(e);
            if (o) {
                const r = o.filter((e)=>e !== t1);
                this.eventHandlers.set(e, r);
            }
        }
        emit(e, t1) {
            const o = this.eventHandlers.get(e);
            o && o instanceof Array && o.slice(0).forEach((e)=>{
                try {
                    e(t1);
                } catch (e) {
                    console.error(e);
                }
            });
        }
        sendMessageToRwg(e) {
            this.seq += 1;
            const t1 = this.seq;
            return this.websocket && this.websocket.readyState === WebSocket.OPEN && this.websocket.send(JSON.stringify(Object.assign(e, {
                seq: t1
            }))), t1;
        }
        connect(e, t1) {
            this.websocket = t1 ? new window.ZoomTPModule.ZoomTPWebSocket(e) : new WebSocket(e), this.websocket.binaryType = "arraybuffer", this.addWebSocketEventListeners();
        }
        close() {
            var e;
            null === (e = this.websocket) || void 0 === e || e.close();
        }
        addWebSocketEventListeners() {
            this.websocket && (this.websocket.addEventListener("open", (e)=>{
                this.emit(UI.Open, e);
            }), this.websocket.addEventListener("message", (e)=>{
                const { data: t1 } = e;
                var o;
                if (t1 instanceof ArrayBuffer) 0 === new Uint8Array(t1)[0] && (null === (o = this.websocket) || void 0 === o || o.send(t1));
                else try {
                    this.emit(UI.Message, JSON.parse(t1));
                } catch (e) {
                    console.warn("Unsupported format", t1);
                }
            }), this.websocket.addEventListener("close", (e)=>{
                this.emit(UI.Close, e);
            }), this.websocket.addEventListener("error", (e)=>{
                this.emit(UI.Error, e);
            }));
        }
        join(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24576,
                    body: {
                        clientCap: e
                    }
                })
            };
        }
        raiseHand() {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24580,
                    body: null
                })
            };
        }
        lowerHand(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24578,
                    jids: e || []
                })
            };
        }
        sendWebinarMseeage(e, t1, o) {
            const r = {
                msg: e,
                jid: t1 ? [
                    t1
                ] : [],
                type: o,
                bcm: arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
            };
            return {
                seq: this.sendMessageToRwg({
                    evt: 24582,
                    body: r
                })
            };
        }
        sendAnswer(e, t1, o) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24584,
                    body: {
                        question_attendeejid: t1.jid,
                        question_attendeename: t1.displayName,
                        question_text: t1.questionText,
                        question_id: t1.questionId,
                        question_anonymous: t1.isAnonymous,
                        question_time: t1.questionTime,
                        text: e,
                        isPrivate: o
                    }
                })
            };
        }
        answerOnline(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24586,
                    body: {
                        question_attendeejid: e.jid,
                        question_attendeename: e.displayName,
                        question_text: e.questionText,
                        question_id: e.questionId,
                        question_anonymous: e.isAnonymous,
                        question_time: e.questionTime,
                        isLiveStart: t1
                    }
                })
            };
        }
        dismissQuestion(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24590,
                    body: {
                        question_attendeejid: e.jid,
                        question_attendeename: e.displayName,
                        question_text: e.questionText,
                        question_id: e.questionId,
                        question_anonymous: e.isAnonymous,
                        question_time: e.questionTime,
                        bOpen: !1
                    }
                })
            };
        }
        deleteQuestion(e) {
            return {
                seq: this.sendMessageToRwg({
                    evt: 24614,
                    body: {
                        question_id: e,
                        bDelete: !0
                    }
                })
            };
        }
        deleteComment(e) {
            return {
                seq: this.sendMessageToRwg({
                    body: {
                        comment_id: e,
                        bDelete: !0
                    },
                    evt: 24616
                })
            };
        }
        reopenQuestion(e) {
            return {
                seq: this.sendMessageToRwg({
                    body: {
                        question_attendeejid: e.jid,
                        question_attendeename: e.displayName,
                        question_text: e.questionText,
                        question_id: e.questionId,
                        question_anonymous: e.isAnonymous,
                        question_time: e.questionTime,
                        bOpen: !0
                    },
                    evt: 24590
                })
            };
        }
        askQuestion(e, t1) {
            let o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = arguments.length > 3 ? arguments[3] : void 0;
            const i = Qr();
            return {
                seq: this.sendMessageToRwg({
                    body: {
                        id: i,
                        text: e,
                        isAnonymous: o,
                        bAllowAttendeeViewAllQuestion: r,
                        name: t1
                    },
                    evt: 24592
                }),
                questionId: i
            };
        }
        upOrDownVote(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    body: {
                        question_attendeejid: e.jid,
                        question_attendeename: e.displayName,
                        question_text: e.questionText,
                        question_id: e.questionId,
                        question_anonymous: e.isAnonymous,
                        question_time: e.questionTime,
                        bUpVote: t1
                    },
                    evt: 24598
                })
            };
        }
        rename(e, t1) {
            return {
                seq: this.sendMessageToRwg({
                    body: {
                        jid: e,
                        displayName: t1
                    },
                    evt: 24600
                })
            };
        }
        setSkinTome(e) {
            return {
                seq: this.sendMessageToRwg({
                    body: {
                        skinTone: e
                    },
                    evt: 24618
                })
            };
        }
    }
    jI.xmppInstance = null;
    const xI = hE.getInstance();
    let BI, FI;
    const HI = ia.createAgent();
    let $I = null;
    function WI(e) {
        switch(e.responseType){
            case "json":
                if ("response" in e) return e.response;
                var t1 = e;
                return JSON.parse(t1.responseText);
            case "document":
                return e.responseXML;
            default:
                return "response" in e ? e.response : (t1 = e).responseText;
        }
    }
    var GI = function(e, t1, o, r) {
        void 0 === r && (r = "download_load"), this.originalEvent = e, this.xhr = t1, this.request = o, this.type = r;
        var i = t1.status, n = t1.responseType;
        this.status = null != i ? i : 0, this.responseType = null != n ? n : "";
        var s = t1.getAllResponseHeaders();
        this.responseHeaders = s ? s.split("\n").reduce(function(e, t1) {
            var o = t1.indexOf(": ");
            return e[t1.slice(0, o)] = t1.slice(o + 2), e;
        }, {}) : {}, this.response = WI(t1);
        var a = e.loaded, d = e.total;
        this.loaded = a, this.total = d;
    }, KI = c(function(e) {
        return function(e, t1, o) {
            var r;
            this.message = e, this.name = "AjaxError", this.xhr = t1, this.request = o, this.status = t1.status, this.responseType = t1.responseType;
            try {
                r = WI(t1);
            } catch (e) {
                r = t1.responseText;
            }
            this.response = r;
        };
    }), zI = function() {
        function e(e, t1) {
            return KI.call(this, "ajax timeout", e, t1), this.name = "AjaxTimeoutError", this;
        }
        return e.prototype = Object.create(KI.prototype), e;
    }();
    var qI = Le(function(e) {
        return e.response;
    });
    var JI, QI = (JI = function(e) {
        return function(e) {
            return new P(function(t1) {
                var o, i, n, s = r({
                    async: !0,
                    crossDomain: !1,
                    withCredentials: !1,
                    method: "GET",
                    timeout: 0,
                    responseType: "json"
                }, e), a = s.queryParams, d = s.body, u = s.headers, l = s.url;
                if (!l) throw new TypeError("url is required");
                if (a) if (l.includes("?")) {
                    var c = l.split("?");
                    if (2 < c.length) throw new TypeError("invalid url");
                    n = new URLSearchParams(c[1]), new URLSearchParams(a).forEach(function(e, t1) {
                        return n.set(t1, e);
                    }), l = c[0] + "?" + n;
                } else l = l + "?" + (n = new URLSearchParams(a));
                var p = {};
                if (u) for(var h in u)u.hasOwnProperty(h) && (p[h.toLowerCase()] = u[h]);
                var m = s.crossDomain;
                m || "x-requested-with" in p || (p["x-requested-with"] = "XMLHttpRequest");
                var g = s.withCredentials, v = s.xsrfCookieName, f = s.xsrfHeaderName;
                if ((g || !m) && v && f) {
                    var y = null !== (i = null === (o = null === document || void 0 === document ? void 0 : document.cookie.match(new RegExp("(^|;\\s*)(" + v + ")=([^;]*)"))) || void 0 === o ? void 0 : o.pop()) && void 0 !== i ? i : "";
                    y && (p[f] = y);
                }
                var S, b = function(e, t1) {
                    var o;
                    if (!e || "string" == typeof e || function(e) {
                        return "undefined" != typeof FormData && e instanceof FormData;
                    }(e) || function(e) {
                        return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams;
                    }(e) || function(e) {
                        return rA(e, "ArrayBuffer");
                    }(e) || function(e) {
                        return rA(e, "File");
                    }(e) || function(e) {
                        return rA(e, "Blob");
                    }(e) || function(e) {
                        return "undefined" != typeof ReadableStream && e instanceof ReadableStream;
                    }(e)) return e;
                    if (function(e) {
                        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView(e);
                    }(e)) return e.buffer;
                    if ("object" == typeof e) return t1["content-type"] = null !== (o = t1["content-type"]) && void 0 !== o ? o : "application/json;charset=utf-8", JSON.stringify(e);
                    throw new TypeError("Unknown body type");
                }(d, p), E = r(r({}, s), {
                    url: l,
                    headers: p,
                    body: b
                });
                S = e.createXHR ? e.createXHR() : new XMLHttpRequest;
                var I = e.progressSubscriber, A = e.includeDownloadProgress, C = void 0 !== A && A, _ = e.includeUploadProgress, R = void 0 !== _ && _, w = function(e, o) {
                    S.addEventListener(e, function() {
                        var e, r = o();
                        null === (e = null == I ? void 0 : I.error) || void 0 === e || e.call(I, r), t1.error(r);
                    });
                };
                w("timeout", function() {
                    return new zI(S, E);
                }), w("abort", function() {
                    return new KI("aborted", S, E);
                });
                var T = function(e, t1) {
                    return new GI(t1, S, E, e + "_" + t1.type);
                }, O = function(e, o, r) {
                    e.addEventListener(o, function(e) {
                        t1.next(T(r, e));
                    });
                };
                R && [
                    XI,
                    eA,
                    tA
                ].forEach(function(e) {
                    return O(S.upload, e, ZI);
                }), I && [
                    XI,
                    eA
                ].forEach(function(e) {
                    return S.upload.addEventListener(e, function(e) {
                        var t1;
                        return null === (t1 = null == I ? void 0 : I.next) || void 0 === t1 ? void 0 : t1.call(I, e);
                    });
                }), C && [
                    XI,
                    eA
                ].forEach(function(e) {
                    return O(S, e, YI);
                });
                var D = function(e) {
                    var o = "ajax error" + (e ? " " + e : "");
                    t1.error(new KI(o, S, E));
                };
                S.addEventListener("error", function(e) {
                    var t1;
                    null === (t1 = null == I ? void 0 : I.error) || void 0 === t1 || t1.call(I, e), D();
                }), S.addEventListener(tA, function(e) {
                    var o, r, i = S.status;
                    if (i < 400) {
                        null === (o = null == I ? void 0 : I.complete) || void 0 === o || o.call(I);
                        var n = void 0;
                        try {
                            n = T(YI, e);
                        } catch (e) {
                            return void t1.error(e);
                        }
                        t1.next(n), t1.complete();
                    } else null === (r = null == I ? void 0 : I.error) || void 0 === r || r.call(I, e), D(i);
                });
                var P = E.user, M = E.method, k = E.async;
                for(var h in P ? S.open(M, l, k, P, E.password) : S.open(M, l, k), k && (S.timeout = E.timeout, S.responseType = E.responseType), "withCredentials" in S && (S.withCredentials = E.withCredentials), p)p.hasOwnProperty(h) && S.setRequestHeader(h, p[h]);
                return b ? S.send(b) : S.send(), function() {
                    S && 4 !== S.readyState && S.abort();
                };
            });
        }("string" == typeof e ? {
            url: e
        } : e);
    }, JI.get = function(e, t1) {
        return QI({
            method: "GET",
            url: e,
            headers: t1
        });
    }, JI.post = function(e, t1, o) {
        return QI({
            method: "POST",
            url: e,
            body: t1,
            headers: o
        });
    }, JI.delete = function(e, t1) {
        return QI({
            method: "DELETE",
            url: e,
            headers: t1
        });
    }, JI.put = function(e, t1, o) {
        return QI({
            method: "PUT",
            url: e,
            body: t1,
            headers: o
        });
    }, JI.patch = function(e, t1, o) {
        return QI({
            method: "PATCH",
            url: e,
            body: t1,
            headers: o
        });
    }, JI.getJSON = function(e, t1) {
        return qI(QI({
            method: "GET",
            url: e,
            headers: t1
        }));
    }, JI), ZI = "upload", YI = "download", XI = "loadstart", eA = "progress", tA = "load", oA = Object.prototype.toString;
    function rA(e, t1) {
        return oA.call(e) === "[object " + t1 + "]";
    }
    const iA = hE.getInstance(), nA = (e)=>{
        const { meeting: { encryptedRWC: t1, encryptedGEORWC: o, discardedRwcList: r, meetingOptions: i } } = e;
        let n = [];
        return (null == i ? void 0 : i.isEnableGeoFenceRWC) && o && (null == o ? void 0 : o.length) > 0 ? n = o.filter((e)=>!r.includes(e.rwc)).reduce((e, t1)=>{
            const { dl: o, rwc: r, rwcToken: i } = t1, n = e.find((e)=>e.dl === o);
            if (n) n.items.push({
                rwc: r,
                rwcToken: i
            });
            else {
                const t1 = {
                    dl: o,
                    items: []
                };
                t1.items.push({
                    rwc: r,
                    rwcToken: i
                }), e.push(t1);
            }
            return e;
        }, []) : t1 && (n = [
            {
                dl: 0,
                items: Object.keys(t1).map((e)=>({
                        rwc: e,
                        rwcToken: t1[e]
                    }))
            }
        ]), n;
    }, sA = (e)=>Xe(...e.map((e)=>0 === e.dl ? _e(e.items) : Ze(e.dl).pipe(Fe(()=>_e(e.items))))), aA = ()=>rt(np(Ia, 1), np(ba, 1), np(Ea, 1)), dA = (e, t1)=>e.pipe(Dt(`${nn}`), ft(t1), ot((e)=>{
            let [, t1] = e;
            return void 0 !== t1.meeting.encryptedRWC || void 0 !== t1.meeting.encryptedGEORWC && t1.meeting.encryptedGEORWC.length > 0;
        }), ht((e)=>{
            let [, o] = e;
            const { meeting: { ts: r, auth: i, meetingNumber: n, meetingOptions: s, meetingId: a, userName: d }, breakoutRoom: u } = o, l = null == s ? void 0 : s.isEnableGeoFenceRWC, c = nA(o);
            if (c.length > 0) {
                const e = {
                    serversLength: c.reduce((e, t1)=>e + t1.items.length, 0),
                    pingFailedServerList: [],
                    pingRwcServerCounts: 0,
                    retryCounts: 0
                };
                let o;
                return l && (o = new H, sA(c).subscribe((e)=>{
                    var t1;
                    return null === (t1 = o) || void 0 === t1 ? void 0 : t1.next(e);
                })), (l ? o : sA(c)).pipe(mt(aA()), gt(()=>{
                    const { meeting: { meetingStatus: r, meetingId: i } } = t1.value, n = r === Xn.Initial && !!i && e.pingFailedServerList.length < e.serversLength && e.serversLength > 0;
                    return !n && o && o.complete(), n;
                }), vt(()=>{
                    if (e.pingRwcServerCounts = e.pingRwcServerCounts + 1, l && e.pingRwcServerCounts === e.serversLength) {
                        const r = 1e3 * Math.floor(5 * Math.pow(2, e.retryCounts));
                        e.retryCounts = e.retryCounts + 1, iA.makeLogger([
                            "Join Meeting Flow"
                        ]).info(`ping rwc retry,current rwc list:${JSON.stringify(nA(t1.value))},retry counts:${e.retryCounts}, ${JSON.stringify({
                            meetingId: a,
                            meetingNumber: dE(n),
                            userName: dE(d)
                        })}`, [
                            "Ping RWC Retry"
                        ]), Ze(r).pipe(Le(()=>{
                            const o = nA(t1.value);
                            return Object.assign(e, {
                                serversLength: o.reduce((e, t1)=>e + t1.items.length, 0),
                                pingFailedServerList: [],
                                pingRwcServerCounts: 0
                            }), o;
                        })).subscribe((e)=>{
                            sA(e).subscribe((e)=>{
                                o.next(e);
                            });
                        });
                    }
                }), Fe((s)=>{
                    const { rwc: c, rwcToken: p } = s, h = ((e, t1, o, r, i, n)=>{
                        const s = {
                            ts: r,
                            auth: i,
                            rwcToken: o,
                            dmz: 1
                        };
                        return n && Object.assign(s, {
                            confID: n
                        }), `https://${e}/wc/ping/${t1}?${new URLSearchParams(s).toString()}`;
                    })(c, n, p, r, i, null == u ? void 0 : u.currentRoom.boConfId);
                    return QI({
                        url: h,
                        crossDomain: ti(h)
                    }).pipe(mt(aA()), Fe((e)=>{
                        let t1 = {};
                        return t1 = e.response ? {
                            ...e.response,
                            rwc: c,
                            fromNginx: !1
                        } : {
                            rwc: c,
                            rwg: c,
                            rwcToken: p,
                            fromNginx: !0
                        }, _e([
                            Mo(t1),
                            Eo()
                        ]);
                    }), it(()=>{
                        const { pingFailedServerList: r, serversLength: i } = e;
                        return r.push(h), r.length === i ? (l && o && o.complete(), iA.report(`ping rwc error, ${JSON.stringify({
                            meetingId: a,
                            meetingNumber: dE(n),
                            userName: dE(d)
                        })}`, [
                            "Join Meeting Flow",
                            "Ping RWC Error"
                        ], "error"), tp(ba, {
                            reason: "connection error",
                            errorCode: hi.CommonError
                        }), _e([
                            ...Gy(t1.value)
                        ])) : ne;
                    }));
                }), pt(Sn(performance.now())));
            }
            return ne;
        }));
    let uA = 0;
    const lA = hE.getInstance(), cA = {
        meetingStatus: Xn.Initial,
        isWindowOpen: !1,
        apiKey: "",
        signature: "",
        signatureType: "",
        lang: "en-US",
        tk: "",
        customerKey: "",
        mtkGuid: "",
        pingRWCTimestamp: 0,
        meetingInfoTimestamp: 0,
        passWord: "",
        meetingNumber: 0,
        userName: "",
        userEmail: "",
        sdkUrl: "",
        sdkOrigin: "",
        proxy: 1,
        cv: "",
        meetingId: "",
        tid: "",
        ts: "",
        auth: "",
        sign: "",
        isSupportCallOut: !1,
        tollNumbers: void 0,
        recordingEnable: !1,
        callOutCountry: void 0,
        inviteEmail: "",
        xmppConfig: null,
        isSupportH323: !1,
        h323GatewayInfo: "",
        h323Password: "",
        trackAuth: "",
        isOriginHost: !1,
        isWebinar: !1,
        encryptedRWC: void 0,
        meetingOptions: {},
        meetingTopic: "",
        bLock: !1,
        bHoldUponEntry: !1,
        viewOnly: 0,
        listenOnlyPhone: 0,
        bAllowRaiseHand: !1,
        bAllowAttendeeRename: !1,
        bBroadcast: void 0,
        bAllowPlayChimeForEnterOrExit: !1,
        bIbDisableShare: !1,
        bIbDisableChat: !1,
        bAllowShowCount: !1,
        encryptKey: "",
        bNoHostTimeOut: !1,
        confId: "",
        conId: "",
        e2eEncrypt: !1,
        zoomId: "",
        jid: "",
        xtoken: "",
        groups: void 0,
        svcUrl: "",
        encType: NaN,
        userGUID: "",
        userId: NaN,
        isHost: !1,
        isCoHost: !1,
        participantID: 0,
        isOnHold: !1,
        isMeetingReset: !1,
        bRecord: !1,
        audioVideoBeforeOnHold: void 0,
        region: void 0,
        network: void 0,
        joinMeetingTimeStamp: 0,
        activeAppInfo: void 0,
        recordingDisclaimerForRecorder: {},
        recordingDisclaimer: {},
        ccUrl: "",
        sessionIdleTimeoutMins: 40,
        reportDomain: "",
        isAudioBridgeEnabled: !0,
        discardedRwcList: [],
        sharePronounType: void 0,
        stayAwake: !1,
        wrInfo: {},
        meetingInfo: {},
        isNewJoinFlow: !1,
        gatewayUserList: [],
        logConfig: "",
        logEncryptionPubKey: "",
        failover: {
            count: 0,
            isCurrentFailoverRecorded: !1,
            reason: -1,
            interval: 0,
            joinMeetingSuccessTimestamp: 0,
            sequence: ""
        },
        enableLongPollingCheckStart: !1,
        rsPwd: "",
        chatModerationPolicy: {},
        isAlternativeHost: !1,
        isAssistant: !1,
        isRlbTP: !1,
        isRlbTPReady: !1
    }, pA = bo({
        [`${pn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            o.customerKey = e.customerKey || o.customerKey || "", Object.assign(e, o), e.meetingStatus = Xn.Initial;
        }),
        [`${hn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            o.customerKey = e.customerKey || o.customerKey || "", Object.assign(e, o);
        }),
        [`${mn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isWindowOpen = o;
        }),
        [`${gn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            o.useSDK ? e.signatureType = "sdk" : e.signatureType = "api", e.apiKey = o.apiKey, e.signature = o.signature, e.lang = o.language;
        }),
        [`${vn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.ztk = o;
        }),
        [`${fn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.zsk = o;
        }),
        [`${yn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.tk = o.tk, e.mtkGuid = o.mtkGuid;
        }),
        [`${Sn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.pingRWCTimestamp = o;
        }),
        [`${Gn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.meetingInfoTimestamp = o;
        }),
        [`${bn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.confId = o.confID, e.conId = o.conID, e.e2eEncrypt = o.e2eEncrypt, e.meetingNumber = parseInt(o.mn, 10), e.zoomId = o.zoomID, e.meetingStatus = Xn.Joined, e.jid = o.jid, e.xtoken = o.xtoken, e.groups = o.groups, e.svcUrl = o.svcUrl, e.encType = o.encType, e.userGUID = o.userGUID, e.userId = o.userID, e.role = o.role, e.participantID = o.participantID, e.reportDomain = o.reportDomain, e.abToken = o.ABtoken, e.supportLocalAB = !!o.supportLocalAB, e.mediasdkConfig = o.mediasdkConfig, o.enableWebTransport && (e.enableWebtransport = o.enableWebTransport, e.webtransportPort = o.WebTransportPort);
        }),
        [`${En}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            if (o.gatewayUser) {
                var r;
                const { userId: t1, sn: n } = o.gatewayUser, s = null === (r = e.gatewayUserList) || void 0 === r ? void 0 : r.find((e)=>e.userId === t1);
                var i;
                s ? s.sn = n : null === (i = e.gatewayUserList) || void 0 === i || i.push(o.gatewayUser);
            } else Object.assign(e, o);
        }),
        [`${An}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isHost = o;
        }),
        [`${Cn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isCoHost = o;
        }),
        [`${_n}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isOnHold = o;
        }),
        [`${Rn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isMeetingReset = o;
        }),
        [`${wn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.audioVideoBeforeOnHold = o;
        }),
        [`${Tn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.currentUserAudioBeforeReset = o;
        }),
        [`${On}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isCurrentUserMutedBeforeReset = o;
        }),
        [`${Dn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.meetingStatus = o;
        }),
        [`${Pn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.region = o.region, e.network = o.network;
        }),
        [`${Mn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isCurrentUserStartVideoBeforeReset = o;
        }),
        [`${kn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.joinMeetingTimeStamp = o;
        }),
        [`${Ln}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.activeAppInfo = o;
        }),
        [`${Nn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.idleStartTime = o;
        }),
        [`${Vn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.sessionIdleTimeoutMins = o;
        }),
        [`${Un}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAudioBridgeEnabled = o;
        }),
        [`${jn}`]: OI((e, t1)=>{
            var o;
            let { payload: r } = t1;
            const i = null === (o = e.encryptedGEORWC) || void 0 === o || null === (o = o.find((e)=>e.rwc === r)) || void 0 === o ? void 0 : o.dc;
            if (i) {
                var n;
                const t1 = null === (n = e.encryptedGEORWC) || void 0 === n ? void 0 : n.filter((e)=>e.dc === i);
                t1 && e.discardedRwcList.some((e)=>(null == t1 ? void 0 : t1.findIndex((t1)=>t1.rwc === e)) >= 0) && e.discardedRwcList.push(...t1.map((e)=>e.rwc)), e.discardedRwcList.push(r);
            }
        }),
        [`${xn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.sharePronounType = o;
        }),
        [`${Bn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.stayAwake = o;
        }),
        [`${Fn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.failover.joinMeetingSuccessTimestamp = o;
        }),
        [`${Hn}`]: OI((e)=>{
            Object.assign(e.failover, {
                ...cA.failover,
                count: e.failover.count,
                joinMeetingSuccessTimestamp: e.failover.joinMeetingSuccessTimestamp
            });
        }),
        [`${$n}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { count: r, reason: i, interval: n, sequence: s } = o;
            e.failover.count = r, e.failover.reason = i, e.failover.interval = n, e.failover.isCurrentFailoverRecorded = !0, e.failover.sequence = s;
        }),
        [`${Wn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.quicklyLeave = o;
        }),
        [`${Kn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isEnableZmkFromRWG = o;
        }),
        [`${zn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isRlbTP = o;
        }),
        [`${qn}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isRlbTPReady = o;
        }),
        [`${In}`]: (e, t1)=>{
            let { payload: o } = t1;
            const { isFailover: r } = o, i = {
                isMeetingReset: !0,
                apiKey: e.apiKey,
                signatureType: e.signatureType,
                signature: e.signature,
                lang: e.lang,
                proxy: 1,
                stayAwake: e.stayAwake
            };
            return r && Object.assign(i, {
                currentUserAudioBeforeReset: e.audioVideoBeforeOnHold ? e.audioVideoBeforeOnHold.audio : o.audio,
                isCurrentUserMutedBeforeReset: e.audioVideoBeforeOnHold ? e.audioVideoBeforeOnHold.muted : o.muted,
                isCurrentUserStartVideoBeforeReset: e.audioVideoBeforeOnHold ? e.audioVideoBeforeOnHold.video : o.video,
                meetingNumber: e.meetingNumber,
                userName: e.userName,
                passWord: e.passWord,
                userEmail: e.userEmail,
                sdkUrl: e.sdkUrl,
                sdkOrigin: e.sdkOrigin,
                cv: e.cv,
                zsk: e.zsk,
                ztk: e.ztk,
                idleStartTime: e.idleStartTime,
                sessionIdleTimeoutMins: e.sessionIdleTimeoutMins,
                customerKey: e.customerKey,
                failover: e.failover,
                stayAwake: e.stayAwake,
                quicklyLeave: e.quicklyLeave
            }), {
                ...cA,
                ...i
            };
        }
    }, cA), hA = {
        meetingFailoverReportEpic0: (e, t1)=>e.pipe(Dt(`${pn}`), ht(()=>{
                const o = 0 === t1.value.meeting.failover.joinMeetingSuccessTimestamp && !!ns.get(ss.WebclientZoomId);
                return e.pipe(Dt(`${bn}`), nt(1), Fe(()=>{
                    const e = [], { count: r, sequence: i } = ns.get(ss.WebclientFailoverCount) || {};
                    let { meeting: { failover: { count: n, reason: s, interval: a } } } = t1.value;
                    const { meeting: { pingRWCTimestamp: d } } = t1.value;
                    if (o) {
                        n = r + 1, s = ts.RefreshPage, a = 0;
                        const t1 = i ? `${i}-${s}` : `${s}`;
                        ns.set(ss.WebclientFailoverCount, {
                            count: n,
                            sequence: t1
                        }, rs.SessionStorage), e.push($n({
                            count: n,
                            reason: s,
                            interval: a,
                            sequence: t1
                        }));
                    }
                    const u = performance.now();
                    let l = `WCL_M, JMCT(${u - d})`;
                    return n > 0 && s !== ts.NormalCase && (l = `${l},FAILOVER(${n},${s},${(a / 1e3).toFixed(1)})`), HI.sendRWGConnectionPerformance(l), e.push(Hn(), Fn(u)), _e(e);
                }));
            })),
        meetingFailoverReportEpic1: (e, t1)=>e.pipe(Dt(`${sn}`), Fe((e)=>{
                const { payload: o } = e, { meeting: { failover: { joinMeetingSuccessTimestamp: r, isCurrentFailoverRecorded: i }, userGUID: n, userId: s, meetingId: a } } = t1.value, d = [];
                if (!i) {
                    let { count: e, sequence: t1 } = ns.get(ss.WebclientFailoverCount) || {};
                    t1 = t1 ? `${t1}-${o}` : `${o}`, o !== ts.NormalCase && (e += 1, ns.set(ss.WebclientFailoverCount, {
                        count: e,
                        sequence: t1
                    }, rs.SessionStorage));
                    const i = performance.now() - r;
                    d.push($n({
                        reason: o,
                        count: e,
                        interval: i,
                        sequence: t1,
                        userGUID: n,
                        userId: s,
                        meetingId: a
                    }));
                }
                return _e(d);
            }))
    }, mA = {
        sessionIdleEpic0: (e, t1)=>e.pipe(Dt(`${bn}`), ft(t1), ot((e)=>{
                let [, t1] = e;
                return void 0 !== t1.meeting.zlkJwtToken;
            }), ht(()=>(BI && BI.complete(), BI = new j, FI = Ye(6e4).pipe(Le(()=>performance.now())).subscribe(BI), BI.pipe(Le((e)=>ln(e)))))),
        sessionIdleEpic1: (e)=>e.pipe(Dt(`${Ao}`)).pipe(vt(()=>{
                BI && (BI.complete(), FI.unsubscribe());
            }), ut(ne)),
        sessionIdleEpic2: (e, t1)=>e.pipe(Dt(`${ln}`), ft(t1), Fe((e)=>{
                var t1;
                let [o, r] = e;
                const { meeting: { idleStartTime: i, sessionIdleTimeoutMins: n, isOriginHost: s, isWebinar: a }, participants: { attendeesList: d, xmppAttendeeList: u }, recording: l, breakoutRoom: c } = r, p = o.payload, h = [];
                if (1 !== d.length || a && 0 !== u.length || (null == c || null === (t1 = c.currentRoom) || void 0 === t1 ? void 0 : t1.status) === Qp.InRoom || (null == l ? void 0 : l.cmrStatus) === qa.Start) h.push(Nn(void 0));
                else if (i) {
                    const e = s && $p(d[0].userRole) ? n : 40;
                    p - i > 60 * e * 1e3 && (console.warn(`No active for ${e} minutes, will end the session.`), xI.report(`Session idle timeout(${e} minutes), end the session automatically!`, [
                        "Join Meeting Flow",
                        "Session idle"
                    ], "warn"), h.push(un()), Ze(500).subscribe(()=>{
                        ap();
                    }));
                } else h.push(Nn(p));
                return _e(h);
            })),
        sessionIdleEpic3: (e, t1)=>e.pipe(Dt(`${_o}`), ot((e)=>[
                    Ps,
                    Ms
                ].includes(e.payload.evt) && void 0 !== t1.value.meeting.idleStartTime), Ie(te), Fe(()=>{
                var e;
                const { participants: { attendeesList: o, xmppAttendeeList: r }, recording: i, breakoutRoom: n } = t1.value, s = [];
                return (o.length > 1 || r.length > 0 || (null == i ? void 0 : i.cmrStatus) === qa.Start || (null == n || null === (e = n.currentRoom) || void 0 === e ? void 0 : e.status) === Qp.InRoom) && s.push(Nn(void 0)), _e(s);
            })),
        sessionIdleEpic4: (e)=>e.pipe(Dt(`${an}`, `${un}`), at(Nn(void 0)))
    }, gA = {
        meetingMainEpics0: (e, t1)=>nr(e, 0).pipe(vt((e)=>{
                var o;
                if ("READY" === (null === (o = e.payload.body) || void 0 === o ? void 0 : o.status)) {
                    const { meeting: { zlkJwtToken: e, signatureType: o, sign: r, passWord: i, isHost: n, isOriginHost: s, ztk: a, zsk: d, tk: u, userEmail: l }, breakoutRoom: c } = t1.value, p = e ? {
                        zlkJwtToken: e
                    } : {
                        signType: o,
                        sign: r
                    };
                    if (i && "" !== i && (e ? Object.assign(p, {
                        mpwd: $r(i)
                    }) : n && s || Object.assign(p, {
                        mpwd: i
                    })), (null == c ? void 0 : c.currentRoom.status) === Qp.Joining) {
                        const { currentRoom: { boId: e, boConfId: t1, boToken: o } } = c;
                        e && t1 && o && Object.assign(p, {
                            botk: o
                        });
                    }
                    if (!e) {
                        a && Object.assign(p, {
                            zak: a
                        }), (sessionStorage.getItem(ss.WebclientZsk) || d) && Object.assign(p, {
                            zak: d
                        }), u && Object.assign(p, {
                            tk: u
                        });
                        const e = ns.get(ss.WebclientWebinarToken);
                        void 0 !== e && Object.assign(p, {
                            tk: e
                        });
                        const t1 = sessionStorage.getItem(ss.WebclientRecordingToken);
                        t1 && Object.assign(p, {
                            localRecordToken: t1
                        }), l && Object.assign(p, {
                            email: l
                        });
                    }
                    NI.sendLaunchParams(p);
                    const h = ns.get(ss.WebclientMeetingToken);
                    h && NI.joinMeeting(h);
                }
            }), ut(ne)),
        meetingMainEpics1: (e, t1)=>{
            return nr(e, Ns).pipe(ft(t1), (o = (e)=>{
                let [t1, o] = e;
                const { payload: { body: { res: r, userID: i, zoomID: n, mn: s, participantID: a, meetingtoken: d, role: u } } } = t1, { meeting: { userEmail: l, userName: c, isMeetingReset: p, apiKey: h, zsk: m, signatureType: g } } = o;
                if (li.Success === r) {
                    const { WebclientParticipantId: e, WebclientZoomId: o, WebclientUserEmail: r, WebclientUserName: v, WebclientMeetingToken: f } = ss;
                    ns.set(o, n, rs.SessionStorage), ns.set(e, a, rs.SessionStorage), l && ns.set(r, l, rs.SessionStorage), ns.set(v, c, rs.SessionStorage), d && ns.set(f, d, rs.SessionStorage), m && NI.sendSdkKeyToMonitor(g, h, i);
                    const y = [
                        bn(t1.payload.body),
                        kn(performance.now())
                    ];
                    return p && y.push(Rn(!1)), (u & Bp.Owner) === Bp.Owner && (tp(ba, {
                        reason: "dont support assisnt join through widget",
                        errorCode: -1
                    }), NI.leaveMeeting()), tp(Sa, {
                        meetingNumber: s
                    }), _e(y);
                }
                if (li.MeetingLocked === r) tp(ba, vi(r));
                else if (li.UserFull === r) tp(ba, Object.assign({}, vi(r), {
                    lmUrl: t1.payload.body.lmURL
                }));
                else if (li.MeetingIsOver === r) tp(ba, vi(r));
                else if (li.MMRIBReject === r) tp(ba, vi(r));
                else if (li.MMRConfParticipantExists === r) tp(ba, vi(r));
                else if ([
                    li.UserHasBeenRemoved,
                    li.WebinarBlockedEmail
                ].includes(r)) tp(ba, vi(r));
                else if (li.MeetingNotStarted === r) {
                    var v;
                    const e = vi(r), { meeting: { meetingNumber: t1, passWord: i, userName: n, userEmail: s, inviteEmail: a, meetingTopic: d, region: u, network: l, userId: c, lang: p, meetingId: h, participantID: m, wrInfo: g, meetingInfo: f, isNewJoinFlow: y, enableLongPollingCheckStart: S, tid: b, signature: E, rsPwd: I } } = o;
                    Object.assign(e, {
                        meetingInfo: {
                            meetingNumber: t1,
                            password: i,
                            userName: n,
                            userEmail: s,
                            inviteEmail: a,
                            meetingTopic: d,
                            region: u,
                            network: l,
                            userId: c,
                            lang: p,
                            webEndpoint: Sr(),
                            meetingId: h,
                            participantId: m,
                            wrInfo: Object.assign({}, g, {
                                isNew: y
                            }),
                            scheduleInfo: f,
                            enableLongPollingCheckStart: S,
                            rid: qy(b),
                            role: Number(null === (v = oi(E)) || void 0 === v ? void 0 : v.role),
                            rsPwd: I
                        }
                    }), tp(ba, e);
                } else tp(ba, vi(r));
                return _e(Gy(o, !1));
            }, O(ht((e, t1)=>o(e) || ne))));
            "TURBOPACK unreachable";
            var o;
        },
        meetingMainEpics2: (e, t1)=>nr(e, Ms).pipe(ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { payload: { body: r } } = t1, { meeting: { zoomId: i, encType: n, gcmSessinKey: s } } = o;
                if (void 0 !== (null == r ? void 0 : r.encryptKey) && Ts.init(i, r.encryptKey, n), void 0 !== (null == r ? void 0 : r.gatewayKey)) {
                    const e = ca.getInstance(), [, t1, o] = r.gatewayKey.split(".");
                    e.sendUserNodeList([
                        {
                            userid: Number(t1),
                            sn: o && zr(o)
                        }
                    ], s);
                }
                return tp(Ca, r), En(r);
            })),
        meetingMainEpics3: (e, t1)=>nr(e, 7939).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { payload: { body: r } } = t1;
                if (void 0 !== r.reason) {
                    if (ci.Reconnect === r.reason) return pi.WaitingRoomFailover === r.subReason ? tp(Ea, {
                        reason: Jn.OnHold
                    }) : tp(Ea, {
                        reason: Jn.Failover
                    }), Re(sn(ts.NormalCase));
                    ci.KickedByHost === r.reason ? tp(Ia, {
                        reason: "kicked by host"
                    }) : [
                        ci.EndByHost,
                        ci.EndByNone,
                        ci.EndByAdmin,
                        ci.EndByHostStartAnotherMeeting
                    ].includes(r.reason) ? tp(Ia, {
                        reason: "ended by host"
                    }) : ci.FreeMeetingTimeout === r.reason ? tp(Ia, {
                        reason: "free meeting ended"
                    }) : [
                        ci.DuplicateSession,
                        ci.MeetingTransfer
                    ].includes(r.reason) && tp(Ia, {
                        reason: "duplicated session"
                    });
                }
                return o.meeting.isMeetingReset ? ne : _e(Gy(o, !1));
            })),
        meetingMainEpics4: (e, t1)=>e.pipe(Dt(`${sn}`), ft(t1), Fe((e)=>{
                let [, t1] = e;
                const o = Gy(t1, !0);
                let r;
                if (t1.meeting.zlkJwtToken) {
                    const e = function(e) {
                        if (e) {
                            const { meeting: { topic: t1, passWord: o, userName: r, zlkJwtToken: i, lang: n, cv: s, customerKey: a } } = e;
                            return {
                                topic: t1,
                                passWord: o,
                                userName: r,
                                zlkJwtToken: i,
                                lang: n,
                                cv: s,
                                customerKey: a
                            };
                        }
                        return null;
                    }(t1), o = {
                        topic: null == e ? void 0 : e.topic,
                        password: null != e && e.passWord ? encodeURIComponent(null == e ? void 0 : e.passWord) : "",
                        userName: null == e ? void 0 : e.userName,
                        zlk: null == e ? void 0 : e.zlkJwtToken,
                        lang: null == e ? void 0 : e.lang,
                        cv: null == e ? void 0 : e.cv,
                        customerKey: null == e ? void 0 : e.customerKey
                    };
                    r = Re(rn(o)).pipe(dt(1e3));
                } else {
                    const e = function(e) {
                        var t1;
                        const { meeting: { apiKey: o, signature: r, signatureType: i, meetingNumber: n, userName: s, lang: a, passWord: d, userEmail: u, sdkUrl: l, sdkOrigin: c, proxy: p, cv: h, ztk: m, zsk: g, tk: v } } = e;
                        let f = m || sessionStorage.getItem(ss.WebclientZtk), y = g || sessionStorage.getItem(ss.WebclientZsk);
                        const S = 1 === Number(null === (t1 = oi(r)) || void 0 === t1 ? void 0 : t1.role);
                        return S || (f = y, y = ""), {
                            apiKey: o,
                            signature: r,
                            signatureType: i,
                            meetingNumber: n,
                            userName: s,
                            lang: a,
                            passWord: d ? encodeURIComponent(d) : "",
                            userEmail: u,
                            sdkUrl: l,
                            sdkOrigin: c,
                            proxy: p,
                            cv: h,
                            ztk: f,
                            zsk: y,
                            tk: v || sessionStorage.getItem(ss.WebclientTk),
                            ulsm: S && y ? 1 : 0
                        };
                    }(t1);
                    r = Re(on(e)).pipe(dt(1e3));
                }
                return $e(_e(o), r);
            })),
        meetingMainEpics5: (e)=>dr(e, 7940).pipe(vt((e)=>{
                tp("MEETING_HOST_CHANGE_INDICATION", e.payload.body.bHost);
            }), Le((e)=>An(e.payload.body))),
        meetingMainEpics6: (e)=>dr(e, 7941).pipe(vt((e)=>{
                tp("MEETING_COHOST_CHANGE_INDICATION", e.payload.body.bCoHost);
            }), Le((e)=>Cn(e.payload.body))),
        meetingMainEpics7: (e)=>dr(e, 7945).pipe(vt((e)=>{
                const { payload: { body: { opt: t1 } } } = e;
                ns.set(ss.WebclientOpt, t1, rs.SessionStorage);
            }), ut(ne)),
        meetingMainEpics8: (e, t1)=>nr(e, 7942).pipe(vt((e)=>{
                const { payload: { body: { bHold: t1 } } } = e;
                ns.set(ss.WebclientIsOnHold, t1 ? 1 : 0, rs.SessionStorage), tp(Aa, t1);
            }), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const r = [
                    _n(t1.payload.body.bHold)
                ];
                if (t1.payload.body.bHold) {
                    const e = ah(o);
                    if (e) {
                        r.push(wn({
                            audio: e.audio,
                            video: e.bVideoOn,
                            muted: e.muted
                        }));
                        const t1 = yE(ca.getInstance());
                        if ("computer" === e.audio && (t1.leaveComputerAudio(), NI.joinOrLeaveVoip(!1)), e.bVideoOn && t1.stopCaptureVideo(), e.sharerOn && (NI.stopSharing(e.userId), t1.stopDesktopSharing(), r.push(Sm(yd.End))), o.video && o.video.subscribedVideoList.length > 0 && o.video.subscribedVideoList.forEach((e)=>{
                            NI.unsubscribeVideo(e);
                        }), o.share && o.share.isReceiveSharing) {
                            const e = o.share.activeNodeId;
                            o.share.remoteControlledUserList.length > 0 && (o.share.remoteControlledUserList.forEach((e)=>{
                                NI.sharingRequestRemoteControl(e, !1);
                            }), cS(o) && t1.stopRemoteControl()), NI.unsubscribeSharing(e), t1.stopRenderSharing();
                        }
                    }
                }
                return _e(r);
            })),
        meetingMainEpics9: (e)=>nr(e, 7954).pipe(Le((e)=>Pn(e.payload.body))),
        meetingMainEpics10: (e)=>nr(e, 4216).pipe(vt((e)=>{
                tp("MEETING_CLAIM_HOST_KEY_RESPONSE", e.payload.body.bresult);
            }), ut(ne)),
        meetingMainEpics11: (e, t1)=>e.pipe(Dt(`${an}`, `${un}`), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const r = yh(o), { socket: { zoomSocketStatus: i }, meeting: { meetingId: n } } = o;
                return i === Sh.Connected && (t1.type === `${an}` ? NI.leaveMeeting(r) : t1.type === `${un}` && NI.endMeeting()), n && tp(Ia, {}), _e(Gy(o, !1));
            })),
        meetingMainEpics12: (e, t1)=>e.pipe(Dt(`${dn}`), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                if (t1.type === `${dn}` && o.meeting.meetingNumber && !o.meeting.zlkJwtToken) {
                    const e = {
                        mn: o.meeting.meetingNumber.toString(),
                        name: o.meeting.userName,
                        customerKey: o.meeting.customerKey ? $r(o.meeting.customerKey) : ""
                    }, { jbhLeave: t1 } = {
                        jbhLeave: `https://${mr}/wc/jbhLeave`
                    }, r = `${t1}/?${new URLSearchParams(e).toString()}`;
                    fetch(r, {
                        method: "POST",
                        headers: {
                            "Content-type": "application/json; charset=UTF-8"
                        }
                    });
                }
                return ne;
            })),
        meetingMainEpics13: (e)=>nr(e, 2).pipe(vt(()=>{
                console.warn("Upgrade to latest version to optimize meeting experience");
            }), ut(ne)),
        meetingMainEpics14: (e)=>nr(e, 1).pipe(vt((e)=>{
                const { payload: { body: { upgradeVersion: t1 } } } = e, o = vi(1e4);
                if (o && o.reason) {
                    const e = o.reason.replace(/{(\d+)}/g, ()=>t1);
                    o.reason = e;
                }
                tp(ba, o);
            }), ut(ne)),
        meetingMainEpics15: (e)=>nr(e, 4265).pipe(Le((e)=>{
                const { payload: { body: t1 } } = e, { nShareType: o } = t1;
                return tp(_a, {
                    userSharePronounType: o
                }), xn(o);
            })),
        meetingMainEpics16: (e)=>nr(e, 4128).pipe(vt((e)=>{
                const { payload: { body: { meetingtoken: t1 } } } = e, { WebclientMeetingToken: o } = ss;
                t1 && ns.set(o, t1, rs.SessionStorage);
            }), ut(ne)),
        meetingMainEpics17: (e, t1)=>e.pipe(Dt(`${bn}`), ot(()=>!!t1.value.meeting.quicklyLeave), ht(()=>qe(window, "beforeunload").pipe(vt(()=>{
                    NI.leaveMeeting();
                }), ut(ne)))),
        meetingMainEpics18: (e, t1)=>nr(e, 8025).pipe(ot((e)=>!!e.payload.body.Zmk && !!t1.value.meeting.isEnableZmkFromRWG), Le((e)=>{
                const { payload: { body: { Zmk: t1 } } } = e;
                return En({
                    zmk: t1
                });
            })),
        meetingMainEpics19: (e, t1)=>e.pipe(Dt(`${pn}`), Fe((e)=>{
                const { payload: { mediaSDKPath: o } } = e, { media: { skipJsMedia: r, patchJsMedia: i, assetsPath: n } } = t1.value, s = `${!r && i && ui(n) && o ? ri(o) : n}/tp.min.js`;
                return _e(void 0 === window.ZoomTPModule || "function" != typeof window.ZoomTPModule.ZoomTPWebSocket ? new Promise((e, t1)=>cr(s, ()=>e(""), ()=>t1())) : Promise.resolve("")).pipe(Fe(()=>{
                    const { logger: e } = t1.value, o = e ? hE.getInstance().makeLogger([
                        "TP MODULE"
                    ]) : void 0;
                    return _e(window.ZoomTPModule.initTPModule({
                        options: "",
                        logInstance: o
                    }).then(()=>(tp(Ra, !0), qn(!0))).catch(()=>(tp(Ra, !1), zn(!1))));
                }), it(()=>(setTimeout(()=>{
                        hE.getInstance().report(`Unable to load tp.min.js,url:${s}`, [
                            "TP MODULE"
                        ], "error");
                    }, 5e3), tp(Ra, !1), _e([
                        zn(!1)
                    ]))), pt(zn(!0)));
            }))
    }, vA = ir(gA, {
        wakeLockEpic0: (e, t1)=>e.pipe(Dt(`${bn}`), ft(t1), ot((e)=>{
                let [, t1] = e;
                return !!t1.meeting.stayAwake;
            }), vt(async ()=>{
                try {
                    const { isSafari: e, isIOSMobile: t1 } = gs;
                    $I && $I.release().then(()=>{
                        $I = null;
                    }), "wakeLock" in navigator && ((e || t1) && await Oe(rt(qe(document, "click").pipe(nt(1)), qe(document, "touchend").pipe(nt(1)))), $I = await navigator.wakeLock.request("screen"), $I.addEventListener("release", ()=>{}));
                } catch (e) {}
            }), ht(()=>qe(document, "visibilitychange").pipe(Fe(async ()=>{
                    if ("visible" === document.visibilityState) {
                        const { isSafari: e, isIOSMobile: t1 } = gs;
                        $I && $I.release().then(()=>{
                            $I = null;
                        }), "wakeLock" in navigator && ((e || t1) && await Oe(rt(qe(document, "click").pipe(nt(1)), qe(document, "touchend").pipe(nt(1)))), $I = await navigator.wakeLock.request("screen"));
                    } else $I && $I.release().then(()=>{
                        $I = null;
                    });
                }), ut(ne)))),
        wakeLockEpic1: (e)=>e.pipe(Dt(`${Ao}`)).pipe(vt(()=>{
                $I && $I.release().then(()=>{
                    $I = null;
                });
            }), ut(ne))
    }, hA, mA, {
        meetingInfoEpic: (e, t1)=>e.pipe(Dt(`${rn}`), ht((o)=>{
                const r = Object.assign({}, o.payload, {
                    password: $r(o.payload.password),
                    topic: $r(o.payload.topic)
                }), { videoSDKUrl: i } = {
                    meetingSDKUrl: `https://${mr}/api/v1/wc/info`,
                    videoSDKUrl: `https://${mr}/wc/lsdk`
                };
                return (function(e, t1) {
                    let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "zoomsdkjsonpcallback";
                    return new P((r)=>{
                        uA++;
                        const i = `${o}${uA}`, n = document.createElement("script");
                        Object.keys(t1).forEach((e)=>(void 0 === t1[e] || null === t1[e]) && delete t1[e]), n.src = `${e}?${new URLSearchParams(Object.assign(t1, {
                            callback: i
                        })).toString()}`, n.async = !0, n.onerror = (e)=>r.error(e), document.getElementsByTagName("head")[0].appendChild(n), window[i] = (e)=>{
                            n.parentNode && n.parentNode.removeChild(n), delete window[i], r.next(e), r.complete();
                        };
                    });
                })(i, r).pipe(mt(e.pipe(Dt(`${an}`), nt(1))), it((e)=>Re({
                        status: !1,
                        result: e.toString(),
                        errorCode: -3e3
                    })), Fe((e)=>{
                    const [r, i] = (n = Re(e), [
                        ot(s = (e)=>!0 === e.status && void 0 !== e.result, a)(Se(n)),
                        ot(tt(s, a))(Se(n))
                    ]);
                    var n, s, a;
                    return i.subscribe((e)=>{
                        lA.report(`get meeting info error, ${JSON.stringify(e)}`, [
                            "Join Meeting Flow",
                            "Get Meeting Info Error"
                        ], "error"), e.state || (3e3 === e.errorCode && "Meeting password is incorrect" === e.errorMessage ? tp(ba, {
                            errorCode: hi.WrongPasscode,
                            reason: "Incorrect passcode."
                        }) : 3e3 === e.errorCode && "The role type error" === e.errorMessage ? tp(ba, {
                            errorCode: hi.RoleTypeMissing,
                            reason: "Role type error"
                        }) : -3e3 === e.errorCode ? tp(ba, {
                            errorCode: hi.CommonError,
                            reason: "connection error"
                        }) : 3e3 === e.errorCode ? tp(ba, {
                            reason: e.errorMessage,
                            errorCode: hi.CommonError
                        }) : 300 === e.errorCode ? tp(ba, {
                            reason: "This account does not exist or does not belong to you",
                            errorCode: hi.CommonError
                        }) : 124 === e.errorCode && "Parse lite sdk topic and pwd fail" === e.errorMessage ? tp(ba, {
                            reason: "Topic is invalid",
                            errorCode: hi.CommonError
                        }) : 124 === e.errorCode && "The java web token is expired or more than 2 days or ineffective." === e.errorMessage ? tp(ba, {
                            reason: "The token has expired, is over 2 days old, or is ineffective.",
                            errorCode: hi.CommonError
                        }) : 124 === e.errorCode && tp(ba, {
                            reason: "Verify JWT failed",
                            errorCode: hi.CommonError
                        }));
                    }), r.pipe(Qy((e)=>{
                        if (!0 === e.status) {
                            const { result: { mid: i, websdkClientFeatureOptions: n, showRecommendVersion: s } } = e;
                            ns.init(i);
                            const a = ((e, t1)=>{
                                if (e.result) {
                                    const { result: { mn: o, ts: r, auth: i, track_auth: n, mid: s, tid: a, encryptedRWC: d, encryptedGEORWC: u, user_identity: l, meetingOptions: c, can_recording: p, wcXMPPConfig: h, call_out_country_json: m, isOriginalHost: g, support_call_out: v, liveTranscription: f, logConfig: y, logEncryptionPubKey: S, toll_numbers_json: b, h323Password: E, liveStreamInfo: I, rc_auto_delete: A, jwt_rc: C, op_rc: _, mediaSDKVersion: R, mediaSDKPathPrefix: w, zmk: T, fileTransfer: O, fileServerDomain: D, accountId: P } } = e, { lang: M, password: k, topic: L, zlk: N, cv: V, userName: U } = t1;
                                    return {
                                        meetingNumber: o,
                                        meetingId: s,
                                        tid: a,
                                        ts: r,
                                        auth: i,
                                        passWord: k,
                                        trackAuth: n,
                                        customerKey: l,
                                        encryptedRWC: JSON.parse(d || "{}"),
                                        encryptedGEORWC: JSON.parse(u || "{}"),
                                        meetingOptions: JSON.parse(c || "{}"),
                                        recordingEnable: "1" === p,
                                        topic: L,
                                        userName: ns.get(ss.WebclientUserName) || U,
                                        cv: V,
                                        zlkJwtToken: N,
                                        xmppConfig: JSON.parse(h || "{}"),
                                        callOutCountry: JSON.parse(m || "{}"),
                                        lang: M,
                                        isOriginHost: g,
                                        isSupportCallOut: "1" === v,
                                        liveTranscription: JSON.parse(f || "{}"),
                                        logConfig: y,
                                        logEncryptionPubKey: S,
                                        tollNumbers: void 0 === b ? void 0 : JSON.parse(b),
                                        h323Password: E,
                                        liveStreamInfo: JSON.parse(I || "{}"),
                                        rcAutoDelete: A,
                                        jwtRc: C,
                                        opRc: _,
                                        mediaSDKPath: R && w ? `${ri(w)}/${R}` : void 0,
                                        zmk: T,
                                        fileTransfer: JSON.parse(O || "{}"),
                                        fileServerDomain: D,
                                        accountId: P
                                    };
                                }
                                return e;
                            })(e, o.payload);
                            var r;
                            s && (null == o || null === (r = o.payload) || void 0 === r || r.lang, console.log("Update VideoSDK-Web to the latest version to optimize meeting experience", "https://developers.zoom.us/docs/video-sdk/web/"));
                            const d = [
                                Re(pn(a)),
                                or(dA, t1, nn())
                            ], u = ((e)=>{
                                const t1 = [];
                                if (e) {
                                    const o = e.split("").reverse();
                                    Object.keys(es).filter((e)=>/M:\d+(,\d+)*;V:\d+(,\d+)*/.test(es[e])).forEach((e)=>{
                                        const r = es[e];
                                        let [i, n] = r.split(";");
                                        i.startsWith("V:") && ([i, n] = [
                                            n,
                                            i
                                        ]);
                                        const s = n.slice(2).split(",").map((e)=>o[Number(e) - 1]).reverse().join(""), a = parseInt(s, 16), d = zy[r];
                                        d && (Array.isArray(d) ? d : [
                                            d
                                        ]).forEach((e)=>{
                                            const o = e.mask ? (a & e.mask) > 0 : a;
                                            t1.push(Re(e.action(o)));
                                        });
                                    });
                                }
                                return t1;
                            })(n);
                            u.length > 0 && d.unshift(...u);
                            const l = ((e)=>{
                                const t1 = [];
                                if (e) {
                                    const r = e.split("").reverse(), i = [];
                                    os.forEach((e)=>{
                                        var t1;
                                        const [o, n] = e.split("-"), s = Number(n) - 1;
                                        i.length < s && (i.length = s + 1), i[s] = null !== (t1 = r[Number(o) - 1]) && void 0 !== t1 ? t1 : "0";
                                    });
                                    for(let e = 0; e < i.length; e++){
                                        var o;
                                        i[e] = null !== (o = i[e]) && void 0 !== o ? o : "0";
                                    }
                                    t1.push(Re(er(i.reverse().join(""))));
                                }
                                return t1;
                            })(n);
                            return l.length > 0 && d.unshift(...l), $e(...d);
                        }
                    }));
                }), pt(Gn(performance.now())));
            })),
        pingRWCEpic: dA
    });
    function fA(e) {
        for(var t1 = 1; t1 < arguments.length; t1++){
            var o = arguments[t1];
            for(var r in o)e[r] = o[r];
        }
        return e;
    }
    var yA = function e(t1, o) {
        function r(e, r, i) {
            if ("undefined" != typeof document) {
                "number" == typeof (i = fA({}, o, i)).expires && (i.expires = new Date(Date.now() + 864e5 * i.expires)), i.expires && (i.expires = i.expires.toUTCString()), e = encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
                var n = "";
                for(var s in i)i[s] && (n += "; " + s, !0 !== i[s] && (n += "=" + i[s].split(";")[0]));
                return document.cookie = e + "=" + t1.write(r, e) + n;
            }
        }
        return Object.create({
            set: r,
            get: function(e) {
                if ("undefined" != typeof document && (!arguments.length || e)) {
                    for(var o = document.cookie ? document.cookie.split("; ") : [], r = {}, i = 0; i < o.length; i++){
                        var n = o[i].split("="), s = n.slice(1).join("=");
                        try {
                            var a = decodeURIComponent(n[0]);
                            if (r[a] = t1.read(s, a), e === a) break;
                        } catch (e) {}
                    }
                    return e ? r[e] : r;
                }
            },
            remove: function(e, t1) {
                r(e, "", fA({}, t1, {
                    expires: -1
                }));
            },
            withAttributes: function(t1) {
                return e(this.converter, fA({}, this.attributes, t1));
            },
            withConverter: function(t1) {
                return e(fA({}, this.converter, t1), this.attributes);
            }
        }, {
            attributes: {
                value: Object.freeze(o)
            },
            converter: {
                value: Object.freeze(t1)
            }
        });
    }({
        read: function(e) {
            return '"' === e[0] && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
        },
        write: function(e) {
            return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
        }
    }, {
        path: "/"
    });
    const { WebclientIsOnHold: SA, WebclientOpt: bA, WebclientParticipantId: EA, WebclientZoomId: IA, WebclientMeetingToken: AA } = ss, { WebclientDeviceId: CA } = as;
    function _A(e) {
        let { retryCount: t1, rwgServerList: o, userName: r, auth: i, trackAuth: n, meetingId: s, customerKey: a, tid: d, lang: u, ts: l, bid: c, botk: p, confID: h, zlkJwtToken: m, isAudioBridgeEnabled: g, isMeetingReset: v, cameraDevicesList: f, isFullHDVideoEnabled: y, isFullHDVideoShareEnabled: S } = e;
        const b = yA.get("_zm_mtk_guid");
        let E = ns.get(CA);
        if (E || (E = yS(), ns.set(CA, E, rs.LocalStorage)), o.length > t1) {
            var I;
            const A = o[t1], C = {
                dn2: $r(r),
                auth: i,
                browser: `${gs.browser}${gs.browserVersion} ${null !== (I = window) && void 0 !== I && I.crossOriginIsolated ? "SAB" : ""}`,
                trackAuth: n,
                mid: s,
                tid: d,
                lang: u,
                ts: l,
                "ZM-CID": E,
                _ZM_MTG_TRACK_ID: b || "",
                customer_key: $r(a),
                cfs: 0,
                islch: 1
            };
            if (m) try {
                const { vendor: e } = oi(m);
                e && Object.assign(C, {
                    vendor: e
                });
            } catch (e) {
                console.log(e);
            }
            A.rwcAuth ? Object.assign(C, {
                rwcAuth: A.rwcAuth
            }) : A.rwcToken && Object.assign(C, {
                rwcToken: A.rwcToken
            });
            const _ = fs() ? 1 : gs.isIE || gs.isSupportEssentialAudioAndVideoAbility ? 2 : 0;
            Object.assign(C, {
                as_type: _
            }), [
                {
                    key: bA,
                    queryKey: "opt"
                },
                {
                    key: EA,
                    queryKey: "participantID"
                },
                {
                    key: IA,
                    queryKey: "zoomid"
                }
            ].forEach((e)=>{
                const t1 = ns.get(e.key);
                void 0 !== t1 && (C[e.queryKey] = t1);
            });
            const R = c && p && h;
            R && Object.assign(C, {
                bid: $r(c),
                confID: h
            }), ns.get(AA) && Object.assign(C, {
                isdj: 1
            }), vs() && (Object.assign(C, {
                from: gs.isAndroidBrowser ? "android" : "ios"
            }), g && Object.assign(C, {
                useABAudio: 1
            })), Object.assign(C, {
                clientCaps: RA({
                    isAudioBridgeEnabled: g && vs(),
                    isBO: R,
                    isFullHDVideoEnabled: y,
                    isFullHDVideoShareEnabled: S
                })
            });
            const w = v ? f.length > 0 ? 1 : 0 : 1;
            return Object.assign(C, {
                isCamera: w
            }), Object.assign(C, {
                clientOS: gs.isAndroidOrIOSBrowser ? gs.isIOSMobile ? "ios" : "android" : gs.isMacOS ? "mac" : "win"
            }), Object.assign(C, {
                audioFeature: ca.getAudioFeatureFlag()
            }), {
                queryObject: {
                    ...C
                },
                rwgServer: A
            };
        }
        return null;
    }
    function RA(e) {
        const { isAudioBridgeEnabled: t1, isBO: o, isFullHDVideoEnabled: r, isFullHDVideoShareEnabled: i } = e;
        let n = Eh.WebCameraIndication | Eh.SendMeetingTokenSeparately | Eh.SmartSummary | Eh.LocalRecording | Eh.LocalRecordingGrantPermission | Eh.UnifyErrorType;
        const s = ca.getPTZCapability();
        return (s.pan || s.tilt || s.zoom) && (n |= Eh.SupportFarEndCameraControl), ca.isSupportVideoShare() && (n |= Eh.SupportVideoShare), t1 && ca.isSupportAudioBridgeAVSync() && (n |= Eh.WebrtcAudioRtcpTime), ca.isSupportShareMultiStream() && (n |= Eh.ShareMultiStream), ca.isSupportVideoLTR() && (n |= Eh.VideoLTR), o || (n |= Eh.RequestRemoteControl), r && ca.isSupportFullHDVideo() && (n |= Eh.SupportSend1080PVideo), i && ca.isSupportFullHDVideoShare() && (n |= Eh.SupportSend1080PVideoShare), n;
    }
    function wA(e, t1) {
        return t1 ? O(dt(t1), ot(()=>{
            const { socket: { zoomSocketStatus: t1 }, meeting: { meetingStatus: o, isMeetingReset: r } } = e.value;
            return t1 !== Sh.Closed && o === Xn.Joined && !r;
        })) : O(ot(()=>{
            const { socket: { zoomSocketStatus: t1 }, meeting: { meetingStatus: o, isMeetingReset: r } } = e.value;
            return t1 !== Sh.Closed && o === Xn.Joined && !r;
        }));
    }
    const TA = ia.createAgent();
    let OA;
    const DA = jI.getInstance();
    let PA;
    const MA = na.getInstance();
    let kA;
    const LA = {
        zoomSocketStatus: Sh.Closed,
        xmppSocketStatus: Sh.Closed,
        mainSessionSocketStatus: Sh.Closed,
        retryCount: 0,
        rwgServerList: []
    }, NA = bo({
        [`${Po}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.zoomSocketStatus = o.status;
        }),
        [`${Mo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { rwgServerList: r } = e;
            r.find((e)=>e.rwg === o.rwg) || r.push(o);
        }),
        [`${ko}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.retryCount = o;
        }),
        [`${Lo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.xmppSocketStatus = o;
        }),
        [`${No}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.mainSessionSocketStatus = o;
        }),
        [`${Vo}`]: ()=>LA
    }, LA), VA = {
        epics0: (e, t1)=>e.pipe(Dt(`${Eo}`), ft(t1), ot((e)=>{
                let [, t1] = e;
                return t1.socket.zoomSocketStatus === Sh.Closed && !!t1.meeting.meetingId;
            }), ht((e)=>{
                let [, o] = e;
                return (function(e) {
                    const { media: { patchedMediaSDKStatus: t1 }, meeting: { isRlbTP: o, isRlbTPReady: r } } = e;
                    return We([
                        t1 === Qd.Loading ? np(cc, 1).pipe(Ie(ee)) : _e([
                            0
                        ]),
                        o ? r ? _e([
                            0
                        ]) : np(Ra, 1).pipe(Ie(ee)) : _e([
                            0
                        ])
                    ]);
                })(o).pipe(ht(()=>{
                    const { socket: { retryCount: e, rwgServerList: o }, meeting: r, breakoutRoom: i, video: n, share: s } = t1.value;
                    let a;
                    const d = {
                        ...r,
                        retryCount: e,
                        rwgServerList: o
                    };
                    if (n) {
                        const { cameraDevicesList: e, isFullHDVideoEnabled: t1 } = n;
                        Object.assign(d, {
                            cameraDevicesList: e,
                            isFullHDVideoEnabled: t1
                        });
                    }
                    if (s) {
                        const { isFullHDVideoShareEnabled: e } = s;
                        Object.assign(d, {
                            isFullHDVideoShareEnabled: e
                        });
                    }
                    if (i && i.currentRoom.status === Qp.Joining) {
                        const { currentRoom: { boId: e, boConfId: t1, boToken: o } } = i;
                        Object.assign(d, {
                            bid: e,
                            botk: o,
                            confID: t1
                        });
                    }
                    if (a = r.zlkJwtToken ? function(e) {
                        const t1 = _A(e);
                        if (t1) {
                            const { queryObject: o, rwgServer: r } = t1, { topic: i, cv: n, meetingNumber: s } = e;
                            return Object.assign(o, {
                                topic: $r(i),
                                iccv: n
                            }), `wss://${r.rwg}/instantsdk/${s}?${new URLSearchParams(o).toString()}`;
                        }
                        return null;
                    }(d) : function(e) {
                        const t1 = _A(e);
                        if (t1) {
                            const { queryObject: o, rwgServer: r } = t1, { cv: i, meetingNumber: n } = e;
                            return Object.assign(o, {
                                jscv: i,
                                browser: o.browser + " ComponentView"
                            }), [
                                {
                                    key: SA,
                                    queryKey: "cfs"
                                }
                            ].forEach((e)=>{
                                const t1 = ns.get(e.key);
                                void 0 !== t1 && (o[e.queryKey] = t1);
                            }), `wss://${r.rwg}/wc/api/${n}?${new URLSearchParams(o).toString()}`;
                        }
                        return null;
                    }(d), a) {
                        const e = (u = a, l = r.isRlbTP, TA.connect(u, l), OA = new j, Qe((e)=>TA.on(oa.Message, e), (e)=>TA.off(oa.Message, e), (e)=>e.data).subscribe(OA), OA);
                        return Xe(e.pipe(ot((e)=>"string" == typeof e), Le((e)=>{
                            try {
                                return JSON.parse(e);
                            } catch (e) {
                                return console.error(e), {
                                    evt: 0
                                };
                            }
                        }), eS(), Jy((e)=>{
                            if (0 !== e.evt || !e.body || "invalid parameters!" !== e.body.test) return _o(e);
                            tp(ba, {
                                errorCode: hi.InvalidParameter,
                                reason: "Invalid parameter"
                            });
                        }), pt(Po({
                            status: Sh.Connecting,
                            rwgUrl: a
                        }))), e.pipe(ot((e)=>e instanceof ArrayBuffer), Le((e)=>Ro(e))));
                    }
                    var u, l;
                    return ne;
                }));
            })),
        epics1: (e, t1)=>e.pipe(Dt(`${Eo}`), ft(t1), ot((e)=>{
                let [, t1] = e;
                return t1.socket.zoomSocketStatus === Sh.Closed && !!t1.meeting.meetingId;
            }), ht(()=>{
                const [e, o, r, i] = [
                    oa.Open,
                    oa.Close,
                    oa.Error,
                    oa.Inactive
                ].map((e)=>Qe((t1)=>TA.on(e, t1), (t1)=>TA.on(e, t1)));
                return Xe(e.pipe(Fe(()=>Xe(Re(Po({
                        status: Sh.Connected
                    })), Ze(6e4).pipe(ft(t1), ot((e)=>{
                        let [, t1] = e;
                        return t1.meeting.meetingStatus === Xn.Initial && !t1.meeting.isMeetingReset;
                    }), Le(()=>(tp(Ea, {
                            reason: Jn.Failover
                        }), sn(ts.NoHeartbeat))))))), o.pipe(wA(t1), Le(()=>(tp(Ea, {
                        reason: Jn.Failover
                    }), sn(ts.Disconnect)))), i.pipe(wA(t1), Le(()=>(tp(Ea, {
                        reason: Jn.Failover
                    }), sn(ts.NoHeartbeat)))), r.pipe(ft(t1), Fe((e)=>{
                    let [, o] = e;
                    const { meeting: { meetingStatus: r, isMeetingReset: i }, socket: { rwgServerList: n, retryCount: s } } = o, a = [];
                    if (r === Xn.Initial && null != n && n.length) {
                        const e = n[s];
                        return Ze(5e3).pipe(ot(()=>t1.value.meeting.meetingStatus === Xn.Initial), Fe(()=>{
                            const { socket: { rwgServerList: e, retryCount: o } } = t1.value, r = [];
                            return e.length > o + 1 ? r.push(ko(o + 1), Ao({
                                retry: !0
                            })) : (tp(ba, {
                                reason: "connection error",
                                errorCode: hi.CommonError
                            }), r.push(...Gy(t1.value))), _e(r);
                        }), pt(jn(null == e ? void 0 : e.rwc)));
                    }
                    return i || r !== Xn.Joined || (tp(Ea, {
                        reason: Jn.Failover
                    }), a.push(sn(ts.OnError))), _e(a);
                })));
            })),
        epics2: (e, t1)=>e.pipe(Dt(`${Ao}`), ht((e)=>e.payload && e.payload.retry ? Re(Eo()).pipe(dt(1e3), pt(Po({
                    status: Sh.Closed
                }))) : Re(Po({
                    status: Sh.Closed
                }))), dt(100), vt(()=>{
                var e;
                t1.value.socket.zoomSocketStatus === Sh.Closed && (TA.close(), null === (e = OA) || void 0 === e || e.complete());
            }))
    }, UA = ir(VA, {
        xmppEpics0: (e, t1)=>e.pipe(Dt(`${bn}`), Fe(()=>{
                const { meeting: { meetingOptions: e, zlkJwtToken: o, isWebinar: r } } = t1.value, i = [];
                return (e.isPollingEnabled || o || r) && i.push(Io()), _e(i);
            })),
        xmppEpics1: (e, t1)=>e.pipe(Dt(`${Io}`), ft(t1), ot((e)=>{
                let [, t1] = e;
                return "closed" === t1.socket.xmppSocketStatus;
            }), ht((e)=>{
                let [, t1] = e;
                const { meeting: { svcUrl: o, meetingNumber: r, conId: i, isRlbTP: n } } = t1, s = function(e, t1, o) {
                    return `wss://${e}/wc/media/${t1}?type=x&cid=${o}`;
                }(o, r, i);
                return ((e, t1)=>(DA.connect(e, t1), PA = new j, Qe((e)=>DA.on(UI.Message, e), (e)=>DA.off(UI.Message, e)).subscribe(PA), PA))(s, n).pipe(ot((e)=>void 0 !== (null == e ? void 0 : e.evt)), Le((e)=>wo(e)), pt(Lo(Sh.Connecting)));
            })),
        xmppEpics2: (e, t1)=>e.pipe(Dt(`${Io}`), ht(()=>{
                const [e, o, r] = [
                    UI.Open,
                    UI.Close,
                    UI.Error
                ].map((e)=>Qe((t1)=>DA.on(e, t1), (t1)=>DA.on(e, t1)));
                return Xe(e.pipe(vt(()=>{
                    const e = function() {
                        const { isSupportEssentialAudioAndVideoAbility: e, isSupportAudioWorklet: t1 } = gs;
                        return e && t1 ? 11 : 10;
                    }();
                    DA.join(e);
                }), at(Lo(Sh.Connected))), o.pipe(wA(t1, 500), Le(()=>(tp(Ea, {
                        reason: Jn.Failover
                    }), sn(ts.DisconnectXmpp)))), r.pipe(wA(t1, 500), Le(()=>(tp(Ea, {
                        reason: Jn.Failover
                    }), sn(ts.OnErrorXmppChannel)))));
            })),
        xmppEpics3: (e)=>e.pipe(Dt(`${Co}`), at(Lo(Sh.Closed)), dt(100), vt(()=>{
                var e;
                DA.close(), null === (e = PA) || void 0 === e || e.complete();
            }))
    }, {
        mainSessionEpics0: (e, t1)=>e.pipe(Dt(`${To}`), ft(t1), ot((e)=>{
                let [, t1] = e;
                return "closed" === t1.socket.mainSessionSocketStatus;
            }), ht((e)=>{
                let [, t1] = e;
                const { meeting: { svcUrl: o, meetingNumber: r, conId: i, isRlbTP: n } } = t1, s = function(e, t1, o) {
                    return `wss://${e}/wc/media/${t1}?type=m&cid=${o}&mode=2`;
                }(o, r, i);
                return ((e, t1)=>(MA.connect(e, t1), kA = new j, Qe((e)=>MA.on(oa.Message, e), (e)=>MA.off(oa.Message, e)).pipe(Le((e)=>e.data)).subscribe(kA), kA))(s, n).pipe(Le((e)=>{
                    try {
                        return JSON.parse(e);
                    } catch (e) {
                        return console.error(e), {
                            evt: 0
                        };
                    }
                }), ot((e)=>0 !== e.evt), eS(), Le((e)=>Do(e)), pt(No(Sh.Connecting)));
            })),
        mainSessionEpics1: (e, t1)=>e.pipe(Dt(`${To}`), ht(()=>{
                const [e, o, r] = [
                    oa.Open,
                    oa.Close,
                    oa.Error
                ].map((e)=>Qe((t1)=>MA.on(e, t1), (t1)=>MA.on(e, t1)));
                return Xe(e.pipe(at(No(Sh.Connected))), o.pipe(wA(t1, 500), Le(()=>(tp(Ea, {
                        reason: Jn.Failover
                    }), sn(ts.DisconnectMChannel)))), r.pipe(wA(t1, 500), Le(()=>(tp(Ea, {
                        reason: Jn.Failover
                    }), sn(ts.OnErrorMChannel)))));
            })),
        mainSessionEpics2: (e)=>e.pipe(Dt(`${Oo}`), at(No(Sh.Closed)), vt(()=>{
                var e;
                MA.close(), null === (e = kA) || void 0 === e || e.complete();
            }))
    }), jA = {
        id: "userId",
        type: (e)=>Wp(e) ? {
                userType: e,
                avatarBackgroundType: Math.floor(8 * Math.random()) + 1
            } : {
                userType: e
            },
        role: (e)=>({
                userRole: e,
                isHost: $p(e)
            }),
        dn2: (e)=>({
                displayName: Wr(e)
            }),
        bShareOn: "sharerOn",
        bSharePause: "sharerPause",
        bLocalRecordStatus: (e)=>({
                bLocalRecord: e
            }),
        bGuest: "isGuest",
        bCapsRequestLT: "isRequestLT",
        customerKey: "userIdentity"
    }, xA = (e)=>{
        const t1 = {};
        return [
            "add",
            "remove",
            "update"
        ].forEach((o)=>{
            const r = o, i = e[r];
            null != i && (t1[r] = i.reduce((e, t1)=>{
                const o = Object.keys(t1).reduce((e, o)=>{
                    const r = jA[o];
                    return "function" == typeof r ? Object.assign(e, r(t1[o])) : "string" == typeof r ? Object.assign(e, {
                        [`${r}`]: t1[o]
                    }) : Object.assign(e, {
                        [`${o}`]: t1[o]
                    }), e;
                }, {}), r = e.find((e)=>e.userId === o.userId);
                return void 0 !== r ? Object.assign(r, o) : e.push(o), e;
            }, []));
        }), t1;
    }, BA = {
        name: "displayName",
        node: (e)=>({
                userId: Number(e)
            }),
        role: (e)=>({
                userRole: Number(e)
            })
    }, FA = (e)=>Object.keys(e).reduce((t1, o)=>{
            const r = BA[o];
            return "function" == typeof r ? Object.assign(t1, r(e[o])) : "string" == typeof r ? Object.assign(t1, {
                [`${r}`]: e[o]
            }) : Object.assign(t1, {
                [`${o}`]: e[o]
            }), t1;
        }, {}), HA = {
        attendeesList: [],
        assistantList: [],
        xmppAttendeeList: [],
        allowTalkAttendeesList: [],
        failoverAttendeesList: [],
        isAdmitAllSilentUsers: !1
    }, $A = bo({
        [`${bp}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            void 0 !== o.add && o.add.length > 0 && o.add.forEach((t1)=>{
                if (t1.userType === Hp.Assitant) {
                    const o = e.assistantList.find((e)=>e.userId === t1.userId);
                    void 0 !== o ? Object.assign(o, t1) : e.assistantList.push(t1);
                } else if (Gp(t1.userRole)) {
                    const o = e.allowTalkAttendeesList.find((e)=>e.userId === t1.userId);
                    void 0 !== o ? Object.assign(o, t1) : e.allowTalkAttendeesList.push(t1);
                } else {
                    const o = e.attendeesList.find((e)=>e.userId === t1.userId);
                    void 0 !== o ? Object.assign(o, t1) : e.attendeesList.push(t1);
                }
            }), void 0 !== o.update && o.update.length > 0 && o.update.forEach((t1)=>{
                const o = e.attendeesList.find((e)=>e.userId === t1.userId);
                if (void 0 !== o) Object.assign(o, t1);
                else {
                    const o = e.allowTalkAttendeesList.find((e)=>e.userId === t1.userId);
                    if (void 0 !== o) Object.assign(o, t1);
                    else {
                        const o = e.assistantList.find((e)=>e.userId === t1.userId);
                        void 0 !== o && Object.assign(o, t1);
                    }
                }
            }), void 0 !== o.remove && o.remove.length > 0 && o.remove.forEach((t1)=>{
                const o = e.attendeesList.findIndex((e)=>e.userId === t1.userId);
                if (-1 !== o) e.attendeesList.splice(o, 1);
                else {
                    const o = e.allowTalkAttendeesList.findIndex((e)=>e.userId === t1.userId);
                    if (-1 !== o) e.allowTalkAttendeesList.splice(o, 1);
                    else {
                        const o = e.assistantList.findIndex((e)=>e.userId === t1.userId);
                        -1 !== o && e.assistantList.splice(o, 1);
                    }
                }
            });
        }),
        [`${Dp}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { xmppAttendeeList: r } = e, i = r.map((e)=>e.jid);
            o.forEach((e)=>{
                const { jid: t1 } = e, o = i.indexOf(t1);
                -1 !== o ? Object.assign(r[o], e) : r.push(e);
            });
        }),
        [`${Ip}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAdmitAllSilentUsers = o;
        }),
        [`${Rp}`]: OI((e)=>{
            e.attendeesList.forEach((e)=>{
                e.bRaiseHand && (e.bRaiseHand = !1);
            });
        }),
        [`${wp}`]: OI((e)=>{
            e.attendeesList.forEach((e)=>{
                e.feedback > 0 && (e.feedback = 0);
            });
        }),
        [`${Cp}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.failoverAttendeesList.push(o);
        }),
        [`${_p}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            o.forEach((t1)=>{
                const o = e.failoverAttendeesList.findIndex((e)=>e.zoomID === t1.zoomID);
                -1 !== o && e.failoverAttendeesList.splice(o, 1);
            });
        }),
        [`${Tp}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { jid: r, name: i } = o, n = e.xmppAttendeeList.find((e)=>e.jid === r);
            n && (n.displayName = i);
        }),
        [`${Op}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { jid: r } = o, i = e.xmppAttendeeList.findIndex((e)=>e.jid === r);
            -1 !== r && e.xmppAttendeeList.splice(i, 1);
        }),
        [`${Pp}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { userId: r, key: i, value: n } = o, s = e.attendeesList.find((e)=>e.userId === r);
            s && (s[`${i}`] = n);
        }),
        [`${Ap}`]: ()=>HA
    }, HA), WA = {
        epics0: (e, t1)=>nr(e, Ps).pipe(Le((e)=>xA(e.payload.body)), ft(t1), Fe((e)=>{
                let [t1, o] = e, r = [
                    bp(t1)
                ];
                const { meeting: { userId: i, isWebinar: n, isOnHold: s }, participants: { attendeesList: a, failoverAttendeesList: d, allowTalkAttendeesList: u } } = o, l = u.map((e)=>e.userId);
                if (t1.add) {
                    const e = t1.add.filter((e)=>e.userId === i);
                    e.length > 0 && e.forEach((e)=>{
                        void 0 !== e.bHold && r.push(_n(e.bHold)), a.some((t1)=>t1.userId === e.userId) ? tp(ha, e) : tp(pa, e);
                    });
                    const s = t1.add.filter((e)=>e.userId !== i);
                    if (s.length > 0) {
                        const e = s.filter((e)=>!Gp(e.userRole)).map((e)=>{
                            const t1 = {
                                ...e
                            };
                            if (Wp(e.userType)) {
                                var r;
                                const i = null === (r = o.audio) || void 0 === r ? void 0 : r.dialout.find((t1)=>t1.phoneNodeId === e.userId);
                                i && Object.assign(t1, {
                                    phoneNumber: i.phoneNumber
                                });
                            }
                            const i = d.find((t1)=>t1.zoomID === e.zoomID);
                            return i && Object.assign(t1, {
                                source: i.isOnHold ? "on hold" : "failover"
                            }), t1;
                        }), t1 = e.filter((e)=>!!e.source).map((e)=>({
                                zoomID: e.zoomID
                            }));
                        if (r.push(_p(t1)), tp(ma, e), n) {
                            const e = s.filter((e)=>Gp(e.userRole));
                            e.length > 0 && tp(fa, e.map((e)=>({
                                    userId: e.userId,
                                    isAllowToTalk: !0
                                })));
                        }
                    }
                }
                if (t1.update) {
                    const e = t1.update.filter((e)=>e.userId === i);
                    e.length > 0 && e.forEach((e)=>{
                        tp(ha, e), void 0 !== e.bHold && r.push(_n(e.bHold));
                    });
                    const o = t1.update.filter((e)=>!(e.userId === i || l.includes(e.userId)));
                    if (o.length > 0 && tp(ga, o), n) {
                        const e = t1.update.filter((e)=>e.userId !== i && l.includes(e.userId));
                        e.length > 0 && tp(fa, e);
                    }
                }
                if (t1.remove) {
                    const e = t1.remove.map((e)=>{
                        const t1 = a.find((t1)=>t1.userId === e.userId);
                        return t1 ? 2 === e.action && 1 === e.nUserStatus ? t1.bHold ? (r.push(Cp({
                            zoomID: t1.zoomID,
                            isOnHold: !0
                        })), {
                            ...e,
                            ...t1,
                            reason: "on hold"
                        }) : (r.push(Cp({
                            zoomID: t1.zoomID,
                            isOnHold: !1
                        })), {
                            ...e,
                            ...t1,
                            reason: "failover"
                        }) : {
                            ...e,
                            ...t1
                        } : null;
                    }).filter((e)=>!!e);
                    if (tp(va, e), n) {
                        const e = t1.remove.filter((e)=>l.includes(e.userId));
                        e.length > 0 && tp(fa, e.map((e)=>({
                                userId: e.userId,
                                isAllowToTalk: !1
                            })));
                    }
                }
                const c = r.filter((e)=>e.type === `${_n}`);
                if (c.length > 0) {
                    const e = c[c.length - 1];
                    r = r.filter((e)=>e.type !== `${_n}`), e.payload !== s && (r.push(e), tp(Aa, !s));
                }
                return _e(r);
            })),
        epics1: (e, t1)=>ar(e, 24595).pipe(Fe((e)=>{
                const { payload: { body: { action: o, data: r } } } = e, { meeting: { jid: i }, participants: { xmppAttendeeList: n } } = t1.value, s = [];
                if (o === VI.rename) {
                    r.forEach((e)=>{
                        s.push(Tp(e));
                    });
                    const e = r.map((e)=>FA(e));
                    tp(fa, e);
                }
                if (o === VI.Remove) {
                    r.forEach((e)=>{
                        s.push(Op(e));
                    });
                    const e = r.map((e)=>({
                            ...FA(e),
                            removed: !0
                        }));
                    tp(ya, e);
                }
                if ([
                    VI.Add,
                    VI.List,
                    VI.update
                ].includes(o)) {
                    const e = r.map((e)=>{
                        const t1 = FA(e);
                        return Object.keys(t1).reduce((e, o)=>("" !== t1[o] && Object.assign(e, {
                                [o]: t1[o]
                            }), e), {});
                    });
                    if (tp(fa, e), s.push(Dp(e)), o === VI.update) {
                        const e = r.find((e)=>e.jid === i);
                        if (e && void 0 !== e.bRaiseHand) {
                            const t1 = n.find((e)=>e.jid === i);
                            (null == t1 ? void 0 : t1.bRaiseHand) !== e.bRaiseHand && tp("MEETING_WEBINAR_ATTENDEE_RAISE_HAND", {
                                bRaiseHand: e.bRaiseHand
                            });
                        }
                    }
                }
                return _e(s);
            })),
        epics2: (e)=>nr(e, 7951).pipe(vt((e)=>{
                !1 === e.payload.body.bStarted && tp("ADMIT_ALL_SILENT_USERS_END", e.payload.body.bStarted);
            }), Le((e)=>Ip(e.payload.body.bStarted))),
        epics3: (e)=>nr(e, 7946).pipe(ot((e)=>{
                var t1;
                return [
                    "bRaiseHand",
                    "feedback"
                ].includes(null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.key) && 0 === e.payload.body.value;
            }), Le((e)=>(tp(ga, {}), "bRaiseHand" === e.payload.body.key ? Rp() : wp())))
    }, GA = ir(WA), KA = {
        audioEncodeStatus: "initial",
        audioDecodeStatus: "initial",
        videoEncodeStatus: "initial",
        videoDecodeStatus: "initial",
        sharingEncodeStatus: "initial",
        sharingDecodeStatus: "initial",
        assetsPath: "",
        mediaConstraints: void 0,
        fileWithVersion: !1,
        enforceMultipleVideos: !1,
        enforceVirtualBackground: !1,
        enableAudioQos: !0,
        enableVideoQos: !0,
        isAudioBridgeReceiveReady: !1,
        isAudioBridgeSendReady: !1,
        isMediaAgentInitialized: !1,
        disableRenderLimits: !1,
        adaptedABOptionForMediaSDK: ""
    }, zA = bo({
        [`${Bo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.audioDecodeStatus = o;
        }),
        [`${xo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.audioEncodeStatus = o;
        }),
        [`${Wo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.sharingDecodeStatus = o;
        }),
        [`${$o}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.sharingEncodeStatus = o;
        }),
        [`${Ho}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.videoDecodeStatus = o;
        }),
        [`${Fo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.videoEncodeStatus = o;
        }),
        [`${Go}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.mediaConstraints = o.mediaConstraints, e.assetsPath = o.assetsPath, e.fileWithVersion = o.fileWithVersion, e.enforceMultipleVideos = !!o.enforceMultipleVideos, e.enforceVirtualBackground = o.enforceVirtualBackground, e.skipJsMedia = o.skipJsMedia, e.patchJsMedia = o.patchJsMedia, e.alternativeNameForVideoPlayer = o.alternativeNameForVideoPlayer, o.enforceMultipleVideos && "object" == typeof o.enforceMultipleVideos && (e.disableRenderLimits = !!o.enforceMultipleVideos.disableRenderLimits);
        }),
        [`${Ko}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { type: r, encryptKey: i, additionalType: n } = o, s = {
                encryptKey: i,
                additionalType: n
            };
            "audio" === r ? e.audioEncrypt = s : "video" === r ? e.videoEncrypt = s : "sharing" === r && (e.sharingEncrypt = s);
        }),
        [`${zo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isEnableDecoderInWorklet = o;
        }),
        [`${qo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.patchedMediaSDKStatus = o;
        }),
        [`${Jo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.assetsPath = o;
        }),
        [`${Qo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.enableAudioQos = o.audioQos, e.enableVideoQos = o.videoQos;
        }),
        [`${Zo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAudioBridgeReceiveReady = o;
        }),
        [`${Yo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAudioBridgeSendReady = o;
        }),
        [`${Xo}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isMediaAgentInitialized = o;
        }),
        [`${er}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.adaptedABOptionForMediaSDK = o;
        }),
        [`${tr}`]: (e)=>({
                ...KA,
                mediaConstraints: e.mediaConstraints,
                assetsPath: e.assetsPath,
                fileWithVersion: e.fileWithVersion,
                enforceMultipleVideos: e.enforceMultipleVideos,
                disableRenderLimits: e.disableRenderLimits,
                enforceVirtualBackground: e.enforceVirtualBackground,
                alternativeNameForVideoPlayer: e.alternativeNameForVideoPlayer
            })
    }, KA), qA = new class {
        constructor(){
            this.state = {
                mediaSDK: void 0,
                mediaSDKInstanceMap: new Map,
                tagName: "video-player",
                renderCountMap: new Map
            }, this.onceMap = new WeakMap, this.subscribers = [];
        }
        get(e) {
            return this.state[e];
        }
        dispatch(e, t1, o) {
            t1 && Object.assign(this.state, t1), e && this.notifySubscribers(e, o);
        }
        subscribe(e) {
            return this.subscribers.push(e), ()=>{
                const t1 = this.subscribers.indexOf(e);
                -1 !== t1 && this.subscribers.splice(t1, 1);
            };
        }
        once(e, t1) {
            this.onceMap.set(t1, {
                event: e,
                unSubscribe: this.subscribe(t1)
            });
        }
        notifySubscribers(e, t1) {
            const o = [];
            this.subscribers.forEach((r)=>{
                r(e, this.state, t1);
                const i = this.onceMap.get(r);
                if (i) {
                    const { event: t1, unSubscribe: n } = i;
                    t1 === e && (o.push(n), this.onceMap.delete(r));
                }
            }), o.forEach((e)=>e());
        }
    };
    var JA, QA;
    !function(e) {
        e[e.ADD_RENDER_VIDEO = 1] = "ADD_RENDER_VIDEO", e[e.STOP_RENDER_VIDEO = 2] = "STOP_RENDER_VIDEO", e[e.START_SHARING = 23] = "START_SHARING", e[e.STOP_SHARING = 24] = "STOP_SHARING", e[e.SWITCH_CANVAS_FOR_VIDEO_CAPTURE = 25] = "SWITCH_CANVAS_FOR_VIDEO_CAPTURE", e[e.UPDATE_SHARING_DECODE_PARAM = 44] = "UPDATE_SHARING_DECODE_PARAM", e[e.UPDATE_CANVAS_SIZE = 46] = "UPDATE_CANVAS_SIZE", e[e.ZOOM_RENDER = 48] = "ZOOM_RENDER", e[e.REMOVE_EXPIRED_CANVAS = 76] = "REMOVE_EXPIRED_CANVAS", e[e.WEBGL_LOST_REPLACE_CANVAS = 77] = "WEBGL_LOST_REPLACE_CANVAS", e[e.UPDATE_VIDEO_QUALITY = 78] = "UPDATE_VIDEO_QUALITY", e[e.SEND_RENDER_LOG = 79] = "SEND_RENDER_LOG";
    }(JA || (JA = {})), function(e) {
        e[e.WEBGL_LOST_IN_MULTI_VIEW = -32] = "WEBGL_LOST_IN_MULTI_VIEW", e[e.MOBILE_CAPTURE_DEVICE_CHANGE = 135] = "MOBILE_CAPTURE_DEVICE_CHANGE";
    }(QA || (QA = {}));
    const ZA = "default-sesssion-key";
    var YA, XA, eC, tC;
    function oC(e, t1, o, r, i) {
        const n = document.createElement("canvas");
        n.id = r;
        const s = hC(n, e, t1);
        return i(`VPISC:${window.devicePixelRatio},${s}`), n.style.pointerEvents = "none", n.style.position = "absolute", n.style.left = "0px", n.style.top = "0px", n.style.width = e + "px", n.width = e * mC(n), n.style.height = t1 + "px", n.height = t1 * mC(n), n.ariaHidden = "true", n.style.zIndex = o, n;
    }
    function rC(e, t1) {
        const o = uC(()=>{
            if (e) {
                hC(e, t1.clientWidth, t1.clientHeight), [
                    JA.UPDATE_CANVAS_SIZE,
                    JA.UPDATE_SHARING_DECODE_PARAM
                ].forEach((o)=>{
                    var r, i;
                    null === (i = aC(null === (r = null == t1 ? void 0 : t1.getSessionId) || void 0 === r ? void 0 : r.call(t1))) || void 0 === i || i.Notify_MeidaSDK(o, {
                        width: t1.clientWidth * mC(e),
                        height: t1.clientHeight * mC(e),
                        canvas: e
                    });
                }), e.style.width = t1.clientWidth + "px", e.style.height = t1.clientHeight + "px";
                try {
                    e.width = t1.clientWidth * mC(e), e.height = t1.clientHeight * mC(e);
                } catch (e) {}
                qA.dispatch("resize", void 0, e.id);
            }
        }, 300), r = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`), i = new ResizeObserver(o);
        return r.addEventListener("change", o), i.observe(t1), ()=>{
            !function(e) {
                pC.delete(e);
            }(e), null == i || i.disconnect(), r.removeEventListener("change", o);
        };
    }
    function iC(e, t1) {
        Object.defineProperties(e, t1.reduce((t1, o)=>(t1[o] = {
                get: ()=>e.getAttribute(o),
                set: (t1)=>{
                    t1 ? e.setAttribute(o, t1) : e.removeAttribute(o);
                }
            }, t1), {}));
    }
    function nC(e, t1) {
        Object.entries(t1).forEach(([t1, o])=>{
            e.getAttribute(t1) || e.setAttribute(t1, o);
        });
    }
    function sC(e, t1) {
        const o = e.getAttribute(t1);
        return !(!o || "true" !== o);
    }
    function aC(e = ZA) {
        var t1;
        return null === (t1 = qA.get("mediaSDKInstanceMap").get(e)) || void 0 === t1 ? void 0 : t1();
    }
    function dC() {
        if ("function" == typeof crypto.randomUUID) return crypto.randomUUID();
        let e = (new Date).getTime(), t1 = performance && performance.now && 1e3 * performance.now() || 0;
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (o)=>{
            let r = 16 * Math.random();
            return e > 0 ? (r = (e + r) % 16 | 0, e = Math.floor(e / 16)) : (r = (t1 + r) % 16 | 0, t1 = Math.floor(t1 / 16)), ("x" === o ? r : 3 & r | 8).toString(16);
        });
    }
    function uC(e, t1) {
        let o;
        return function(...r) {
            clearTimeout(o), o = setTimeout(()=>{
                e(...r);
            }, t1);
        };
    }
    function lC(e, t1) {
        const o = Object.keys(e), r = Object.keys(t1);
        if (o.length !== r.length) return !1;
        for (const r of o){
            const o = e[r], i = t1[r];
            if ("object" == typeof o && "object" == typeof i) {
                if (!lC(o, i)) return !1;
            } else if (o !== i) return !1;
        }
        return !0;
    }
    function cC(e) {
        return !e || "0" === e;
    }
    !function(e) {
        e.Video = "video", e.Share = "share";
    }(YA || (YA = {})), function(e) {
        e.DEFAULT = "", e.MAIN = "main";
    }(XA || (XA = {})), function(e) {
        e.Video_90P = "0", e.Video_180P = "1", e.Video_360P = "2", e.Video_720P = "3", e.Video_1080P = "4";
    }(eC || (eC = {})), function(e) {
        e[e.Unknown = 0] = "Unknown", e[e.VideoTag = 1] = "VideoTag", e[e.WebGL = 2] = "WebGL", e[e.WebGL2 = 3] = "WebGL2", e[e.WebGPU = 4] = "WebGPU";
    }(tC || (tC = {}));
    const pC = new Map;
    function hC(e, t1, o) {
        const r = t1 >= 2 * window.screen.width || o >= 2 * window.screen.height ? 1 : window.devicePixelRatio, i = pC.get(e);
        return pC.set(e, r), i && i !== r && qA.dispatch("scale", void 0, e.id), r;
    }
    function mC(e) {
        return pC.get(e) || window.devicePixelRatio;
    }
    function gC(e, t1) {
        t1 && (null == e || e.Notify_MeidaSDK(JA.SEND_RENDER_LOG, {
            message: t1
        }));
    }
    function vC(e, t1) {
        const o = qA.get("renderCountMap"), r = o.get(e) || 0;
        o.set(e, t1 ? r + 1 : r - 1);
    }
    function fC(e, t1) {
        const { left: o, top: r, bottom: i, right: n, width: s, height: a } = e.getBoundingClientRect(), d = t1.getBoundingClientRect();
        return {
            left: o - d.left,
            top: r - d.top,
            bottom: d.bottom - i,
            right: d.right - n,
            width: s,
            height: a
        };
    }
    const yC = [];
    for(let e = 0; e <= 1; e += .01)yC.push(e);
    class SC {
        constructor(e, t1){
            if (this.getRenderParams = t1, this.el = document.createElement("div"), this.position = null, this.id = "", this.srcObject = null, this.removePositionObserve = null, this.viewId = `${qA.get("tagName")}-${dC()}`, this.getSDK = ()=>{
                var e, t1;
                return aC(null === (t1 = null === (e = this.container) || void 0 === e ? void 0 : e.getSessionId) || void 0 === t1 ? void 0 : t1.call(e));
            }, !e) throw new Error(`The ${qA.get("tagName")} must have a ${qA.get("tagName")}-container as its ancestor element.`);
            this.container = e, this.el.style.width = "100%", this.el.style.height = "100%", this.debounceUpdateVideoPosition = uC(this.updateVideoPosition.bind(this), 300);
        }
        getElement() {
            return this.el;
        }
        init() {
            this.removeSubscribe = qA.subscribe((e, t1, o)=>{
                o === this.getCanvas().id && ("resize" === e ? (this.updateVideoPosition(), setTimeout(()=>{
                    this.updateVideoPosition();
                }, 300)) : "scale" === e && gC(this.getSDK(), `VPSC:${mC(this.getCanvas())}`));
            });
        }
        getCanvas() {
            return this.container.getCanvas();
        }
        initObservePosition() {
            this.stopObservePosition(), this.removePositionObserve = function(e, t1, o = {}) {
                const { wrapper: r = document.documentElement } = o, i = uC(t1, 300);
                let n, s;
                const a = (o = 1, s = !1)=>{
                    n && (n.disconnect(), n = null);
                    const { top: d, left: u, width: l, height: c, right: p, bottom: h } = fC(e, r);
                    if (!l || !c) return void t1({
                        hide: !0,
                        cross: !1,
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        bottom: 0,
                        right: 0
                    });
                    const m = ((e, t1, o, r)=>e < 0 || t1 < 0 || o < 0 || r < 0)(d, h, u, p), g = ((e, t1, o, r, i, n)=>e <= 0 && e + n <= 0 || t1 <= 0 && t1 + n <= 0 || o <= 0 && o + i <= 0 || r <= 0 && r + i <= 0)(d, h, u, p, l, c), v = {
                        root: r,
                        threshold: m ? yC : o
                    };
                    m || (v.rootMargin = `${-d}px ${-p}px ${-h}px ${-u}px`);
                    let f = !0, y = !0;
                    s && (y = !1), t1({
                        hide: g,
                        cross: m,
                        top: d,
                        left: u,
                        width: l,
                        height: c,
                        bottom: h,
                        right: p
                    }), i({
                        hide: g,
                        cross: m,
                        top: d,
                        left: u,
                        width: l,
                        height: c,
                        bottom: h,
                        right: p
                    }, !0), n = new IntersectionObserver(([e])=>{
                        if (0 === e.intersectionRatio) return y ? a(1, !0) : void 0;
                        if (o !== e.intersectionRatio) {
                            if (!f) return a();
                            a(0 === e.intersectionRatio ? 1e-7 : e.intersectionRatio);
                        }
                        1 === e.intersectionRatio && m && a(), f = !1;
                    }, v), n.observe(e);
                };
                return a(), s = new ResizeObserver(()=>a()), s.observe(e), ()=>{
                    null == n || n.disconnect(), n = null, null == s || s.disconnect(), s = null;
                };
            }(this.el, (e, t1)=>{
                t1 ? setTimeout(()=>{
                    this.updateVideoPosition();
                }, 300) : this.debounceUpdateVideoPosition(e);
            }, {
                wrapper: this.container
            });
        }
        stopObservePosition() {
            this.removePositionObserve && (this.removePositionObserve(), this.removePositionObserve = null);
        }
        getCurrentPosition(e) {
            return this.transformRectToPosition(fC(e, this.container));
        }
        transformRectToPosition(e) {
            const { left: t1, width: o, height: r, bottom: i, top: n } = e, s = mC(this.getCanvas());
            return {
                x: t1 * s,
                y: i * s,
                width: o * s,
                height: r * s,
                left: t1 * s,
                bottom: i * s,
                top: n * s
            };
        }
        playVideo(e) {
            this.initObservePosition(), "string" == typeof e ? this.id = e : this.srcObject = e;
            const t1 = this.getCurrentPosition(this.el);
            this.addRender(Object.assign(Object.assign(Object.assign(Object.assign({}, t1), {
                canvas: this.getCanvas(),
                zone: this.viewId,
                userId: Number(this.id),
                ssrc: Number(this.id)
            }), this.getRenderParams()), this.srcObject ? {
                srcObject: this.srcObject
            } : {})), this.position = t1;
        }
        updateVideoPosition(e) {
            if (!this.id && !this.srcObject) return;
            const t1 = this.transformRectToPosition(e || fC(this.el, this.container));
            this.position && lC(t1, this.position) || (this.zoomRender(Object.assign(Object.assign(Object.assign(Object.assign({}, t1), {
                userId: Number(this.id),
                canvas: this.getCanvas(),
                RGBA: this.container.getRGBA(),
                zone: this.viewId
            }), this.getRenderParams()), this.srcObject ? {
                srcObject: this.srcObject
            } : {})), this.position = t1);
        }
        stopVideo() {
            this.stopObservePosition(), (this.id || this.srcObject) && this.position && ((this.id || this.srcObject) && this.stopRender(Object.assign(Object.assign(Object.assign(Object.assign({}, this.position), {
                userId: Number(this.id),
                canvas: this.getCanvas(),
                RGBA: this.container.getRGBA(),
                zone: this.viewId
            }), this.getRenderParams()), this.srcObject ? {
                srcObject: this.srcObject
            } : {})), this.position = null, this.id = "", this.srcObject = null);
        }
        updateVideoQuality(e) {
            var t1;
            this.id && (null === (t1 = this.getSDK()) || void 0 === t1 || t1.Notify_MeidaSDK(JA.UPDATE_VIDEO_QUALITY, {
                userId: this.id,
                videoQuality: e
            }));
        }
        refresh() {
            this.debounceUpdateVideoPosition();
        }
        destroy() {
            var e;
            this.stopVideo(), null === (e = this.removeSubscribe) || void 0 === e || e.call(this);
        }
    }
    class bC {
        constructor(e){
            this.container = e, this.id = "", this.srcObject = null, this.getSDK = ()=>{
                var e, t1;
                return aC(null === (t1 = null === (e = this.container) || void 0 === e ? void 0 : e.getSessionId) || void 0 === t1 ? void 0 : t1.call(e));
            }, this.el = document.createElement("video"), this.el.style.width = "100%", this.el.style.height = "100%", this.el.setAttribute("autoplay", "true"), this.el.setAttribute("muted", "true"), this.el.setAttribute("playsinline", "true");
        }
        getElement() {
            return this.el;
        }
        init() {}
        playVideo(e) {
            "string" == typeof e ? this.id = e : this.srcObject = e, this.addRender(Object.assign({
                userId: Number(this.id),
                videodom: this.el
            }, this.srcObject ? {
                srcObject: this.srcObject
            } : {}));
        }
        stopVideo() {
            (this.id || this.srcObject) && (this.stopRender(Object.assign({
                userId: Number(this.id),
                videodom: this.el
            }, this.srcObject ? {
                srcObject: this.srcObject
            } : {})), this.id = "", this.srcObject = null);
        }
        updateVideoQuality(e) {}
        destroy() {
            this.stopVideo();
        }
    }
    class EC extends SC {
        addRender({ width: e, height: t1, x: o, y: r, canvas: i, zone: n, userId: s, left: a, bottom: d, top: u, fillMode: l, videoQuality: c }) {
            var p;
            this.getSDK() && (vC(this.container, !0), function(e) {
                var t1, o;
                const r = qA.get("renderCountMap").get(e) || 0, i = (null === (o = null === (t1 = null === JsMediaSDK_Instance || void 0 === JsMediaSDK_Instance ? void 0 : JsMediaSDK_Instance.util) || void 0 === t1 ? void 0 : t1.getMaxCountRender) || void 0 === o ? void 0 : o.call(t1)) || 25, n = r >= 0 && r <= i, s = qA.get("tagName");
                n || console.error(`In your environment, the maximum number of ${s} that can be accommodated in each ${s}-container is ${i}. The current number has exceeded this limit, which may cause video rendering issues.`);
            }(this.container)), null === (p = this.getSDK()) || void 0 === p || p.Notify_MeidaSDK(JA.ADD_RENDER_VIDEO, {
                width: e,
                height: t1,
                x: o,
                y: r,
                canvas: i,
                zone: n,
                userId: s,
                left: a,
                bottom: d,
                top: u,
                fillMode: l,
                videoQuality: c
            });
        }
        zoomRender({ width: e, height: t1, x: o, y: r, userId: i, canvas: n, RGBA: s, zone: a, left: d, bottom: u, top: l }) {
            var c;
            null === (c = this.getSDK()) || void 0 === c || c.Notify_MeidaSDK(JA.ZOOM_RENDER, {
                width: e,
                height: t1,
                x: o,
                y: r,
                userId: i,
                canvas: n,
                RGBA: s,
                zone: a,
                left: d,
                bottom: u,
                top: l
            });
        }
        stopRender({ width: e, height: t1, x: o, y: r, userId: i, canvas: n, doNotClean: s, RGBA: a, zone: d, left: u, bottom: l, top: c, videoQuality: p }) {
            var h;
            this.getSDK() && vC(this.container, !1), null === (h = this.getSDK()) || void 0 === h || h.Notify_MeidaSDK(JA.STOP_RENDER_VIDEO, {
                width: e,
                height: t1,
                x: o,
                y: r,
                userId: i,
                canvas: n,
                doNotClean: s,
                RGBA: a,
                zone: d,
                left: u,
                bottom: l,
                top: c,
                videoQuality: p
            });
        }
    }
    class IC extends bC {
        addRender({ userId: e, videodom: t1 }) {
            var o;
            null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(JA.ADD_RENDER_VIDEO, {
                userId: e,
                videodom: t1
            });
        }
        stopRender({ userId: e, videodom: t1 }) {
            var o;
            null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(JA.STOP_RENDER_VIDEO, {
                userId: e,
                videodom: t1
            });
        }
    }
    class AC extends SC {
        addRender({ width: e, height: t1, userId: o, canvas: r, isFromMainSession: i }) {
            var n;
            null === (n = this.getSDK()) || void 0 === n || n.Notify_MeidaSDK(JA.START_SHARING, {
                width: e,
                height: t1,
                canvas: r,
                ssrc: o,
                isFromMainSession: i
            });
        }
        zoomRender() {}
        stopRender({ canvas: e }) {
            var t1;
            null === (t1 = this.getSDK()) || void 0 === t1 || t1.Notify_MeidaSDK(JA.STOP_SHARING, {
                canvas: e
            });
        }
    }
    class CC extends bC {
        addRender({ userId: e, videodom: t1 }) {
            var o, r;
            null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(JA.SWITCH_CANVAS_FOR_VIDEO_CAPTURE, [
                t1
            ]), null === (r = this.getSDK()) || void 0 === r || r.Notify_MeidaSDK(JA.ADD_RENDER_VIDEO, {
                userId: e,
                videodom: t1
            });
        }
        stopRender({ userId: e, videodom: t1 }) {
            var o;
            null === (o = this.getSDK()) || void 0 === o || o.Notify_MeidaSDK(JA.STOP_RENDER_VIDEO, {
                userId: e,
                videodom: t1
            });
        }
    }
    class _C {
        static VERTEX_SHADER = "\n    attribute vec2 position;\n    varying vec2 texCoord;\n\n    void main() {\n      texCoord = (position + 1.0) * 0.5;\n      // gl_Position = vec4(position, 0.0, 1.0);\n      gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n    }\n  ";
        static FRAGMENT_SHADER = "\n    precision mediump float;\n    varying vec2 texCoord;\n    uniform sampler2D videoTexture;\n\n    void main() {\n      gl_FragColor = texture2D(videoTexture, texCoord);\n    }\n  ";
        constructor(){}
        preview(e, t1, o) {
            const r = t1.getContext("webgl"), i = this.#e(r, _C.VERTEX_SHADER, _C.FRAGMENT_SHADER), n = r.getAttribLocation(i, "position"), s = r.getUniformLocation(i, "videoTexture");
            r.useProgram(i);
            const a = this.#t(r);
            r.bindBuffer(r.ARRAY_BUFFER, a), r.enableVertexAttribArray(n), r.vertexAttribPointer(n, 2, r.FLOAT, !1, 0, 0), this.frame({
                glContext: r,
                program: i,
                positionAttributeLocation: n,
                textureLocation: s,
                positionBuffer: a,
                viewport: o,
                source: e
            });
        }
        frame(e) {
            const t1 = e.glContext;
            e.glContext.clearColor(0, 0, 0, 1), e.glContext.clear(e.glContext.COLOR_BUFFER_BIT), e.glContext.viewport(e.viewport.x, e.viewport.y, e.viewport.w, e.viewport.h), e.glContext.enable(e.glContext.DEPTH_TEST);
            const o = e.glContext.createTexture();
            t1.activeTexture(t1.TEXTURE0), t1.bindTexture(t1.TEXTURE_2D, o), t1.uniform1i(e.textureLocation, 0), t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, e.source), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_S, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_T, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MIN_FILTER, t1.LINEAR), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MAG_FILTER, t1.LINEAR), e.glContext.drawArrays(e.glContext.TRIANGLE_STRIP, 0, 4), requestAnimationFrame(()=>this.frame(e));
        }
        #e(e, t1, o) {
            const r = this.#o(e, e.VERTEX_SHADER, t1), i = this.#o(e, e.FRAGMENT_SHADER, o);
            let n = e.createProgram();
            return e.attachShader(n, r), e.attachShader(n, i), e.linkProgram(n), n;
        }
        #o(e, t1, o) {
            const r = e.createShader(t1);
            return e.shaderSource(r, o), e.compileShader(r), r;
        }
        #t(e) {
            const t1 = e.createBuffer();
            return e.bindBuffer(e.ARRAY_BUFFER, t1), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
                -1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1
            ]), e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, null), t1;
        }
    }
    class RC {
        static VERTEX_SHADER = "#version 300 es\n    in vec2 position;\n    out vec2 texCoord;\n\n    void main() {\n      texCoord = (position + 1.0) * 0.5;\n      gl_Position = vec4(position.x, -position.y, 0.0, 1.0);\n    }\n  ";
        static FRAGMENT_SHADER = "#version 300 es\n    precision mediump float;\n    in vec2 texCoord;\n    uniform sampler2D videoTexture;\n    out vec4 fragColor;\n\n    void main() {\n      fragColor = texture(videoTexture, texCoord);\n    }\n  ";
        constructor(){}
        preview(e, t1, o) {
            const r = t1.getContext("webgl2"), i = this.#e(r, RC.VERTEX_SHADER, RC.FRAGMENT_SHADER), n = r.getAttribLocation(i, "position"), s = r.getUniformLocation(i, "videoTexture");
            r.useProgram(i);
            const a = this.#t(r);
            r.bindBuffer(r.ARRAY_BUFFER, a), r.enableVertexAttribArray(n), r.vertexAttribPointer(n, 2, r.FLOAT, !1, 0, 0), this.frame({
                glContext: r,
                program: i,
                positionAttributeLocation: n,
                textureLocation: s,
                positionBuffer: a,
                viewport: o,
                source: e
            });
        }
        frame(e) {
            const t1 = e.glContext;
            e.glContext.clearColor(0, 0, 0, 1), e.glContext.clear(e.glContext.COLOR_BUFFER_BIT), e.glContext.viewport(e.viewport.x, e.viewport.y, e.viewport.w, e.viewport.h), e.glContext.enable(e.glContext.DEPTH_TEST);
            const o = e.glContext.createTexture();
            t1.activeTexture(t1.TEXTURE0), t1.bindTexture(t1.TEXTURE_2D, o), t1.uniform1i(e.textureLocation, 0), t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, e.source), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_S, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_WRAP_T, t1.CLAMP_TO_EDGE), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MIN_FILTER, t1.LINEAR), t1.texParameteri(t1.TEXTURE_2D, t1.TEXTURE_MAG_FILTER, t1.LINEAR), e.glContext.drawArrays(e.glContext.TRIANGLE_STRIP, 0, 4), requestAnimationFrame(()=>this.frame(e));
        }
        #e(e, t1, o) {
            const r = this.#o(e, e.VERTEX_SHADER, t1), i = this.#o(e, e.FRAGMENT_SHADER, o);
            let n = e.createProgram();
            return e.attachShader(n, r), e.attachShader(n, i), e.linkProgram(n), n;
        }
        #o(e, t1, o) {
            const r = e.createShader(t1);
            return e.shaderSource(r, o), e.compileShader(r), r;
        }
        #t(e) {
            const t1 = e.createBuffer();
            return e.bindBuffer(e.ARRAY_BUFFER, t1), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
                -1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1
            ]), e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, null), t1;
        }
    }
    class wC {
        static VERTEX_SHADER = "\n    struct VertexOutput {\n      @builtin(position) Position: vec4<f32>,\n      @location(0) uv: vec2<f32>,\n    }\n\n    @vertex\n    fn vert_main(@builtin(vertex_index) VertexIndex: u32) -> VertexOutput {\n      var pos = array<vec2<f32>, 6>(\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>( 1.0, -1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>( 1.0,  1.0),\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(-1.0,  1.0)\n      );\n\n      var uv = array<vec2<f32>, 6>(\n        vec2<f32>(1.0, 0.0),\n        vec2<f32>(1.0, 1.0),\n        vec2<f32>(0.0, 1.0),\n        vec2<f32>(1.0, 0.0),\n        vec2<f32>(0.0, 1.0),\n        vec2<f32>(0.0, 0.0)\n      );\n\n      var output : VertexOutput;\n      output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n      output.uv = uv[VertexIndex];\n      return output;\n    }\n  ";
        static FRAG_SHADER_VF = "\n    @group(0) @binding(0) var mySampler: sampler;\n    @group(0) @binding(1) var vfTexture: texture_external;\n\n    @fragment\n    fn frag_main(@location(0) uv : vec2<f32>) -> @location(0) vec4<f32> {\n      var color0: vec4<f32> = textureSampleBaseClampToEdge(vfTexture, mySampler, uv);\n      return color0;\n    }\n  ";
        constructor(){}
        async preview(e, t1, o) {
            if (!e || !t1 || !o) throw new Error("Invalid arguments: source, target, or viewport is missing");
            const r = await navigator.gpu.requestAdapter(), i = await r.requestDevice(), n = navigator.gpu.getPreferredCanvasFormat(), s = t1.getContext("webgpu");
            s.configure({
                device: i,
                format: n,
                alphaMode: "opaque"
            });
            const a = i.createSampler({}), d = i.createRenderPipeline({
                layout: "auto",
                vertex: {
                    module: i.createShaderModule({
                        code: wC.VERTEX_SHADER
                    }),
                    entryPoint: "vert_main"
                },
                fragment: {
                    module: i.createShaderModule({
                        code: wC.FRAG_SHADER_VF
                    }),
                    entryPoint: "frag_main",
                    targets: [
                        {
                            format: n
                        }
                    ]
                },
                primitive: {
                    topology: "triangle-list"
                }
            }), u = {
                device: i,
                context: s,
                pipeline: d,
                sampler: a,
                source: e,
                viewport: o
            };
            this.frame(u);
        }
        frame(e) {
            const t1 = e.device.createCommandEncoder(), o = {
                colorAttachments: [
                    {
                        view: e.context.getCurrentTexture().createView(),
                        loadOp: "clear",
                        storeOp: "store"
                    }
                ]
            }, r = t1.beginRenderPass(o);
            r.setPipeline(e.pipeline);
            const i = e.device.createBindGroup({
                layout: e.pipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: e.sampler
                    },
                    {
                        binding: 1,
                        resource: e.device.importExternalTexture({
                            source: e.source
                        })
                    }
                ]
            });
            r.setBindGroup(0, i), r.setViewport(e.viewport.x, e.viewport.y, e.viewport.w, e.viewport.h, 0, 1), r.draw(6), r.end(), e.device.queue.submit([
                t1.finish()
            ]), requestAnimationFrame(()=>this.frame(e));
        }
    }
    class TC {
        constructor(){}
        preview(e, t1, o, r) {
            let i = null;
            1 == e ? o.srcObject = t1 : 2 == e ? (i = new _C, i.preview(t1, o, r)) : 3 == e ? (i = new RC, i.preview(t1, o, r)) : 4 == e && (i = new wC, i.preview(t1, o, r));
        }
        static getInstance() {
            return TC.instance || (TC.instance = new TC), TC.instance;
        }
    }
    class OC extends SC {
        constructor(){
            super(...arguments), this.rendersProxy = TC.getInstance(), this.videoSource = null;
        }
        createSource(e, t1, o) {
            return function(e, t1, o, r) {
                return new (o || (o = Promise))(function(t1, i) {
                    function n(e) {
                        try {
                            a(r.next(e));
                        } catch (e) {
                            i(e);
                        }
                    }
                    function s(e) {
                        try {
                            a(r.throw(e));
                        } catch (e) {
                            i(e);
                        }
                    }
                    function a(e) {
                        var r;
                        e.done ? t1(e.value) : (r = e.value, r instanceof o ? r : new o(function(e) {
                            e(r);
                        })).then(n, s);
                    }
                    a((r = r.apply(e, [])).next());
                });
            }(this, 0, void 0, function*() {
                const r = document.createElement("video");
                return r.width = t1, r.height = o, r.loop = !0, r.autoplay = !0, r.muted = !0, r.srcObject = e, yield r.play(), r;
            });
        }
        addRender(e) {
            e.renderType && e.srcObject && !this.videoSource && (this.videoSource && (this.videoSource = null), this.createSource(e.srcObject, e.width, e.height).then((t1)=>{
                this.videoSource = t1, this.rendersProxy.preview(e.renderType, this.videoSource, e.canvas, {
                    x: e.x,
                    y: e.renderType === tC.WebGPU ? e.top : e.y,
                    w: e.width,
                    h: e.height
                });
            }));
        }
        zoomRender(e) {
            e.renderType && this.videoSource && (this.videoSource.width !== e.width && (this.videoSource.width = e.width), this.videoSource.height !== e.height && (this.videoSource.height = e.height));
        }
        stopRender(e) {
            e.renderType && this.videoSource && (this.videoSource.srcObject = null, this.videoSource = null);
        }
    }
    class DC extends bC {
        constructor(){
            super(...arguments), this.rendersProxy = TC.getInstance();
        }
        addRender(e) {
            e.srcObject && e.videodom && this.rendersProxy.preview(tC.VideoTag, e.srcObject, e.videodom);
        }
        stopRender(e) {
            e.videodom.srcObject = null;
        }
    }
    const PC = "node-id", MC = "media-type", kC = "video-quality", LC = "share-source", NC = "fill-mode", VC = "stop-no-clean", UC = "refresh-key";
    class jC extends HTMLElement {
        static get observedAttributes() {
            return [
                PC,
                MC,
                kC,
                UC
            ];
        }
        constructor(){
            super(), this.container = null, this._srcObject = null, iC(this, jC.customAttributes), this.getRenderParams = this.getParsedParams.bind(this), this.callback = (e, t1)=>{
                e === QA.MOBILE_CAPTURE_DEVICE_CHANGE && t1 === this.getAttribute(PC) && this.initRender();
            };
        }
        initRender() {
            var e, t1, o, r, i;
            if (this.render && this.render.destroy(), null === (e = this.getContainer()) || void 0 === e ? void 0 : e.useInsideRender()) {
                const e = null === (t1 = this.getContainer()) || void 0 === t1 ? void 0 : t1.getInsideRenderType();
                if (e === tC.VideoTag) this.render = new DC(this.getContainer());
                else {
                    if (![
                        tC.WebGL,
                        tC.WebGL2,
                        tC.WebGPU
                    ].includes(e)) return void console.error("Inside render type error.");
                    this.render = new OC(this.getContainer(), this.getRenderParams);
                }
                return this.shadowRoot && (this.shadowRoot.innerHTML = "", this.shadowRoot.appendChild(this.render.getElement())), this.render.init(), void (this.srcObject && this.render.playVideo(this.srcObject));
            }
            const n = this.getAttribute(PC), s = n && (null === (o = this.getCurrentMediaSDK()) || void 0 === o ? void 0 : o.isPreviewVideotag(n));
            let a = 0;
            this.getAttribute(MC) === YA.Share ? (this.render = new AC(this.getContainer(), this.getRenderParams), a = 2) : (null === (r = this.getCurrentMediaSDK()) || void 0 === r ? void 0 : r.getWebRTCFlag()) ? (this.render = new IC(this.getContainer()), a = 4) : s ? (this.render = new CC(this.getContainer()), a = 1) : (this.render = new EC(this.getContainer(), this.getRenderParams), a = 3), this.getCurrentMediaSDK() && gC(this.getCurrentMediaSDK(), `VPREN:${a}`), this.innerHTML = "", this.appendChild(this.render.getElement()), this.render.init();
            const d = this.getAttribute(PC);
            cC(d) || null === (i = this.render) || void 0 === i || i.playVideo(d);
        }
        get srcObject() {
            return this._srcObject;
        }
        set srcObject(e) {
            var t1, o, r, i;
            !this._srcObject && e ? null === (t1 = this.render) || void 0 === t1 || t1.playVideo(e) : this._srcObject && e ? (null === (o = this.render) || void 0 === o || o.stopVideo(), null === (r = this.render) || void 0 === r || r.playVideo(e)) : this._srcObject && (null === (i = this.render) || void 0 === i || i.stopVideo()), this._srcObject = e;
        }
        getContainer() {
            return this.container || (this.container = this.closest(`${qA.get("tagName")}-container`)), this.container;
        }
        getCurrentMediaSDK() {
            var e, t1;
            return aC(null === (t1 = null === (e = this.getContainer()) || void 0 === e ? void 0 : e.getSessionId) || void 0 === t1 ? void 0 : t1.call(e));
        }
        getParsedParams() {
            var e, t1;
            return {
                fillMode: sC(this, NC),
                doNotClean: sC(this, VC),
                isFromMainSession: "main" === this.getAttribute(LC),
                videoQuality: this.getAttribute(kC),
                renderType: null !== (t1 = null === (e = this.getContainer()) || void 0 === e ? void 0 : e.getInsideRenderType()) && void 0 !== t1 ? t1 : tC.Unknown
            };
        }
        connectedCallback() {
            var e;
            this.style.display = "block", nC(this, jC.defaultValues), this.initRender(), null === (e = this.getCurrentMediaSDK()) || void 0 === e || e.addCallback(this.callback), this.removeSubscribe = qA.subscribe((e, t1, o)=>{
                var r, i, n, s;
                "failover" === e && o === ((null === (i = null === (r = this.getContainer()) || void 0 === r ? void 0 : r.getSessionId) || void 0 === i ? void 0 : i.call(r)) || ZA) && (this.initRender(), cC(this.getAttribute(PC)) || null === (n = this.render) || void 0 === n || n.playVideo(this.getAttribute(PC)), this.srcObject && (null === (s = this.render) || void 0 === s || s.playVideo(this.srcObject)));
            });
        }
        disconnectedCallback() {
            var e, t1, o;
            null === (e = this.removeSubscribe) || void 0 === e || e.call(this), null === (t1 = this.render) || void 0 === t1 || t1.destroy(), this.callback && (null === (o = this.getCurrentMediaSDK()) || void 0 === o || o.removeCallback(this.callback));
        }
        attributeChangedCallback(e, t1, o) {
            var r, i, n, s, a;
            if (this.render) switch(e){
                case PC:
                    (null === (r = this.getCurrentMediaSDK()) || void 0 === r ? void 0 : r.getWebRTCFlag()) || Boolean(null === (i = this.getCurrentMediaSDK()) || void 0 === i ? void 0 : i.isPreviewVideotag(o)) !== this.render instanceof CC && this.initRender(), cC(t1) && !cC(o) ? this.render.playVideo(o) : cC(t1) || cC(o) ? cC(t1) || this.render.stopVideo() : (this.render.stopVideo(), this.render.playVideo(o));
                    break;
                case MC:
                    this.initRender();
                    break;
                case kC:
                    null === (n = this.render) || void 0 === n || n.updateVideoQuality(o);
                    break;
                case UC:
                    cC(o) || null === (a = null === (s = this.render) || void 0 === s ? void 0 : s.refresh) || void 0 === a || a.call(s);
            }
        }
    }
    jC.customAttributes = [
        PC,
        MC,
        kC,
        LC,
        NC,
        VC,
        UC
    ], jC.defaultValues = {
        [PC]: "",
        [MC]: YA.Video
    };
    const xC = "session-id", BC = "z-index", FC = "inside-render", HC = "label";
    class $C extends HTMLElement {
        static get observedAttributes() {
            return [
                xC,
                BC,
                FC
            ];
        }
        constructor(){
            super(), this.canvasId = "video-player-canvas-" + (this.getAttribute(HC) ? `${this.getAttribute(HC)}-` : "") + dC(), this.needInitCanvas = !1, this.callback = null, iC(this, $C.customAttributes);
            const e = this.attachShadow({
                mode: "open"
            }), t1 = document.createElement("slot");
            this.appendCanvas = (o)=>{
                e.insertBefore(o, t1);
            }, e.appendChild(t1);
        }
        connectedCallback() {
            this.style.display = "block", this.style.position || (this.style.position = "relative"), nC(this, $C.defaultValues), this.needInitCanvas && this.initCanvasEvents(), this.removeSubscribe = qA.subscribe((e, t1, o)=>{
                "failover" === e && o === (this.getSessionId() || ZA) && (this.replaceCanvas(), this.initCanvasEvents());
            });
        }
        disconnectedCallback() {
            var e, t1, o, r;
            null === (e = this.removeListener) || void 0 === e || e.call(this), null === (t1 = this.removeSubscribe) || void 0 === t1 || t1.call(this), this.canvas && (null === (o = aC(this.getSessionId())) || void 0 === o || o.Notify_MeidaSDK(JA.REMOVE_EXPIRED_CANVAS, {
                canvasId: this.canvasId
            }), this.canvas.remove(), this.canvas = void 0), this.callback && (null === (r = aC(this.getSessionId())) || void 0 === r || r.removeCallback(this.callback));
        }
        attributeChangedCallback(e, t1, o) {
            e === BC && this.canvas && o && (this.canvas.style.zIndex = o);
        }
        adoptedCallback() {}
        createCanvas() {
            this.getCurrentMediaSDK() && gC(this.getCurrentMediaSDK(), "VPCC"), this.canvas = oC(this.clientWidth, this.clientHeight, this.getAttribute(BC) || "", this.canvasId, (e)=>gC(this.getCurrentMediaSDK(), e)), this.appendCanvas(this.canvas), this.isConnected ? this.initCanvasEvents() : this.needInitCanvas = !0;
        }
        initCanvasEvents() {
            var e;
            this.removeListener = rC(this.canvas, this), this.callback = (e, t1)=>{
                var o, r;
                e === QA.WEBGL_LOST_IN_MULTI_VIEW && t1.replaceCanvas && t1.canvasId === (null === (o = this.canvas) || void 0 === o ? void 0 : o.id) && (this.replaceCanvas(), null === (r = aC(this.getSessionId())) || void 0 === r || r.Notify_MeidaSDK(JA.WEBGL_LOST_REPLACE_CANVAS, {
                    canvasId: this.canvasId,
                    canvas: this.canvas
                }));
            }, null === (e = this.getCurrentMediaSDK()) || void 0 === e || e.addCallback(this.callback);
        }
        replaceCanvas() {
            var e;
            if (this.getCurrentMediaSDK() && gC(this.getCurrentMediaSDK(), "VPRC"), this.canvas) {
                null === (e = this.removeListener) || void 0 === e || e.call(this);
                const t1 = oC(this.clientWidth, this.clientHeight, this.getAttribute(BC) || "", this.canvasId, (e)=>gC(this.getCurrentMediaSDK(), e));
                this.removeListener = rC(t1, this), this.shadowRoot && this.shadowRoot.replaceChild(t1, this.canvas), this.canvas = t1;
            }
        }
        getCanvas() {
            return this.canvas || this.createCanvas(), this.canvas;
        }
        useInsideRender() {
            return null !== this.getAttribute(FC) && void 0 !== this.getAttribute(FC) && "false" !== this.getAttribute(FC) && "0" !== this.getAttribute(FC);
        }
        getInsideRenderType() {
            return Number(this.getAttribute("inside-render-type"));
        }
        getSessionId() {
            return this.getAttribute(xC) || void 0;
        }
        getCurrentMediaSDK() {
            return aC(this.getSessionId());
        }
        getRGBA() {
            return function(e) {
                let t1 = 0, o = 0, r = 0, i = 0;
                if ("r" === e[0]) if ("a" === e[3]) {
                    const n = e.slice(5, -1).split(",").map((e)=>parseInt(e.trim(), 10));
                    t1 = n[0], o = n[1], r = n[2], i = n[3];
                } else {
                    const i = e.slice(4, -1).split(",").map((e)=>parseInt(e.trim(), 10));
                    t1 = i[0], o = i[1], r = i[2];
                }
                else if ("#" === e[0]) {
                    let i = e.slice(1);
                    3 === i.length && (i = i.split("").map((e)=>e.repeat(2)).join(""));
                    const n = parseInt(i, 16);
                    t1 = n >> 16 & 255, o = n >> 8 & 255, r = 255 & n;
                }
                return {
                    R: t1 / 255,
                    G: o / 255,
                    B: r / 255,
                    A: i
                };
            }(getComputedStyle(this).getPropertyValue("background-color"));
        }
    }
    function WC(e) {
        const { audio: { isBackgroundNoiseSuppression: t1, originalSound: o, highBitrate: r } } = e, i = {
            currentSelect: Yd.Denoise
        }, n = {
            highfidelity: !1,
            stereo: !1
        };
        if (o) {
            Object.assign(i, {
                currentSelect: Yd.OriginalSound
            });
            const e = {};
            "boolean" == typeof o ? Object.assign(e, n) : Object.assign(e, {
                highfidelity: !!o.hifi,
                stereo: !!o.stereo
            }), Object.assign(i, {
                originalSound: e
            });
        }
        return Object.assign(i, {
            backgroundNoiseSuppression: t1 ? Zd.Zoom : Zd.Browser,
            highBitrate: r
        }), i;
    }
    function GC(e, t1, o, r) {
        const { meeting: { userId: i }, audio: { localShareAudioUserMutedList: n }, share: { isReceiveSharingFromMainSession: s } } = r;
        return n.filter((e)=>e.userId !== t1).forEach((t1)=>{
            e.setSharingAudioVolume(t1.userId, !0, t1.isFromMainSession);
        }), e.setSharingAudioVolume(t1, o, !!s), t1 === i ? Gh(o) : Hh({
            userId: t1,
            muted: o
        });
    }
    async function KC(e, t1, o) {
        var r, i;
        const { audio: { audioSsrc: n, activeMicrophone: s, activeSpeaker: a, isAllowToTalk: d, customizeAudioOption: { speakerOnly: u, mute: l, microphoneId: c, speakerId: p }, isUsingMediaPlayback: h, mediaPlaybackFile: m, isHIDEnabled: g, microphoneDevicesList: v, isVerifiedAudioPermissionOnIOSMobile: f, speakerDevicesList: y }, meeting: { svcUrl: S, conId: b, reportDomain: E, isAudioBridgeEnabled: I, userId: A, supportLocalAB: C, abToken: _ } } = t1, R = ah(t1), w = !!u || Kp(R.userRole) && !d, T = null != o ? o : !w;
        vs() && (I || console.warn("Cannot start audio due to the service is not ready."), await Oe(Vy(t1, !T)).then((e)=>{
            let [t1, o] = e;
            return t1 && o ? Promise.resolve() : Promise.reject();
        }));
        let O = s, D = a;
        if (void 0 !== c || void 0 !== p) {
            let e = v, t1 = y;
            if (0 === v.length) {
                const { microphones: o, speakers: r } = await Oe(_y());
                e = o, t1 = r;
            }
            c && e.findIndex((e)=>e.deviceId === c) > -1 && (O = c), p && t1.findIndex((e)=>e.deviceId === p) > -1 && (D = p);
        }
        if (h && null != m && m.url) {
            const t1 = Wy.getInstance();
            await t1.setAudioElement(m), O = t1.audioElement, void 0 !== m.playback && (e.enablePlayAudioFileLocally(!!m.playback), O.dataset.playback = m.playback ? "1" : "0");
        } else Wy.getInstance().stopAudioElement();
        return w && !f && gs.isIOSMobile && await async function() {
            await navigator.mediaDevices.getUserMedia({
                audio: !0
            });
        }(), null === (r = e.joinComputerAudio(n, O, D, T, WC(t1), vs() ? {
            rwgHost: S,
            cid: b,
            nginxHost: E,
            abToken: _,
            supportLocalAB: C,
            useWebRTCOnDesktop: !gs.isAndroidOrIOSBrowser
        } : void 0, g ? {
            microphoneLabel: null === (i = v.find((e)=>e.deviceId === s)) || void 0 === i ? void 0 : i.label,
            defaultMuted: !(null == R || !R.muted)
        } : void 0)) || void 0 === r ? void 0 : r.then(()=>{
            l && (ia.createAgent().mute(A, !0), e.muteAudio()), null != R && R.muted ? e.muteAudio() : e.unmuteAudio();
        });
    }
    async function zC(e, t1, o) {
        const r = [], { audio: { isJoinComputerAudioBeforeSharingAudio: i, mutedBeforeSharingAudio: n } } = o, s = ah(o);
        return !0 === i && (await KC(e, o), r.push($h(void 0)), !1 === n && (r.push(am(ld.SharingAudio)), t1.mute(s.userId, !1)), r.push(Bh(void 0))), r;
    }
    async function qC(e, t1, o) {
        const { audio: { isSharingAudio: r }, meeting: { userId: i } } = o, n = [];
        if (n.push(GC(e, i, !0, o)), r) {
            await e.leaveSharingAudio(!1), n.push(Kh(!1));
            const r = await zC(e, t1, o);
            n.push(...r), setTimeout(()=>{
                tp(il, {
                    state: "off"
                });
            }, 0);
        }
        return n.push(Wh(!1)), n;
    }
    async function JC(e, t1, o) {
        const { audio: { audioSsrc: r, activeMicrophone: i, activeSpeaker: n }, meeting: { svcUrl: s, conId: a, reportDomain: d, supportLocalAB: u, abToken: l } } = o, c = ah(o), p = [];
        if (!YC()) {
            const t1 = await async function(e, t1) {
                const o = [], r = ah(t1), { audio: { isMicrophoneForbidden: i } } = t1;
                return (null == r ? void 0 : r.audio) === Wd.Computer && (o.push($h(!0)), o.push(Bh(r.muted)), r.muted || e.muteAudio(), await e.leaveComputerAudio(), o.push(Ph(0)), i && o.push(Dh(!1))), o;
            }(e, o);
            p.push(...t1);
        }
        return await e.leaveSharingAudio(!0), await e.joinSharingAudio({
            ssrc: r,
            microphoneDeviceId: i,
            speakerDeviceId: n,
            isCaptureAudio: Kp(c.userRole),
            audioBridge: vs() ? {
                rwgHost: s,
                cid: a,
                nginxHost: d,
                abToken: l,
                supportLocalAB: u,
                useWebRTCOnDesktop: !gs.isAndroidOrIOSBrowser
            } : void 0
        }), p.push(Wh(!0)), p.push(Kh(!0)), p.push(GC(e, c.userId, !1, o)), p.findIndex((e)=>e.type === `${$h}` && !0 === e.payload) > -1 && (p.push(sm(ud.SharingAudio)), t1.mute(o.meeting.userId, !0)), setTimeout(()=>{
            tp(il, {
                state: "on"
            });
        }, 0), p;
    }
    $C.customAttributes = [], $C.defaultValues = {};
    const QC = ()=>{
        if (bs()) return !0;
        {
            var e;
            let { browser: o } = gs;
            if (o = null === (e = o) || void 0 === e ? void 0 : e.toLocaleLowerCase(), o.indexOf("safari") > -1 && -1 === o.indexOf("ios-safari")) {
                var t1;
                const e = null === (t1 = navigator.userAgent.match(/version\/(\d+\.?\d+)/i)) || void 0 === t1 ? void 0 : t1[1];
                return Jr(e || "", "15.2") >= 0 && Jr(e || "", "17.1") < 0;
            }
            return !1;
        }
    };
    function ZC(e, t1, o) {
        for(let r = 0; r < o.length && 0 !== t1.length; r++){
            const { userId: i, displayName: n } = o[r];
            if (t1.includes(i)) {
                const o = e.find((e)=>e.userId === i);
                o && (o.displayName = n, t1.splice(t1.indexOf(i), 1));
            }
        }
    }
    function YC() {
        return ca.isSupportOpenMicWhenShareAudio();
    }
    function XC(e) {
        return ca.isSupportAudioDenoise(e);
    }
    function e_() {
        return ca.isSupportStereoAudio();
    }
    function t_() {
        var e;
        return "function" == typeof (null === (e = window.navigator.hid) || void 0 === e ? void 0 : e.requestDevice);
    }
    function o_(e, t1, o) {
        const { audio: { isAllowToTalk: r, customizeAudioOption: i }, media: { audioDecodeStatus: n, audioEncodeStatus: s } } = e;
        return {
            encodeInitStatus: Kp(t1.userRole) && !r || o || null != i && i.speakerOnly || vs() ? "success" : s,
            decodeInitStatus: vs() ? "success" : n
        };
    }
    function r_(e, t1, o) {
        vs() ? Vy(t1, o).subscribe((t1)=>{
            let [o, r] = t1;
            o && r && e.joinOrLeaveVoip(!0);
        }) : e.joinOrLeaveVoip(!0);
    }
    const i_ = ia.createAgent(), n_ = Py(yE(ca.getInstance())), s_ = (e)=>!e.muted, a_ = ia.createAgent(), d_ = Py(yE(ca.getInstance())), u_ = ia.createAgent(), l_ = Py(yE(ca.getInstance())), c_ = [
        hd.Canceled,
        hd.CancelFailed
    ], p_ = {
        asnIds: {
            asn1: {
                userId: 0,
                displayName: null
            },
            asn2: {
                userId: 0,
                displayName: null
            },
            asn3: {
                userId: 0,
                displayName: null
            }
        },
        microphoneDevicesList: [],
        speakerDevicesList: [],
        activeMicrophone: "default",
        activeSpeaker: "default",
        isMicrophoneForbidden: !1,
        audioSsrc: 0,
        bCanUnmute: !1,
        bMutedUponEntry: !1,
        isAllowToTalk: void 0,
        dialout: [],
        crcDevice: [],
        canPlayAudio: !1,
        mutedSource: void 0,
        unmutedSource: void 0,
        isUserGrantCaptureAudio: !1,
        webrtcRestartCount: 0,
        isComputerAudioLoading: !1,
        isUsingMediaPlayback: !1,
        customizeAudioOption: {},
        localShareAudioUserMutedList: [],
        locallyMutedAudioList: [],
        localUserAudioVolumeList: [],
        isStopAllImcomingAudio: !1,
        statistic: {
            encode: {
                sample_rate: 0,
                rtt: 0,
                jitter: 0,
                avg_loss: 0,
                max_loss: 0,
                bandwidth: 0,
                bitrate: 0
            },
            decode: {
                sample_rate: 0,
                rtt: 0,
                jitter: 0,
                avg_loss: 0,
                max_loss: 0,
                bandwidth: 0,
                bitrate: 0
            }
        }
    }, h_ = bo({
        [`${Ih}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.asnIds = {
                ...o
            };
        }),
        [`${Ah}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.bCanUnmute = o;
        }),
        [`${Ch}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { sequence: r, phoneNumber: i } = o;
            -1 === e.dialout.findIndex((e)=>e.sequence === r) && e.dialout.push({
                sequence: r,
                phoneNumber: i,
                returnCode: -1,
                uuid: yS()
            });
        }),
        [`${_h}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { sequence: r, code: i, nodeId: n } = o, s = e.dialout.find((e)=>e.sequence === r);
            s && (s.returnCode = i, n && (s.phoneNodeId = n));
        }),
        [`${Rh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAllowToTalk = o, e.isAllowToTalkAttendeeConnected = !1;
        }),
        [`${sm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.mutedSource = o;
        }),
        [`${am}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.unmutedSource = o;
        }),
        [`${wh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.audioSsrc = o;
        }),
        [`${Th}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.bMutedUponEntry = o;
        }),
        [`${Oh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isUserGrantCaptureAudio = o;
        }),
        [`${Dh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isMicrophoneForbidden = o;
        }),
        [`${Ph}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.webrtcRestartCount = o;
        }),
        [`${Mh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.microphoneDevicesList = o;
        }),
        [`${kh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.speakerDevicesList = o;
        }),
        [`${Lh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.activeMicrophone = o;
        }),
        [`${Nh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.activeSpeaker = o;
        }),
        [`${Vh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.canPlayAudio = o;
        }),
        [`${jh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isComputerAudioLoading = o;
        }),
        [`${Xh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            if (o) {
                const { speakerOnly: t1, mute: r, backgroundNoiseSuppression: i, originalSound: n, syncButtonsOnHeadset: s, mediaFile: a, microphoneId: d, speakerId: u, highBitrate: l } = o;
                e.customizeAudioOption.speakerOnly = t1, e.customizeAudioOption.mute = r, e.customizeAudioOption.microphoneId = d, e.customizeAudioOption.speakerId = u, e.isBackgroundNoiseSuppression = !!i, e.isHIDEnabled = !!s, e.originalSound = n, e.highBitrate = !!l, Zr(e.mediaPlaybackFile, a) || (e.mediaPlaybackFile = a, e.isUsingMediaPlayback = !(null == a || !a.url)), r && (e.mutedSource = ud.Inherited);
            }
        }),
        [`${xh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAllowToTalkAttendeeConnected = o;
        }),
        [`${Bh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.mutedBeforeSharingAudio = o;
        }),
        [`${Kh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isSharingAudio = o;
        }),
        [`${Gh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isShareAudioMuted = o;
        }),
        [`${Fh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { userId: r, isFromMainSession: i } = o;
            -1 === e.localShareAudioUserMutedList.findIndex((e)=>e.userId === r) && e.localShareAudioUserMutedList.push({
                userId: r,
                isFromMainSession: i,
                muted: !1
            });
        }),
        [`${Hh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.localShareAudioUserMutedList.find((e)=>e.userId === o.userId);
            r && (r.muted = o.muted);
        }),
        [`${$h}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isJoinComputerAudioBeforeSharingAudio = o;
        }),
        [`${Wh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isShareAudioEnabled = o;
        }),
        [`${zh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { data: { encoding: r, rate: i, ...n } } = o;
            e.statistic.encode = {
                bitrate: i,
                ...n
            };
        }),
        [`${qh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { data: { encoding: r, rate: i, ...n } } = o;
            e.statistic.decode = {
                bitrate: i,
                ...n
            };
        }),
        [`${Jh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            -1 === e.locallyMutedAudioList.findIndex((e)=>e === o) && e.locallyMutedAudioList.push(o);
        }),
        [`${Qh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.locallyMutedAudioList.findIndex((e)=>e === o);
            -1 !== r && e.locallyMutedAudioList.splice(r, 1);
        }),
        [`${Zh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.localUserAudioVolumeList.find((e)=>e.userId === o.userId);
            r ? r.volume = o.volume : e.localUserAudioVolumeList.push(o);
        }),
        [`${Yh}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.localUserAudioVolumeList.findIndex((e)=>e.userId === o.userId);
            -1 !== r && e.localUserAudioVolumeList.splice(r, 1);
        }),
        [`${em}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isBackgroundNoiseSuppression = o;
        }),
        [`${tm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isHIDEnabled = o;
        }),
        [`${om}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.mediaPlaybackFile = o, e.isUsingMediaPlayback = !(null == o || !o.url);
        }),
        [`${rm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isStopAllImcomingAudio = o;
        }),
        [`${im}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isVerifiedAudioPermissionOnIOSMobile = o;
        }),
        [`${nm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAudioBridgeSignalReconnecting = o;
        }),
        [`${dm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.originalSound = o;
        }),
        [`${um}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.leaveAudioSource = o;
        }),
        [`${lm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.secondaryAudioMicrophoneId = o;
        }),
        [`${cm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { sequence: r, ip: i, protocol: n } = o;
            -1 === e.crcDevice.findIndex((e)=>e.sequence === r) && e.crcDevice.push({
                sequence: r,
                ip: i,
                protocol: n,
                transId: 0,
                uuid: yS()
            });
        }),
        [`${pm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { sequence: r, transID: i, result: n } = o, s = e.crcDevice.find((e)=>e.sequence === r);
            s && Object.assign(s, {
                transId: i,
                returnCode: n
            });
        }),
        [`${Uh}`]: (e, t1)=>{
            let { dialout: o, crcDevice: r, locallyMutedAudioList: i, localUserAudioVolumeList: n, customizeAudioOption: s, originalSound: a, highBitrate: d, isHIDEnabled: u, isBackgroundNoiseSuppression: l, isStopAllImcomingAudio: c, mediaPlaybackFile: p, isUsingMediaPlayback: h, isVerifiedAudioPermissionOnIOSMobile: m, activeSpeaker: g, activeMicrophone: v } = e, { payload: f } = t1;
            return f ? {
                ...p_,
                dialout: o,
                crcDevice: r,
                locallyMutedAudioList: i,
                localUserAudioVolumeList: n,
                customizeAudioOption: {
                    ...p_.customizeAudioOption,
                    speakerOnly: s.speakerOnly
                },
                originalSound: a,
                highBitrate: d,
                isHIDEnabled: u,
                isBackgroundNoiseSuppression: l,
                isStopAllImcomingAudio: c,
                mediaPlaybackFile: p,
                isUsingMediaPlayback: h,
                isVerifiedAudioPermissionOnIOSMobile: m,
                activeSpeaker: g,
                activeMicrophone: v
            } : {
                ...p_
            };
        }
    }, p_), m_ = {
        dialEpics0: (e, t1)=>nr(e, 8198).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                const { audio: { dialout: r } } = o, { payload: { seq: i, body: n } } = t1;
                return r.map((e)=>e.sequence).includes(i) || c_.includes(null == n ? void 0 : n.result);
            }), Fe((e)=>{
                let [t1, o] = e;
                const { payload: { seq: r, body: { phoneNodeID: i, result: n } } } = t1, s = [
                    _h({
                        code: n,
                        sequence: r,
                        nodeId: i
                    })
                ], { audio: { dialout: a } } = o;
                let d = a.find((e)=>e.sequence === r);
                !d && c_.includes(n) && (d = a.find((e)=>[
                        hd.Calling,
                        hd.Ringing,
                        hd.Accepted
                    ].includes(e.returnCode)));
                const u = {
                    code: n
                };
                if (d && (Object.assign(u, {
                    phoneNumber: d.phoneNumber,
                    uuid: d.uuid
                }), i && Object.assign(u, {
                    userId: i
                })), tp(zu, u), n === hd.Success) {
                    if (tp(qu), i && ph(o).findIndex((e)=>e.userId === i) > -1) {
                        var l;
                        const e = null === (l = o.audio.dialout.find((e)=>e.sequence === r)) || void 0 === l ? void 0 : l.phoneNumber;
                        e && (s.push(Pp({
                            userId: i,
                            key: "phoneNumber",
                            value: e
                        })), tp(ga, [
                            {
                                userId: i,
                                phoneNumber: e
                            }
                        ]));
                    }
                } else [
                    hd.Canceling,
                    hd.Canceled,
                    hd.CancelFailed
                ].includes(n) ? n === hd.Canceled ? tp(Qu) : n === hd.CancelFailed && tp(Zu) : -1 === [
                    hd.Calling,
                    hd.Ringing,
                    hd.Accepted,
                    hd.Success
                ].indexOf(n) && tp(Ju);
                return _e(s);
            })),
        dialEpics1: (e, t1)=>nr(e, 4120).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                return o.audio.crcDevice.map((e)=>e.sequence).includes(t1.payload.seq);
            }), Fe((e)=>{
                let [t1, o] = e;
                const { payload: { seq: r, body: { result: i, transID: n } } } = t1, { audio: { crcDevice: s } } = o, a = [], d = s.find((e)=>e.sequence === r);
                return d && (tp(ul, {
                    code: i,
                    ip: d.ip,
                    protocol: d.protocol,
                    uuid: d.uuid
                }), a.push(pm({
                    sequence: r,
                    transID: n,
                    result: i
                }))), i === tu.Success ? tp(ll) : [
                    tu.Success,
                    tu.Ringing
                ].includes(i) || tp(cl), _e(a);
            }))
    }, g_ = {
        epics0: (e, t1)=>nr(e, 12033).pipe(ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { participants: { allowTalkAttendeesList: r } } = o, i = t1.payload.body;
                let n = {};
                if (i) {
                    const e = ph(o), t1 = Object.keys(i).map((e)=>({
                            key: e,
                            userId: i[e]
                        })), s = t1.map((e)=>e.userId);
                    ZC(t1, s, e), r.length > 0 && s.length > 0 && ZC(t1, s, r), n = t1.reduce((e, t1)=>({
                            ...e,
                            [`${t1.key}`]: {
                                userId: t1.userId,
                                displayName: t1.displayName
                            }
                        }), {}), tp(xu, Object.values(n));
                }
                return Ih(n);
            })),
        epics1: (e, t1)=>nr(e, 16135).pipe(ft(t1), vt((e)=>{
                let [t1, o] = e;
                const { payload: { body: { id: r, bLeadershipOn: i } } } = t1, { audio: { bCanUnmute: n } } = o, s = ah(o);
                if (s) {
                    const { isHost: e, bCoHost: t1, userId: o, audio: a, muted: d } = s, u = e || t1;
                    i && Yr(o, r) && (null !== a && "" !== a && !0 !== d || !u && !n || tp(Bu, dd.Spotlight));
                }
            }), ut(ne)),
        epics2: (e, t1)=>nr(e, 12037).pipe(ft(t1), vt((e)=>{
                let [, t1] = e;
                const o = ah(t1);
                null !== (null == o ? void 0 : o.audio) && "" !== (null == o ? void 0 : o.audio) && 1 == (null == o ? void 0 : o.muted) && tp(Bu, dd.Unmute);
            }), ut(ne)),
        epics3: (e, t1)=>nr(e, Ms).pipe(ot((e)=>e.payload.body && [
                    "bCanUnmute",
                    "bMutedAll",
                    "bMutedUponEntry"
                ].some((t1)=>void 0 !== e.payload.body[t1])), Fe((e)=>{
                const { payload: { body: { bCanUnmute: o, bMutedAll: r, bMutedUponEntry: i } } } = e, n = [];
                if (void 0 !== o && n.push(Ah(e.payload.body.bCanUnmute)), void 0 !== r) {
                    const o = ah(t1.value);
                    (null == o ? void 0 : o.audio) !== Wd.Computer && (null == o ? void 0 : o.audio) !== Wd.Phone || 0 != o.muted || e.payload.body.bMutedAll && n.push(sm(ud.PassiveByMuteAll));
                }
                return void 0 !== i && n.push(Th(e.payload.body.bMutedUponEntry)), _e(n);
            })),
        epics4: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [, t1] = e;
                return t1.socket.zoomSocketStatus === Sh.Connected;
            }), Fe((e)=>{
                let [o, r] = e;
                const { payload: { body: { update: i } } } = o;
                if (null != i && i.some((e)=>void 0 !== e.audio || void 0 !== e.muted)) {
                    const { meeting: { userId: e } } = r, o = i.filter((t1)=>t1.id !== e), n = i.filter((t1)=>t1.id === e);
                    if (o && o.forEach((e)=>{
                        tp(Ku, e);
                    }), n.length > 0) return Ay(t1).pipe(Fe((e)=>{
                        const { audio: { mutedSource: o, unmutedSource: r, isAllowToTalk: i, isShareAudioEnabled: s, isSharingAudio: a, isAudioBridgeSignalReconnecting: d, leaveAudioSource: u, customizeAudioOption: { speakerOnly: l } } } = t1.value, c = e;
                        return _e(n).pipe(Zy(async (e)=>{
                            const t1 = [];
                            if (e.audio !== c.audio) if ("" === e.audio) tp($u, {
                                source: u
                            }), t1.push(um(void 0));
                            else if (e.audio === Wd.Computer) {
                                const e = Kp(c.userRole) && !i || !!l;
                                a && tp(Fu), e && (tp(Fu), gs.isIOSMobile && t1.push(im(!0))), d && (tp(Fu), t1.push(nm(!1)));
                            } else e.audio === Wd.Phone && (c.audio === Wd.Computer && (await n_.leaveComputerAudio(), t1.push(um(cd.Pstn)), i_.joinOrLeaveVoip(!1)), tp(Hu));
                            if ("" !== c.audio && e.muted !== c.muted) {
                                if (e.muted !== c.muted) {
                                    if (!0 === e.muted) {
                                        if (o !== ud.Inherited) {
                                            const e = null != o ? o : ud.PassiveByMuteOne;
                                            tp(Wu, {
                                                source: e
                                            });
                                        }
                                        c.audio !== Wd.Computer || s && !YC() || n_.muteAudio();
                                    } else if (!1 === e.muted) {
                                        if (r !== ld.Inherited) {
                                            const e = null != r ? r : ld.Passive;
                                            tp(Gu, {
                                                source: e
                                            });
                                        }
                                        c.audio === Wd.Computer && n_.unmuteAudio();
                                    }
                                }
                                void 0 !== e.muted && t1.push(sm(void 0), am(void 0));
                            }
                            return t1;
                        }));
                    }));
                }
                return ne;
            })),
        epics5: (e, t1)=>nr(e, 12036).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const r = ah(o), { media: { audioEncodeStatus: i } } = o, { promoterID: n, bAllowTalk: s } = t1.payload.body;
                if ((null == r ? void 0 : r.userId) === n) {
                    if (tp(rl, s), s) return "success" !== i && n_.enableAudioEncode(), Iy("audio", i, "success").pipe(Fe((e)=>(e && tp(Bu, dd.AllowToTalk), ne)), pt(Rh(!0)));
                    if (i_.mute(n, !0), (null == r ? void 0 : r.audio) === Wd.Computer) return n_.leaveComputerAudio(), Ze(300).pipe(vt(async ()=>{
                        (QC() ? Oe(rt(qe(document, "click").pipe(nt(1)), qe(document, "touchend").pipe(nt(1)))) : Promise.resolve(!0)).then(()=>{
                            KC(n_, o, !1);
                        });
                    }), ut(ne), pt(Rh(!1), sm(ud.Inherited)));
                }
                return ne;
            })),
        epics6: (e)=>nr(e, 8205).pipe(vt((e)=>{
                tp("AUDIO_ALLOW_TO_TALK_RESPONSE", e.payload.body);
            }), ut(ne)),
        epics7: (e, t1)=>ar(e, 24597).pipe(ft(t1), vt((e)=>{
                let [t1, o] = e;
                const r = ah(o);
                (null == r ? void 0 : r.audio) === Wd.Phone ? i_.audioDrop(r.userId) : (null == r ? void 0 : r.audio) === Wd.Computer && t1.payload.body.bPromote;
            }), ut(ne)),
        epics8: (e, t1)=>nr(e, 12035).pipe(ft(t1), ht((e)=>{
                let [o, r] = e;
                const { meeting: { currentUserAudioBeforeReset: i, isCurrentUserMutedBeforeReset: n, userId: s } } = r, { payload: { body: { ssrc: a } } } = o, d = Ay(t1).pipe(Fe((e)=>{
                    if (!(i !== Wd.Computer || null != e && e.audio)) {
                        const { encodeInitStatus: o, decodeInitStatus: r } = o_(t1.value, e);
                        return Iy("audio", o, r).pipe(ot((e)=>{
                            let [t1, o] = e;
                            return t1 && o;
                        }), vt(()=>{
                            (QC() ? Oe(rt(qe(document, "click").pipe(nt(1)), qe(document, "touchend").pipe(nt(1)))) : Promise.resolve(!0)).then(()=>{
                                r_(i_, t1.value), KC(n_, t1.value);
                            });
                            const { audio: { locallyMutedAudioList: e, localUserAudioVolumeList: o, isStopAllImcomingAudio: r } } = t1.value;
                            e.length > 0 && e.forEach((e)=>{
                                n_.muteOrUnmuteOtherAudio(e, !0);
                            }), o.length > 0 && o.forEach((e)=>{
                                n_.adjustOtherAudioVolume(e.userId, e.volume);
                            }), r && n_.stopAllIncomingAudio(!0);
                        }), at(Tn(void 0)));
                    }
                    return i === Wd.Phone && n ? (i_.mute(s, !0), _e([
                        Tn(void 0),
                        On(void 0)
                    ])) : ne;
                }));
                return tp(sl, a), Xe(Re(wh(a)), d);
            })),
        epics9: (e, t1)=>nr(e, 7952).pipe(ht((e)=>np(Hu, 1).pipe(ft(t1), vt((t1)=>{
                    let [, o] = t1;
                    const { BindStatus: r, nOperatorUserId: i } = e.payload.body, n = o.participants.attendeesList.find((e)=>e.userId === i);
                    !0 === r && tp(Yu, {
                        operatorName: null == n ? void 0 : n.displayName,
                        operatorUserId: i,
                        operatorRole: null == n ? void 0 : n.userRole
                    });
                }), ut(ne)))),
        epics10: (e, t1)=>ur(e, sd.UserGrantCaptureAudio).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const r = ah(o);
                var i;
                (i = r, (null == i ? void 0 : i.audio) === Wd.Computer ? Promise.resolve() : ip({
                    event: ha,
                    operations: [
                        ot((e)=>void 0 !== e.audio && "" !== e.audio),
                        nt(1)
                    ]
                }, (e)=>{
                    let { audio: t1 } = e;
                    return t1 === Wd.Phone || t1 === Wd.Computer;
                })).then(()=>{
                    tp(Fu);
                });
                const { meeting: { isCurrentUserMutedBeforeReset: n }, audio: { bMutedUponEntry: s, isUserGrantCaptureAudio: a, isAllowToTalk: d, activeMicrophone: u, isUsingMediaPlayback: l } } = o, { payload: { data: c } } = t1, p = [
                    Oh(!0)
                ];
                if (r) {
                    !0 === r.muted && !1 === d && (p.push(sm(ud.Inherited)), i_.mute(r.userId, !0));
                    const e = a || r.isHost || d;
                    (!0 === n || !e && s) && (p.push(sm(ud.Inherited)), i_.mute(r.userId, !0), n && p.push(On(void 0))), !l && c && u !== c && p.push(Lh(c));
                }
                return _e(p);
            })),
        epics11: (e)=>ur(e, sd.UserForbiddedCaptureAudio).pipe(vt(()=>{
                tp(Xu);
            }), at(Dh(!0))),
        epics12: (e)=>ur(e, sd.AudioWebsocketBroken).pipe(vt(()=>{
                tp(el);
            }), ut(ne)),
        epics13: (e, t1)=>ur(e, sd.AudioZeroData).pipe(ft(t1), Jy((e)=>{
                let [, t1] = e;
                const { audio: { webrtcRestartCount: o, activeMicrophone: r } } = t1;
                if (o < 3) return n_.restoreWebRTC(r), Ph(o + 1);
            })),
        epics14: (e, t1)=>e.pipe(Dt(`${Vh}`), ot((e)=>!1 === e.payload), Fe(()=>(tp(tl), rt(qe(document, "click").pipe(nt(1)), qe(document, "touchend").pipe(nt(1))).pipe(vt(()=>{
                    r_(i_, t1.value), KC(n_, t1.value);
                }), at(Vh(!0)))))),
        epics15: (e)=>ur(e, [
                sd.JoinComputerAudioComplete,
                sd.JoinSharingAudioComplete,
                sd.LeaveComputerAudioComplete,
                sd.LeaveSharingAudioComplete
            ]).pipe(vt(()=>{
                Dy.completeAudioAction();
            }), ut(ne)),
        epics16: (e, t1)=>ur(e, sd.AudioQosData).pipe(ft(t1), Le((e)=>{
                var t1;
                let [o, r] = e;
                const { meeting: { isWebinar: i }, media: { audioEncodeStatus: n, audioDecodeStatus: s }, participants: { xmppAttendeeList: a, allowTalkAttendeesList: d } } = r, u = ah(r), l = vh(r);
                let c = l.length > 0, p = l.some(s_);
                const h = vs();
                i && (c = c || Boolean(a.length), p = p || d.some(s_));
                const m = ((null == u ? void 0 : u.audio) === Wd.Computer || (null == u ? void 0 : u.audio) === Wd.Phone) && ("success" === n || h) && !(null != u && u.muted) && c, g = ((null == u ? void 0 : u.audio) === Wd.Computer || (null == u ? void 0 : u.audio) === Wd.Phone) && ("success" === s || h) && c && p;
                return null !== (t1 = o.payload.data) && void 0 !== t1 && t1.encoding ? m ? (tp(nl, o.payload), zh(o.payload)) : zh(Nd) : g ? (tp(nl, o.payload), qh(o.payload)) : qh(Nd);
            })),
        epics17: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                const { payload: { body: r } } = t1, { audio: { locallyMutedAudioList: i, localUserAudioVolumeList: n } } = o;
                return (i.length > 0 || n.length > 0) && (null == r ? void 0 : r.remove) && r.remove.length > 0;
            }), Fe((e)=>{
                let [t1, o] = e;
                const { payload: { body: { remove: r } } } = t1, { audio: { locallyMutedAudioList: i, localUserAudioVolumeList: n } } = o, s = i.concat(n.map((e)=>e.userId)).filter((e)=>-1 !== r.indexOf((t1)=>t1.id === e));
                return s.length > 0 ? (s.forEach((e)=>{
                    n_.muteOrUnmuteOtherAudio(e, !1);
                }), _e(s.map((e)=>[
                        Qh(e),
                        Yh({
                            userId: e
                        })
                    ]).flat())) : ne;
            })),
        epics18: (e, t1)=>ur(e, sd.HidStatusMute).pipe(Fe((e)=>{
                const { payload: { data: o } } = e, r = t1.value, { meeting: { userId: i }, audio: { isShareAudioEnabled: n, bCanUnmute: s } } = r, a = [];
                if (o) n && !YC() && a.push(Bh(!0)), a.push(sm(ud.Active)), i_.mute(i, !0);
                else if (!n || YC()) {
                    n && a.push(Bh(!1));
                    const e = ah(r);
                    (s || null != e && e.isHost || null != e && e.bCoHost) && (a.push(am(ld.Active)), i_.mute(i, !1));
                }
                return _e(a);
            })),
        epics19: (e)=>nr(e, 12040).pipe(vt((e)=>{
                const { payload: { body: { mode: t1 } } } = e;
                n_.setAudioCodecMode(t1);
            }), ut(ne)),
        epics20: (e, t1)=>ur(e, [
                sd.AudioSpeakerSetSuccess,
                sd.JoinComputerAudioComplete,
                sd.AudioSpeakerSetError
            ]).pipe(Fe((e)=>{
                const { payload: { data: o, type: r } } = e, { audio: { activeSpeaker: i, activeMicrophone: n, isUsingMediaPlayback: s } } = t1.value, a = [];
                return r === sd.AudioSpeakerSetSuccess && i !== o ? a.push(Nh(o)) : s || r !== sd.JoinComputerAudioComplete || null === o || n === o || a.push(Lh(o)), r === sd.AudioSpeakerSetSuccess ? tp(al, !0) : r === sd.AudioSpeakerSetError && tp(al, !1), _e(a);
            })),
        epics21: (e, t1)=>ur(e, sd.AudioLevelIndicator).pipe(ot(()=>{
                const e = ah(t1.value);
                return !!e && e.audio === Wd.Computer && !e.muted;
            }), vt((e)=>{
                const { payload: { data: t1 } } = e;
                tp(pl, {
                    level: t1.value
                });
            }), Fe(()=>ne))
    }, v_ = ir(g_, {
        shareAudioEpics0: (e, t1)=>dr(e, Ps).pipe(ot((e)=>{
                const t1 = e.payload.body.update;
                return t1 && t1.length > 0 && t1.findIndex((e)=>void 0 !== e.bShareOn) > -1;
            }), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { payload: { body: { update: r } } } = t1, { audio: { localShareAudioUserMutedList: i } } = o, n = r.filter((e)=>!0 === e.bShareOn && !0 === e.bShareAudioOn), s = [];
                return n.length > 0 && n.forEach((e)=>{
                    -1 === i.findIndex((t1)=>t1.userId === e.id) && s.push(Fh({
                        userId: e.id,
                        isFromMainSession: !!e.bShareToBORooms
                    }));
                }), _e(s);
            })),
        shareAudioEpics1: (e, t1)=>ur(e, sd.SharingDesktopStreamHaveAudio).pipe(ot(()=>!t1.value.audio.secondaryAudioMicrophoneId), ht(()=>nr(e, Ps).pipe(ot((e)=>{
                    var o;
                    const { payload: { body: r } } = e, { meeting: { userId: i } } = t1.value;
                    return (null == r || null === (o = r.update) || void 0 === o ? void 0 : o.findIndex((e)=>e.id === i && !0 === e.bShareOn)) > -1;
                }), nt(1), Zy(async ()=>{
                    const e = t1.value;
                    return await JC(d_, a_, e);
                }), pt(Wh(!0))))),
        shareAudioEpics2: (e, t1)=>ur(e, sd.SharingDesktopStreamHaveNoAudio).pipe(ft(t1), ot((e)=>{
                var t1;
                let [, o] = e;
                return !0 === (null === (t1 = o.audio) || void 0 === t1 ? void 0 : t1.isShareAudioEnabled);
            }), Zy(async (e)=>{
                let [, t1] = e;
                return await qC(d_, a_, t1);
            })),
        shareAudioEpics3: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [, t1] = e;
                return t1.socket.zoomSocketStatus === Sh.Connected && !0 === t1.audio.isSharingAudio;
            }), Fe((e)=>{
                var o;
                let [r, i] = e;
                if (null !== (o = r.payload.body.update) && void 0 !== o && o.some((e)=>void 0 !== e.audio || void 0 !== e.muted)) {
                    const { meeting: { userId: e } } = i, o = r.payload.body.update.filter((t1)=>t1.id === e);
                    return Ay(t1).pipe(Fe((e)=>{
                        const t1 = [];
                        return o.findIndex((e)=>e.audio === Wd.Computer) > -1 && (null == e ? void 0 : e.audio) !== Wd.Computer && !YC() && (t1.push($h(!0)), t1.push(Bh(!0))), _e(t1);
                    }));
                }
                return ne;
            })),
        shareAudioEpics4: (e, t1)=>e.pipe(Dt(`${Sm}`), Ie(te), ft(t1), ot((e)=>{
                var t1;
                let [, o] = e;
                return !0 === (null === (t1 = o.audio) || void 0 === t1 ? void 0 : t1.isShareAudioEnabled);
            }), Zy(async (e)=>{
                let [t1, o] = e;
                const { payload: r } = t1, { audio: { isShareAudioMuted: i, isSharingAudio: n } } = o, s = [];
                if (r === yd.End) {
                    const e = await qC(d_, a_, o);
                    s.push(...e);
                } else if (r === yd.Paused) {
                    if (!1 === i && !0 === n) {
                        await d_.leaveSharingAudio(!0), s.push(Kh(!1));
                        const e = await zC(d_, a_, o);
                        s.push(...e), setTimeout(()=>{
                            tp(il, {
                                state: "off"
                            });
                        }, 0);
                    }
                } else if (r === yd.Sharing && !1 === i && !1 === n) {
                    const e = await JC(d_, a_, o);
                    s.push(...e);
                }
                return s;
            })),
        shareAudioEpics5: (e, t1)=>ur(e, sd.SharingDesktopStreamHaveAudio).pipe(ot(()=>!!t1.value.audio.secondaryAudioMicrophoneId), vt(()=>{
                const { audio: { audioSsrc: e, secondaryAudioMicrophoneId: o }, meeting: { svcUrl: r, conId: i, reportDomain: n, supportLocalAB: s, abToken: a } } = t1.value;
                d_.joinSharingAudio({
                    ssrc: e,
                    microphoneDeviceId: o,
                    speakerDeviceId: null,
                    isCaptureAudio: !0,
                    audioBridge: vs() ? {
                        rwgHost: r,
                        cid: i,
                        nginxHost: n,
                        abToken: a,
                        supportLocalAB: s,
                        useWebRTCOnDesktop: !gs.isAndroidOrIOSBrowser
                    } : void 0
                }), tp(dl);
            }), Fe(()=>ne))
    }, {
        audioBridgEpics0: (e)=>nr(e, 4299).pipe(vt((e)=>{
                const { payload: t1 } = e;
                l_.passThroughRWGMessage(t1);
            }), ut(ne)),
        audioBridgEpics1: (e)=>ur(e, sd.AudioBridgeReconnectStart).pipe(Fe(()=>(u_.joinOrLeaveVoip(!1), _e([
                    nm(!0),
                    um(cd.Failover)
                ])))),
        audioBridgEpics2: (e, t1)=>ur(e, sd.AudioBridgeReconnectEnd).pipe(vt(()=>{
                r_(u_, t1.value);
            }), ut(ne)),
        audioBridgEpics3: (e)=>nr(e, Ps).pipe(ot((e)=>{
                var t1, o;
                return vs() && ((null === (t1 = e.payload.body.update) || void 0 === t1 ? void 0 : t1.some((e)=>void 0 !== e.muted)) || (null === (o = e.payload.body.remove) || void 0 === o ? void 0 : o.length) > 0);
            }), vt((e)=>{
                const { payload: { body: { update: t1, remove: o } } } = e;
                l_.sendUserAudioStatus({
                    update: (t1 || []).filter((e)=>void 0 !== e.muted).map((e)=>({
                            userId: e.id,
                            muted: e.muted
                        })),
                    remove: (o || []).map((e)=>({
                            userId: e.id
                        }))
                });
            }), ut(ne)),
        audioBridgEpics4: (e, t1)=>ur(e, sd.NotifyUIFailover).pipe(ot(()=>!t1.value.meeting.isMeetingReset && t1.value.meeting.meetingStatus === Xn.Joined), Le(()=>(tp(Ea, {
                    reason: Jn.Failover
                }), sn(ts.NotifyUiFailover)))),
        audioBridgEpics5: (e, t1)=>lr(e, t1).pipe(ot(()=>{
                const { meeting: { isAudioBridgeEnabled: e, abToken: o } } = t1.value;
                return e && vs() && !!o;
            }), vt(()=>{
                const { meeting: { abToken: e, svcUrl: o, reportDomain: r, conId: i, supportLocalAB: n } } = t1.value;
                l_.preInitAudioBridge({
                    abToken: e,
                    rwgHost: o,
                    cid: i,
                    nginxHost: r,
                    supportLocalAB: n,
                    useWebRTCOnDesktop: !gs.isAndroidOrIOSBrowser
                });
            }), ut(ne)),
        audioBridgEpics6: (e, t1)=>nr(e, 16129).pipe(ot((e)=>{
                const { payload: { body: { bVideoOn: o } } } = e, { meeting: { isAudioBridgeEnabled: r } } = t1.value;
                return r && vs() && !!o;
            }), vt((e)=>{
                const { payload: { body: { id: t1 } } } = e;
                l_.changeActiveVideoSsrc(t1);
            }), ut(ne)),
        audioBridgEpics7: (e, t1)=>ur(e, [
                sd.RecoverWebrtcAudio,
                sd.AudioStreamFailed
            ]).pipe(Fe(()=>{
                const e = ah(t1.value), o = [];
                return (null == e ? void 0 : e.audio) === Wd.Computer && (l_.leaveComputerAudio(), QC() || gs.isIOSMobile ? (u_.joinOrLeaveVoip(!1), o.push(um(cd.EndedBySystem)), o.push(Ph(0))) : KC(l_, t1.value)), _e(o);
            })),
        audioBridgEpics8: (e)=>ur(e, [
                sd.AudioBridgeFirstRecvData,
                sd.AudioBridgeCanSendData
            ]).pipe(Le((e)=>{
                const { payload: { type: t1 } } = e;
                return t1 === sd.AudioBridgeFirstRecvData ? (tp(pc), Zo(!0)) : (tp(hc), Yo(!0));
            })),
        audioBridgEpics9: (e, t1)=>e.pipe(Dt(`${pn}`), ot(()=>!!t1.value.meeting.zlkJwtToken), vt(()=>{
                const { meeting: { zlkJwtToken: e } } = t1.value;
                if (e) {
                    const { enforce_web_rtc_audio: t1, audio_compatible_mode: o } = oi(e);
                    void 0 === t1 && void 0 === o || ns.set(ds.EnforceWebRTCAudio, 1 === Number(t1) || 1 === Number(o), rs.Memory);
                }
            }), ut(ne))
    }, m_);
    var f_ = Array.isArray;
    function y_(e) {
        if (!SS(e)) return !1;
        var t1 = kS(e);
        return "[object Function]" == t1 || "[object GeneratorFunction]" == t1 || "[object AsyncFunction]" == t1 || "[object Proxy]" == t1;
    }
    var S_, b_ = IS["__core-js_shared__"], E_ = (S_ = /[^.]+$/.exec(b_ && b_.keys && b_.keys.IE_PROTO || "")) ? "Symbol(src)_1." + S_ : "", I_ = Function.prototype.toString;
    function A_(e) {
        if (null != e) {
            try {
                return I_.call(e);
            } catch (e) {}
            try {
                return e + "";
            } catch (e) {}
        }
        return "";
    }
    var C_ = /^\[object .+?Constructor\]$/, __ = Function.prototype, R_ = Object.prototype, w_ = __.toString, T_ = R_.hasOwnProperty, O_ = RegExp("^" + w_.call(T_).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function D_(e, t1) {
        var o = function(e, t1) {
            return null == e ? void 0 : e[t1];
        }(e, t1);
        return function(e) {
            return !(!SS(e) || (t1 = e, E_ && E_ in t1)) && (y_(e) ? O_ : C_).test(A_(e));
            "TURBOPACK unreachable";
            var t1;
        }(o) ? o : void 0;
    }
    var P_ = D_(IS, "WeakMap"), M_ = /^(?:0|[1-9]\d*)$/;
    function k_(e, t1) {
        var o = typeof e;
        return !!(t1 = null == t1 ? 9007199254740991 : t1) && ("number" == o || "symbol" != o && M_.test(e)) && e > -1 && e % 1 == 0 && e < t1;
    }
    function L_(e, t1) {
        return e === t1 || e != e && t1 != t1;
    }
    function N_(e) {
        return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991;
    }
    function V_(e) {
        return null != e && N_(e.length) && !y_(e);
    }
    var U_ = Object.prototype;
    function j_(e) {
        var t1 = e && e.constructor;
        return e === ("function" == typeof t1 && t1.prototype || U_);
    }
    function x_(e) {
        return LS(e) && "[object Arguments]" == kS(e);
    }
    var B_ = Object.prototype, F_ = B_.hasOwnProperty, H_ = B_.propertyIsEnumerable, $_ = x_(function() {
        return arguments;
    }()) ? x_ : function(e) {
        return LS(e) && F_.call(e, "callee") && !H_.call(e, "callee");
    }, W_ = "object" == typeof e && e && !e.nodeType && e, G_ = W_ && "object" == ("TURBOPACK compile-time value", "object") && module && !module.nodeType && module, K_ = G_ && G_.exports === W_ ? IS.Buffer : void 0, z_ = (K_ ? K_.isBuffer : void 0) || function() {
        return !1;
    }, q_ = {};
    q_["[object Float32Array]"] = q_["[object Float64Array]"] = q_["[object Int8Array]"] = q_["[object Int16Array]"] = q_["[object Int32Array]"] = q_["[object Uint8Array]"] = q_["[object Uint8ClampedArray]"] = q_["[object Uint16Array]"] = q_["[object Uint32Array]"] = !0, q_["[object Arguments]"] = q_["[object Array]"] = q_["[object ArrayBuffer]"] = q_["[object Boolean]"] = q_["[object DataView]"] = q_["[object Date]"] = q_["[object Error]"] = q_["[object Function]"] = q_["[object Map]"] = q_["[object Number]"] = q_["[object Object]"] = q_["[object RegExp]"] = q_["[object Set]"] = q_["[object String]"] = q_["[object WeakMap]"] = !1;
    var J_, Q_ = "object" == typeof e && e && !e.nodeType && e, Z_ = Q_ && "object" == ("TURBOPACK compile-time value", "object") && module && !module.nodeType && module, Y_ = Z_ && Z_.exports === Q_ && bS.process, X_ = function() {
        try {
            return Z_ && Z_.require && Z_.require("util").types || Y_ && Y_.binding && Y_.binding("util");
        } catch (e) {}
    }(), eR = X_ && X_.isTypedArray, tR = eR ? (J_ = eR, function(e) {
        return J_(e);
    }) : function(e) {
        return LS(e) && N_(e.length) && !!q_[kS(e)];
    }, oR = Object.prototype.hasOwnProperty;
    var rR = function(e, t1) {
        return function(o) {
            return e(t1(o));
        };
    }(Object.keys, Object), iR = Object.prototype.hasOwnProperty;
    function nR(e) {
        if (!j_(e)) return rR(e);
        var t1 = [];
        for(var o in Object(e))iR.call(e, o) && "constructor" != o && t1.push(o);
        return t1;
    }
    function sR(e) {
        return V_(e) ? function(e) {
            var t1 = f_(e), o = !t1 && $_(e), r = !t1 && !o && z_(e), i = !t1 && !o && !r && tR(e), n = t1 || o || r || i, s = n ? function(e, t1) {
                for(var o = -1, r = Array(e); ++o < e;)r[o] = t1(o);
                return r;
            }(e.length, String) : [], a = s.length;
            for(var d in e)!oR.call(e, d) || n && ("length" == d || r && ("offset" == d || "parent" == d) || i && ("buffer" == d || "byteLength" == d || "byteOffset" == d) || k_(d, a)) || s.push(d);
            return s;
        }(e) : nR(e);
    }
    var aR = D_(Object, "create"), dR = Object.prototype.hasOwnProperty, uR = Object.prototype.hasOwnProperty;
    function lR(e) {
        var t1 = -1, o = null == e ? 0 : e.length;
        for(this.clear(); ++t1 < o;){
            var r = e[t1];
            this.set(r[0], r[1]);
        }
    }
    function cR(e, t1) {
        for(var o = e.length; o--;)if (L_(e[o][0], t1)) return o;
        return -1;
    }
    lR.prototype.clear = function() {
        this.__data__ = aR ? aR(null) : {}, this.size = 0;
    }, lR.prototype.delete = function(e) {
        var t1 = this.has(e) && delete this.__data__[e];
        return this.size -= t1 ? 1 : 0, t1;
    }, lR.prototype.get = function(e) {
        var t1 = this.__data__;
        if (aR) {
            var o = t1[e];
            return "__lodash_hash_undefined__" === o ? void 0 : o;
        }
        return dR.call(t1, e) ? t1[e] : void 0;
    }, lR.prototype.has = function(e) {
        var t1 = this.__data__;
        return aR ? void 0 !== t1[e] : uR.call(t1, e);
    }, lR.prototype.set = function(e, t1) {
        var o = this.__data__;
        return this.size += this.has(e) ? 0 : 1, o[e] = aR && void 0 === t1 ? "__lodash_hash_undefined__" : t1, this;
    };
    var pR = Array.prototype.splice;
    function hR(e) {
        var t1 = -1, o = null == e ? 0 : e.length;
        for(this.clear(); ++t1 < o;){
            var r = e[t1];
            this.set(r[0], r[1]);
        }
    }
    hR.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
    }, hR.prototype.delete = function(e) {
        var t1 = this.__data__, o = cR(t1, e);
        return !(o < 0 || (o == t1.length - 1 ? t1.pop() : pR.call(t1, o, 1), --this.size, 0));
    }, hR.prototype.get = function(e) {
        var t1 = this.__data__, o = cR(t1, e);
        return o < 0 ? void 0 : t1[o][1];
    }, hR.prototype.has = function(e) {
        return cR(this.__data__, e) > -1;
    }, hR.prototype.set = function(e, t1) {
        var o = this.__data__, r = cR(o, e);
        return r < 0 ? (++this.size, o.push([
            e,
            t1
        ])) : o[r][1] = t1, this;
    };
    var mR = D_(IS, "Map");
    function gR(e, t1) {
        var o, r, i = e.__data__;
        return ("string" == (r = typeof (o = t1)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== o : null === o) ? i["string" == typeof t1 ? "string" : "hash"] : i.map;
    }
    function vR(e) {
        var t1 = -1, o = null == e ? 0 : e.length;
        for(this.clear(); ++t1 < o;){
            var r = e[t1];
            this.set(r[0], r[1]);
        }
    }
    function fR(e) {
        var t1 = this.__data__ = new hR(e);
        this.size = t1.size;
    }
    vR.prototype.clear = function() {
        this.size = 0, this.__data__ = {
            hash: new lR,
            map: new (mR || hR),
            string: new lR
        };
    }, vR.prototype.delete = function(e) {
        var t1 = gR(this, e).delete(e);
        return this.size -= t1 ? 1 : 0, t1;
    }, vR.prototype.get = function(e) {
        return gR(this, e).get(e);
    }, vR.prototype.has = function(e) {
        return gR(this, e).has(e);
    }, vR.prototype.set = function(e, t1) {
        var o = gR(this, e), r = o.size;
        return o.set(e, t1), this.size += o.size == r ? 0 : 1, this;
    }, fR.prototype.clear = function() {
        this.__data__ = new hR, this.size = 0;
    }, fR.prototype.delete = function(e) {
        var t1 = this.__data__, o = t1.delete(e);
        return this.size = t1.size, o;
    }, fR.prototype.get = function(e) {
        return this.__data__.get(e);
    }, fR.prototype.has = function(e) {
        return this.__data__.has(e);
    }, fR.prototype.set = function(e, t1) {
        var o = this.__data__;
        if (o instanceof hR) {
            var r = o.__data__;
            if (!mR || r.length < 199) return r.push([
                e,
                t1
            ]), this.size = ++o.size, this;
            o = this.__data__ = new vR(r);
        }
        return o.set(e, t1), this.size = o.size, this;
    };
    var yR = Object.prototype.propertyIsEnumerable, SR = Object.getOwnPropertySymbols, bR = SR ? function(e) {
        return null == e ? [] : (e = Object(e), function(e, t1) {
            for(var o = -1, r = null == e ? 0 : e.length, i = 0, n = []; ++o < r;){
                var s = e[o];
                t1(s) && (n[i++] = s);
            }
            return n;
        }(SR(e), function(t1) {
            return yR.call(e, t1);
        }));
    } : function() {
        return [];
    };
    function ER(e) {
        return function(e, t1, o) {
            var r = t1(e);
            return f_(e) ? r : function(e, t1) {
                for(var o = -1, r = t1.length, i = e.length; ++o < r;)e[i + o] = t1[o];
                return e;
            }(r, o(e));
        }(e, sR, bR);
    }
    var IR = D_(IS, "DataView"), AR = D_(IS, "Promise"), CR = D_(IS, "Set"), _R = "[object Map]", RR = "[object Promise]", wR = "[object Set]", TR = "[object WeakMap]", OR = "[object DataView]", DR = A_(IR), PR = A_(mR), MR = A_(AR), kR = A_(CR), LR = A_(P_), NR = kS;
    (IR && NR(new IR(new ArrayBuffer(1))) != OR || mR && NR(new mR) != _R || AR && NR(AR.resolve()) != RR || CR && NR(new CR) != wR || P_ && NR(new P_) != TR) && (NR = function(e) {
        var t1 = kS(e), o = "[object Object]" == t1 ? e.constructor : void 0, r = o ? A_(o) : "";
        if (r) switch(r){
            case DR:
                return OR;
            case PR:
                return _R;
            case MR:
                return RR;
            case kR:
                return wR;
            case LR:
                return TR;
        }
        return t1;
    });
    var VR = IS.Uint8Array;
    function UR(e) {
        var t1 = -1, o = null == e ? 0 : e.length;
        for(this.__data__ = new vR; ++t1 < o;)this.add(e[t1]);
    }
    function jR(e, t1) {
        for(var o = -1, r = null == e ? 0 : e.length; ++o < r;)if (t1(e[o], o, e)) return !0;
        return !1;
    }
    function xR(e, t1, o, r, i, n) {
        var s = 1 & o, a = e.length, d = t1.length;
        if (a != d && !(s && d > a)) return !1;
        var u = n.get(e), l = n.get(t1);
        if (u && l) return u == t1 && l == e;
        var c = -1, p = !0, h = 2 & o ? new UR : void 0;
        for(n.set(e, t1), n.set(t1, e); ++c < a;){
            var m = e[c], g = t1[c];
            if (r) var v = s ? r(g, m, c, t1, e, n) : r(m, g, c, e, t1, n);
            if (void 0 !== v) {
                if (v) continue;
                p = !1;
                break;
            }
            if (h) {
                if (!jR(t1, function(e, t1) {
                    if (s = t1, !h.has(s) && (m === e || i(m, e, o, r, n))) return h.push(t1);
                    var s;
                })) {
                    p = !1;
                    break;
                }
            } else if (m !== g && !i(m, g, o, r, n)) {
                p = !1;
                break;
            }
        }
        return n.delete(e), n.delete(t1), p;
    }
    function BR(e) {
        var t1 = -1, o = Array(e.size);
        return e.forEach(function(e, r) {
            o[++t1] = [
                r,
                e
            ];
        }), o;
    }
    function FR(e) {
        var t1 = -1, o = Array(e.size);
        return e.forEach(function(e) {
            o[++t1] = e;
        }), o;
    }
    UR.prototype.add = UR.prototype.push = function(e) {
        return this.__data__.set(e, "__lodash_hash_undefined__"), this;
    }, UR.prototype.has = function(e) {
        return this.__data__.has(e);
    };
    var HR = RS ? RS.prototype : void 0, $R = HR ? HR.valueOf : void 0, WR = Object.prototype.hasOwnProperty, GR = "[object Arguments]", KR = "[object Array]", zR = "[object Object]", qR = Object.prototype.hasOwnProperty;
    function JR(e, t1, o, r, i) {
        return e === t1 || (null == e || null == t1 || !LS(e) && !LS(t1) ? e != e && t1 != t1 : function(e, t1, o, r, i, n) {
            var s = f_(e), a = f_(t1), d = s ? KR : NR(e), u = a ? KR : NR(t1), l = (d = d == GR ? zR : d) == zR, c = (u = u == GR ? zR : u) == zR, p = d == u;
            if (p && z_(e)) {
                if (!z_(t1)) return !1;
                s = !0, l = !1;
            }
            if (p && !l) return n || (n = new fR), s || tR(e) ? xR(e, t1, o, r, i, n) : function(e, t1, o, r, i, n, s) {
                switch(o){
                    case "[object DataView]":
                        if (e.byteLength != t1.byteLength || e.byteOffset != t1.byteOffset) return !1;
                        e = e.buffer, t1 = t1.buffer;
                    case "[object ArrayBuffer]":
                        return !(e.byteLength != t1.byteLength || !n(new VR(e), new VR(t1)));
                    case "[object Boolean]":
                    case "[object Date]":
                    case "[object Number]":
                        return L_(+e, +t1);
                    case "[object Error]":
                        return e.name == t1.name && e.message == t1.message;
                    case "[object RegExp]":
                    case "[object String]":
                        return e == t1 + "";
                    case "[object Map]":
                        var a = BR;
                    case "[object Set]":
                        var d = 1 & r;
                        if (a || (a = FR), e.size != t1.size && !d) return !1;
                        var u = s.get(e);
                        if (u) return u == t1;
                        r |= 2, s.set(e, t1);
                        var l = xR(a(e), a(t1), r, i, n, s);
                        return s.delete(e), l;
                    case "[object Symbol]":
                        if ($R) return $R.call(e) == $R.call(t1);
                }
                return !1;
            }(e, t1, d, o, r, i, n);
            if (!(1 & o)) {
                var h = l && qR.call(e, "__wrapped__"), m = c && qR.call(t1, "__wrapped__");
                if (h || m) {
                    var g = h ? e.value() : e, v = m ? t1.value() : t1;
                    return n || (n = new fR), i(g, v, o, r, n);
                }
            }
            return !!p && (n || (n = new fR), function(e, t1, o, r, i, n) {
                var s = 1 & o, a = ER(e), d = a.length;
                if (d != ER(t1).length && !s) return !1;
                for(var u = d; u--;){
                    var l = a[u];
                    if (!(s ? l in t1 : WR.call(t1, l))) return !1;
                }
                var c = n.get(e), p = n.get(t1);
                if (c && p) return c == t1 && p == e;
                var h = !0;
                n.set(e, t1), n.set(t1, e);
                for(var m = s; ++u < d;){
                    var g = e[l = a[u]], v = t1[l];
                    if (r) var f = s ? r(v, g, l, t1, e, n) : r(g, v, l, e, t1, n);
                    if (!(void 0 === f ? g === v || i(g, v, o, r, n) : f)) {
                        h = !1;
                        break;
                    }
                    m || (m = "constructor" == l);
                }
                if (h && !m) {
                    var y = e.constructor, S = t1.constructor;
                    y == S || !("constructor" in e) || !("constructor" in t1) || "function" == typeof y && y instanceof y && "function" == typeof S && S instanceof S || (h = !1);
                }
                return n.delete(e), n.delete(t1), h;
            }(e, t1, o, r, i, n));
        }(e, t1, o, r, JR, i));
    }
    var QR = Object.prototype.hasOwnProperty;
    const ZR = (e)=>4294966272 & e, YR = (e)=>{
        let t1 = {
            R: 0,
            G: 0,
            B: 0,
            A: 0
        };
        if ("string" == typeof e && e.startsWith("#")) {
            const a = e.slice(1);
            try {
                if (3 === a.length) {
                    const e = Array.from(a).map((e)=>e.repeat(2)).map((e)=>parseInt(e, 16));
                    t1 = {
                        R: e[0] / 255,
                        G: e[1] / 255,
                        B: e[2] / 255,
                        A: 1
                    };
                } else if (6 === a.length || 8 === a.length) {
                    var o, r, i, n, s;
                    const e = null === (o = a.match(/\S{2}/g)) || void 0 === o ? void 0 : o.map((e)=>parseInt(e, 16));
                    t1 = {
                        R: (null !== (r = null == e ? void 0 : e[0]) && void 0 !== r ? r : 0) / 255,
                        G: (null !== (i = null == e ? void 0 : e[1]) && void 0 !== i ? i : 0) / 255,
                        B: (null !== (n = null == e ? void 0 : e[2]) && void 0 !== n ? n : 0) / 255,
                        A: null != e && e[3] ? (null !== (s = null == e ? void 0 : e[3]) && void 0 !== s ? s : 0) / 255 : 1
                    };
                }
            } catch (t1) {
                console.warn("error color representation:", e);
            }
        } else "object" == typeof e && (t1 = {
            R: e.R / 255,
            G: e.G / 255,
            B: e.B / 255,
            A: e.A || 1
        });
        return t1;
    };
    function XR(e) {
        let { captureWidth: t1 = 0, captureHeight: o = 0 } = e || {};
        const { hd: r } = e || {};
        var i, n;
        return 0 !== t1 && 0 !== o || (r && ca.isSupportSending720P() ? (t1 = 1280, o = 720) : (t1 = 640, o = 360)), {
            captureWidth: t1,
            captureHeight: o,
            isCustomizedResolution: !(null == e || !e.captureWidth || !e.captureHeight || (i = t1, n = o, Math.abs(Math.floor(i / n * 10) - Math.floor(16 / 9 * 10)) <= 1))
        };
    }
    function ew(e, t1) {
        return "default" === e || t1.some((t1)=>t1.deviceId === e) || [
            wd.Environment,
            wd.User,
            wd.Left,
            wd.Right
        ].includes(e);
    }
    function tw(e, t1) {
        if ("function" == typeof DOMMatrixReadOnly) {
            const o = new DOMMatrixReadOnly(getComputedStyle(e).transform).scale(-1, 1).toString();
            e.style.transform = o, e.dataset.mirrored = t1 ? "1" : "0";
        }
    }
    function ow(e, t1, o) {
        const r = [], { video: { videoSsrc: i, activeCamera: n } } = t1, { cameraId: s = n, videoElement: a, originalRatio: d, ptz: u, hd: l, fullHd: c, mediaFile: p, fps: h, mirrored: m } = o || {};
        let g;
        if (void 0 !== a) {
            let e = a instanceof HTMLVideoElement ? a : null;
            if ("string" == typeof a) {
                let [t1, o] = [
                    document.body,
                    a
                ];
                if (a.indexOf(">") > -1) {
                    const [e, r] = a.split(">");
                    t1 = document.querySelector(e), o = r;
                }
                t1 && (e = t1.querySelector(o));
            }
            if (!e) return [];
            g = e, e.id || (e.id = ei("__ZOOM_SDK_SELF_VIDEO_@__")), m && "1" !== e.dataset.mirrored && tw(e, m);
        }
        let v = null != h ? h : Jd.Default;
        v = Math.max(Jd.Min, v), v = Math.min(Jd.Max, v);
        const { captureWidth: f, captureHeight: y, isCustomizedResolution: S } = XR(o);
        if (S) e.updateVideoHDValue(!1);
        else {
            e.updateVideoHDValue(!!l || !!c);
            const t1 = !!c && ca.isSupportFullHDVideo();
            e.updateVideoFullhdValue(t1);
        }
        let b = Promise.resolve(s);
        if (p && p.url) {
            const e = Wy.getInstance();
            b = e.setVideoElement(p).then(()=>e.videoElement);
        } else Wy.getInstance().stopVideoElement();
        return b.then((t1)=>{
            e.startCaptureVideo(i, t1, f, y, g, gs.isAndroidOrIOSBrowser && Td.includes(t1), !d && function() {
                var e, t1;
                const { isAndroidOrIOSBrowser: o, isFirefox: r, isSafari: i } = gs;
                return o || !(null !== (e = navigator.mediaDevices) && void 0 !== e && null !== (t1 = e.getSupportedConstraints) && void 0 !== t1 && t1.call(e).aspectRatio) || r || i || bs();
            }(), u, v);
        }), r.push(_g({
            cameraId: s,
            captureWidth: f,
            captureHeight: y,
            videoElement: "string" == typeof a ? a : a instanceof HTMLVideoElement ? si(a) : void 0,
            originalRatio: d,
            ptz: u,
            hd: l,
            fullHd: c,
            mediaFile: p,
            fps: v,
            mirrored: m
        })), r;
    }
    function rw(e, t1, o) {
        const { max: r, min: i, step: n } = e;
        let s = o / 100 * (r - i);
        n && (s = Math.min(Math.floor(s / n) * n, Math.floor(s)));
        let a = t1 + s;
        return a = Math.min(r, a), a = Math.max(i, a), a;
    }
    function iw(e, t1) {
        let o = "", r = t1;
        switch(e){
            case jd.Down:
                r = -t1, o = "tilt";
                break;
            case jd.Up:
                o = "tilt";
                break;
            case jd.Left:
                r = -t1, o = "pan";
                break;
            case jd.Right:
                o = "pan";
                break;
            case jd.ZoomIn:
                o = "zoom";
                break;
            case jd.ZoomOut:
                r = -t1, o = "zoom";
        }
        return {
            key: o,
            range: r
        };
    }
    function nw(e) {
        const t1 = [
            "pan",
            "tilt",
            "zoom"
        ].reduce((t1, o)=>e[o] && 0 !== e[o].value ? {
                ...t1,
                [o]: e[o].value
            } : t1, {});
        return function(e) {
            if (null == e) return !0;
            if (V_(e) && (f_(e) || "string" == typeof e || "function" == typeof e.splice || z_(e) || tR(e) || $_(e))) return !e.length;
            var t1 = NR(e);
            if ("[object Map]" == t1 || "[object Set]" == t1) return !e.size;
            if (j_(e)) return !nR(e).length;
            for(var o in e)if (QR.call(e, o)) return !1;
            return !0;
        }(t1) ? null : t1;
    }
    function sw(e) {
        return {
            pan: (e & xd.Pan) === xd.Pan,
            tilt: (e & xd.Tilt) === xd.Tilt,
            zoom: (e & xd.Zoom) === xd.Zoom
        };
    }
    function aw(e) {
        const { isAndroidBrowser: t1, isIOSMobile: o, isFirefox: r, isSupportMediaStreamTrackProcessor: i, isSupportOffscreenCanvas: n } = gs, s = t1 && !r, a = i && n, d = "function" != typeof window.SharedArrayBuffer && s && a;
        return o && "function" == typeof VideoFrame || d || !ys() && a && !e && !Ty();
    }
    function dw(e, t1, o) {
        const { meeting: { userId: r }, video: { isSupportHDVideo: i, renderedVideoList: n, maximumNumbeOfHDSubscriptions: s, receivedVideoMaxQuality: a } } = o, d = e === r;
        let u = t1;
        if (t1 >= Sd.Video_720P) if (i) {
            const t1 = n.filter((e)=>e.videoQuality === Sd.Video_720P).map((e)=>e.userId), o = null != s ? s : 1;
            t1.length >= o && (t1.includes(e) || d || (console.warn(`Warning: Web Video SDK currently only supports subscribing to ${o} 720p video stream, so quality has been downgraded to 360p`), u = Sd.Video_360P));
        } else console.warn("Can not subscribe 720P video stream,will downgrade to 360P stream"), u = Sd.Video_360P;
        const l = Math.max(a, Sd.Video_360P);
        return [
            u,
            Math.min(u, l)
        ];
    }
    const uw = ia.createAgent(), lw = yE(ca.getInstance());
    let cw, pw;
    async function hw(e, t1, o) {
        const r = ei(e), i = document.createElement("img");
        return i.src = t1, i.id = r, i.style.display = "none", ti(t1) && i.setAttribute("crossorigin", ""), await new Promise((e, r)=>{
            i.onload = ()=>{
                o && URL.revokeObjectURL(t1), e("");
            }, i.onerror = ()=>{
                o && URL.revokeObjectURL(t1), r("Cannot load  image.");
            };
        }), {
            imageId: r,
            imgElement: i
        };
    }
    async function mw(e, t1, o) {
        if (e === Rd) return Rd;
        {
            let r = e;
            if (t1) {
                const t1 = await function(e) {
                    return new Promise((t1, o)=>{
                        try {
                            cw && pw || (cw = document.createElement("canvas"), pw = cw.getContext("2d"));
                            const r = cw, i = pw;
                            if (i) {
                                i.clearRect(0, 0, cw.width, cw.height);
                                const n = new Image;
                                n.src = e, ti(e) && (n.crossOrigin = "");
                                const s = 16 / 9, a = 1280, d = Math.floor(a / s);
                                r.width = a, r.height = d, n.onload = ()=>{
                                    const { width: e, height: u } = n, l = u * s;
                                    if (l > e) {
                                        const t1 = e, o = Math.floor(e / s), r = 0, l = (u - o) / 2;
                                        null == i || i.drawImage(n, r, l, t1, o, 0, 0, a, d);
                                    } else {
                                        const t1 = l, o = u, r = (e - t1) / 2, s = 0;
                                        i.drawImage(n, r, s, t1, o, 0, 0, a, d);
                                    }
                                    try {
                                        r.toBlob((e)=>{
                                            t1(e);
                                        });
                                    } catch (e) {
                                        e instanceof DOMException && e.code === DOMException.SECURITY_ERR && console.error("Image is not from the same origin, add CORS header to solve this issue"), o(e);
                                    }
                                }, n.onerror = (e)=>{
                                    o("Cannot load  image.");
                                };
                            }
                        } catch (e) {
                            o(e);
                        }
                    });
                }(e);
                r = URL.createObjectURL(t1);
            }
            if (r) {
                const { imageId: e, imgElement: i } = await hw("__ZOOM_SDK_VIRTUAL_BACKGROUND_IMAGE_@__", r, !!t1);
                return (null != o ? o : document.body).appendChild(i), e;
            }
        }
        return null;
    }
    async function gw(e, t1, o) {
        var r;
        const i = null !== (r = o && o.parentNode) && void 0 !== r ? r : document.body, { imageUrl: n, cropped: s, rootWidth: a, rootHeight: d } = e;
        let u = e;
        !t1.video.customizedVideoOption || e.captureWidth && e.captureHeight || (u = t1.video.customizedVideoOption);
        const { captureWidth: l, captureHeight: c } = XR(u), p = document.createElement("div");
        let h;
        p.style.display = "none", h = n ? await mw(n, s, p) : null;
        let m, g = ei("__ZOOM_SDK_VIRTUAL_BACKGROUND_CANVAS_@__");
        if (o) {
            const t1 = wy(o);
            t1.id ? g = t1.id : t1.id = g, m = t1;
            try {
                a && o.width !== a && (o.width = a), d && o.height !== d && (o.height = d);
            } catch (e) {
                console.warn("Cannot set the canvas width/height, and pay attention the canvas dimension is different from the setting");
            }
        } else {
            const e = document.createElement("canvas");
            e.width = null != a ? a : 380, e.height = null != d ? d : 214, e.id = g, m = e, p.appendChild(e);
        }
        return null == i || i.appendChild(p), {
            captureWidth: l,
            captureHeight: c,
            imageId: h,
            canvas: m,
            divElement: p
        };
    }
    async function vw(e, t1, o, r) {
        const i = Array.isArray(e) ? e : e && [
            e
        ];
        if ((null == i ? void 0 : i.length) > 0) {
            cw && pw || (cw = document.createElement("canvas"), pw = cw.getContext("2d"));
            const n = cw, s = pw;
            if (n.width = t1, n.height = o, s) try {
                s.fillStyle = "#fff", s.clearRect(0, 0, t1, o);
                for(let e = 0; e < i.length; e++){
                    const t1 = i[e], { type: o, x: r, y: n } = t1;
                    if ("rectangle" === o) {
                        const { width: e, height: o } = t1;
                        s.fillRect(r, n, e, o);
                    } else if ("square" === o) {
                        const { length: e } = t1;
                        s.fillRect(r, n, e, e);
                    } else if ("circle" === o) {
                        const { radius: e } = t1;
                        s.beginPath(), s.arc(r, n, e, 0, 2 * Math.PI), s.fill();
                    } else if ("svg" === o) {
                        const { svg: e, width: o, height: i } = t1, a = new Image;
                        a.src = e, ti(e) && (a.crossOrigin = ""), await new Promise((e, t1)=>{
                            a.onload = ()=>{
                                e("");
                            }, a.onerror = ()=>{
                                t1();
                            };
                        });
                        const { width: d, height: u } = a;
                        s.drawImage(a, 0, 0, d, u, r, n, o, i);
                    }
                }
                const e = await new Promise((e)=>{
                    null == n || n.toBlob((t1)=>{
                        e(t1);
                    });
                });
                if (e) {
                    const t1 = URL.createObjectURL(e), { imageId: o, imgElement: i } = await hw("__ZOOM_SDK_MASK_CLIP_@__", t1, !0);
                    return (null != r ? r : document.body).appendChild(i), o;
                }
            } catch (e) {
                e instanceof DOMException && e.code === DOMException.SECURITY_ERR && console.error("Image is not from the same origin, add CORS header to solve this issue");
            }
        }
        return null;
    }
    function fw(e, t1) {
        if (e === t1) return !0;
        if (null == e && null == t1) return !0;
        const o = Array.isArray(e) ? [
            ...e
        ] : [
            e
        ], r = Array.isArray(t1) ? [
            ...t1
        ] : [
            t1
        ];
        if (o.length !== r.length) return !1;
        const i = (e, t1)=>e.type < t1.type ? -1 : e.type === t1.type ? 0 : 1;
        o.sort(i), r.sort(i);
        for(let e = 0; e < o.length; e++)if (!Zr(o[e], r[e])) return !1;
        return !0;
    }
    function yw(e, t1, o, r) {
        const { video: { isCurrentUserStartedVideo: i, virtualBackground: { isVBPreloadReady: n, isVBConfigured: s, imageSrc: a }, backgroundMode: d }, meeting: { isCurrentUserStartVideoBeforeReset: u } } = o;
        return Oe(function(e) {
            return void 0 !== e ? _e([
                e
            ]) : np(Eu, 1).pipe(Le((e)=>e));
        }(n)).then((n)=>n ? r || !s && e.imageUrl !== Rd && e.imageUrl ? (async function(e, t1, o, r) {
                const { canvas: i, imageId: n, captureHeight: s, captureWidth: a, divElement: d } = await gw(e, o, r), { cameraId: u } = e, { video: { videoSsrc: l, activeCamera: c } } = o;
                return t1.startVirtualBackgroundSetting(i, n, l, null != u ? u : c, a, s), d;
            })(e, t1, o, r).then((e)=>i ? bg(!0) : Oe(np(Iu, 1)).then((o)=>{
                    var i;
                    return r || t1.stopVirtualBackgroundSetting(), o ? (null == e || null === (i = e.parentNode) || void 0 === i || i.removeChild(e), !0) : Promise.reject("Cannot access the virtual background image.");
                })) : a === e.imageUrl && d === $d.VirtualBackground && !u || async function(e, t1, o) {
                const { imageUrl: r, cropped: i } = e;
                if (r) {
                    const e = await mw(r, i);
                    e && (o.video.backgroundMode === $d.Mask && (t1.stopMaskSetting(!0), await Xr(()=>{
                        t1.stopVirtualBackgroundSetting();
                    }, 0)), t1.updateVirtualBackgroundImage(e), e !== Rd && setTimeout(()=>{
                        hr(e);
                    }, 0));
                } else t1.updateVirtualBackgroundImage(null);
            }(e, t1, o) : Promise.reject("Cannot load virtual background model."));
    }
    function Sw(e, t1, o, r) {
        const { video: { mask: { isMaskConfigured: i, imageSrc: n, clip: s }, backgroundMode: a, isCurrentUserStartedVideo: d }, meeting: { isCurrentUserStartVideoBeforeReset: u } } = o;
        return r || !i && e.imageUrl ? (async function(e, t1, o, r) {
            const { canvas: i, imageId: n, captureHeight: s, captureWidth: a, divElement: d } = await gw(e, o, r), { cameraId: u, clip: l, rootWidth: c = 1280, rootHeight: p = 720 } = e, h = l ? await vw(l, c, p, d) : null, { video: { videoSsrc: m, activeCamera: g } } = o;
            return h ? (t1.startMaskSetting(i, n, h, m, null != u ? u : g, c, p, a, s), d) : Promise.reject("Clip is empty");
        })(e, t1, o, r).then((e)=>d ? Vg(!0) : Oe(np(Du, 1)).then((o)=>{
                var i;
                return r || t1.stopMaskSetting(), o ? (null == e || null === (i = e.parentNode) || void 0 === i || i.removeChild(e), !0) : Promise.reject("Cannot set video mask");
            })) : a === $d.Mask && e.imageUrl === n && fw(e.clip, s) && !u ? Promise.resolve(!0) : async function(e, t1, o) {
            const { imageUrl: r, cropped: i, clip: n, rootWidth: s, rootHeight: a } = e, { video: { mask: { imageSrc: d, cropped: u, clip: l }, backgroundMode: c } } = o;
            if (r) {
                if (c === $d.VirtualBackground && (t1.stopVirtualBackgroundSetting(!0), await Xr(()=>{
                    t1.stopMaskSetting();
                }, 0)), r !== d || i !== u) {
                    const e = await mw(r, i);
                    e && (t1.updateMaskBackgroundImage(e), setTimeout(()=>{
                        hr(e);
                    }, 0));
                }
                if ((!fw(n, l) || !d) && n && s && a) {
                    const e = await vw(n, s, a);
                    e && (t1.updateMaskClip(e, s, a), setTimeout(()=>{
                        hr(e);
                    }, 0));
                }
            } else t1.updateMaskBackgroundImage(null), t1.updateMaskClip(null, s, a);
        }(e, t1, o);
    }
    const bw = ia.createAgent(), Ew = yE(ca.getInstance()), Iw = ia.createAgent(), Aw = yE(ca.getInstance()), Cw = {
        videoSsrc: 0,
        cameraDevicesList: [],
        activeCamera: gs.isAndroidOrIOSBrowser ? wd.User : "default",
        activeVideoId: 0,
        isCurrentUserStartedVideo: !1,
        spotlightUserList: [],
        isCaptureForbidden: !1,
        isMirrored: !1,
        receivedVideoMaxQuality: navigator.hardwareConcurrency >= 8 ? Sd.Video_1080P : Sd.Video_360P,
        subscribedVideoList: [],
        renderedVideoList: [],
        ensuredCanvas: [],
        isVideoMuted: !1,
        isCaptureCameraLoading: !1,
        isCameraTaken: !1,
        isUsingMediaPlayback: !1,
        receivedVideoDimension: {
            width: 0,
            height: 0
        },
        capturedVideoDimension: {
            width: 0,
            height: 0
        },
        isFollowHostVideoLayout: !1,
        hostDragLayout: [],
        isSupportHDVideo: !1,
        isFullHDVideoEnabled: !1,
        bCanUnmuteVideo: !1,
        virtualBackground: {
            isVBConfigured: !1,
            isVBPreloadReady: void 0,
            imageSrc: void 0,
            cropped: void 0
        },
        mask: {
            imageSrc: void 0,
            cropped: void 0,
            clip: void 0
        },
        backgroundMode: $d.Null,
        statistic: {
            encode: {
                sample_rate: 0,
                rtt: 0,
                jitter: 0,
                avg_loss: 0,
                max_loss: 0,
                width: 0,
                height: 0,
                fps: 0,
                bandwidth: 0,
                bitrate: 0
            },
            decode: {
                sample_rate: 0,
                rtt: 0,
                jitter: 0,
                avg_loss: 0,
                max_loss: 0,
                width: 0,
                height: 0,
                fps: 0,
                bandwidth: 0,
                bitrate: 0
            }
        },
        hardwareAcceleration: {
            encode: !1,
            decode: !1
        },
        networkQuality: {},
        ptz: {},
        currentCameraControlStatus: {
            isRequested: !1,
            isInControl: !1,
            isCameraMoving: !1
        },
        farEndCameraControlStatus: {
            controlledUserList: [],
            isControlling: !1
        },
        subscriptionStatus: {
            encode: !1,
            decode: !1,
            detailed: !1
        },
        videoAttachments: {},
        rendererType: Xd.WebGL,
        selfPreviewVideoList: []
    }, _w = bo({
        [`${Zm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.videoSsrc = o;
        }),
        [`${Xm}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.cameraDevicesList = o;
        }),
        [`${eg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.activeCamera;
            if (r in e.ptz) {
                const t1 = e.ptz[r];
                [
                    "pan",
                    "tilt",
                    "zoom"
                ].forEach((e)=>{
                    t1[e] && (t1[e].value = 0);
                });
            }
            e.activeCamera = o;
        }),
        [`${Ym}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.activeVideoId = o.userId;
        }),
        [`${tg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isCurrentUserStartedVideo = o;
        }),
        [`${og}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.spotlightUserList = o;
        }),
        [`${rg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isCaptureForbidden = o;
        }),
        [`${ig}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.receivedVideoMaxQuality = o;
        }),
        [`${ng}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isVideoMuted = o;
        }),
        [`${sg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isCaptureCameraLoading = o;
        }),
        [`${ag}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isCameraTaken = o;
        }),
        [`${ug}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.receivedVideoDimension = o;
        }),
        [`${lg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.subscribedVideoList.includes(o) || e.subscribedVideoList.push(o);
        }),
        [`${cg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.subscribedVideoList.indexOf(o);
            r >= 0 && e.subscribedVideoList.splice(r, 1);
        }),
        [`${mg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.renderedVideoList.find((e)=>e.userId === o.userId && e.key === o.key && e.canvasId === o.canvasId);
            r ? (void 0 !== o.videoQuality && (r.videoQuality = o.videoQuality), void 0 !== o.aspectRatio && (r.aspectRatio = o.aspectRatio)) : e.renderedVideoList.push({
                ...o
            });
        }),
        [`${gg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.renderedVideoList.findIndex((e)=>e.userId === o.userId && e.key === o.key && e.canvasId === o.canvasId);
            r >= 0 && e.renderedVideoList.splice(r, 1);
        }),
        [`${pg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isFollowHostVideoLayout = o;
        }),
        [`${hg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.hostDragLayout = o;
        }),
        [`${vg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isSupportHDVideo = o;
        }),
        [`${fg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.maximumNumbeOfHDSubscriptions = o;
        }),
        [`${yg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.bCanUnmuteVideo = o;
        }),
        [`${Sg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.virtualBackground.isVBPreloadReady = o;
        }),
        [`${bg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.virtualBackground.isVBConfigured = o;
        }),
        [`${Eg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.virtualBackground.imageSrc = o.imageUrl, e.virtualBackground.cropped = o.cropped, e.backgroundMode = $d.VirtualBackground;
        }),
        [`${Cg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { encode: r, decode: i } = o;
            void 0 !== r && (e.hardwareAcceleration.encode = r), void 0 !== i && (e.hardwareAcceleration.decode = i);
        }),
        [`${Ig}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { data: { encoding: r, rate: i, ...n } } = o;
            e.statistic.encode = {
                bitrate: i,
                ...n
            };
        }),
        [`${Ag}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { data: { encoding: r, rate: i, ...n } } = o;
            e.statistic.decode = {
                bitrate: i,
                ...n
            };
        }),
        [`${_g}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { cameraId: r, captureWidth: i, captureHeight: n, videoElement: s, originalRatio: a, ptz: d, hd: u, fullHd: l, mediaFile: c, fps: p, mirrored: h } = o;
            e.activeCamera = r, e.customizedVideoOption = {
                captureWidth: i,
                captureHeight: n,
                videoElement: s,
                originalRatio: a,
                ptz: d,
                hd: u,
                fullHd: l,
                fps: p
            }, Zr(e.mediaPlaybackFile, c) || (e.mediaPlaybackFile = c, e.isUsingMediaPlayback = !(null == c || !c.url)), void 0 !== h && (e.isMirrored = !!h);
        }),
        [`${Rg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { userId: r, level: i, bwLevel: n, type: s } = o;
            if (Object.prototype.hasOwnProperty.call(e.networkQuality, `${r}`)) e.networkQuality[`${r}`][`${s}`] = {
                level: i,
                bwLevel: n
            };
            else {
                const t1 = {
                    [s]: {
                        level: i,
                        bwLevel: n
                    }
                };
                Object.assign(e.networkQuality, {
                    [`${r}`]: t1
                });
            }
        }),
        [`${wg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { deviceId: r, ptzRange: i } = o;
            if (Object.prototype.hasOwnProperty.call(e.ptz, r)) {
                const t1 = e.ptz[r];
                t1 && [
                    "pan",
                    "tilt",
                    "zoom"
                ].forEach((e)=>{
                    const o = i[e];
                    if (o) {
                        var r;
                        const i = null === (r = t1[e]) || void 0 === r ? void 0 : r.capability;
                        i ? Object.assign(i, {
                            ...o
                        }) : t1[e] = {
                            capability: {
                                ...o
                            },
                            value: 0
                        };
                    }
                });
            } else Object.assign(e.ptz, {
                [r]: {
                    pan: i.pan ? {
                        capability: {
                            ...i.pan
                        },
                        value: 0
                    } : null,
                    tilt: i.tilt ? {
                        capability: {
                            ...i.tilt
                        },
                        value: 0
                    } : null,
                    zoom: i.zoom ? {
                        capability: {
                            ...i.zoom
                        },
                        value: 0
                    } : null
                }
            });
        }),
        [`${Tg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.currentCameraControlStatus.isRequested = o;
        }),
        [`${Og}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { isInControl: r, userId: i } = o;
            e.currentCameraControlStatus.isInControl = r, e.currentCameraControlStatus.controllingUserId = i;
        }),
        [`${Dg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.farEndCameraControlStatus.controlledUserList.includes(o) || e.farEndCameraControlStatus.controlledUserList.push(o);
        }),
        [`${Pg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.farEndCameraControlStatus.controlledUserList.indexOf(o);
            -1 !== r && e.farEndCameraControlStatus.controlledUserList.splice(r, 1);
        }),
        [`${Mg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.currentCameraControlStatus.isCameraMoving = "start" === o.cmd;
        }),
        [`${kg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { constraints: r, deviceId: i } = o, n = e.ptz[i];
            [
                "pan",
                "tilt",
                "zoom"
            ].forEach((e)=>{
                void 0 !== r[e] && (n[e].value = r[e]);
            });
        }),
        [`${Lg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.farEndCameraControlStatus.isControlling = o;
        }),
        [`${Ng}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.networkQualityBroadcastTime = o;
        }),
        [`${Vg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.mask.isMaskConfigured = o;
        }),
        [`${jg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { imageUrl: r, cropped: i, rootHeight: n, rootWidth: s, clip: a } = o;
            e.mask.imageSrc = r, e.mask.cropped = i, e.mask.clip = a, e.mask.rootWidth = s, e.mask.rootHeight = n, e.backgroundMode = $d.Mask;
        }),
        [`${Ug}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.backgroundMode = o;
        }),
        [`${xg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.capturedVideoDimension = o;
        }),
        [`${Bg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.ensuredCanvas.includes(o) || e.ensuredCanvas.push(o);
        }),
        [`${Fg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.mediaPlaybackFile = o, e.isUsingMediaPlayback = !(null == o || !o.url);
        }),
        [`${Hg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            if (o) {
                const { lastCopy: t1, ...r } = o;
                e.prefetchedVideo = r;
            } else e.prefetchedVideo = o;
        }),
        [`${$g}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            Object.assign(e.subscriptionStatus, o);
        }),
        [`${Wg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isFullHDVideoEnabled = o;
        }),
        [`${Gg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { userId: r, element: i } = o, n = e.videoAttachments[`${r}`];
            if (n) -1 === n.indexOf(i) && n.push(i);
            else {
                const t1 = [];
                t1.push(i), Object.assign(e.videoAttachments, {
                    [`${r}`]: t1
                });
            }
        }),
        [`${Kg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { userId: r, element: i } = o, n = e.videoAttachments[`${r}`];
            let s = i;
            Array.isArray(i) || (s = [
                i
            ]), s.forEach((e)=>{
                if (n) {
                    const t1 = n.indexOf(e);
                    -1 !== t1 && n.splice(t1, 1);
                }
            });
        }),
        [`${zg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            o && (e.rendererType = Xd.WebGL2);
        }),
        [`${qg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            o && (e.rendererType = Xd.WebGPU);
        }),
        [`${Jg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.rendererType = o;
        }),
        [`${Qg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isMirrored = o;
        }),
        [`${Zg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.selfPreviewVideoList.includes(o) || e.selfPreviewVideoList.push(o);
        }),
        [`${Yg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            if (o) {
                const t1 = e.selfPreviewVideoList.indexOf(o);
                t1 >= 0 && e.selfPreviewVideoList.splice(t1, 1);
            } else e.selfPreviewVideoList = [];
        }),
        [`${Xg}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.leadershipUserId = o;
        }),
        [`${dg}`]: (e, t1)=>{
            let { payload: o } = t1;
            const r = {
                cameraDevicesList: e.cameraDevicesList
            };
            return o && Object.assign(r, {
                activeCamera: e.activeCamera,
                customizedVideoOption: e.customizedVideoOption,
                virtualBackground: {
                    imageSrc: e.virtualBackground.imageSrc,
                    cropped: e.virtualBackground.cropped
                },
                mask: {
                    imageSrc: e.mask.imageSrc,
                    cropped: e.mask.cropped,
                    rootWidth: e.mask.rootWidth,
                    rootHeight: e.mask.rootHeight,
                    clip: e.mask.clip
                },
                backgroundMode: e.backgroundMode,
                ptz: e.ptz,
                subscriptionStatus: e.subscriptionStatus
            }), {
                ...Cw,
                ...r
            };
        }
    }, Cw), Rw = {
        cameraPtzEpics0: (e, t1)=>nr(e, 8004).pipe(Fe((e)=>{
                const { payload: { body: { nCmd: o, nUserID: r, nReason: i, nButtonID: n } } } = e, s = t1.value, a = ph(s), { video: { currentCameraControlStatus: { isInControl: d, controllingUserId: u }, cameraDevicesList: l, activeCamera: c } } = s, p = a.find((e)=>Yr(e.userId, r)), h = [];
                if (h.push(Tg(!0)), o === Ud.Request) {
                    const e = {
                        userId: null == p ? void 0 : p.userId,
                        displayName: null == p ? void 0 : p.displayName
                    };
                    if (d) {
                        const t1 = a.find((e)=>e.userId === u);
                        Object.assign(e, {
                            currentControllingUserId: null == t1 ? void 0 : t1.userId,
                            currentControllingDisplayName: null == t1 ? void 0 : t1.displayName
                        });
                    }
                    tp(Ru, e);
                } else if (o === Ud.Approve) h.push(Dg(null == p ? void 0 : p.userId)), tp(wu, {
                    isApproved: !0,
                    userId: null == p ? void 0 : p.userId,
                    displayName: null == p ? void 0 : p.displayName
                });
                else if (o === Ud.Decline) h.push(Pg(null == p ? void 0 : p.userId)), tp(wu, {
                    isApproved: !1,
                    userId: null == p ? void 0 : p.userId,
                    displayName: null == p ? void 0 : p.displayName,
                    reason: i
                });
                else if (o === Ud.GiveUp) h.push(Og({
                    isInControl: !1,
                    userId: 0
                })), tp(Tu, {
                    isControlled: !1
                });
                else if (o === Ud.StartControl || o === Ud.StopControl) h.push(Mg({
                    cmd: o === Ud.StartControl ? "start" : "stop",
                    type: n
                }));
                else if (o === Ud.SwitchCamera) {
                    const e = l.findIndex((e)=>e.deviceId === c), t1 = e + 1 === l.length ? 0 : e + 1;
                    if (t1 !== e) {
                        const e = l[t1].deviceId;
                        Aw.changeCamera(e, Td.includes(e));
                    }
                }
                return _e(h);
            })),
        cameraPtzEpics1: (e, t1)=>nr(e, Ps).pipe(ot((e)=>{
                var t1;
                const { payload: { body: o } } = e;
                return null == o || null === (t1 = o.update) || void 0 === t1 ? void 0 : t1.some((e)=>void 0 !== e.nFECC || void 0 !== e.nFECCExecutive);
            }), vt((e)=>{
                const { payload: { body: { update: o } } } = e, r = o.find((e)=>void 0 !== e.nFECC || void 0 !== e.nFECCExecutive);
                if (r) {
                    const { meeting: { userId: e } } = t1.value;
                    Yr(r.nFECCExecutive, e) && tp(Ou, {
                        userId: r.id,
                        ptz: sw(r.nFECC)
                    });
                }
            }), ut(ne)),
        cameraPtzEpics2: (e, t1)=>nr(e, Ps).pipe(ot((e)=>{
                var o;
                const { payload: { body: r } } = e, { video: { farEndCameraControlStatus: { controlledUserList: i } } } = t1.value;
                return null == r || null === (o = r.remove) || void 0 === o ? void 0 : o.some((e)=>i.includes(e.id));
            }), Fe((e)=>{
                var o;
                const { payload: { body: r } } = e, i = [], { video: { farEndCameraControlStatus: { controlledUserList: n } } } = t1.value, s = null == r || null === (o = r.remove) || void 0 === o ? void 0 : o.find((e)=>n.includes(e.id));
                return s && i.push(Pg(s.id)), _e(i);
            })),
        cameraPtzEpics3: (e, t1)=>e.pipe(Dt(`${Mg}`), ht((e)=>{
                const { payload: { cmd: o, type: r } } = e;
                return "start" === o ? Ze(0, 200).pipe(gt(()=>!!t1.value.video.currentCameraControlStatus.isCameraMoving), Fe(()=>{
                    const { video: { ptz: e, activeCamera: o } } = t1.value, i = e[o], n = nw(i) || {}, { key: s, range: a } = iw(r, 2);
                    return i[s] ? (Object.assign(n, {
                        [s]: rw(i[s].capability, i[s].value, a)
                    }), Aw.movePTZCamera(n).then(()=>kg({
                            deviceId: o,
                            constraints: n
                        }))) : Promise.resolve(void 0);
                }), Fe((e)=>"object" == typeof e && void 0 !== e.type ? Re(e) : ne)) : ne;
            })),
        cameraPtzEpics4: (e, t1)=>e.pipe(Dt(`${eg}`), Fe((e)=>{
                const { payload: o } = e, { video: { customizedVideoOption: r, ptz: i } } = t1.value;
                if (null != r && r.ptz) {
                    const e = null == i ? void 0 : i[o];
                    void 0 !== e && Iw.sendCameraAblity({
                        pan: !!e.pan,
                        tilt: !!e.tilt,
                        zoom: !!e.zoom
                    });
                }
                return ne;
            }))
    }, ww = {
        videoCaptureEpics0: (e, t1)=>ur(e, sd.StartVideoCaptureSuccess).pipe(Zy(async (e)=>{
                const { video: { activeCamera: o, ptz: r, isCurrentUserStartedVideo: i, isUsingMediaPlayback: n }, meeting: { userId: s } } = t1.value, { payload: { data: { currentDeviceID: a, PTZRange: d, VideoSelectValue: u, usingFacingMode: l } } } = e, c = [], { cameras: p } = await Oe(_y());
                if (p.length < 1 && !n && (tp(du, {
                    reason: "Cannot detect camera devices"
                }), Ew.stopCaptureVideo()), ew(o, p) || n) {
                    let e = "";
                    if (e = l ? Array.isArray(u) && u[0] ? u[0] : u : a, i || bw.muteAttendeeVideo(s, !1), tp(Pu), n) c.push(eg("default"));
                    else if (e && d && c.push(wg({
                        deviceId: e,
                        ptzRange: d
                    })), o !== e && c.push(eg(e)), Object.prototype.hasOwnProperty.call(r, e)) {
                        const t1 = r[e];
                        if (t1) {
                            const e = nw(t1);
                            e && Ew.movePTZCamera(e);
                        }
                    }
                } else tp(uu, {
                    reason: "cannot find target camera"
                }), Ew.stopCaptureVideo();
                return c;
            })),
        videoCaptureEpics1: (e, t1)=>nr(e, Ps).pipe(ot((e)=>{
                const { payload: { body: { update: o } } } = e, { meeting: { userId: r } } = t1.value;
                return null == o ? void 0 : o.some((e)=>e.id === r && void 0 !== e.bVideoOn);
            }), Le((e)=>{
                const { payload: { body: { update: o } } } = e, { meeting: { userId: r } } = t1.value, i = o.find((e)=>e.id === r);
                return !0 === i.bVideoOn ? tp(mu) : tp(gu), tg(!!i.bVideoOn);
            })),
        videoCaptureEpics2: (e)=>ur(e, [
                sd.UserForbiddedCaptureVideo,
                sd.UserCameraIsTakenByOtherPrograms,
                sd.VideoWebsocketBroken,
                sd.StopVideoCaptureFailed
            ]).pipe(Fe((e)=>{
                const { payload: { type: t1 } } = e, o = [];
                switch(t1){
                    case sd.UserForbiddedCaptureVideo:
                        tp(lu), o.push(rg(!0));
                        break;
                    case sd.UserCameraIsTakenByOtherPrograms:
                        tp(cu, {
                            reason: "User camera is taken by other programs."
                        }), o.push(ag(!0));
                        break;
                    case sd.VideoWebsocketBroken:
                        tp(hu, {
                            reason: "Video websocket broken."
                        });
                        break;
                    case sd.StopVideoCaptureFailed:
                        tp(gu, {
                            failed: !0,
                            reason: "Unknown."
                        });
                }
                return _e(o);
            })),
        videoCaptureEpics3: (e, t1)=>ur(e, sd.StopVideoCaptureSuccess).pipe(ft(t1), Le((e)=>{
                let [, t1] = e;
                const { meeting: { userId: o }, video: { isCurrentUserStartedVideo: r } } = t1;
                return r || tp(gu), bw.muteAttendeeVideo(o, !0), sg(!1);
            })),
        videoCaptureEpics4: (e, t1)=>nr(e, 16133).pipe(ft(t1), ot((e)=>{
                var t1;
                let [o, r] = e;
                return (null == o || null === (t1 = o.payload) || void 0 === t1 || null === (t1 = t1.body) || void 0 === t1 ? void 0 : t1.id) === r.meeting.userId;
            }), Jy((e)=>{
                let [t1] = e;
                const { id: o, bVideoMute: r } = t1.payload.body;
                return tp(iu, {
                    id: o,
                    isVideoMuted: r
                }), !0 === r && Ew.stopCaptureVideo(), !1 === r && tp(nu, {
                    id: o,
                    isVideoMuted: r
                }), ng(r);
            })),
        videoCaptureEpics5: (e, t1)=>nr(e, 16131).pipe(ot((e)=>void 0 !== e.payload.body.ssrc), ht((e)=>{
                const { payload: { body: { ssrc: o } } } = e;
                return tp(ku, o), Xe(Re(Zm(o)), Ay(t1).pipe(Fe((e)=>{
                    const { meeting: { isCurrentUserStartVideoBeforeReset: o }, media: { videoEncodeStatus: r } } = t1.value;
                    return !0 !== (null == e ? void 0 : e.bVideoOn) && !0 === o ? Iy("video", r, "success").pipe(ot((e)=>{
                        let [t1, o] = e;
                        return t1 && o;
                    }), Le(()=>{
                        const e = t1.value, { video: { backgroundMode: o, mask: r, virtualBackground: i, activeCamera: n, customizedVideoOption: s } } = e;
                        let a = Promise.resolve(!0);
                        return o === $d.VirtualBackground && i.imageSrc ? a = yw({
                            imageUrl: i.imageSrc,
                            cropped: i.cropped
                        }, Ew, e) : o === $d.Mask && r.imageSrc && r.clip && (a = Sw({
                            imageUrl: r.imageSrc,
                            cropped: r.cropped,
                            clip: r.clip,
                            rootHeight: r.rootHeight,
                            rootWidth: r.rootWidth
                        }, Ew, e)), a.then(()=>{
                            ow(Ew, e, {
                                cameraId: n,
                                ...s
                            });
                        }), Mn(void 0);
                    })) : ne;
                })));
            })),
        videoCaptureEpics6: (e, t1)=>e.pipe(Dt(`${Xm}`), vt((e)=>{
                const { payload: o } = e, r = t1.value, { meeting: { userId: i } } = r, n = ah(r);
                0 === o.length ? n && !n.bVideoConnect || bw.connectCamera(i, !1) : null != n && n.bVideoConnect || bw.connectCamera(i, !0);
            }), ut(ne)),
        videoCaptureEpics7: (e)=>ur(e, sd.InitSuccessVideo).pipe(ot((e)=>!gs.isIPad && gs.isAndroidOrIOSBrowser && e.payload.data === ad.EncodeSuccess), ht(()=>$y().pipe(vt((e)=>{
                    Ew.setMobileRotateMode(e);
                }), st()))),
        videoCaptureEpics8: (e)=>ur(e, sd.StartVideoCaptureSuccess).pipe(ot(()=>!gs.isIPad && gs.isAndroidOrIOSBrowser), vt(()=>{
                Ew.setMobileRotateMode(Hy());
            }), ut(ne)),
        videoCaptureEpics9: (e, t1)=>ur(e, sd.VideoStreamFailed).pipe(ot(()=>!!t1.value.video.isCurrentUserStartedVideo && gs.isIOSMobile), vt(()=>{
                Ew.stopCaptureVideo();
            }), Fe(()=>ne)),
        videoCaptureEpics10: (e)=>nr(e, 24322).pipe(vt((e)=>{
                const { payload: t1 } = e;
                Ew.passThroughRWGMessage(t1);
            }), Fe(()=>ne))
    }, Tw = {
        videoRenderEpics0: (e)=>nr(e, 16129).pipe(Le((e)=>{
                const { payload: { body: { id: t1, bVideoOn: o } } } = e, r = ZR(t1);
                return tp(ru, {
                    bVideoOn: o,
                    userId: r
                }), Ym({
                    bVideoOn: o,
                    userId: r
                });
            })),
        videoRenderEpics1: (e, t1)=>ur(e, sd.VideoDecodeMaxSize).pipe(ot((e)=>{
                var t1;
                return null == e || null === (t1 = e.payload) || void 0 === t1 ? void 0 : t1.data;
            }), Le((e)=>{
                const { size: o } = e.payload.data, { video: { renderedVideoList: r, receivedVideoMaxQuality: i }, meeting: { userId: n } } = t1.value, s = r.filter((e)=>e.videoQuality >= Sd.Video_720P && e.userId !== n);
                return i !== o && s.length > 0 && (o >= Sd.Video_720P || i >= Sd.Video_720P) && s.forEach((e)=>{
                    uw.subscribeVideo(e.userId, e.videoQuality, !1);
                }), ig(o);
            })),
        videoRenderEpics2: (e)=>nr(e, 16135).pipe(Fe((e)=>{
                const { payload: { body: { bLeadershipOn: t1, id: o } } } = e, r = [], i = [], n = t1 ? ZR(o) : 0;
                return t1 && i.push(n), r.push(og(i), Xg(n)), rt(np(vu, 1), Ze(2e3).pipe(Le(()=>({
                        leadershipEventOnly: !0
                    })))).subscribe((e)=>{
                    const { spotlightList: o, leadershipEventOnly: r } = e;
                    t1 ? 1 === (null == o ? void 0 : o.length) && i[0] === (null == o ? void 0 : o[0]) || tp(Nu, {
                        spotlightList: o
                    }) : (r || 0 === (null == o ? void 0 : o.length)) && tp(Nu, {
                        spotlightList: []
                    });
                }), _e(r);
            })),
        videoRenderEpics3: (e, t1)=>nr(e, 7958).pipe(ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { payload: { body: r } } = t1;
                let i = [];
                r && r.group_list && r.group_list[0] && (i = r.group_list[0].map((e)=>e.id));
                const n = ph(o);
                return n.length > 0 && (i = i.filter((e)=>n.findIndex((t1)=>t1.userId === e) >= 0)), tp(vu, {
                    spotlightList: i
                }), og(i);
            })),
        videoRenderEpics4: (e)=>ur(e, sd.CurrentVideoResolution).pipe(Jy((e)=>(tp(su, e.payload.data), ug(e.payload.data)))),
        videoRenderEpics5: (e)=>ur(e, [
                sd.CurrentVideoResolution,
                sd.CurrentCaptureVideoWidthHeight
            ]).pipe(ot((e)=>!!e.payload.data), Le((e)=>{
                const { payload: { data: t1, type: o } } = e;
                return o === sd.CurrentVideoResolution ? (tp(su, t1), ug(t1)) : (tp(au, t1), xg(t1));
            })),
        videoRenderEpics6: (e)=>nr(e, Ms).pipe(ot((e)=>{
                const { payload: { body: t1 } } = e;
                return [
                    "bFollowHostVideo",
                    "VideoHd",
                    "bCanUnmuteVideo"
                ].some((e)=>void 0 !== t1[e]);
            }), Le((e)=>{
                const { payload: { body: { bFollowHostVideo: t1, VideoHd: o, bCanUnmuteVideo: r } } } = e;
                if (void 0 !== t1) return tp(fu, {
                    bOn: t1
                }), pg(t1);
                if (void 0 !== r) return yg(r);
                {
                    const e = 1 === o;
                    return lw.updateVideoHDValue(e), lw.enableHardwareAccelerationForVideoEncode(!1), vg(e);
                }
            })),
        videoRenderEpics7: (e, t1)=>nr(e, 7957).pipe(ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { video: { isFollowHostVideoLayout: r } } = o, { payload: { body: i } } = t1, n = i && i.drag_list && i.drag_list.map((e)=>e.id);
                return r && tp(yu, {
                    layout: n
                }), hg(n);
            })),
        videoRenderEpics8: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                const { meeting: { userId: r }, video: { subscribedVideoList: i } } = o, n = t1.payload.body.update, s = t1.payload.body.remove;
                return n && n.length > 0 && n.findIndex((e)=>e.id !== r && (void 0 !== e.bVideoOn || e.bHold)) > -1 || s && s.some((e)=>i.includes(e.id));
            }), vt((e)=>{
                let [t1, o] = e;
                const { payload: { body: { remove: r, update: i } } } = t1, { video: { subscribedVideoList: n } } = o, s = ch(o);
                if (r && r.length > 0 && r.filter((e)=>n.includes(e.id)).forEach((e)=>{
                    tp(bu, {
                        userId: e.id
                    });
                }), i && i.length > 0) {
                    const e = i.filter((e)=>void 0 !== e.bVideoOn).filter((e)=>-1 === s.findIndex((t1)=>t1.userId === e.id)), t1 = i.filter((e)=>!0 === e.bHold);
                    t1.length > 0 && t1.filter((e)=>n.includes(e.id)).forEach((e)=>{
                        tp(bu, {
                            userId: e.id
                        });
                    }), e.forEach((e)=>{
                        e.bVideoOn ? tp(Su, {
                            userId: e.id
                        }) : n.includes(e.id) && tp(bu, {
                            userId: e.id
                        });
                    });
                }
            }), ut(ne)),
        videoRenderEpics9: (e, t1)=>ur(e, sd.VideoQosData).pipe(ft(t1), Le((e)=>{
                var t1;
                let [o, r] = e;
                const { video: { isCaptureForbidden: i, isCameraTaken: n }, media: { videoEncodeStatus: s, videoDecodeStatus: a } } = r, d = ah(r), u = vh(r), l = u.length > 0, c = (null == d ? void 0 : d.bVideoOn) && !i && !n, p = u.some((e)=>e.bVideoOn), h = "success" === s && c && l, m = "success" === a && l && p;
                return null !== (t1 = o.payload.data) && void 0 !== t1 && t1.encoding ? h ? (tp(Au, o.payload), Ig(o.payload)) : Ig(Vd) : m ? (tp(Au, o.payload), Ag(o.payload)) : Ag(Vd);
            })),
        videoRenderEpics10: (e, t1)=>ur(e, [
                sd.CurrentDecodeVideoQuality,
                sd.CurrentDecodeVideoFps
            ]).pipe(vt((e)=>{
                const { payload: { type: o, data: r } } = e, { video: { subscriptionStatus: i } } = t1.value;
                if (i.detailed) {
                    if (o === sd.CurrentDecodeVideoQuality) {
                        const { ssrc: e, width: t1, height: o, quality: i } = r;
                        tp(Cu, {
                            userId: e,
                            width: t1,
                            height: o,
                            quality: i
                        });
                    } else if (o === sd.CurrentDecodeVideoFps) {
                        const { ssrc: e, fps: t1 } = r;
                        tp(Cu, {
                            userId: e,
                            fps: t1
                        });
                    }
                }
            }), ut(ne)),
        videoRenderEpics11: (e, t1)=>lr(e, t1).pipe(Fe(async ()=>gs.isAndroidOrIOSBrowser ? 1 : await ca.isSupportVideoDecodeHardwareAcceleration() ? 4 : 1), Le((e)=>fg(e))),
        videoRenderEpics12: (e, t1)=>ur(e, [
                sd.NetworkQualityChange,
                sd.NetworkQualityChangeAudio
            ]).pipe(ot((e)=>!!e.payload.data), Fe((e)=>{
                var o;
                const { payload: { data: { bwLevel: r, isUplink: i, networkLevel: n } } } = e, s = [], { meeting: { userId: a }, video: { networkQuality: d, subscribedVideoList: u, networkQualityBroadcastTime: l } } = t1.value, c = i ? "uplink" : "downlink";
                s.push(Rg({
                    userId: a,
                    level: n,
                    bwLevel: r,
                    type: c
                }));
                const p = Zr(null === (o = d[`${a}`]) || void 0 === o ? void 0 : o[c], {
                    level: n,
                    bwLevel: r
                });
                if (!p && -1 !== n) {
                    (!i && u.filter((e)=>e !== a).length > 0 || i) && tp(_u, {
                        userId: a,
                        type: c,
                        level: n
                    });
                }
                if (i) {
                    const e = performance.now();
                    (!p || e - (null != l ? l : 0) > 3e4) && (uw.broadcastUserNetworkQuality({
                        isUplink: i,
                        level: n,
                        bwLevel: r
                    }), s.push(Ng(e)));
                }
                return _e(s);
            })),
        videoRenderEpics13: (e, t1)=>dr(e, 8005).pipe(ot((e)=>{
                var t1;
                return !(null === (t1 = e.payload.body) || void 0 === t1 || !t1.nUserID);
            }), Fe((e)=>{
                const { payload: { body: { nLevel: o, nUserID: r } } } = e, { video: { networkQuality: i } } = t1.value, n = i[`${r}`], s = [];
                return n && n.uplink.level === o || (tp(_u, {
                    userId: r,
                    level: o,
                    type: "uplink"
                }), s.push(Rg({
                    userId: r,
                    level: o,
                    type: "uplink"
                }))), _e(s);
            })),
        videoRenderEpics14: (e, t1)=>nr(e, Ps).pipe(ot((e)=>{
                const { payload: { body: o } } = e, { video: { prefetchedVideo: r } } = t1.value;
                return (null == r ? void 0 : r.userId) && (o.update || o.remove);
            }), Fe((e)=>{
                const { payload: { body: o } } = e, r = [], { video: { prefetchedVideo: i } } = t1.value;
                let n = !1;
                return o.remove && (n = -1 !== o.remove.findIndex((e)=>e.id === (null == i ? void 0 : i.userId))), o.update && (n = -1 !== o.update.findIndex((e)=>e.id === (null == i ? void 0 : i.userId) && !1 === e.bVideoOn)), n && i && (i.loaded || lw.cancelPrefetchVideoSsrc(i.userId), uw.unsubscribeVideo(i.userId), r.push(Hg(void 0))), _e(r);
            })),
        videoRenderEpics15: (e, t1)=>e.pipe(Dt(`${Hg}`), ot((e)=>!!e.payload), vt((e)=>{
                const { payload: { lastCopy: o } } = e, { video: { prefetchedVideo: r } } = t1.value;
                !r || o && o.userId === r.userId || (null != o && o.userId && (o.loaded && lw.cancelPrefetchVideoSsrc(o.userId), uw.unsubscribeVideo(o.userId)), uw.subscribeVideo(r.userId, Sd.Video_360P, !1), lw.prefetchVideoSsrc(r.userId));
            }), ut(ne)),
        videoRenderEpics16: (e, t1)=>ur(e, sd.NewActiveSpeakerFirstFrameCallback).pipe(ot(()=>!!t1.value.video.prefetchedVideo), Fe((e)=>{
                const { payload: { data: { ssrc: o } } } = e, { video: { prefetchedVideo: r } } = t1.value, i = [];
                return r && (Yr(r.userId, o) ? (i.push(Hg({
                    userId: r.userId,
                    loaded: !0,
                    lastCopy: r
                })), tp(Mu, {
                    userId: r.userId
                })) : uw.unsubscribeVideo(r.userId)), _e(i);
            })),
        videoRenderEpics17: (e, t1)=>nr(e, 16131).pipe(ot((e)=>void 0 !== e.payload.body.ssrc), vt(()=>{
                const { media: { videoDecodeStatus: e, videoEncodeStatus: o } } = t1.value;
                Iy("video", o, e).subscribe((e)=>{
                    let [o, r] = e;
                    const { video: { subscriptionStatus: i } } = t1.value;
                    o && i.encode && lw.subscribeToQos([
                        ua.VideoEncode
                    ], Od), r && (i.decode && lw.subscribeToQos([
                        ua.VideoDecode
                    ], Od), i.detailed && lw.enableVideoObserver(!0));
                });
            }), ut(ne)),
        videoRenderEpics18: (e, t1)=>e.pipe(Dt(`${mg}`, `${gg}`), ot(()=>{
                const e = t1.value.video.renderedVideoList.length;
                return [
                    0,
                    1
                ].includes(e);
            }), vt(()=>{
                const e = t1.value.video.renderedVideoList.length;
                1 === e ? lw.enableVideoObserver(!0, !0) : 0 === e && lw.enableVideoObserver(!1);
            }), ut(ne)),
        videoRenderEpics19: (e, t1)=>ur(e, sd.CurrentDecodeVideoQuality).pipe(Fe((e)=>{
                const { payload: { data: o } } = e, { video: { renderedVideoList: r, videoAttachments: i } } = t1.value, n = [], { ssrc: s, width: a, height: d } = o, u = d ? a / d : 0, l = r.filter((e)=>Yr(e.userId, s));
                if (l.some((e)=>e.aspectRatio && Math.abs(e.aspectRatio - u) > .2)) {
                    const e = l.filter((e)=>e.canvasId === kd);
                    if (e.length > 0) {
                        const e = i[`${s}`];
                        e && e.every((e)=>{
                            if (e) {
                                const { clientWidth: t1, clientHeight: o } = e, r = o ? t1 / o : 0;
                                return Math.abs(r - u) <= .2;
                            }
                            return !0;
                        }) && n.push(mg({
                            userId: s,
                            key: Pd,
                            canvasId: kd,
                            aspectRatio: u
                        }));
                    }
                    e.length === l.length && 0 !== n.length || tp(Lu, {
                        userId: s,
                        aspectRatio: u
                    });
                }
                return _e(n);
            })),
        videoRenderEpics20: (e, t1)=>ur(e, sd.SyncRendererTypeResponse).pipe(Fe((e)=>{
                const { payload: { data: { rendererType: o } } } = e, { video: { rendererType: r } } = t1.value, i = [];
                return r !== o && i.push(Jg(o)), _e(i);
            }))
    }, Ow = ir(Tw, ww, {
        vbEpics0: (e)=>ur(e, [
                sd.VbModelPreloadingOk,
                sd.VbModelPreloading_3S,
                sd.VbModelPreloading_10S,
                sd.VbSettingParaError
            ]).pipe(Fe((e)=>{
                const { payload: { type: t1, data: o } } = e, r = [];
                return [
                    sd.VbModelPreloadingOk,
                    sd.VbModelPreloading_3S,
                    sd.VbModelPreloading_10S
                ].includes(t1) ? (r.push(Sg(!0)), tp(Eu, !0), t1 === sd.VbModelPreloading_10S && console.warn("Virtual Background is taking longer than expected to load.")) : t1 === sd.VbSettingParaError && (o === _d.VBModelNotMatch ? (tp(Eu, !1), r.push(Sg(!1))) : (tp(Iu, !1), r.push(bg(!1)))), _e(r);
            })),
        vbEpics1: (e)=>ur(e, sd.StartVideoStreamInVbSettingSuccess).pipe(Le(()=>(tp(Iu, !0), bg(!0)))),
        vbEpics2: (e)=>ur(e, sd.StartVideoStreamInMaskSettingSuccess).pipe(Le(()=>(tp(Du, !0), Vg(!0)))),
        vbEpics3: (e)=>ur(e, sd.MaskSettingParaError).pipe(Le(()=>(tp(Du, !1), Vg(!1))))
    }, Rw);
    class Dw {
        constructor(){
            this.assetsPath = void 0, this.instance = void 0, this.callbackList = void 0, this.mediaWorkersPath = void 0, this.mediaOptions = void 0, this.inProgress = void 0, this.callbackList = [];
        }
        static getInstance() {
            return void 0 === this.agentInstance && (this.agentInstance = new Dw), this.agentInstance;
        }
        init(e, t1) {
            var o, r, i, n, s;
            if (!this.instance && window.JsMediaSDK_Instance) {
                const e = {
                    ivObj: {
                        [Is.AUDIO_ENCODE]: void 0,
                        [Is.VIDEO_ENCODE]: void 0,
                        [Is.SHARING_ENCODE]: void 0
                    }
                };
                this.instance = new window.JsMediaSDK_Instance(e);
            }
            this.mediaWorkersPath = da(e, !1), this.onMediaSDKCallback = this.onMediaSDKCallback.bind(this), this.mediaOptions = t1, null === (o = this.instance) || void 0 === o || o.JsMediaSDK_PreLoad(this.mediaWorkersPath, this.onMediaSDKCallback, t1);
            const a = Ss(null === (r = this.mediaOptions) || void 0 === r ? void 0 : r.enableMultiDecodeVideoWithoutSAB);
            null === (i = this.instance) || void 0 === i || i.setPropsBeforeInit({
                callback: this.onMediaSDKCallback,
                audioWorkerPath: null === (n = this.mediaWorkersPath) || void 0 === n ? void 0 : n.audioWorkletPath,
                isEnableListenInitEvent: !0
            }), null === (s = this.instance) || void 0 === s || s.initVideoEncode(this.mediaWorkersPath, "", 0, !1, "", 0, a, !1, !1, !0, !0, !1, !0), this.inProgress = !0;
        }
        onMediaSDKCallback(e, t1) {
            this.callbackList.length > 0 && this.callbackList.forEach((o)=>o(e, t1));
        }
        registerCallback(e) {
            this.callbackList.push(e);
        }
        unregisterCallback(e) {
            this.callbackList = this.callbackList.filter((t1)=>t1 !== e);
        }
        async destroy() {
            var e;
            this.callbackList = [], await (null === (e = this.instance) || void 0 === e ? void 0 : e.destroy()), this.instance = null, this.inProgress = !1;
        }
        disconnect() {
            var e, t1;
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(17, {}), null === (t1 = this.instance) || void 0 === t1 || t1.JsMediaSDK_UnInit();
        }
        startVirtualBackgroundSetting(e, t1, o, r, i, n) {
            var s;
            let a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
            null === (s = this.instance) || void 0 === s || s.Notify_MeidaSDK(91, {
                canvas: e,
                bgdom: t1,
                width: i,
                height: n,
                ssid: 0,
                VideoSelectValue: "default" === r ? null : r,
                disableOriginalRatio: a,
                usingFacingMode: [
                    "user",
                    "environment"
                ].includes(r)
            });
        }
        updateVirtualBackgroundImage(e) {
            var t1;
            null === (t1 = this.instance) || void 0 === t1 || t1.Notify_MeidaSDK(92, {
                bgdom: e
            });
        }
        stopVirtualBackgroundSetting() {
            var e;
            let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(93, {
                isSwitch: t1
            });
        }
        startMaskSetting(e, t1, o, r, i, n, s, a, d) {
            var u;
            null === (u = this.instance) || void 0 === u || u.Notify_MeidaSDK(62, {
                canvas: e,
                maskdom: null,
                bgdom: null,
                dx: 0,
                dy: 0,
                dWidth: 170,
                dHeight: 170,
                width: 1280,
                height: 720,
                ssid: 0,
                originWidth: 379,
                originHeight: 213,
                VideoSelectValue: "default" === i ? null : i,
                usingFacingMode: [
                    "user",
                    "environment"
                ].includes(i)
            });
        }
        stopMaskSetting() {
            var e;
            let t1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            null === (e = this.instance) || void 0 === e || e.Notify_MeidaSDK(65, {
                isSwitch: t1
            });
        }
    }
    Dw.agentInstance = void 0;
    const Pw = "PREVIEW_VIDEO_ENCODE_SUCCESS", Mw = "PREVIEW_VIDEO_VB_MODEL_READY";
    async function kw(e, t1, o, r) {
        const { imageUrl: i, cropped: n, deviceId: s } = o, a = ei("__ZOOM_SDK_PREVIEW_VIRTUAL_BACKGROUND_CANVAS_@__");
        t1.id || (t1.id = a);
        let [d, u] = [
            640,
            360
        ];
        if (ca.isSupportSending720P() && (d = 1280, u = 720), i && My(r)) {
            const o = await mw(i, n);
            return e.startVirtualBackgroundSetting(t1, o, 0, null != s ? s : "default", d, u), o && o !== Rd && setTimeout(()=>{
                hr(o);
            }, 0), "vb";
        }
        return e.startMaskSetting(t1, null, null, 0, null != s ? s : "default", 0, 0, 0, 0), "mask";
    }
    class Lw {
        constructor(){
            this.previewMediaAgent = Dw.getInstance(), this.state = void 0, this.eventHandler = (e, t1)=>{
                switch(e){
                    case sd.InitSuccessVideo:
                        t1 === ad.EncodeSuccess && (Lw.isVideoEncoded = !0, tp(Pw));
                        break;
                    case sd.VbModelPreloadingOk:
                    case sd.VbModelPreloading_3S:
                    case sd.VbModelPreloading_10S:
                        Lw.isVBModelReady = !0, tp(Mw, !0);
                        break;
                    case sd.VbSettingParaError:
                        t1 === _d.VBModelNotMatch && (Lw.isVBModelReady = !1, tp(Mw, !1));
                }
            };
        }
        static setMediaOption(e) {
            Lw.mediaOption = e;
        }
        setup() {
            if (Lw.mediaOption) {
                if (ca.getInstance().inProgress) return Promise.resolve("");
                if (!Dw.getInstance().inProgress) {
                    Lw.isVideoEncoded = void 0, Lw.isVBModelReady = void 0, this.previewMediaAgent.unregisterCallback(this.eventHandler);
                    const { assetsPath: e, enforceMultipleVideos: t1, enforceVirtualBackground: o } = Lw.mediaOption, r = {
                        ...Ny(e, t1, o)
                    };
                    this.previewMediaAgent.init(e, r), this.previewMediaAgent.registerCallback(this.eventHandler);
                }
                return Promise.resolve("");
            }
            return Promise.reject({
                type: Kl,
                reason: "Cannot preview video with virtual background before `client.init` method."
            });
        }
        async startPreview(e, t1) {
            if (ca.getInstance().inProgress) {
                var o;
                kw(ca.getInstance(), e, t1, null === (o = Lw.mediaOption) || void 0 === o ? void 0 : o.enforceVirtualBackground);
            } else {
                var r;
                let o;
                o = t1.imageUrl ? void 0 !== Lw.isVBModelReady ? _e([
                    Lw.isVBModelReady
                ]) : np(Mw, 1).pipe(Le(()=>!0)) : _e([
                    !0
                ]), null === (r = o) || void 0 === r || r.subscribe((o)=>{
                    o && (Lw.isVideoEncoded ? _e([
                        !0
                    ]) : np(Pw, 1)).subscribe(()=>{
                        var o;
                        kw(Dw.getInstance(), e, t1, null === (o = Lw.mediaOption) || void 0 === o ? void 0 : o.enforceVirtualBackground).then((o)=>{
                            this.state = {
                                mode: o,
                                canvas: e,
                                vb: t1
                            };
                        });
                    });
                });
            }
        }
        async stopPreview() {
            var e;
            ca.getInstance().inProgress ? ca.getInstance().stopVirtualBackgroundSetting() : "vb" === (null === (e = this.state) || void 0 === e ? void 0 : e.mode) ? Dw.getInstance().stopVirtualBackgroundSetting() : Dw.getInstance().stopMaskSetting();
        }
        async updatePreview(e, t1) {
            const o = ca.getInstance().inProgress ? ca.getInstance() : Dw.getInstance();
            var r;
            if (e) if ("mask" === (null === (r = this.state) || void 0 === r ? void 0 : r.mode)) {
                var i;
                gs.isChrome ? (await this.stopPreview(), await this.startPreview(this.state.canvas, {
                    imageUrl: e,
                    cropped: t1,
                    deviceId: null === (i = this.state.vb) || void 0 === i ? void 0 : i.deviceId
                })) : console.warn('use the `start` method with the virtual background image parameter instead of using `updateVirtualBackground` to preview the video." ');
            } else {
                const r = await mw(e, t1);
                r && (o.updateVirtualBackgroundImage(r), r !== Rd && setTimeout(()=>{
                    hr(r);
                }, 0));
            }
            else o.updateVirtualBackgroundImage(null);
        }
    }
    Lw.mediaOption = void 0, Lw.isVideoEncoded = void 0, Lw.isVBModelReady = void 0;
    const { InitSuccessVideo: Nw, InitSuccessAudio: Vw, InitSuccessSharing: Uw, InitFailedVideo: jw, InitFailedAudio: xw, InitFailedSharing: Bw, SharingHealthCheckFailed: Fw, VideoHealthCheckFailed: Hw, AudioHealthCheckFailed: $w, AudioStreamMuted: Ww } = sd, Gw = yE(ca.getInstance()), Kw = hE.getInstance(), zw = Kw.makeLogger([
        "Media Agent"
    ]), qw = [], Jw = {
        epics0: (e, t1)=>e.pipe(Dt(`${pn}`), ht(()=>{
                const { meeting: { isMeetingReset: o } } = t1.value;
                return e.pipe(mt(e.pipe(Dt(`${Ao}`), ot((e)=>{
                    var t1;
                    return !(null !== (t1 = e.payload) && void 0 !== t1 && t1.retry);
                }), nt(1))), Dt(`${bn}`), nt(1), Zy((e)=>{
                    var r;
                    const { logger: i, media: { mediaConstraints: n, assetsPath: s }, meeting: { zlkJwtToken: a, cv: d } } = t1.value, { payload: { disableAqos: u, disableVqos: l } } = e, c = null != i && null !== (r = i.options) && void 0 !== r && r.enable ? hE.getInstance().makeLogger([
                        "MEDIA SDK"
                    ]) : void 0;
                    return (function(e) {
                        const { media: { patchedMediaSDKStatus: t1 } } = e;
                        return t1 === Qd.Loading ? Oe(np(cc, 1)) : Promise.resolve();
                    })(t1.value).then(()=>{
                        const e = [];
                        let t1 = !l;
                        const r = !u;
                        return a && Jr(d, "1.3.0") < 0 && (t1 = !1), e.push(Qo({
                            audioQos: r,
                            videoQos: t1
                        })), Gw.init(function(e) {
                            return e ? new Proxy(e, {
                                get: (e, t1)=>"string" == typeof t1 && "error" === t1 ? function() {
                                        try {
                                            var e;
                                            mE.report(arguments.length <= 0 ? void 0 : arguments[0], [
                                                "MEDIA SDK",
                                                ...null !== (e = arguments.length <= 1 ? void 0 : arguments[1]) && void 0 !== e ? e : []
                                            ], "error");
                                        } catch (e) {}
                                    } : Reflect.get(e, t1)
                            }) : e;
                        }(c)), e.push(Xo(!0)), o && void 0 !== n && void 0 !== s && e.push(Uo()), e;
                    }).catch(()=>[]);
                }));
            })),
        epics1: (e, t1)=>e.pipe(Dt(`${pn}`), ot((e)=>{
                const { payload: { mediaSDKPath: o } } = e, { media: { skipJsMedia: r, patchJsMedia: i, assetsPath: n }, meeting: { isMeetingReset: s } } = t1.value;
                return !r && ui(n) && !!i && !!o && !s;
            }), ht((e)=>{
                const { payload: { mediaSDKPath: t1 } } = e, o = ri(t1);
                return _e(new Promise((e, t1)=>{
                    const r = `${o}/${Qn}`;
                    "JsMediaSDK_Instance" in window && (window.JsMediaSDK_Instance_backup = window.JsMediaSDK_Instance, delete window.JsMediaSDK_Instance), cr(r, ()=>{
                        "JsMediaSDK_Instance_backup" in window && delete window.JsMediaSDK_Instance_backup, zw.info(`patched media sdk url:${r}`), e("");
                    }, ()=>{
                        "JsMediaSDK_Instance_backup" in window && (window.JsMediaSDK_Instance = window.JsMediaSDK_Instance_backup, delete window.JsMediaSDK_Instance_backup), zw.error(`cannot load patched media sdk :${r}`), t1();
                    });
                })).pipe(Fe(()=>(tp(cc), _e([
                        qo(Qd.Done),
                        Jo(o)
                    ]))), it(()=>(tp(cc), _e([
                        qo(Qd.Done)
                    ]))), pt(qo(Qd.Loading)));
            })),
        epics2: (e, t1)=>lr(e, t1).pipe(vt(()=>{
                const { media: { assetsPath: e, mediaConstraints: o, fileWithVersion: r, enforceMultipleVideos: i, enforceVirtualBackground: n, isEnableDecoderInWorklet: s }, meeting: { isAudioBridgeEnabled: a } } = t1.value;
                if (Gw.notifySDKMeetingReady(), e && o) {
                    const t1 = {
                        enableDecoderInWorklet: s,
                        enableAudioBridge: a && vs()
                    };
                    Object.assign(t1, Ny(e, i, n)), Gw.setAssetsAndConstraint(e, o, r, t1);
                }
                Ay(t1).pipe(ht((e)=>_e(xy.acquire().then(()=>e)))).subscribe((e)=>{
                    const { meeting: { svcUrl: o, meetingNumber: r, conId: i, e2eEncrypt: n, userId: s, isWebinar: a, enableWebtransport: d, webtransportPort: u, mediasdkConfig: l }, media: { enableAudioQos: c, enableVideoQos: p, alternativeNameForVideoPlayer: h, adaptedABOptionForMediaSDK: m }, video: { rendererType: g } } = t1.value;
                    e && (Gw.connect({
                        svcUrl: o,
                        meetingNumber: r,
                        conId: i,
                        e2eEncrypt: n,
                        isViewOnly: Kp(e.userRole),
                        currentUserId: s,
                        isWebinar: a,
                        enableAudioQos: c,
                        enableVideoQos: p,
                        enableWebtransport: d,
                        webtransportPort: u,
                        rendererType: g,
                        adaptedABOptionForMediaSDK: m,
                        mediasdkConfig: l
                    }), function(e) {
                        var t1;
                        let o = "video-player";
                        e.tagName && (o = e.tagName, qA.dispatch("", {
                            tagName: e.tagName
                        }), gC(null === (t1 = e.mediaSDK) || void 0 === t1 ? void 0 : t1.call(e), `VPTN:${o}`));
                        const r = `${o}-container`, i = e.sessionId || dC();
                        qA.get("renderCountMap").clear(), e.mediaSDK && (qA.get("mediaSDKInstanceMap").set(ZA, e.mediaSDK), qA.get("mediaSDKInstanceMap").set(i, e.mediaSDK)), e.failover && qA.dispatch("failover", void 0, e.sessionId || ZA), customElements.get(r) || customElements.define(r, $C), customElements.get(o) || customElements.define(o, jC);
                    }({
                        mediaSDK: ()=>Gw.instance,
                        tagName: h,
                        failover: "1"
                    }));
                });
            }), ht(()=>Qe((e)=>Gw.registerCallback(e), (e)=>Gw.unregisterCallback(e), (e, t1)=>({
                        type: e,
                        data: t1
                    })).pipe(Le((e)=>jo(e))))),
        epics3: (e)=>ur(e, [
                Nw,
                Vw,
                Uw,
                jw,
                xw,
                Bw
            ]).pipe(Qy((e)=>{
                const { payload: { type: t1, data: o } } = e;
                if (t1 === Vw || t1 === xw) {
                    if (o === ad.EncodeSuccess) return tp(Yl), Re(xo("success"));
                    if (o === ad.DecodeSuccess) return tp(Xl), Re(Bo("success"));
                    if (o === ad.EncodeFailed) return tp(ic), Re(xo("failed"));
                    if (o === ad.DecodeFailed) return tp(nc), Re(Bo("failed"));
                } else if (t1 === Nw || t1 === jw) {
                    if (o === ad.EncodeSuccess) return tp(ec), Re(Fo("success"));
                    if (o === ad.DecodeSuccess) return tp(tc), Re(Ho("success"));
                    if (o === ad.EncodeFailed) return tp(sc), Re(Fo("failed"));
                    if (o === ad.DecodeFailed) return tp(ac), Re(Ho("failed"));
                } else if (t1 === Uw || t1 === Bw) {
                    if (o === ad.EncodeSuccess) return tp(oc), Re($o("success"));
                    if (o === ad.DecodeSuccess) return tp(rc), Re(Wo("success"));
                    if (o === ad.EncodeFailed) return tp(dc), Re($o("failed"));
                    if (o === ad.DecodeFailed) return tp(uc), Re(Wo("failed"));
                    if (t1 === Uw && void 0 === o) return tp(rc), Re(Wo("success"));
                }
            })),
        epics4: (e, t1)=>ur(e, [
                Nw,
                Vw
            ]).pipe(ht(()=>"object" == typeof navigator.mediaDevices ? Xe(_y(), Xe(ur(e, sd.StartVideoCaptureSuccess), qe(navigator.mediaDevices, "devicechange"), ur(e, sd.UserGrantCaptureAudio).pipe(ot(()=>!t1.value.audio.isUserGrantCaptureAudio))).pipe(Fe(()=>_y().pipe(vt(()=>{
                        setTimeout(()=>{
                            tp(lc);
                        }, 50);
                    }))))).pipe(ft(t1), Fe((e)=>{
                    let [t1, o] = e;
                    const r = [
                        Mh(t1.microphones),
                        kh(t1.speakers),
                        Xm(t1.cameras)
                    ];
                    if (o.audio) {
                        const { audio: { activeMicrophone: e, activeSpeaker: s, microphoneDevicesList: a, speakerDevicesList: d }, video: { cameraDevicesList: u, activeCamera: l } } = o, c = ah(o), { microphones: p, speakers: h, cameras: m } = t1, g = a.filter((e)=>-1 === p.findIndex((t1)=>t1.deviceId === e.deviceId)), v = d.filter((e)=>-1 === h.findIndex((t1)=>t1.deviceId === e.deviceId)), f = u.filter((e)=>-1 === m.findIndex((t1)=>t1.deviceId === e.deviceId));
                        if (g.length > 0) {
                            if (g.some((t1)=>Uy(t1, e, a))) {
                                const e = jy(p);
                                Gw.changeMicrophone("default", null == e ? void 0 : e.label, !(null == c || !c.muted)), r.push(Lh("default"));
                            }
                        } else if ("default" === e) {
                            const e = jy(a), t1 = jy(p);
                            a.length > 0 && (null == e ? void 0 : e.label) !== (null == t1 ? void 0 : t1.label) && Gw.changeMicrophone("default", null == t1 ? void 0 : t1.label, !(null == c || !c.muted));
                        }
                        var i, n;
                        v.length > 0 ? v.some((e)=>Uy(e, s, d)) && (Gw.changeSpeaker("default"), r.push(Nh("default"))) : "default" === s && d.length > 0 && (null === (i = jy(d)) || void 0 === i ? void 0 : i.label) !== (null === (n = jy(h)) || void 0 === n ? void 0 : n.label) && Gw.changeSpeaker("default"), f.length > 0 && f.some((e)=>Uy(e, l, u)) && (Gw.stopCaptureVideo(), r.push(eg(gs.isAndroidOrIOSBrowser ? wd.User : "default")));
                    }
                    return _e(r);
                })) : ne)),
        epics5: (e, t1)=>dr(e, Ps).pipe(vt((e)=>{
                const { type: o, payload: { body: r } } = e, i = o === `${Do}`;
                if (r.add) {
                    const e = r.add.map((e)=>({
                            userid: e.id,
                            sn: e.zoomID && zr(e.zoomID)
                        }));
                    if (!i) {
                        const { meeting: { gcmSessinKey: o } } = t1.value;
                        Gw.sendUserNodeList(e, o);
                    }
                    Gw.updateUserMediaSN({
                        added: e,
                        isFromMainSession: i,
                        iVType: Is.SHARING_DECODE
                    }), i && Gw.updateUserMediaSN({
                        added: e,
                        isFromMainSession: i,
                        iVType: Is.AUDIO_DECODE
                    });
                }
                if (r.remove && r.remove.length > 0) {
                    if (!i) {
                        const { meeting: { gcmSessinKey: e } } = t1.value;
                        Gw.sendUserNodeList(r.remove.map((e)=>({
                                userid: e.id,
                                bremove: !0
                            })), e);
                    }
                    Gw.updateUserMediaSN({
                        removed: r.remove.map((e)=>e.id),
                        isFromMainSession: i,
                        iVType: Is.SHARING_DECODE
                    }), i && Gw.updateUserMediaSN({
                        removed: r.remove.map((e)=>e.id),
                        isFromMainSession: i,
                        iVType: Is.AUDIO_DECODE
                    });
                }
            }), ut(ne)),
        epics6: (e)=>ur(e, sd.AesGcmIvResponse).pipe(vt((e)=>{
                const { payload: { data: { workerType: t1, iv: o } } } = e, r = ns.get(ss.WebclientIVState);
                if (r) {
                    const e = {
                        ...r,
                        [t1]: o
                    };
                    ns.set(ss.WebclientIVState, e, rs.SessionStorage);
                }
            }), ut(ne)),
        epics7: (e)=>e.pipe(Dt(`${_o}`), ot((e)=>[
                    ks,
                    Ls,
                    Ds
                ].includes(e.payload.evt)), Le((e)=>{
                const { payload: { evt: t1, body: { encryptKey: o, additionalType: r } } } = e;
                return Ko({
                    type: t1 === ks ? "audio" : t1 === Ls ? "video" : "sharing",
                    encryptKey: o,
                    additionalType: r
                });
            })),
        epics8: (e)=>e.pipe(Dt(`${Go}`), vt((e)=>{
                const { payload: t1 } = e;
                Lw.setMediaOption({
                    assetsPath: t1.assetsPath,
                    enforceMultipleVideos: t1.enforceMultipleVideos,
                    enforceVirtualBackground: t1.enforceVirtualBackground
                });
            }), ut(ne)),
        epics9: (e)=>e.pipe(Dt(`${rn}`, `${on}`), vt(()=>{
                Dw.getInstance().inProgress && (Dw.getInstance().disconnect(), xy.watch(Dw.getInstance().destroy()));
            }), ut(ne)),
        epics10: (e)=>e.pipe(Dt(`${rn}`, `${on}`), ht(()=>"permissions" in navigator ? [
                    "microphone",
                    "camera"
                ].map((e)=>{
                    navigator.permissions.query({
                        name: e
                    }).then((t1)=>{
                        const o = ()=>{
                            tp(mc, {
                                name: e,
                                state: t1.state
                            });
                        };
                        o(), t1.addEventListener("change", o), qw.push(()=>{
                            t1.removeEventListener("change", o);
                        });
                    }).catch(()=>{});
                }) : ne), ut(ne)),
        epics11: (e)=>e.pipe(Dt(`${Dn}`), ot((e)=>e.payload === Xn.Closed), vt(()=>{
                qw.length > 0 && (qw.forEach((e)=>e()), qw.length = 0);
            }), ut(ne)),
        epics12: (e, t1)=>ur(e, [
                Fw,
                Hw,
                $w,
                jw,
                xw,
                Bw,
                Ww
            ]).pipe(Fe((o)=>{
                var r, i;
                const { payload: { type: n, data: s } } = o;
                let a, d;
                if (n === Ww) {
                    const o = "audio";
                    let [r, i] = [
                        0,
                        ""
                    ];
                    s ? (r = ou.MicrophoneMuted, i = "Your mic is muted in system or browser settings. Please open your settings to unmute and adjust the level.") : (r = ou.AudioStreamMuted, i = "Audio was interrupted by the system. Please click anywhere to resume playback.", d = rt(qe(document, "click").pipe(nt(1)), qe(document, "touchend").pipe(nt(1))).pipe(mt(sp())).pipe(mt(ur(e, sd.AudioStreamUnmuted).pipe(nt(1))), vt(()=>{
                        !function(e, t1) {
                            const { audio: { activeMicrophone: o, microphoneDevicesList: r } } = t1, i = r.find((e)=>e.deviceId === o), n = ah(t1);
                            e.changeMicrophone(o, null == i ? void 0 : i.label, !(null == n || !n.muted));
                        }(Gw, t1.value);
                    }))), a = {
                        message: i,
                        type: o,
                        code: r
                    };
                } else if (n === Fw) {
                    let [e, t1] = [
                        "",
                        0
                    ];
                    -129 === s ? (e = "sharing", t1 = ou.SharingStreamFailed) : [
                        -130,
                        -135
                    ].includes(s) ? (e = "video", t1 = ou.VideoStreamFailed) : [
                        -131,
                        -136
                    ].includes(s) && (e = "audio", t1 = ou.AudioStreamFailed), a = {
                        message: "Oops! Something went wrong. Please close all browsers and rejoin the meeting.",
                        type: e,
                        code: t1
                    };
                }
                return Kw.report(`active media failed. reason:${n}; message:${null === (r = a) || void 0 === r ? void 0 : r.message}`, `${null === (i = a) || void 0 === i || null === (i = i.type) || void 0 === i ? void 0 : i.replace(/^./, (e)=>e.toUpperCase())} exception flow`), tp(gc, a), null != d ? d : _e([]);
            }), Fe(()=>ne)),
        epics13: (e)=>nr(e, 4366).pipe(vt((e)=>{
                const { payload: t1 } = e;
                Gw.bypassMediaMessage(t1);
            }), Fe(()=>ne))
    }, Qw = ir(Jw), Zw = {
        meeting: pA,
        socket: NA,
        participants: $A,
        media: zA
    }, Yw = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || wt;
    function Xw(e) {
        return function(e) {
            for(var t1 = Object.keys(e), o = {}, r = 0; r < t1.length; r++){
                var i = t1[r];
                "function" == typeof e[i] && (o[i] = e[i]);
            }
            var n, s = Object.keys(o);
            try {
                !function(e) {
                    Object.keys(e).forEach(function(t1) {
                        var o = e[t1];
                        if (void 0 === o(void 0, {
                            type: _t.INIT
                        })) throw new Error(It(12));
                        if (void 0 === o(void 0, {
                            type: _t.PROBE_UNKNOWN_ACTION()
                        })) throw new Error(It(13));
                    });
                }(o);
            } catch (e) {
                n = e;
            }
            return function(e, t1) {
                if (void 0 === e && (e = {}), n) throw n;
                for(var r = !1, i = {}, a = 0; a < s.length; a++){
                    var d = s[a], u = o[d], l = e[d], c = u(l, t1);
                    if (void 0 === c) throw t1 && t1.type, new Error(It(14));
                    i[d] = c, r = r || c !== l;
                }
                return (r = r || s.length !== Object.keys(e).length) ? i : e;
            };
        }({
            ...Zw,
            ...e
        });
    }
    function eT(e, t1, o, r, i) {
        var n = {};
        return Object.keys(r).forEach(function(e) {
            n[e] = r[e];
        }), n.enumerable = !!n.enumerable, n.configurable = !!n.configurable, ("value" in n || n.initializer) && (n.writable = !0), n = o.slice().reverse().reduce(function(o, r) {
            return r(e, t1, o) || o;
        }, n), i && void 0 !== n.initializer && (n.value = n.initializer ? n.initializer.call(i) : void 0, n.initializer = void 0), void 0 === n.initializer ? (Object.defineProperty(e, t1, n), null) : n;
    }
    const tT = Symbol("store"), oT = Symbol("getState"), rT = Symbol("dispatch"), iT = Symbol("additionFeatures"), nT = Symbol("mediaContext");
    function sT(e, t1, o) {
        const r = o.value;
        o.value = function() {
            const e = this[tT];
            if (e) {
                const { meeting: { isOnHold: t1, isMeetingReset: o, meetingStatus: r } } = e.getState();
                if (r !== Xn.Joined) return Promise.reject({
                    type: Ql,
                    reason: "closed"
                });
                if (o) return Promise.reject({
                    type: Ql,
                    reason: "reconnecting"
                });
                if (t1) return Promise.reject({
                    type: Ql,
                    reason: "on hold"
                });
            }
            for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
            return r.apply(this, o);
        };
    }
    function aT(e, t1, o) {
        const r = o.value;
        o.value = function() {
            const e = this[tT];
            if (e) {
                const t1 = e.getState();
                if (!dh(t1)) return Promise.reject({
                    type: Jl,
                    reason: "only host or co-host can do the operation"
                });
            }
            for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
            return r.apply(this, o);
        };
    }
    function dT(e, t1, o) {
        const r = o.value;
        o.value = function() {
            const e = this[tT];
            if (e) {
                const t1 = e.getState();
                if (!uh(t1)) return Promise.reject({
                    type: Jl,
                    reason: "only host can do the operation"
                });
            }
            for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
            return r.apply(this, o);
        };
    }
    function uT(e) {
        return function(t1, o, r) {
            const i = r.value;
            r.value = function() {
                const t1 = this[tT];
                if (t1 && void 0 === t1.getState()[e]) return Promise.reject({
                    type: Kl,
                    reason: `Module:${e} is not enabled`
                });
                for(var o = arguments.length, r = new Array(o), n = 0; n < o; n++)r[n] = arguments[n];
                return i.apply(this, r);
            };
        };
    }
    function lT(e) {
        return function(t1, o, r) {
            const i = r.value;
            r.value = function() {
                const t1 = this[tT];
                if (t1) {
                    const { meeting: { meetingOptions: o } } = t1.getState();
                    if (!0 === o[e]) return Promise.reject({
                        type: "OPERATION_LOCKED",
                        reason: `${e} is locked`
                    });
                }
                for(var o = arguments.length, r = new Array(o), n = 0; n < o; n++)r[n] = arguments[n];
                return i.apply(this, r);
            };
        };
    }
    let cT = function(e) {
        return e.Self = "Self", e.Other = "Other", e.Client = "Client", e.Phone = "Phone", e.Attendee = "Attendee", e;
    }({});
    function pT(e) {
        return function(t1, o, r) {
            const i = r.value;
            r.value = function(t1) {
                const o = this[tT];
                if (o) {
                    const r = o.getState(), i = Array.isArray(e) ? e : [
                        e
                    ];
                    let n = ph(r).find((e)=>e.userId === t1);
                    if (i.findIndex((e)=>e === cT.Attendee) > -1 && (n = lh(r).find((e)=>e.userId === t1)), !n) return Promise.reject({
                        type: Zl,
                        reason: "no matching user"
                    });
                    {
                        const { meeting: { userId: e } } = o.getState();
                        for(let o = 0; o < i.length; o++){
                            const r = i[o];
                            if (r === cT.Other && t1 === e) return Promise.reject({
                                type: Kl,
                                reason: "operation is not applicable to self"
                            });
                            if (r === cT.Self && t1 !== e) return Promise.reject({
                                type: Kl,
                                reason: "operation is only applicable to self "
                            });
                            if (r === cT.Client && Wp(n.userType) || r === cT.Phone && !Wp(n.userType)) return Promise.reject({
                                types: Kl,
                                reason: "improper target client"
                            });
                        }
                    }
                }
                for(var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)n[s - 1] = arguments[s];
                const a = [
                    t1,
                    ...n
                ];
                return i.apply(this, a);
            };
        };
    }
    const hT = hE.getInstance();
    function mT(e, t1) {
        return function(o, r, i) {
            const n = i.value;
            i.value = function() {
                for(var o = arguments.length, i = new Array(o), s = 0; s < o; s++)i[s] = arguments[s];
                if (hT.checkLaplace()) try {
                    var a;
                    const o = hT.makeLogger([
                        e
                    ]), s = null === (a = t1 ? i.map((e, o)=>t1.includes(o + 1) ? dE(e) : e) : i) || void 0 === a ? void 0 : a.map((e)=>ai(e));
                    return o.info(`${r},params:${JSON.stringify(s)}`), n.apply(this, i).then((e)=>(o.info(`${r} success`), e)).catch((t1)=>{
                        let o = `${r},params:${JSON.stringify(s)},return failed,`;
                        return "object" == typeof t1 && (o = `${o},${t1.type ? `type:${t1.type},` : ""}${t1.reason ? `reason:${t1.reason}` : ""}`), hT.report(o, `${e} exception flow`, "error"), Promise.reject(t1);
                    });
                } catch (e) {}
                return n.apply(this, i);
            };
        };
    }
    function gT(e, t1, o) {
        return function(r, i, n) {
            const s = n.value;
            n.value = function() {
                for(var r, i, n = arguments.length, a = new Array(n), d = 0; d < n; d++)a[d] = arguments[d];
                const u = a[t1];
                let l = e;
                return Array.isArray(l) || (l = [
                    l
                ]), !l.some((e)=>u instanceof e) || o && !o.every((e)=>!!u[e]) ? Promise.reject({
                    type: Zl,
                    reason: `Expected to accept ${null === (r = l) || void 0 === r ? void 0 : r.map((e)=>e.name).join(" or ")}, but actual it is ${"object" == typeof u && null !== u ? null === (i = Object.getPrototypeOf(u)) || void 0 === i ? void 0 : i.constructor.name : u}`
                }) : s.apply(this, a);
            };
        };
    }
    class vT {
        constructor(e){
            this[tT] = void 0, this[rT] = void 0, this[oT] = void 0, this[iT] = void 0, this[tT] = e, this[rT] = e.dispatch, this[oT] = e.getState;
        }
    }
    const fT = [
        "userId",
        "displayName",
        "audio",
        "isHost",
        "avatar",
        "bRaiseHand",
        "bHold",
        "bVideoOn",
        "sharerOn",
        "sharerPause",
        "feedback",
        "bLocalRecord",
        "strPronoun",
        "sdkKey",
        "audioConnectionStatus",
        "caps",
        "bAllowISORecord",
        "bVideoConnect",
        "userIdentity",
        "isSpeakerOnly",
        "bVideoShare",
        "bShareAudioOn",
        "bShareToBORooms",
        "bid",
        {
            from: "bInFailover",
            to: "isInFailover"
        },
        {
            from: "userGUID",
            to: "userGuid"
        },
        {
            from: "bGuest",
            to: "isGuest"
        },
        {
            from: "sharerPause",
            to: "sharePause"
        },
        {
            from: "bCoHost",
            to: (e)=>({
                    isCoHost: !!e
                })
        },
        {
            from: "muted",
            to: (e, t1)=>({
                    muted: null != t1 && t1.isSpeakerOnly || "" === (null == t1 ? void 0 : t1.audio) ? void 0 : e
                })
        },
        {
            from: "userType",
            to: (e, t1)=>{
                const o = Wp(e), r = {
                    isPhoneUser: o
                };
                return o && null != t1 && t1.phoneNumber && Object.assign(r, {
                    phoneNumber: t1.phoneNumber
                }), r;
            }
        }
    ];
    function yT(e) {
        return fT.reduce((t1, o)=>{
            const r = "string" == typeof o ? o : o.from, i = function(e, t1, o) {
                if ("string" == typeof e) return {
                    [`${e}`]: t1
                };
                if ("object" == typeof e && void 0 !== e.from) {
                    const { to: r } = e;
                    return "string" == typeof r ? {
                        [`${r}`]: t1
                    } : r(t1, o);
                }
            }(o, e[r], e);
            return {
                ...t1,
                ...i
            };
        }, {});
    }
    function ST() {
        const { isSupportAudioWorklet: e, isSupportEssentialAudioAndVideoAbility: t1, isAndroidOrIOSBrowser: o, isSupportSendScreenSharing: r } = gs, i = t1 && e || o, n = t1 && void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaCapabilities, s = "function" == typeof "".replaceAll;
        return {
            audio: s && i,
            video: s && n,
            screen: s && t1 && r
        };
    }
    const bT = (e)=>{
        let { breakoutRoom: { mainSessionAttendeeList: t1 } } = e;
        return t1;
    }, ET = (e)=>{
        let { meeting: { zoomId: t1 } } = e;
        return t1;
    }, IT = (e)=>{
        let { breakoutRoom: { isHugeBO: t1 } } = e;
        return t1;
    }, AT = Vp([
        (e)=>{
            let { breakoutRoom: { controlStatus: t1 } } = e;
            return t1;
        },
        (e)=>{
            let { breakoutRoom: { currentRoom: { status: t1 } } } = e;
            return t1;
        },
        (e)=>{
            let { breakoutRoom: { currentRoom: { boId: t1 } } } = e;
            return t1;
        }
    ], (e, t1, o)=>!(e !== qp.InProgress && e !== qp.Closing || t1 !== Qp.InRoom && t1 !== Qp.TimeUp || !o)), CT = Vp([
        (e)=>{
            let { breakoutRoom: { rooms: t1 } } = e;
            return t1;
        },
        Up,
        ET,
        bT,
        AT,
        IT
    ], (e, t1, o, r, i, n)=>{
        const s = e.reduce((e, t1)=>{
            const { attendeeGuidList: o } = t1;
            return e.concat(o);
        }, []);
        return (i ? r : t1).filter((e)=>!e.bHold && !e.isHost && e.zoomID !== o && !e.bid && !s.includes(e.userGUID) && (!n || iS(e.caps)));
    }), _T = Vp([
        AT,
        bT,
        Up,
        ET,
        IT
    ], (e, t1, o, r, i)=>(e ? t1 : o).filter((e)=>!e.bHold && !e.isHost && e.zoomID !== r && !e.bid && (!i || iS(e.caps)))), RT = Vp([
        AT,
        bT,
        Up
    ], (e, t1, o)=>e ? t1.find((e)=>e.isHost) : o.find((e)=>e.isHost));
    var wT, TT, OT, DT;
    const PT = ia.createAgent();
    let MT = (wT = pT(cT.Other), TT = pT(cT.Other), OT = pT(cT.Other), DT = class extends vT {
        constructor(e){
            super(e), this.modules = void 0, this.useSDK = void 0, this.useSDK = !1, this.modules = new Map;
        }
        initWithSDK(e, t1, o) {
            return this.useSDK = !0, this.init(e, t1, o);
        }
        init(e, t1, o) {
            const { audio: r, video: i } = ST();
            if (!r || !i) return console.error("https://developers.zoom.us/docs/video-sdk/web/browser-support"), Promise.reject({
                type: Kl,
                reason: "Please update to the latest Chrome, Edge, Safari, or Firefox, as your current browser doesn't support audio/video. Retry after the upgrade."
            });
            const { [rT]: n, [tT]: s } = this;
            let a = fr;
            const d = (null == o ? void 0 : o.fileWithVersion) || !1;
            let u = "en-US", l = `${fr}/${Qn}`;
            if (o) {
                const { dependentAssets: e, additionalFeatures: t1, constraints: r, language: i, webEndpoint: n } = o;
                i && (u = i), n && function(e) {
                    mr = pr(e, {
                        hostname: !0
                    });
                }(n), e === Zn.CDN || e === vr ? (a = vr, l = `${vr}/${Qn}`) : e === Zn.Global || e === fr ? (a = fr, l = `${fr}/${Qn}`) : e === Zn.CN || e === yr ? (a = yr, l = `${yr}/${Qn}`) : e && /^https?:\/\//.test(e) && (a = ri(e), l = d ? `${a}/1501_js_media.min.js` : `${a}/${Qn}`), t1 && Array.isArray(t1) && t1.forEach((e)=>{
                    if (this[iT][e] && void 0 === s.getState()[e]) {
                        const { epic: t1, reducer: o, Client: r } = this[iT][e];
                        s.injectReducer(e, o), s.injectEpic(t1);
                        const i = new r(s);
                        this.modules.set(e, i);
                    }
                }), null != r && r.audio && void 0 === s.getState().audio && (s.injectReducer("audio", h_), s.injectEpic(v_)), null != r && r.video && void 0 === s.getState().video && (s.injectReducer("video", _w), s.injectEpic(Ow)), null != r && r.screen && void 0 === s.getState().share && (s.injectReducer("share", PI), s.injectEpic(LI));
            }
            return n(gn({
                apiKey: e,
                signature: t1,
                language: u,
                useSDK: this.useSDK
            })), n(Go({
                mediaConstraints: o && o.constraints || {},
                assetsPath: a,
                fileWithVersion: d,
                enforceMultipleVideos: null == o ? void 0 : o.enforceMultipleVideos,
                enforceVirtualBackground: null == o ? void 0 : o.enforceVirtualBackground,
                skipJsMedia: null == o ? void 0 : o.skipJsMedia,
                patchJsMedia: null == o ? void 0 : o.patchJsMedia,
                alternativeNameForVideoPlayer: null == o ? void 0 : o.alternativeNameForVideoPlayer
            })), void 0 !== (null == o ? void 0 : o.stayAwake) && n(Bn(o.stayAwake)), void 0 !== (null == o ? void 0 : o.quicklyLeaveMeeting) && n(Wn(o.quicklyLeaveMeeting)), new Promise((e, t1)=>{
                null != o && o.skipJsMedia ? e("") : cr(l, ()=>{
                    e("");
                }, ()=>{
                    t1({
                        type: Zl,
                        reason: "dependent assets are not accessible"
                    });
                });
            });
        }
        on(e, t1) {
            ((e, t1)=>{
                const o = qc[e];
                if (o) {
                    const r = Qc.get(e);
                    if (r) r.push(t1), Qc.set(e, r);
                    else {
                        const r = [
                            t1
                        ];
                        Qc.set(e, r);
                        const i = Xe(...o.map((e)=>{
                            const { event: t1, payload: o } = e;
                            return qe(Jc, t1).pipe(Le((e)=>o(e)), Ie(ee));
                        })).subscribe((t1)=>{
                            const o = Qc.get(e);
                            o && o.forEach((e)=>{
                                e(t1);
                            });
                        });
                        Zc.push(i);
                    }
                }
            })(e, t1);
        }
        off(e, t1) {
            ((e, t1)=>{
                if (qc[e]) {
                    const o = Qc.get(e);
                    if (Array.isArray(o)) {
                        const r = o.filter((e)=>e !== t1);
                        Qc.set(e, r);
                    }
                }
            })(e, t1);
        }
        getFeatureModule(e) {
            return this.modules.get(e);
        }
        leave() {
            const { [oT]: e, [rT]: t1 } = this, { socket: { zoomSocketStatus: o } } = e();
            return o === Sh.Connected || o === Sh.Connecting ? t1(an()) : t1(dn()), Oe(Ze(500).pipe(at("")));
        }
        end() {
            const { [oT]: e, [rT]: t1 } = this;
            return "connected" === e().socket.zoomSocketStatus ? (t1(un()), Oe(Ze(500).pipe(vt(()=>{
                ap();
            }), at("")))) : Promise.resolve("");
        }
        changeName(e, t1) {
            const o = this[tT].getState(), { meeting: { bAllowAttendeeRename: r } } = o, i = ah(o), n = Kp(i.userRole), s = dh(o);
            if (n) return Promise.reject({
                type: Jl
            });
            if (t1 && t1 !== (null == i ? void 0 : i.userId)) {
                if (s) {
                    const { participants: { attendeesList: r } } = o, i = r.find((e)=>e.userId === t1);
                    if (i) return PT.rename(t1, $r(e), $r(i.displayName)), Ky({
                        userId: t1,
                        key: "displayName"
                    }, (t1)=>t1.displayName === e);
                    {
                        const r = lh(o).find((e)=>e.userId === t1);
                        if (r) {
                            const t1 = jI.getInstance();
                            return PT.rename(r.userId, $r(e), $r(r.displayName)), t1.rename(r.jid, e), ip(fa, (t1)=>{
                                const o = t1.find((e)=>e.jid === r.jid);
                                return o && o.displayName === e;
                            });
                        }
                        return Promise.reject({
                            type: Zl,
                            reason: "no matching user"
                        });
                    }
                }
                return Promise.reject({
                    type: Jl
                });
            }
            return e === i.displayName ? Promise.resolve() : s || r ? (PT.rename(i.userId, $r(e), $r(i.displayName)), ip(ha, (t1)=>t1.displayName === e)) : Promise.reject({
                type: Jl,
                reason: "host disallow rename themselves"
            });
        }
        makeHost(e) {
            return PT.assignHost(e, !1), Ky({
                userId: e,
                key: "isHost"
            }, (e)=>!0 === e.isHost);
        }
        makeCoHost(e) {
            const t1 = this[tT].getState(), o = ph(t1).find((t1)=>t1.userId === e);
            return !0 === (null == o ? void 0 : o.bCoHost) ? Promise.reject({
                type: Zl,
                reason: `user:[${e}] is already co-host `
            }) : (PT.assignHost(e, !0), Ky({
                userId: e,
                key: "bCoHost"
            }, (e)=>!0 === e.bCoHost));
        }
        revokeCoHost(e) {
            const t1 = this[tT].getState(), o = ph(t1).find((t1)=>t1.userId === e);
            return !1 === (null == o ? void 0 : o.bCoHost) ? Promise.reject({
                type: Zl,
                reason: `user:[${e}] is not a co-host`
            }) : (PT.revokeCoHost(e), Ky({
                userId: e,
                key: "bCoHost"
            }, (e)=>!1 === e.bCoHost));
        }
        reclaimHost() {
            const e = this[oT](), { meeting: { isOriginHost: t1 } } = e, o = ah(e);
            return null != o && o.isHost ? Promise.resolve("") : t1 ? (PT.reclaimHost(o.userId, !1), ip(ha, (e)=>!0 === e.isHost)) : Promise.reject({
                type: Jl,
                reason: "You are not the origin host"
            });
        }
        isHost() {
            const e = this[tT].getState(), t1 = ah(e);
            return !!t1 && t1.isHost;
        }
        isCoHost() {
            const e = this[tT].getState(), t1 = ah(e);
            return !!t1 && !!t1.bCoHost;
        }
        isOriginHost() {
            const { meeting: { isOriginHost: e } } = this[oT]();
            return e;
        }
        getCurrentUserInfo() {
            const e = this[tT].getState(), t1 = ah(e);
            if (t1) {
                const o = yT(t1);
                if (e.meeting.isWebinar && Kp(t1.userRole)) {
                    const { audio: t1 } = e, r = null == t1 ? void 0 : t1.isAllowToTalk;
                    Object.assign(o, {
                        isAllowToTalk: r
                    });
                }
                if (e.breakoutRoom && AT(e)) {
                    const { breakoutRoom: { currentRoom: { boId: t1 } } } = e;
                    Object.assign(o, {
                        bid: t1
                    });
                }
                return o;
            }
            return null;
        }
        getParticipantsList() {
            const e = this[tT].getState(), { meeting: { meetingStatus: t1 } } = e, o = ah(e);
            if (t1 === Xn.Joined && o && !o.bHold) {
                var r;
                const t1 = e.breakoutRoom && AT(e) ? null === (r = e.breakoutRoom) || void 0 === r || null === (r = r.currentRoom) || void 0 === r ? void 0 : r.boId : "";
                return ph(e).map((e)=>{
                    const o = yT(e);
                    return t1 && Object.assign(o, {
                        bid: t1
                    }), o;
                });
            }
            return [];
        }
        getAssistantsList() {
            const e = this[tT].getState(), { meeting: { meetingStatus: t1 } } = e, o = ah(e);
            return t1 === Xn.Joined && o ? hh(e).map((e)=>({
                    userId: e.userId,
                    displayName: e.displayName,
                    isNewAst: !0
                })) : [];
        }
        getMeetingHost() {
            var e;
            const t1 = this[oT]();
            let o = mh(t1);
            return o || (null === (e = t1.breakoutRoom) || void 0 === e ? void 0 : e.currentRoom.status) !== Qp.InRoom || (o = t1.breakoutRoom.mainSessionAttendeeList.find((e)=>e.isHost)), void 0 !== o ? yT(o) : null;
        }
        getMeetingInfo() {
            const { meeting: { meetingStatus: e, isOnHold: t1, meetingNumber: o, passWord: r, userName: i, userEmail: n, meetingTopic: s, meetingOptions: a, encType: d, region: u, network: l, topic: c, zlkJwtToken: p, userId: h, lang: m, inviteEmail: g, meetingId: v, participantID: f, h323Password: y, recordingDisclaimer: S, recordingDisclaimerForRecorder: b, wrInfo: E, meetingInfo: I, isNewJoinFlow: A, chatModerationPolicy: C } } = this[oT](), _ = e === Xn.Joined && !t1;
            if (p) return {
                topic: c,
                password: r,
                userName: i,
                isInMeeting: _,
                userId: h,
                meetingId: v
            };
            {
                let e = "";
                return 0 === d ? e = "None" : 1 === d ? e = "AES ECB" : 2 === d && (e = "AES GCM"), {
                    meetingNumber: o,
                    password: r,
                    userName: i,
                    userEmail: n,
                    inviteEmail: g,
                    meetingTopic: s,
                    encryptionType: e,
                    region: u,
                    network: l,
                    isInMeeting: _,
                    userId: h,
                    lang: m,
                    webEndpoint: Sr(),
                    meetingId: v,
                    participantId: f,
                    telPwd: y,
                    recordingInfo: {
                        recordingDisclaimer: S,
                        recordingDisclaimerForRecorder: b,
                        isUserEnableRecordingReminder: null == a ? void 0 : a.isUserEnableRecordingReminder
                    },
                    wrInfo: Object.assign({}, E, {
                        isNew: A
                    }),
                    scheduleInfo: I,
                    chatModerationPolicy: C
                };
            }
        }
    }, eT(DT.prototype, "end", [
        dT,
        sT
    ], Object.getOwnPropertyDescriptor(DT.prototype, "end"), DT.prototype), eT(DT.prototype, "changeName", [
        sT
    ], Object.getOwnPropertyDescriptor(DT.prototype, "changeName"), DT.prototype), eT(DT.prototype, "makeHost", [
        wT,
        dT,
        sT
    ], Object.getOwnPropertyDescriptor(DT.prototype, "makeHost"), DT.prototype), eT(DT.prototype, "makeCoHost", [
        TT,
        dT,
        sT
    ], Object.getOwnPropertyDescriptor(DT.prototype, "makeCoHost"), DT.prototype), eT(DT.prototype, "revokeCoHost", [
        OT,
        dT,
        sT
    ], Object.getOwnPropertyDescriptor(DT.prototype, "revokeCoHost"), DT.prototype), eT(DT.prototype, "reclaimHost", [
        sT
    ], Object.getOwnPropertyDescriptor(DT.prototype, "reclaimHost"), DT.prototype), DT);
    const kT = ia.createAgent(), LT = jI.getInstance(), NT = (e, t1, o)=>{
        const r = null == t1 ? void 0 : t1.userId;
        if (null == e || !e.zoomID || null == t1 || !t1.displayName || r === e.userId) return {
            type: Zl,
            reason: "invalid target user"
        };
        const { chat: { chatPrivilege: i, panelistChatPrivilege: n }, meeting: { isWebinar: s } } = o, a = dh(o), d = t1.isHost || t1.bCoHost;
        let u = !1;
        if (!a) {
            if (s) if (Kp(e.userRole)) (i === xs.NoAttendee || i === xs.AllPanelist && r !== Fs.Panelist || i === xs.All && r !== Fs.All && r !== Fs.Panelist) && (u = !0);
            else {
                const e = Kp(null == t1 ? void 0 : t1.userRole);
                (n === Bs.Invalid || n === Bs.AllPanelist && (e || r === Fs.All)) && (u = !0);
            }
            else (i === xs.NoAttendee || i === xs.Host && !d || r === Fs.SilentModeUsers || i === xs.EveryonePublicly && r !== Fs.All && !d) && (u = !0);
            if (u) return {
                type: Jl,
                reason: "Insufficient chat privilege"
            };
        }
        return null;
    };
    function VT(e, t1) {
        if (t1 === Fs.All) return qs;
        if (t1 === Fs.Panelist) return Js;
        if (t1 === Fs.SilentModeUsers) return Qs;
        {
            const { meeting: { isWebinar: o }, participants: { xmppAttendeeList: r, attendeesList: i } } = e;
            return o ? i.find((e)=>e.userId === t1) || r.find((e)=>e.userId === t1) : i.find((e)=>e.userId === t1);
        }
    }
    function UT(e, t1, o) {
        if (null != o && o.host) return [
            mh(e),
            ...gh(e)
        ].filter((e)=>(null == e ? void 0 : e.userId) !== t1).map((e)=>({
                userId: null == e ? void 0 : e.userId,
                displayName: null == e ? void 0 : e.displayName,
                isHost: null == e ? void 0 : e.isHost,
                isCoHost: null == e ? void 0 : e.bCoHost
            }));
        {
            let r = [
                mh(e),
                ...gh(e),
                ...e.participants.attendeesList.filter((e)=>!(e.bCoHost || e.isHost || e.bHold))
            ];
            if (null != o && o.includeAttendee) {
                const t1 = lh(e).filter((e)=>!Wp(e.userType));
                r = [
                    ...r,
                    ...t1
                ];
            }
            return r.filter((e)=>void 0 !== e && e.userId !== t1).map((e)=>({
                    userId: null == e ? void 0 : e.userId,
                    displayName: null == e ? void 0 : e.displayName,
                    isHost: null == e ? void 0 : e.isHost,
                    isCoHost: null == e ? void 0 : e.bCoHost
                }));
        }
    }
    function jT(e) {
        const { text: t1, destId: o, sn: r, attendeeId: i } = e;
        return Ts.beginEncrypt({
            text: t1,
            type: Cs.RWG_CHAT
        }).then((e)=>{
            kT.chat(e, o, r, i);
        });
    }
    function xT(e, t1) {
        const { chat: { chatHistory: o } } = t1;
        return o.find((t1)=>{
            var o;
            return (null === (o = t1.file) || void 0 === o || null === (o = o.upload) || void 0 === o ? void 0 : o.uniqueId) === e;
        });
    }
    function BT(e, t1) {
        const { meeting: { isWebinar: o }, participants: { attendeesList: r } } = t1, { destNodeID: i, senderName: n, attendeeNodeID: s } = e, a = r.find((e)=>e.userId === i), d = e.sn ? e.sn : null == a ? void 0 : a.zoomID, u = n ? Wr(n) : null == a ? void 0 : a.displayName;
        let l, c = "";
        if (s === Fs.SilentModeUsers) return {
            sender: {
                name: "Host",
                userId: i
            },
            receiver: {
                name: "Everyone (in Waiting Room)",
                userId: s
            },
            timestamp: (new Date).getTime()
        };
        if (s === Fs.All) c = o ? "All panelists and attendees" : "Everyone";
        else if (s === Fs.Panelist) c = "All panelists";
        else {
            if (o) {
                const e = lh(t1).find((e)=>e.userId === s);
                e && (c = e.displayName);
            }
            if (!c) {
                const e = r.find((e)=>e.userId === s);
                e && (c = e.displayName, l = e.userGUID);
            }
        }
        return {
            sn: d,
            sender: {
                name: u,
                userId: i,
                userGuid: null == a ? void 0 : a.userGUID,
                avatar: null == a ? void 0 : a.avatar
            },
            receiver: {
                name: c,
                userId: s,
                userGuid: l
            },
            timestamp: (new Date).getTime()
        };
    }
    function FT(e) {
        var t1;
        const [o] = e.split(".").reverse();
        return null !== (t1 = ta[o]) && void 0 !== t1 ? t1 : "";
    }
    function HT(e, t1) {
        const o = [];
        for(let r = e.length - 1; r >= 0; r--){
            const i = e[r];
            if (!i.file && (!i.id && i.sender.userId === t1.userId && [
                Fs.All,
                Fs.Panelist,
                Fs.IndividualCcPanelist,
                t1.destNodeID
            ].includes(i.receiver.userId) && o.unshift(i), i.id)) break;
        }
        return o.length > 0 ? o[0] : null;
    }
    const $T = hE.getInstance(), WT = $T.makeLogger([
        "File Transfer"
    ]);
    function GT(e, t1, o) {
        const { name: r, size: i } = e, { meeting: { reportDomain: n, svcUrl: s, conId: a } } = o;
        return `https://${n}${t1}?${new URLSearchParams({
            filename: r,
            filesize: i,
            rwg: s,
            cid: a
        }).toString()}`;
    }
    function KT(e, t1) {
        return t1.fileObj ? `${e}/zoomfile/download?objkey=${t1.fileObj}&business=meeting` : `${e}/file/${t1.fileID}?business=meeting`;
    }
    function zT(e, t1) {
        return {
            fileName: e.name,
            fileSize: e.size,
            receiverId: null == t1 ? void 0 : t1.userId,
            receiverGuid: null == t1 ? void 0 : t1.userGuid
        };
    }
    function qT(e, t1, o) {
        $T.report(`${e}. file name:${dE(t1.name)},file size:${t1.size}, ${"type" in t1 ? `file type:${t1.type}` : ""}, error:${o.name};${o.message}`, [
            "File Transfer"
        ]);
    }
    function JT(e) {
        var t1, o, r;
        return {
            id: e.id,
            fileName: null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.name,
            fileSize: null === (o = e.file) || void 0 === o ? void 0 : o.size,
            fileUrl: null === (r = e.file) || void 0 === r ? void 0 : r.fileUrl,
            senderId: e.sender.userId,
            senderGuid: e.sender.userGuid
        };
    }
    function QT(e, t1, o) {
        return new Promise((r, i)=>{
            const n = new FileReader;
            n.readAsArrayBuffer(e.slice(t1, o)), n.onload = (e)=>{
                var t1;
                return r(null === (t1 = e.target) || void 0 === t1 ? void 0 : t1.result);
            }, n.onerror = (e)=>i(e);
        });
    }
    async function ZT(e, t1) {
        let [o, r] = [
            e.size,
            0
        ];
        null != t1 && (o = Math.min(Ys.ChunkSize, e.size - t1), r = t1);
        const i = e.size - r <= Ys.ChunkSize, n = Math.ceil(o / Ys.EncodeBlockSize);
        try {
            return function(e) {
                const t1 = e.reduce((e, t1)=>e + t1.byteLength, 0), o = new Uint8Array(t1);
                let r = 0;
                for (const t1 of e)o.set(new Uint8Array(t1), r), r += t1.byteLength;
                return o;
            }(await Promise.all(Array.from({
                length: i ? Math.max(n - 1, 1) : n
            }, (e, t1)=>({
                    start: t1 * Ys.EncodeBlockSize + r,
                    end: (i && t1 === n - 2 ? t1 + 2 : t1 + 1) * Ys.EncodeBlockSize + r
                })).map(async (o)=>{
                let { start: r, end: i } = o;
                try {
                    const t1 = await QT(e, r, i);
                    return t1 ? await Ts.beginEncrypt({
                        text: new Uint8Array(t1),
                        type: Cs.CHAT_FILE
                    }) : Promise.reject(null);
                } catch (o) {
                    return qT(`encrypt file buffer error. offset:${t1},`, e, o), Promise.reject(o);
                }
            })));
        } catch (e) {
            console.warn(e);
        }
        return null;
    }
    function YT(e, t1, o, r) {
        return r.pipe(Dt(`${Iv}`, `${Ao}`), ot((r)=>{
            if (r.type === `${Ao}`) return !0;
            const { payload: { uniqueId: i, fileName: n, userId: s } } = r;
            return t1 === i && e.name === n && o.userId === s;
        }), nt(1), vt((r)=>{
            WT.info(`Cancel file upload. file name:${dE(e.name)},file size:${e.size},receiver id:${o.userId}`), tp(xa, {
                ...zT(e, o),
                progress: 0,
                status: Xs.Cancel,
                retryToken: r.type === `${Iv}` ? t1 : void 0
            });
        }));
    }
    function XT(e, t1) {
        if (null != e && e.file) {
            const { file: o, receiver: r } = e, { upload: { chunkIndex: i, totalChunks: n, uniqueId: s } } = o;
            return tp(xa, {
                ...zT(t1, r),
                progress: Math.floor((null != i ? i : 0) / (null != n ? n : 1) * 100),
                status: Xs.Fail,
                retryToken: s
            }), _e([
                Ev({
                    upload: {
                        status: Xs.Fail,
                        progress: 0,
                        uniqueId: s
                    }
                }),
                Av({
                    uniqueId: s,
                    file: t1
                })
            ]);
        }
        return ne;
    }
    function eO(e, t1) {
        return tp(xa, {
            ...zT(e),
            progress: 0,
            status: Xs.Fail
        }), Re(Ev({
            upload: {
                status: Xs.Fail,
                progress: 0,
                uniqueId: t1
            }
        }));
    }
    async function tO(e, t1, o, r) {
        const i = GT(e, "/wc/fileupload", r.value), n = new FormData;
        try {
            const s = await ZT(e), a = xT(t1, r.value);
            if (s && a) {
                n.append("file", new File([
                    s
                ], e.name));
                const { meeting: { zmk: d } } = r.value, { receiver: u } = a;
                return QI({
                    url: i,
                    method: "POST",
                    headers: {
                        "Zoom-File-Origin": "redirect=support_auth",
                        zmk: d
                    },
                    crossDomain: ti(i),
                    body: n,
                    includeUploadProgress: !0
                }).pipe(mt(YT(e, t1, u, o)), Fe((o)=>{
                    const { type: i, loaded: n, responseHeaders: s, total: a } = o;
                    let d = 0, l = Xs.InProgress;
                    const c = {
                        upload: {
                            uniqueId: t1
                        }
                    }, p = [];
                    if ("upload_loadstart" === i) d = 0;
                    else if ("upload_progress" === i) d = Math.floor(n / a * 100 * .9);
                    else if ("upload_load" === i) d = 90;
                    else if ("download_load" === i) {
                        var h, m;
                        d = 100, l = Xs.Success;
                        const { chat: { fileServerDomain: e } } = r.value, t1 = null === (h = s["zoom-file-id"]) || void 0 === h ? void 0 : h.trim(), o = null === (m = s["zoom-file-obj"]) || void 0 === m ? void 0 : m.trim(), i = KT(e, {
                            fileObj: o
                        });
                        Object.assign(c, {
                            fileID: t1,
                            fileObj: o,
                            fileUrl: i
                        });
                    }
                    return Object.assign(c.upload, {
                        progress: d,
                        status: l
                    }), (d > 0 || "upload_loadstart" === i) && (tp(xa, {
                        ...zT(e, u),
                        progress: d,
                        status: l
                    }), p.push(Ev(c))), _e(p);
                }), it((t1)=>(console.warn(t1), qT("Upload small file error.", e, t1), XT(a, e))));
            }
        } catch (e) {
            console.warn(e);
        }
        return eO(e, t1);
    }
    const oO = (()=>{
        const e = new Ey;
        return (t1)=>async function() {
                await e.acquire(), t1(...arguments), setTimeout(()=>{
                    e.release();
                }, 3e3);
            };
    })(), rO = function(e) {
        const t1 = [
            "chatFileTransfer"
        ];
        return new Proxy(e, {
            get: (e, o)=>"string" == typeof o && t1.includes(o) ? function() {
                    return oO(e[o].bind(e))(...arguments);
                } : Reflect.get(e, o)
        });
    }(ia.createAgent()), iO = {
        chatHistory: [],
        chatPrivilege: xs.All,
        panelistChatPrivilege: Bs.AllPanelist,
        isAllowAttendeeChat: !0,
        isFileTransferEnable: !0,
        isEnableFileTransferEncrypted: !0,
        fileTransferFileType: [],
        fileDownloadPromptIgnoreList: [],
        fileTransferSizeLimit: 0,
        fileServerDomain: "",
        failedFileTransfer: {}
    }, nO = bo({
        [`${mv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.chatHistory.push(o);
        }),
        [`${pv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.chatPrivilege = o;
        }),
        [`${hv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.panelistChatPrivilege = o;
        }),
        [`${vv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isAllowAttendeeChat = o;
        }),
        [`${fv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { destNodeID: r, msgID: i, userId: n } = o, s = HT(e.chatHistory, {
                userId: n,
                destNodeID: r
            });
            s && Object.assign(s, {
                id: i
            });
        }),
        [`${yv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { msgId: r } = o, i = e.chatHistory.findIndex((e)=>e.id === r);
            i >= 0 && e.chatHistory.splice(i, 1);
        }),
        [`${Sv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            Object.assign(e, o);
        }),
        [`${bv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { originFile: r, ...i } = o;
            e.chatHistory.push(i);
        }),
        [`${Ev}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { upload: r, download: i, originFile: n, ...s } = o;
            if (r) {
                var a;
                const { uniqueId: t1, ...o } = r, i = e.chatHistory.find((e)=>{
                    var o;
                    return e.file && (null === (o = e.file.upload) || void 0 === o ? void 0 : o.uniqueId) === t1;
                });
                null != i && null !== (a = i.file) && void 0 !== a && a.upload && (Object.assign(i.file.upload, {
                    ...o
                }), Object.assign(i.file, {
                    ...s
                }), i.file.upload.status === Xs.Success && e.failedFileTransfer[i.file.upload.uniqueId] && delete e.failedFileTransfer[i.file.upload.uniqueId]);
            } else if (i) {
                const { id: t1, fileUrl: o } = s, r = e.chatHistory.find((e)=>{
                    var r;
                    return e.id === t1 && (null === (r = e.file) || void 0 === r ? void 0 : r.fileUrl) === o;
                });
                null != r && r.file && (r.file.download ? Object.assign(r.file.download, {
                    ...i
                }) : Object.assign(r.file, {
                    download: i
                }));
            }
        }),
        [`${Iv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { uniqueId: r, fileName: i, userId: n } = o, s = e.chatHistory.find((e)=>e.file && e.file.name == i && e.file.upload.uniqueId === r && e.file.upload.status === Xs.InProgress && e.receiver.userId === n);
            var a;
            null != s && s.file && Object.assign(null === (a = s.file) || void 0 === a ? void 0 : a.upload, {
                status: Xs.Cancel,
                progress: 0
            });
        }),
        [`${Av}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { uniqueId: r, file: i } = o;
            e.failedFileTransfer[`${r}`] || Object.assign(e.failedFileTransfer, {
                [`${r}`]: i
            });
        }),
        [`${Cv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { fileID: r, msgID: i, senderId: n } = o, s = e.chatHistory.find((e)=>{
                var t1;
                return (null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.fileID) === r && e.sender.userId === n;
            });
            s && Object.assign(s, {
                id: i
            });
        }),
        [`${_v}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { id: r, fileUrl: i } = o, n = e.chatHistory.find((e)=>{
                var t1, o;
                return e.id === r && (null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.fileUrl) === i && (null === (o = e.file) || void 0 === o ? void 0 : o.download.status) === ea.InProgress;
            });
            var s;
            null != n && n.file && Object.assign(null === (s = n.file) || void 0 === s ? void 0 : s.download, {
                status: ea.Cancel,
                progress: 0
            });
        }),
        [`${gv}`]: ()=>({
                ...iO
            })
    }, iO);
    var sO;
    const aO = ia.createAgent();
    let dO = (sO = class extends vT {
        send(e, t1) {
            if (!e) return Promise.reject({
                type: Zl,
                reason: "Text is empty"
            });
            const { [oT]: o, [rT]: r } = this, i = o(), n = ah(i), s = VT(i, t1), a = NT(n, s, i);
            if (a) return Promise.reject(a);
            const { meeting: { isWebinar: d, encType: u } } = i, l = u === As.AES_GCM;
            let c = Promise.resolve(), p = !1;
            const h = d && Kp(s.userRole);
            return t1 === Fs.SilentModeUsers ? aO.chat($r(e), t1) : d ? h ? 8 & ~s.clientCap ? (c = jT({
                text: e,
                destId: Fs.Panelist,
                sn: null == n ? void 0 : n.zoomID,
                attendeeId: t1
            }).then(()=>(function(e) {
                    const { text: t1, jid: o, isGCMEnabled: r } = e;
                    return Ts.beginEncrypt({
                        text: t1,
                        type: Cs.XMPP_CHAT
                    }).then((e)=>{
                        LT.sendWebinarMseeage(e, o, Fs.IndividualCcPanelist, r);
                    });
                })({
                    text: e,
                    jid: s.jid,
                    isGCMEnabled: l
                })), p = !0) : c = jT({
                text: e,
                destId: Fs.IndividualCcPanelist,
                sn: null == n ? void 0 : n.zoomID,
                attendeeId: t1
            }) : s && (c = jT({
                text: e,
                destId: s.userId,
                sn: null == n ? void 0 : n.zoomID
            })) : c = jT({
                text: e,
                destId: s.userId,
                sn: null == n ? void 0 : n.zoomID
            }), c.then(()=>{
                const o = function(e, t1, o, r) {
                    const i = (new Date).getTime(), n = performance.now();
                    return {
                        message: e,
                        sender: {
                            name: t1.displayName,
                            userId: t1.userId,
                            userGuid: t1.userGUID,
                            avatar: t1.avatar
                        },
                        receiver: {
                            name: null == o ? void 0 : o.displayName,
                            userId: r ? Fs.IndividualCcPanelist : null == o ? void 0 : o.userId,
                            userGuid: null == o ? void 0 : o.userGUID
                        },
                        timestamp: i,
                        highResTimeStampForIdentification: n
                    };
                }(e, n, s, h);
                return r(mv(o)), p ? (tp(Na, o), o) : new Promise((e, r)=>{
                    np(Ua).pipe(Me(5e3), ct((e)=>o.highResTimeStampForIdentification !== e.identification || !([
                            e.receiverId,
                            Fs.All,
                            Fs.Panelist
                        ].includes(t1) || e.receiverId === Fs.IndividualCcPanelist)), nt(1)).subscribe((t1)=>{
                        const { msgId: r } = t1, { highResTimeStampForIdentification: i, ...n } = o, a = {
                            id: r,
                            ...n,
                            ...h && {
                                receiver: {
                                    name: null == s ? void 0 : s.displayName,
                                    userId: null == s ? void 0 : s.userId
                                }
                            }
                        };
                        tp(Na, a), e(a);
                    }, ()=>{
                        r({
                            type: ql
                        });
                    });
                });
            });
        }
        setPrivilege(e) {
            const t1 = this[oT](), { meeting: { isWebinar: o }, chat: { chatPrivilege: r }, breakoutRoom: i } = t1;
            return r === e ? Promise.resolve("") : (null == i ? void 0 : i.controlStatus) === qp.InProgress && AT(t1) ? Promise.reject({
                type: Kl,
                reason: "Cannot update chat privilege in a subsession"
            }) : !o && !Ws.includes(e) || o && !Gs.includes(e) ? Promise.reject({
                type: Zl,
                reason: "invalid privilege value of parameter"
            }) : (aO.setChatPriviledge(e), ip(Va, (t1)=>t1.chatPrivilege === e));
        }
        setPanelistPrivilege(e) {
            const t1 = this[oT](), { chat: { panelistChatPrivilege: o } } = t1, r = zs[e];
            return o === r ? Promise.resolve("") : Object.values(Ks).includes(e) ? (aO.setPanelistChatPrivilege(e), ip(Va, (e)=>e.panelistChatPrivilege === r)) : Promise.reject({
                type: Zl,
                reason: "Panelist privilege value is invalid"
            });
        }
        deleteMessage(e) {
            const t1 = this[oT](), { chat: { chatHistory: o }, meeting: { meetingOptions: r, userId: i } } = t1;
            if (null != r && r.isEnableDeleteChatMsg) {
                const r = dh(t1), n = o.find((t1)=>t1.id === e);
                if (n) {
                    const { sender: t1 } = n;
                    if (r) aO.chatCmdReq(e, Hs.Delete);
                    else {
                        if (t1.userId !== i) return Promise.reject({
                            type: Jl,
                            reason: "can not delete message"
                        });
                        aO.chatCmdReq(e, Hs.Delete);
                    }
                    return ip(ja, (t1)=>t1.id === e).then(()=>({
                            id: e
                        }));
                }
                return Promise.reject({
                    type: Zl,
                    reason: "msgId is wrong"
                });
            }
            return Promise.reject({
                type: Kl,
                reason: "can not delete messages"
            });
        }
        lockChat(e) {
            const t1 = this[oT](), { meeting: { meetingOptions: o } } = t1, r = null != o && o.isPrivateChatEnabled ? xs.All : xs.EveryonePublicly;
            return this.setPrivilege(e ? xs.NoOne : r);
        }
        sendFile(e, t1) {
            if (!e) return Promise.reject({
                type: Zl,
                reason: "File is empty"
            });
            const { [oT]: o, [rT]: r } = this, i = o(), { chat: { isFileTransferEnable: n, fileTransferFileType: s, fileTransferSizeLimit: a, failedFileTransfer: d } } = i;
            if (!n) return Promise.reject({
                type: Kl,
                reason: "Send files via in-session chat is not enabled"
            });
            if ("string" == typeof e) {
                const t1 = xT(e, i);
                if (null != t1 && t1.file && d[e]) {
                    const { file: { upload: o, ...i } } = t1, { file: { name: n, upload: { uniqueId: s } }, receiver: { userId: a } } = t1;
                    return r(Ev({
                        originFile: d[e],
                        ...i,
                        upload: {
                            ...o,
                            status: Xs.InProgress
                        }
                    })), Promise.resolve(()=>{
                        r(Iv({
                            uniqueId: s,
                            fileName: n,
                            userId: a
                        }));
                    });
                }
                return Promise.reject({
                    type: Zl,
                    reason: "Retry token is not correct."
                });
            }
            {
                const { name: o } = e;
                if (s.length > 0) {
                    const [e] = o.split(".").reverse();
                    if (!s.some((t1)=>t1 === e)) return Promise.reject({
                        type: Kl,
                        reason: "File is not in the allow list"
                    });
                }
                if (e.size > a) return Promise.reject({
                    type: Kl,
                    reason: "File size exceeds the maximum limit."
                });
                const n = ah(i), d = VT(i, t1), u = NT(n, d, i);
                if (u) return Promise.reject(u);
                const l = Qr();
                return r(bv(function(e, t1, o, r) {
                    const i = (new Date).getTime();
                    return {
                        file: {
                            name: e.name,
                            size: e.size,
                            type: e.type,
                            upload: {
                                progress: 0,
                                uniqueId: t1,
                                totalChunks: 0,
                                chunkIndex: 0
                            }
                        },
                        originFile: e,
                        sender: {
                            name: o.displayName,
                            userId: o.userId,
                            userGuid: o.userGUID,
                            avatar: o.avatar
                        },
                        receiver: {
                            name: null == r ? void 0 : r.displayName,
                            userId: null == r ? void 0 : r.userId,
                            attendeeId: void 0,
                            userGuid: null == r ? void 0 : r.userGUID
                        },
                        timestamp: i
                    };
                }(e, l, n, d))), Promise.resolve(()=>{
                    r(Av({
                        uniqueId: l,
                        file: e
                    })), r(Iv({
                        uniqueId: l,
                        fileName: o,
                        userId: null == d ? void 0 : d.userId
                    }));
                });
            }
        }
        downloadFile(e, t1, o) {
            const { [oT]: r, [rT]: i } = this, { chat: { chatHistory: n } } = r();
            if (!e || !t1) return Promise.reject({
                type: Zl,
                reason: "Invalid message id or file url!"
            });
            const s = n.find((o)=>{
                var r;
                return o.id === e && (null === (r = o.file) || void 0 === r ? void 0 : r.fileUrl) === t1;
            });
            return s ? (i(Ev({
                id: e,
                fileUrl: t1,
                download: {
                    status: ea.InProgress,
                    progress: 0,
                    blob: o
                }
            })), Promise.resolve(()=>i(_v({
                    id: e,
                    fileUrl: t1
                })))) : Promise.reject({
                type: Zl,
                reason: "Invalid message id or file url!"
            });
        }
        getPrivilege() {
            const { chat: { chatPrivilege: e, isAllowAttendeeChat: t1 } } = this[oT]();
            return t1 ? e : xs.NoAttendee;
        }
        getReceivers() {
            const e = this[oT](), { chat: { chatPrivilege: t1, panelistChatPrivilege: o, isAllowAttendeeChat: r }, meeting: { isWebinar: i } } = e;
            if (!i && !r) return [];
            const n = ah(e), s = dh(e);
            if (n) if (i) if (Kp(n.userRole)) {
                if (!r) return [];
                if (t1 === xs.All) return [
                    Js,
                    qs
                ];
                if (t1 === xs.AllPanelist) return [
                    Js
                ];
                if (t1 === xs.NoOne) return [];
            } else {
                if (s || o === Bs.Everyone) {
                    const t1 = UT(e, n.userId, {
                        includeAttendee: !0
                    });
                    return [
                        Js,
                        qs,
                        ...t1
                    ];
                }
                if (o === Bs.AllPanelist) {
                    const t1 = UT(e, n.userId);
                    return [
                        Js,
                        ...t1
                    ];
                }
            }
            else {
                const o = dh(e);
                if (t1 === xs.All || o) {
                    const t1 = UT(e, n.userId);
                    return [
                        qs,
                        ...t1
                    ];
                }
                if (t1 === xs.Host) return UT(e, n.userId, {
                    host: !0
                });
                if (t1 === xs.EveryonePublicly) {
                    const t1 = UT(e, n.userId, {
                        host: !0
                    });
                    return [
                        qs,
                        ...t1
                    ];
                }
                if (t1 === xs.NoOne) return [];
            }
            return [];
        }
        getHistory() {
            return this[oT]().chat.chatHistory.map((e)=>{
                const { highResTimeStampForIdentification: t1, ...o } = e;
                if (o.file) {
                    const { name: e, size: t1, type: r, fileUrl: i, upload: n, download: s } = o.file, a = {
                        name: e,
                        size: t1,
                        type: r,
                        fileUrl: i
                    };
                    return n && Object.assign(a, {
                        upload: {
                            status: n.status,
                            progress: n.progress
                        }
                    }), s && Object.assign(a, {
                        download: {
                            status: s.status,
                            progress: s.progress
                        }
                    }), {
                        ...o,
                        file: a
                    };
                }
                return o;
            });
        }
        isAllowToDeleteMessages() {
            const e = this[oT](), { meeting: { meetingOptions: t1 } } = e;
            return null == t1 ? void 0 : t1.isEnableDeleteChatMsg;
        }
        isFileTransferEnabled() {
            return this[oT]().chat.isFileTransferEnable;
        }
        getFileTransferSetting() {
            const e = this[oT](), { chat: { fileTransferFileType: t1, fileTransferSizeLimit: o } } = e;
            return {
                typeLimit: (null != t1 ? t1 : []).map((e)=>`.${e}`).join(","),
                sizeLimit: o
            };
        }
    }, eT(sO.prototype, "send", [
        sT
    ], Object.getOwnPropertyDescriptor(sO.prototype, "send"), sO.prototype), eT(sO.prototype, "setPrivilege", [
        aT,
        sT
    ], Object.getOwnPropertyDescriptor(sO.prototype, "setPrivilege"), sO.prototype), eT(sO.prototype, "setPanelistPrivilege", [
        aT,
        sT,
        function(e, t1, o) {
            const r = o.value;
            o.value = function() {
                const e = this[tT];
                if (e) {
                    const { meeting: { isWebinar: t1 } } = e.getState();
                    if (!t1) return Promise.reject({
                        type: Ql,
                        reason: "non-webinar"
                    });
                }
                for(var t1 = arguments.length, o = new Array(t1), i = 0; i < t1; i++)o[i] = arguments[i];
                return r.apply(this, o);
            };
        }
    ], Object.getOwnPropertyDescriptor(sO.prototype, "setPanelistPrivilege"), sO.prototype), eT(sO.prototype, "deleteMessage", [
        sT
    ], Object.getOwnPropertyDescriptor(sO.prototype, "deleteMessage"), sO.prototype), eT(sO.prototype, "lockChat", [
        aT,
        sT
    ], Object.getOwnPropertyDescriptor(sO.prototype, "lockChat"), sO.prototype), eT(sO.prototype, "sendFile", [
        sT
    ], Object.getOwnPropertyDescriptor(sO.prototype, "sendFile"), sO.prototype), eT(sO.prototype, "downloadFile", [
        sT
    ], Object.getOwnPropertyDescriptor(sO.prototype, "downloadFile"), sO.prototype), sO);
    const uO = {
        epics0: (e, t1)=>ar(e, 24583).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                if (o.meeting.zlkJwtToken) return ne;
                const { payload: { body: { sn: r, senderName: i, senderJid: n, receiver: s, text: a, type: d } } } = t1, u = ah(o), l = lh(o), { meeting: { jid: c, userId: p }, participants: { xmppAttendeeList: h } } = o;
                return Ts.beginDecrypt({
                    decryptedText: a,
                    type: Cs.XMPP_CHAT,
                    zoomId: r
                }).then((e)=>{
                    var t1;
                    let { message: o } = e, r = null, a = 0, m = "";
                    u && Kp(u.userRole) && c === s ? (r = h.find((e)=>e.jid === n), a = p, m = u.displayName) : d === Fs.Panelist && (r = l.find((e)=>e.jid === n), a = Fs.Panelist, m = Js.displayName);
                    const g = {
                        message: o,
                        sender: {
                            name: i,
                            userId: (null === (t1 = r) || void 0 === t1 ? void 0 : t1.userId) || 0,
                            avatar: ""
                        },
                        receiver: {
                            name: m,
                            userId: a
                        },
                        timestamp: (new Date).getTime()
                    };
                    return tp(Na, g), mv(g);
                });
            })),
        epics1: (e, t1)=>nr(e, 7944).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { meeting: { bIbDisableChat: r } } = o, { payload: { body: { attendeeNodeID: i, sn: n, destNodeID: s, text: a, senderName: d, msgID: u } } } = t1, l = ah(o);
                if (l) {
                    const e = Kp(null == l ? void 0 : l.userRole) && i === l.userId && !u;
                    if (!r && !e) {
                        const { sn: e, ...t1 } = BT({
                            destNodeID: s,
                            attendeeNodeID: i,
                            senderName: d,
                            sn: n
                        }, o);
                        return (i === Fs.SilentModeUsers ? Promise.resolve({
                            id: u,
                            message: Wr(a),
                            ...t1
                        }) : Ts.beginDecrypt({
                            decryptedText: a,
                            zoomId: e,
                            type: Cs.RWG_CHAT
                        }).then((e)=>{
                            let { message: o } = e;
                            return {
                                id: u,
                                message: o,
                                ...t1
                            };
                        })).then((e)=>(tp(Na, e), mv(e)));
                    }
                }
                return ne;
            })),
        epics2: (e, t1)=>nr(e, Ms).pipe(ot((e)=>{
                var t1, o;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.chatPriviledge) || void 0 !== (null === (o = e.payload.body) || void 0 === o ? void 0 : o.bAllowAttendeeChat);
            }), ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { payload: { body: { chatPriviledge: r, bAllowAttendeeChat: i } } } = t1, { chat: { chatPrivilege: n } } = o;
                return void 0 !== i ? (tp(Va, !0 === i ? {
                    chatPrivilege: n
                } : {
                    chatPrivilege: xs.NoAttendee
                }), vv(i)) : (tp(Va, {
                    chatPrivilege: r
                }), pv(r));
            })),
        epics3: (e)=>nr(e, Ms).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.panelistChatPriviledge);
            }), Le((e)=>{
                const { payload: { body: { panelistChatPriviledge: t1 } } } = e;
                return tp(Va, {
                    panelistChatPrivilege: t1
                }), hv(t1);
            })),
        epics4: (e, t1)=>nr(e, 4136).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { payload: { body: { result: r, destNodeID: i, msgID: n, fileID: s } } } = t1, { meeting: { userId: a }, chat: { chatHistory: d } } = o, u = [];
                if (r === $s.Success) if (s) {
                    const e = d.find((e)=>{
                        var t1;
                        return (null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.fileID) === s;
                    });
                    if (e) {
                        const { file: t1, receiver: o, ...r } = e, { name: i, size: d, type: l, fileUrl: c } = null != t1 ? t1 : {}, { attendeeId: p, ...h } = o;
                        tp(Na, {
                            id: n,
                            file: {
                                name: i,
                                size: d,
                                type: l,
                                fileUrl: c,
                                upload: {
                                    status: Xs.Complete,
                                    progress: 100
                                }
                            },
                            receiver: {
                                ...h
                            },
                            ...r
                        }), u.push(Cv({
                            fileID: s,
                            msgID: n,
                            senderId: a
                        }));
                    }
                } else {
                    const e = HT(d, {
                        userId: a,
                        destNodeID: i
                    });
                    var l;
                    e && (tp(Ua, {
                        msgId: n,
                        receiverId: i,
                        identification: null !== (l = e.highResTimeStampForIdentification) && void 0 !== l ? l : 0
                    }), u.push(fv({
                        destNodeID: i,
                        msgID: n,
                        userId: a
                    })));
                }
                else r !== $s.Delete && r !== $s.Block || u.push(yv({
                    msgId: n
                }));
                return _e(u);
            })),
        epics5: (e)=>nr(e, 4238).pipe(Fe((e)=>{
                const { payload: { body: { bSuccess: t1, cmd: o, msgID: r } } } = e, i = [];
                return t1 && o === Hs.Delete && (i.push(yv({
                    msgId: r
                })), tp(ja, {
                    id: r
                })), _e(i);
            })),
        epics6: (e)=>nr(e, 7960).pipe(Fe((e)=>{
                const { payload: { body: { cmd: t1, msgID: o } } } = e, r = [];
                return t1 === Hs.Delete && (r.push(yv({
                    msgId: o
                })), tp(ja, {
                    id: o
                })), _e(r);
            }))
    }, lO = ir(uO, {
        chatFileEpics0: (e)=>e.pipe(Dt(`${pn}`), Le((e)=>{
                var t1, o, r;
                const { payload: { fileTransfer: i, fileServerDomain: n } } = e;
                return Sv({
                    isFileTransferEnable: null == i ? void 0 : i.isEnable,
                    isEnableFileTransferEncrypted: null == i ? void 0 : i.isEnableFileTransferEncrypted,
                    fileTransferFileType: (null !== (t1 = null == i ? void 0 : i.fileType) && void 0 !== t1 ? t1 : "").replace(/\./g, "").split(",").filter(Boolean),
                    fileTransferSizeLimit: 1024 * (null !== (o = null == i ? void 0 : i.sizeLimit) && void 0 !== o ? o : 0) * 1024 || Ys.MaxSize,
                    fileDownloadPromptIgnoreList: (null !== (r = null == i ? void 0 : i.fileDownloadPromptIgnoreList) && void 0 !== r ? r : "").replace(/\./g, "").split(","),
                    fileServerDomain: `https://${n}`
                });
            })),
        chatFileEpics1: (e, t1)=>e.pipe(Dt(`${bv}`), Fe(async (o)=>{
                const { payload: { originFile: r, file: { upload: { uniqueId: i } } } } = o;
                return r.size > Ys.ChunkSize ? await async function(e, t1, o, r) {
                    const i = GT(e, "/wc/multiupload/init", r.value), n = await async function(e) {
                        const t1 = Math.ceil(e.size / Ys.ReaderChunkSize);
                        return (await Promise.all(Array.from({
                            length: t1
                        }, (e, t1)=>({
                                start: t1 * Ys.ReaderChunkSize,
                                end: (t1 + 1) * Ys.ReaderChunkSize
                            })).map(async (t1)=>{
                            let { start: o, end: r } = t1;
                            try {
                                const t1 = await QT(e, o, r);
                                return ii(await window.crypto.subtle.digest("SHA-256", t1));
                            } catch (t1) {
                                return qT("calculate file hash error.", e, t1), Promise.reject(t1);
                            }
                        }))).join("");
                    }(e), { meeting: { zmk: s, meetingId: a } } = r.value, d = xT(t1, r.value);
                    if (n && d) {
                        const { receiver: r } = d, u = {
                            fileName: e.name,
                            length: e.size,
                            channelType: 4,
                            digest: n,
                            shareJid: a
                        };
                        return QI({
                            url: i,
                            method: "POST",
                            headers: {
                                "Zoom-File-Origin": "redirect=support_auth",
                                zmk: s
                            },
                            crossDomain: ti(i),
                            body: u
                        }).pipe(mt(YT(e, t1, r, o)), Le((o)=>{
                            var r;
                            const { responseHeaders: i, response: n } = o, s = null === (r = i["x-zm-trackingid"]) || void 0 === r ? void 0 : r.trim(), { uploadid: a, path: d, metadata: u } = n, l = Math.ceil(e.size / Ys.ChunkSize);
                            return Ev({
                                originFile: e,
                                upload: {
                                    uniqueId: t1,
                                    status: Xs.InProgress,
                                    progress: 0,
                                    chunkIndex: 0,
                                    totalChunks: l,
                                    uploadid: a,
                                    trackingId: s,
                                    path: d,
                                    metadata: u
                                }
                            });
                        }), it((t1)=>(console.warn(t1), qT("Upload file meta error.", e, t1), XT(d, e))), pt(Ev({
                            upload: {
                                uniqueId: t1,
                                status: Xs.Init
                            }
                        })));
                    }
                    return eO(e, t1);
                }(r, i, e, t1) : await tO(r, i, e, t1);
            }), Fe((e)=>e)),
        chatFileEpics2: (e, t1)=>e.pipe(Dt(`${Ev}`), ot((e)=>{
                var t1;
                return (null === (t1 = e.payload.upload) || void 0 === t1 ? void 0 : t1.status) === Xs.Success;
            }), Zy(async (e)=>{
                const { payload: { upload: { uniqueId: o } } } = e, { chat: { isEnableFileTransferEncrypted: r, chatHistory: i } } = t1.value, n = i.find((e)=>{
                    var t1;
                    return (null === (t1 = e.file) || void 0 === t1 || null === (t1 = t1.upload) || void 0 === t1 ? void 0 : t1.uniqueId) === o;
                }), s = [];
                if (n && n.file) {
                    const { file: { name: e, size: t1, fileObj: i, fileID: a, type: d }, receiver: { userId: u, attendeeId: l } } = n;
                    let [c, p] = [
                        "",
                        ""
                    ];
                    if (r) {
                        const [o, r] = await Promise.all([
                            e,
                            `${t1}`
                        ].map((e)=>Ts.beginEncrypt({
                                text: e,
                                type: Cs.RWG_CHAT
                            })));
                        [c, p] = [
                            o,
                            r
                        ];
                    } else [c, p] = [
                        e,
                        `${t1}`
                    ].map((e)=>$r(e));
                    await rO.chatFileTransfer({
                        fileID: a,
                        fileSize: p,
                        fileName: c,
                        fileObj: i,
                        type: d,
                        destNodeID: u,
                        attendeeNodeID: l
                    }), s.push(Ev({
                        upload: {
                            uniqueId: o,
                            status: Xs.Complete
                        }
                    }));
                }
                return s;
            })),
        chatFileEpics3: (e, t1)=>e.pipe(Dt(`${Ev}`), ot((e)=>{
                const { payload: { upload: t1, originFile: o } } = e;
                return !!t1 && !!t1.uniqueId && t1.status === Xs.InProgress && (null == o ? void 0 : o.size) <= Ys.ChunkSize && 0 === t1.totalChunks;
            }), Fe(async (o)=>{
                const { payload: { originFile: r, upload: { uniqueId: i } } } = o;
                return await tO(r, i, e, t1);
            }), Fe((e)=>e)),
        chatFileEpics4: (e, t1)=>e.pipe(Dt(`${Ev}`), ot((e)=>{
                const { payload: { upload: t1 } } = e;
                return !!t1 && !!t1.uniqueId && t1.totalChunks > 0 && t1.chunkIndex !== t1.totalChunks;
            }), Fe(async (o)=>{
                const { payload: { originFile: r, upload: { uniqueId: i } } } = o;
                return await async function(e, t1, o, r) {
                    const i = xT(t1, r.value);
                    if (null != i && i.file) {
                        const { file: { upload: { chunkIndex: n, totalChunks: s, uploadid: a, path: d, trackingId: u, etags: l }, size: c }, receiver: p } = i, h = n * Ys.ChunkSize, m = await ZT(e, h);
                        if (m) {
                            const { chat: { fileServerDomain: h }, meeting: { zmk: g } } = r.value, v = `${h}/upload/parts?${new URLSearchParams({
                                uploadid: a,
                                partNumber: n + 1
                            }).toString()}`, f = new FormData, y = new File([
                                m
                            ], e.name);
                            return f.append("file", y), QI({
                                url: v,
                                method: "POST",
                                headers: {
                                    "Zoom-File-Size": y.size,
                                    "Zoom-File-Path": d,
                                    "x-zm-trackingid": u,
                                    "Zoom-File-Origin": "redirect=support_auth",
                                    zmk: g
                                },
                                crossDomain: ti(v),
                                body: f,
                                includeUploadProgress: !0
                            }).pipe(mt(YT(e, t1, p, o)), Fe((o)=>{
                                var i;
                                const { type: a, loaded: d, total: u, responseHeaders: h } = o;
                                let m = 0;
                                const g = {
                                    upload: {
                                        uniqueId: t1,
                                        status: Xs.InProgress
                                    }
                                }, v = [], f = xT(t1, r.value), y = null == f || null === (i = f.file) || void 0 === i ? void 0 : i.upload.progress;
                                if ("upload_loadstart" === a) m = y || Math.floor(n / s * 100);
                                else if ("upload_progress" === a) m = Math.floor((n * Ys.ChunkSize + .9 * d) / c * 100);
                                else if ("upload_load" === a) m = Math.floor((n * Ys.ChunkSize + .9 * u) / c * 100);
                                else if ("download_load" === a) {
                                    m = y || Math.floor((n + 1) / s * 100);
                                    const t1 = h["x-zm-etag"].trim(), o = l ? {
                                        ...l,
                                        [`${n + 1}`]: t1
                                    } : {
                                        [`${n + 1}`]: t1
                                    };
                                    Object.assign(g.upload, {
                                        etags: o,
                                        chunkIndex: n + 1,
                                        totalChunks: s
                                    }), Object.assign(g, {
                                        originFile: e
                                    });
                                }
                                return (m > 0 || "upload_loadstart" === a) && (Object.assign(g.upload, {
                                    progress: m
                                }), tp(xa, {
                                    ...zT(e, p),
                                    progress: m,
                                    status: Xs.InProgress
                                }), v.push(Ev(g))), _e(v);
                            }), it((t1)=>(console.warn(t1), qT(`Upload file chunk error. chunk:${n},total chunks:${s},uploadid:${a},trackingId:${u}`, e, t1), XT(i, e))));
                        }
                    }
                    return eO(e, t1);
                }(r, i, e, t1);
            }), Fe((e)=>e)),
        chatFileEpics5: (e, t1)=>e.pipe(Dt(`${Ev}`), ot((e)=>{
                const { payload: { upload: t1 } } = e;
                return !!t1 && !!t1.uniqueId && t1.totalChunks > 0 && t1.chunkIndex == t1.totalChunks;
            }), Fe((o)=>{
                const { payload: { originFile: r, upload: { uniqueId: i } } } = o;
                return function(e, t1, o, r) {
                    const { chat: { fileServerDomain: i }, meeting: { zmk: n } } = r.value, s = xT(t1, r.value);
                    if (null != s && s.file) {
                        const { file: { upload: { uploadid: a, metadata: d, etags: u, trackingId: l } }, receiver: c } = s, p = `${i}/upload/complete?uploadid=${a}`;
                        return QI({
                            url: p,
                            method: "POST",
                            headers: {
                                "x-zm-trackingid": l,
                                "Zoom-File-Origin": "redirect=support_auth",
                                zmk: n
                            },
                            crossDomain: ti(p),
                            body: {
                                metadata: d,
                                etags: u
                            }
                        }).pipe(mt(YT(e, t1, c, o)), Le((o)=>{
                            var i, n;
                            const { chat: { fileServerDomain: s } } = r.value, { responseHeaders: a } = o, d = null === (i = a["zoom-file-id"]) || void 0 === i ? void 0 : i.trim(), u = null === (n = a["zoom-file-obj"]) || void 0 === n ? void 0 : n.trim(), l = `${s}/zoomfile/download?objkey=${u}&business=meeting`;
                            return tp(xa, {
                                ...zT(e, c),
                                progress: 100,
                                status: Xs.Success
                            }), Ev({
                                fileID: d,
                                fileObj: u,
                                fileUrl: l,
                                upload: {
                                    uniqueId: t1,
                                    progress: 100,
                                    status: Xs.Success
                                }
                            });
                        }), it((t1)=>(console.warn(t1), qT(`Upload chunks checksum error.uploadid${a},trackingId${l}`, e, t1), XT(s, e))));
                    }
                    return eO(e, t1);
                }(r, i, e, t1);
            })),
        chatFileEpics6: (e, t1)=>nr(e, 4308).pipe(Zy(async (e)=>{
                const { payload: { body: { attendeeNodeID: o, destNodeID: r, fileID: i, fileName: n, fileObj: s, fileSize: a, fileType: d, msgID: u, senderName: l } } } = e, { meeting: { bIbDisableChat: c }, chat: { fileServerDomain: p, isEnableFileTransferEncrypted: h } } = t1.value, m = [];
                if (!c) {
                    const e = KT(p, {
                        fileObj: s,
                        fileID: i
                    });
                    if (d === Zs.Local) {
                        const { sn: d, ...c } = BT({
                            destNodeID: r,
                            attendeeNodeID: o,
                            senderName: l
                        }, t1.value);
                        let [p, g] = [
                            "",
                            0
                        ];
                        if (h) {
                            const [e, t1] = await Promise.all([
                                n,
                                a
                            ].map((e)=>Ts.beginDecrypt({
                                    decryptedText: e,
                                    zoomId: d,
                                    type: Cs.RWG_CHAT
                                })));
                            p = e.message, g = Number(t1.message);
                        } else p = Wr(n), g = Number(Wr(a));
                        const v = {
                            id: u,
                            file: {
                                name: p,
                                size: g,
                                fileUrl: e
                            },
                            ...c
                        };
                        m.push(mv({
                            ...v,
                            file: {
                                ...v.file,
                                fileID: i,
                                fileObj: s
                            }
                        })), setTimeout(()=>{
                            tp(Na, v);
                        }, 0);
                    }
                }
                return m;
            })),
        chatFileEpics7: (e, t1)=>e.pipe(Dt(`${Ev}`), ot((e)=>{
                var t1, o;
                const { payload: r } = e;
                return r.id && r.fileUrl && (null === (t1 = r.download) || void 0 === t1 ? void 0 : t1.status) === ea.InProgress && 0 === (null === (o = r.download) || void 0 === o ? void 0 : o.progress);
            }), Fe((o)=>(function(e, t1, o) {
                    var r;
                    const { chat: { chatHistory: i }, meeting: { zmk: n }, participants: { attendeesList: s } } = o.value, a = i.find((t1)=>t1.id === e);
                    if (null != a && null !== (r = a.file) && void 0 !== r && r.fileUrl) {
                        const { file: { fileUrl: o } } = a;
                        return QI({
                            url: o,
                            method: "GET",
                            headers: {
                                "Zoom-File-Origin": "redirect=support_auth",
                                zmk: n
                            },
                            crossDomain: ti(o),
                            responseType: "arraybuffer",
                            includeDownloadProgress: !0
                        }).pipe(mt(function(e, t1) {
                            return t1.pipe(Dt(`${_v}`, `${Ao}`), ot((t1)=>{
                                if (t1.type === `${Ao}`) return !0;
                                const { payload: { id: o } } = t1;
                                return e.id === o;
                            }), nt(1), vt(()=>{
                                var t1, o, r;
                                WT.info(`Cancel file download. file name:${dE(null === (t1 = e.file) || void 0 === t1 ? void 0 : t1.name)},file size:${null === (o = e.file) || void 0 === o ? void 0 : o.size},sender id:${null === (r = e.sender) || void 0 === r ? void 0 : r.userId}`), tp(Ba, {
                                    ...JT(e),
                                    progress: 0,
                                    status: ea.Cancel
                                });
                            }));
                        }(a, t1)), Zy(async (t1)=>{
                            const { type: o, loaded: r, total: i } = t1, n = [], d = {
                                ...JT(a),
                                progress: 0,
                                status: ea.InProgress
                            };
                            if ("download_loadstart" === o && Object.assign(d, {
                                progress: 0
                            }), "download_progress" === o) {
                                var u;
                                const t1 = Math.floor(r / i * 100);
                                n.push(Ev({
                                    id: e,
                                    fileUrl: null === (u = a.file) || void 0 === u ? void 0 : u.fileUrl,
                                    download: {
                                        progress: t1
                                    }
                                })), Object.assign(d, {
                                    progress: t1
                                });
                            } else if ("download_load" === o) {
                                var l, c, p;
                                const o = 100, r = ea.Success;
                                Object.assign(d, {
                                    progress: o,
                                    status: r
                                }), n.push(Ev({
                                    id: e,
                                    fileUrl: null === (l = a.file) || void 0 === l ? void 0 : l.fileUrl,
                                    download: {
                                        progress: o,
                                        status: r
                                    }
                                }));
                                const i = null === (c = s.find((e)=>e.userId === a.sender.userId)) || void 0 === c ? void 0 : c.zoomID, u = await async function(e, t1, o) {
                                    const r = Math.ceil(e.byteLength / Ys.DecodeBlockSize);
                                    try {
                                        const i = await Promise.all(Array.from({
                                            length: Math.max(r - 1, 1)
                                        }, (e, t1)=>({
                                                start: t1 * Ys.DecodeBlockSize,
                                                end: (t1 === r - 2 ? t1 + 2 : t1 + 1) * Ys.DecodeBlockSize
                                            })).map(async (r)=>{
                                            let { start: i, end: n } = r;
                                            try {
                                                const t1 = e.slice(i, n), { message: r } = await Ts.beginDecrypt({
                                                    decryptedText: t1,
                                                    zoomId: o,
                                                    type: Cs.CHAT_FILE
                                                });
                                                return r;
                                            } catch (o) {
                                                return qT("decrypt file buffer error.", {
                                                    name: t1,
                                                    size: e.byteLength
                                                }, o), Promise.reject(o);
                                            }
                                        }));
                                        return new Blob(i, {
                                            type: FT(t1)
                                        });
                                    } catch (e) {
                                        return null;
                                    }
                                }(t1.response, null === (p = a.file) || void 0 === p ? void 0 : p.name, i);
                                var h, m;
                                u && (null !== (h = a.file) && void 0 !== h && h.download.blob ? Object.assign(d, {
                                    fileBlob: u
                                }) : function(e, t1) {
                                    const o = document.createElement("a"), r = window.URL.createObjectURL(e);
                                    o.href = r, o.download = t1, o.click(), window.URL.revokeObjectURL(r);
                                }(u, null === (m = a.file) || void 0 === m ? void 0 : m.name));
                            }
                            return (d.progress > 0 || "download_loadstart" === o) && tp(Ba, d), n;
                        }), it((t1)=>(console.warn(t1), qT(`download file error. file url:${o}`, {
                                name: void 0,
                                size: void 0
                            }, t1), tp(Ba, {
                                ...JT(a),
                                progress: 0,
                                status: ea.Fail
                            }), Re(Ev({
                                id: e,
                                fileUrl: o,
                                download: {
                                    status: ea.Fail,
                                    progress: 0
                                }
                            })))));
                    }
                    return ne;
                })(o.payload.id, e, t1)))
    });
    function cO(e, t1) {
        var o, r, i;
        const { meeting: { isMeetingReset: n, meetingId: s, meetingNumber: a, userName: d, userEmail: u, tid: l, userId: c, userGUID: p }, breakoutRoom: h } = e;
        let m = "";
        var g;
        return m = n ? null != h && null !== (g = h.currentRoom) && void 0 !== g && g.boConfId ? "join breakout room" : "meeting failover" : "join meeting", {
            label: m,
            payload: {
                meetingId: null !== (o = null == t1 ? void 0 : t1.meetingId) && void 0 !== o ? o : s,
                tid: l,
                userId: null !== (r = null == t1 ? void 0 : t1.userId) && void 0 !== r ? r : c,
                userGUID: null !== (i = null == t1 ? void 0 : t1.userGUID) && void 0 !== i ? i : p,
                meetingNumber: dE(a),
                userName: dE(d),
                userEmail: dE(u)
            }
        };
    }
    function pO(e, t1, o) {
        return O(ht((r)=>{
            let i = !1;
            try {
                var n, s;
                const { logger: { options: e }, meeting: { logConfig: o } } = t1.value;
                i = null !== (n = null == e ? void 0 : e.enable) && void 0 !== n ? n : null === (s = JSON.parse(o || "{}")) || void 0 === s ? void 0 : s.enable;
            } catch (e) {}
            try {
                if (i) {
                    const { logger: { isLaplaceInitialized: i } } = t1.value;
                    if (!i) return e.pipe(Dt(`${ly}`), nt(1), Fe((e)=>(e.payload && o(r), ne)));
                    o(r);
                }
            } catch (e) {
                console.warn(e);
            }
            return ne;
        }));
    }
    function hO(e, t1, o, r) {
        return ur(e, o).pipe(pO(e, t1, r));
    }
    function mO(e, t1, o, r) {
        return nr(e, o).pipe(pO(e, t1, r));
    }
    function gO(e) {
        var t1, o;
        const { audio: { activeMicrophone: r, activeSpeaker: i, microphoneDevicesList: n, speakerDevicesList: s } } = e;
        return `microphone: [${r} - ${null == n || null === (t1 = n.find((e)=>e.deviceId === r)) || void 0 === t1 ? void 0 : t1.label}]; speaker: [${i} - ${null == s || null === (o = s.find((e)=>e.deviceId === i)) || void 0 === o ? void 0 : o.label}]`;
    }
    function vO(e) {
        var t1;
        const { video: { activeCamera: o, cameraDevicesList: r } } = e;
        return `camera: [${o} - ${null == r || null === (t1 = r.find((e)=>e.deviceId === o)) || void 0 === t1 ? void 0 : t1.label}]`;
    }
    function fO(e, t1) {
        return void 0 !== t1 ? ` ,${e}:${t1}` : "";
    }
    const { InitSuccessAudio: yO, InitFailedAudio: SO, InitSuccessVideo: bO, InitFailedVideo: EO, InitSuccessSharing: IO, InitFailedSharing: AO } = sd, { DecodeSuccess: CO, DecodeFailed: _O, EncodeSuccess: RO, EncodeFailed: wO } = ad, TO = {
        [`${yO}`]: {
            name: "Audio",
            isException: !1
        },
        [`${SO}`]: {
            name: "Audio",
            isException: !0
        },
        [`${bO}`]: {
            name: "Video",
            isException: !1
        },
        [`${EO}`]: {
            name: "Video",
            isException: !0
        },
        [`${IO}`]: {
            name: "Sharing",
            isException: !1
        },
        [`${AO}`]: {
            name: "Sharing",
            isException: !0
        }
    };
    function OO(e) {
        const t1 = (null != e ? e : "").split("-");
        return [
            ...new Set(t1)
        ].map((e)=>({
                reason: e,
                count: t1.filter((t1)=>e === t1).length
            }));
    }
    const DO = hE.getInstance(), PO = ()=>{
        if ("connection" in navigator) {
            const { effectiveType: e, rtt: t1, downlink: o } = navigator.connection;
            DO.makeLogger([
                "Network Connection Type"
            ]).info(`Network connection. ect:${e},rtt:${t1},downlink:${o}`);
        }
    }, MO = hE.getInstance().makeLogger([
        "Remote Control"
    ]), kO = yE(ca.getInstance()), LO = [
        {
            event: sd.AudioBridgeReconnectStart,
            message: sE.AudioBridgeReconnectStart,
            logType: "info",
            additionalTags: [
                "Audio Join Flow"
            ]
        },
        {
            event: sd.AudioBridgeReconnectEnd,
            message: sE.AudioBridgeReconnectEnd,
            logType: "info",
            additionalTags: [
                "Audio Join Flow"
            ]
        },
        {
            event: sd.UserGrantCaptureAudio,
            message: (e)=>`${sE.DeviceAudioStreamCaptured},${gO(e)}`,
            logType: "info",
            additionalTags: [
                "Audio Capture Flow"
            ]
        },
        {
            event: sd.JoinComputerAudioComplete,
            message: sE.AudioJoinComplete,
            logType: "info",
            additionalTags: [
                "Audio Join Flow"
            ]
        },
        {
            event: sd.LeaveComputerAudioComplete,
            message: sE.AudioLeaveComplete,
            logType: "info",
            additionalTags: [
                "Audio Join Flow"
            ]
        },
        {
            event: sd.JoinSharingAudioComplete,
            message: sE.SharingAudioStartComplete,
            logType: "info",
            additionalTags: [
                "Audio Sharing Flow"
            ]
        },
        {
            event: sd.LeaveSharingAudioComplete,
            message: sE.SharingAudioStopComplete,
            logType: "info",
            additionalTags: [
                "Audio Sharing Flow"
            ]
        }
    ], NO = [
        {
            event: sd.StartVideoCaptureSuccess,
            message: (e)=>`${aE.StartCaptureVideoSuccess}, ${vO(e)}`,
            logType: "info",
            additionalTags: [
                "Video Join Flow"
            ]
        },
        {
            event: sd.StopVideoCaptureSuccess,
            message: aE.StopCaptureVideoSuccess,
            logType: "info",
            additionalTags: [
                "Video Join Flow"
            ]
        },
        {
            event: sd.StartVideoStreamInVbSettingSuccess,
            message: aE.VBSettingSuccess,
            logType: "info",
            additionalTags: [
                "Video VB Flow"
            ]
        },
        {
            event: sd.VbModelPreloadingOk,
            message: aE.VBPreloadSuccess,
            logType: "info",
            additionalTags: [
                "Video VB Flow"
            ]
        },
        {
            event: sd.VbModelPreloading_3S,
            message: aE.VBPreloading3S,
            logType: "warn",
            additionalTags: [
                "Video VB Flow"
            ]
        },
        {
            event: sd.VbModelPreloading_10S,
            message: aE.VBPreloading10S,
            logType: "warn",
            additionalTags: [
                "Video VB Flow"
            ]
        },
        {
            event: sd.VbSettingParaError,
            message: aE.VBSettingFailed,
            logType: "error",
            additionalTags: [
                "Video VB Flow"
            ]
        }
    ], VO = LO.map((e)=>({
            ...e,
            tag: "Audio"
        })).concat(NO.map((e)=>({
            ...e,
            tag: "Video"
        }))), UO = hE.getInstance(), { InitSuccessVideo: jO, InitSuccessAudio: xO, InitSuccessSharing: BO, InitFailedVideo: FO, InitFailedAudio: HO, InitFailedSharing: $O, RecoverWebrtcAudio: WO, AudioBridgeFirstRecvData: GO, AudioBridgeCanSendData: KO, UserForbiddedCaptureAudio: zO, AudioWebsocketBroken: qO, AudioZeroData: JO, UserForbiddedCaptureVideo: QO, UserCameraIsTakenByOtherPrograms: ZO, VideoWebsocketBroken: YO, StopVideoCaptureFailed: XO, DesktopSharingPermissionDenied: eD, DesktopSharingSystemError: tD, AudioSpeakerSetError: oD, VbSettingParaError: rD, MaskSettingParaError: iD, WebglLostInMultiView: nD, VideoStreamFailed: sD, AudioStreamFailed: aD, NotifyUIFailover: dD } = sd, uD = hE.getInstance(), lD = {
        options: void 0,
        isLaplaceInitialized: !1
    }, cD = bo({
        [`${uy}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.options = o;
        }),
        [`${ly}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isLaplaceInitialized = o;
        }),
        [`${cy}`]: (e, t1)=>{
            let { options: o } = e, { payload: r } = t1;
            return r ? {
                ...lD,
                options: o
            } : {
                ...lD
            };
        }
    }, lD), pD = {
        mlEpics0: (e, t1)=>ur(e, [
                jO,
                xO,
                BO,
                FO,
                HO,
                $O
            ]).pipe(pO(e, t1, (e)=>{
                const { payload: { type: o, data: r } } = e, { meeting: { userId: i } } = t1.value, n = function(e, t1) {
                    const o = TO[`${e}`];
                    if (o) {
                        const { name: e, isException: r } = o, i = [
                            e,
                            `${e} Init Flow`
                        ];
                        r && i.push(`${e} exception flow`);
                        let n = "";
                        return [
                            CO,
                            _O
                        ].includes(t1) && (n = `${n} decode`.trim()), [
                            RO,
                            wO
                        ].includes(t1) && (n = `${n} encode`.trim()), [
                            RO,
                            CO
                        ].includes(t1) && (n = `${n} success`.trim()), [
                            _O,
                            wO
                        ].includes(t1) && (n = `${n} failed`.trim()), {
                            message: `init ${e.toLowerCase()} ${n}`,
                            tags: i,
                            isException: r
                        };
                    }
                    return null;
                }(o, r);
                if (n) {
                    const { message: e, tags: t1, isException: o } = n;
                    o ? UO.report(`${e}. userId:${i}`, t1) : UO.makeLogger(t1).info(e);
                }
            })),
        mlEpics1: (e, t1)=>hO(e, t1, VO.map((e)=>e.event), (e)=>{
                const { payload: { type: o } } = e, r = VO.find((e)=>e.event === o);
                if (r) {
                    const { message: e, logType: o, additionalTags: i, tag: n } = r;
                    let s = e;
                    "function" == typeof e ? window.setTimeout(()=>{
                        s = e(t1.value), UO.makeLogger([
                            n
                        ])[o](s, i);
                    }, 0) : s && UO.makeLogger([
                        n
                    ])[o](s, i);
                }
            }),
        mlEpics2: (e, t1)=>e.pipe(Dt(`${Vh}`), ot((e)=>!e.payload), pO(e, t1, ()=>{
                UO.makeLogger([
                    "Audio"
                ]).warn(`Auto play audio failed,${gO(t1.value)}`);
            })),
        mlEpics3: (e, t1)=>hO(e, t1, WO, ()=>{
                UO.report("Audio bridge, recover audio failed, need to rejoin the audio", [
                    "Audio exception flow"
                ]);
            }),
        mlEpics4: (e, t1)=>hO(e, t1, [
                GO,
                KO
            ], (e)=>{
                const { payload: { type: t1 } } = e;
                UO.makeLogger([
                    "Audio"
                ]).log("Audio bridge connection: " + (t1 === GO ? "first receive data" : "can send data"));
            }),
        mlEpics5: (e, t1)=>hO(e, t1, dD, (e)=>{
                UO.report(`Audio bridge, notify ui failover, subreason:${e.payload.data}`, [
                    "Audio exception flow"
                ]);
            }),
        mlEpics6: (e, t1)=>hO(e, t1, [
                zO,
                qO,
                JO,
                oD,
                aD
            ], (e)=>{
                const { payload: { type: o } } = e;
                let r = `Audio error case:${o}`;
                o === zO ? r = "Audio capture is forbidden by the user" : o === JO ? t1.value.audio.webrtcRestartCount < 3 && (r = "audio capture zero data, auto failover") : o === oD ? r = "audio change speaker error" : o === aD && (r = "audio stream ended or muted, stop capture audio"), UO.report(`${r},${gO(t1.value)}`, [
                    "Audio exception flow"
                ]);
            }),
        mlEpics7: (e, t1)=>hO(e, t1, [
                QO,
                ZO,
                YO,
                XO,
                sD
            ], (e)=>{
                const { payload: { type: o, data: r } } = e;
                let i = `Video error case:${o}`;
                if (o === QO) i = "Video capture is forbidden by the user" + (r ? ` (error name:${null == r ? void 0 : r.name};error message:${null == r ? void 0 : r.message})` : "");
                else if (o === ZO) i = "Camera is taken by other programs" + (r ? ` (error name:${null == r ? void 0 : r.name};error message:${null == r ? void 0 : r.message})` : "");
                else if (o === rD) {
                    var n;
                    i = `VB setting error, param:${JSON.stringify(null !== (n = t1.value.video.virtualBackground) && void 0 !== n ? n : {})}`;
                } else if (o === iD) {
                    var s;
                    i = `Mask setting error, param:${JSON.stringify(null !== (s = t1.value.video.mask) && void 0 !== s ? s : {})}`;
                } else o === sD && (i = `Video stream ended or muted, if it is on iOS platform, will stop capture video.platform:${gs.browser}`);
                UO.report(`${i},${vO(t1.value)}`, [
                    "Video exception flow"
                ]);
            }),
        mlEpics8: (e, t1)=>hO(e, t1, [
                eD,
                tD
            ], (e)=>{
                const { payload: { type: t1 } } = e;
                let o = "";
                t1 === tD ? gs.isMacOS && (o = "Need to allow screen recording access in system setting on MacOS") : o = "Need to allow the permission request", UO.report(`${o}`, [
                    "Sharing exception flow"
                ]);
            }),
        mlEpics9: (e, t1)=>hO(e, t1, nD, (e)=>{
                const { payload: { data: o } } = e, { video: { renderedVideoList: r } } = t1.value;
                if (null != o && o.canvasId) {
                    const e = r.filter((e)=>e.canvasId === o.canvasId);
                    UO.report(`WebGl Context lost, canvas ID:${o.canvasId}, affected video node Ids:${e.map((e)=>e.userId).join(",")}`, [
                        "Video exception flow"
                    ]);
                }
            }),
        mlEpics10: (e, t1)=>qe(document, "visibilitychange").pipe(pO(e, t1, ()=>{
                UO.makeLogger([
                    "Video"
                ]).log(`Page visibility ${document.visibilityState} `), setTimeout(()=>{
                    const e = "visible" !== document.visibilityState, { video: { subscribedVideoList: o }, meeting: { userId: r } } = t1.value, i = o.filter((e)=>e !== r).length > 0;
                    e && i && (ia.createAgent().sendRWGConnectionPerformance("VCSV"), UO.makeLogger([
                        "Video"
                    ]).warn("Still subscribing videos after switching to background"));
                }, 1e3);
            })),
        mlEpics11: (e)=>ur(e, sd.InitSuccessVideo).pipe(ot((e)=>e.payload.data === ad.EncodeSuccess && gs.isAndroidOrIOSBrowser), ht(()=>{
                const e = UO.makeLogger([
                    "Video"
                ]);
                return e.info("Screen orientation: " + (Hy() ? "landscape" : "portrait")), $y().pipe(vt((t1)=>{
                    e.info("Screen orientation changes, current orientation: " + (t1 ? "landscape" : "portrait"));
                }), st());
            }))
    }, hD = {
        rmclEpics0: (e, t1)=>e.pipe(Dt(`${zm}`), pO(e, t1, (e)=>{
                const { payload: { isRemoteControlEnabled: t1, isEnableAutoDeleteRcApp: o } } = e;
                MO.log(`isRemoteControlEnabled:${t1},auto delete:${o}`);
            })),
        rmclEpics1: (e, t1)=>e.pipe(Dt(`${$m}`), ot((e)=>!!e.payload), pO(e, t1, (e)=>{
                MO.log(`Launch Remote control app, scheme:${e.payload}`);
            })),
        rmclEpics2: (e, t1)=>e.pipe(Dt(`${Vm}`), ot((e)=>!!e.payload), pO(e, t1, (e)=>{
                MO.log(`Remote control session starts, controlling ssrc:${e.payload}`);
            })),
        rmclEpics3: (e, t1)=>mO(e, t1, 16430, ()=>{
                MO.log("Remote control app connected to rwg.");
            }),
        rmclEpics4: (e, t1)=>mO(e, t1, js, ()=>{
                MO.log("Remote control app disconnected to rwg.");
            }),
        rmclEpics5: (e, t1)=>mO(e, t1, js, (e)=>{
                const { share: { status: o, isRemoteControlEnabled: r } } = t1.value;
                r && o !== yd.End && e.payload.body.bOn && MO.log(`Remote control sharing device info.${JSON.stringify(kO.getShareStreamInfo())}`);
            }),
        rmclEpics6: (e, t1)=>hO(e, t1, sd.CurrentDesktopSharingWidthHeight, ()=>{
                const { share: { isRemoteControlEnabled: e } } = t1.value;
                e && MO.log(`Remote control sharing device info changes.${JSON.stringify(kO.getShareStreamInfo())}`);
            }),
        rmclEpics7: (e, t1)=>hO(e, t1, sd.SendRemoteControlQrCode, (e)=>{
                const { share: { status: o } } = t1.value, { payload: { data: r } } = e;
                MO.log(`Remote control QR code result. sharing status:${o}, result${JSON.stringify(r)}`);
            })
    }, mD = {
        epics0: (e, t1)=>e.pipe(Dt(`${pn}`), Fe(async (e)=>{
                const { meeting: { logConfig: o, logEncryptionPubKey: r, zlkJwtToken: i, accountId: n, enableAutoLog: s, collectionToggleEnable: a, zsk: d }, logger: { options: u } } = t1.value;
                let l = u || {};
                if (o) try {
                    const { enable: e, enableReport: t1 } = JSON.parse(o);
                    l = {
                        ...l,
                        enable: e,
                        enableReport: t1
                    };
                } catch (e) {}
                if (i) {
                    const { telemetry_tracking_id: t1 } = oi(i), { payload: { meetingId: o } } = e, r = null != t1 ? t1 : o;
                    l = {
                        ...l,
                        enable: !0,
                        enableReport: !0,
                        trackingId: r
                    };
                } else {
                    let e = !1;
                    e = d && void 0 !== a ? !(s && a) : !s, ns.set(ds.DisableAutoReportLogs, e, rs.Memory);
                }
                return DO.init({
                    ...l,
                    logConfig: o,
                    logEncryptionPubKey: r,
                    accountId: n
                }).then(()=>[
                        ly(!0),
                        uy(l)
                    ]).catch(()=>[
                        ly(!1)
                    ]);
            }), Fe((e)=>_e(e))),
        epics1: (e, t1)=>mO(e, t1, Ns, (e)=>{
                var o, r, i, n;
                const { payload: { body: s } } = e;
                if (s && s.res === li.Success) {
                    DO.makeLogger([
                        "A/V Performance Info"
                    ]).info(`CPU cores:${navigator.hardwareConcurrency}, SharedArrayBuffer:${!!gs.isSupportSharedArrayBuffer}, browser:${gs.browser} ${gs.browserVersion}, OS:${gs.os} ${gs.osVersion}${fO("wow64", gs.wow64)}${fO("GPU", gs.gpu)}${fO("architecture", gs.architecture)}${fO("bitness", gs.bitness)}${fO("model", gs.model)}${ns.get(ds.EnforceWebRTCAudio) ? "; Enforce WebTRC audio" : ""}`, [
                        "CPU_CORES"
                    ]);
                    const { media: { enforceMultipleVideos: e, enforceVirtualBackground: o, assetsPath: r, disableRenderLimits: i }, meeting: { stayAwake: n, quicklyLeave: s } } = t1.value;
                    DO.makeLogger([
                        "Init Option"
                    ]).info(`Init option:${JSON.stringify({
                        enforceMultipleVideos: e,
                        disableRenderLimits: i,
                        enforceVirtualBackground: o,
                        assetsPath: r,
                        stayAwake: n,
                        leaveOnPageUnload: s
                    })}`), "connection" in navigator && (PO(), navigator.connection.addEventListener("change", PO));
                } else DO.report(`join meeting failed, error:${JSON.stringify(vi(null == s ? void 0 : s.res))}, rwg error code:${null == s ? void 0 : s.res}, rwg conID:${null == s ? void 0 : s.conID}, error message:${null == s ? void 0 : s.error_desc}, rwg url:${null == s ? void 0 : s.svcUrl},mid:${t1.value.meeting.meetingId}`, "JOIN_MEETING_FAILED", "error");
                const { meeting: { meetingInfoTimestamp: a, pingRWCTimestamp: d, tid: u, meetingId: l, topic: c, accountId: p, cv: h }, socket: { rwgServerList: m, retryCount: g }, video: { rendererType: v }, media: { patchJsMedia: f, assetsPath: y } } = t1.value;
                let S = [
                    "conID",
                    "confID",
                    "mmrFeature",
                    "mmrFeatureEx",
                    "reportDomain",
                    "res",
                    "role",
                    "svcUrl",
                    "userID"
                ].reduce((e, t1)=>void 0 !== s[t1] ? {
                        ...e,
                        [`${t1}`]: s[t1]
                    } : e, {});
                S = [
                    "jid",
                    "mn",
                    "participantID",
                    "zoomID"
                ].reduce((e, t1)=>void 0 !== s[t1] ? {
                        ...e,
                        [`${t1}`]: dE(s[t1])
                    } : e, S), S.response = S.res, delete S.res;
                const b = [
                    "connection_info_map"
                ];
                let E;
                if (s.res === li.Success && b.push("Command Socket Event", "User Info Map"), u) {
                    const e = u.match(/clid=(\S+);/);
                    e && e.length > 1 && (E = e[1]);
                }
                const I = Math.floor(performance.now() - a), A = Math.floor(performance.now() - d), C = ia.createAgent();
                DO.report(JSON.stringify({
                    ...S,
                    tid: u,
                    mid: l,
                    userRegion: E,
                    rwgUrl: m.length > 0 ? null === (o = m[g]) || void 0 === o ? void 0 : o.rwg : void 0,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    sharedArrayBuffer: gs.isSupportSharedArrayBuffer,
                    browserVersion: `${gs.browser} ${gs.browserVersion}`,
                    osVersion: `${gs.os} ${gs.osVersion}`,
                    gpu: gs.gpu,
                    architecture: gs.architecture,
                    model: gs.model,
                    bitness: gs.bitness,
                    totalDurationOfJoining: I,
                    durationOfRWG: A,
                    rendererType: v,
                    sdkVersion: h,
                    mediaSdkVersion: null === (r = window.JsMediaSDK_Instance) || void 0 === r ? void 0 : r.version,
                    topic: c ? dE(c) : void 0,
                    accountId: p ? dE(p) : void 0,
                    patchJSMediaSDK: f,
                    dependentAssets: y,
                    webRtcAudio: vs(),
                    crossOriginIsolated: !!window.crossOriginIsolated,
                    isRlbTP: null === (i = C.websocket) || void 0 === i ? void 0 : i.isRlb
                }), b, "info"), C.sendRWGConnectionPerformance(`WCL_M, conId: ${null == s ? void 0 : s.conID}, trackingId: ${null === (n = t1.value.logger) || void 0 === n || null === (n = n.options) || void 0 === n ? void 0 : n.trackingId}, JOINFS(${I}), JOINFRWC(${A})`);
            }),
        epics2: (e, t1)=>e.pipe(Dt(`${nn}`), ft(t1), ot((e)=>{
                let [, t1] = e;
                return void 0 === t1.meeting.encryptedRWC && (void 0 === t1.meeting.encryptedGEORWC || 0 === t1.meeting.encryptedGEORWC.length);
            }), pO(e, t1, ()=>{
                const { label: e, payload: o } = cO(t1.value);
                DO.report(`${e} ${JSON.stringify(o)}`, [
                    "Join Meeting Flow",
                    "Ping RWC Domain Empty"
                ], "error");
            })),
        epics3: (e, t1)=>e.pipe(Dt(`${sn}`), ot((e)=>e.payload === ts.OnError || e.payload === ts.Disconnect || e.payload === ts.NoHeartbeat), pO(e, t1, (e)=>{
                const { payload: o } = e, { socket: { rwgServerList: r, retryCount: i } } = t1.value, { payload: n } = cO(t1.value);
                DO.report(`websocket unexpected disconnected,${JSON.stringify({
                    code: o,
                    rwgHost: r[i],
                    ...n
                })}`, [
                    "Join Meeting Flow",
                    "RWG Disconnect"
                ]);
            })),
        epics4: (e, t1)=>e.pipe(Dt(`${$n}`), pO(e, t1, (e)=>{
                const { payload: { reason: o, count: r, interval: i, sequence: n, userId: s, userGUID: a, meetingId: d } } = e, { payload: u } = cO(t1.value, {
                    meetingId: d,
                    userId: s,
                    userGUID: a
                });
                DO.report(`meeting failover,${JSON.stringify({
                    reason: o,
                    count: r,
                    interval: i,
                    sequence: n,
                    detailed: OO(n),
                    ...u
                })}`, [
                    "Join Meeting Flow",
                    "Failover"
                ]), "connection" in navigator && navigator.connection.removeEventListener("change", PO);
            })),
        epics5: (e, t1)=>e.pipe(Dt(`${Po}`), ot((e)=>e.payload.status === Sh.Connecting), pO(e, t1, (e)=>{
                const { payload: { rwgUrl: o } } = e;
                let r = o.replace(/(\d+)\?/, `${dE("$1")}?`);
                r = [
                    "email",
                    "zoomid",
                    "participantID",
                    "dn2",
                    "customer_key",
                    "mpwd",
                    "topic"
                ].reduce((e, t1)=>e.indexOf(t1) > -1 ? e.replace(new RegExp(`${t1}=([^&]+)`, "g"), `${t1}=${dE("$1")}`) : e, r);
                const { payload: i } = cO(t1.value);
                DO.makeLogger([
                    "Join Meeting Flow"
                ]).info(`RWG URL,${JSON.stringify({
                    rwgUrl: r,
                    ...i
                })}`, [
                    "RWG Url"
                ]);
            })),
        epics6: (e, t1)=>e.pipe(Dt(`${Ao}`), ot((e)=>{
                const { payload: o } = e;
                return o ? o.retry : t1.value.meeting.meetingStatus === Xn.Initial;
            }), pO(e, t1, ()=>{
                const { meeting: { meetingStatus: e }, socket: { rwgServerList: o, retryCount: r } } = t1.value;
                if (e !== Xn.Joined) {
                    const { payload: e } = cO(t1.value), i = (null == o ? void 0 : o.length) > 0 ? o[r] : void 0;
                    DO.report(JSON.stringify({
                        ...e,
                        rwc: null == i ? void 0 : i.rwc,
                        rwg: null == i ? void 0 : i.rwg
                    }), [
                        "UNAVAILABLE_RWG"
                    ]);
                }
            })),
        epics7: (e, t1)=>mO(e, t1, 1, (e)=>{
                const { payload: { body: o } } = e;
                DO.report(`join meeting failed, version blocked. Current version:${t1.value.meeting.cv},upgrade version:${null == o ? void 0 : o.upgradeVersion}`, "JOIN_MEETING_FAILED", "error");
            }),
        epics8: (e, t1)=>mO(e, t1, 2, ()=>{
                DO.report(`join meeting with low version of SDK. Current version:${t1.value.meeting.cv}.`, "Join Meeting Flow", "warn");
            }),
        epics9: (e, t1)=>e.pipe(Dt(`${on}`, `${rn}`), ht(()=>np(ba, 1).pipe(vt((e)=>{
                    try {
                        const { payload: o } = cO(t1.value);
                        DO.report(`Connection change with join meeting failed. payload:${JSON.stringify(e)}. meeting info:${JSON.stringify(o)}`, "JOIN_MEETING_FAILED", "error");
                    } catch (e) {}
                }), Fe(()=>ne))))
    }, gD = ir(mD, hD, pD), vD = ia.createAgent(), fD = {
        cmrStatus: qa.Stop,
        recordingEnable: !1,
        recordingIsoEnable: !1,
        allowStopAutoRecording: !1,
        automaticCloudRecordingEnable: !1,
        isZoomIQ: !1,
        zoomIQChanging: !1,
        localStatus: Ja.Stop,
        supportLocalRecording: Qa.None,
        localGrantPermissionOption: Za.None,
        localPermissionUserList: []
    }, yD = bo({
        [`${hf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.cmrStatus = o;
        }),
        [`${mf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.recordingEnable = o;
        }),
        [`${gf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.recordingIsoEnable = o;
        }),
        [`${vf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.allowStopAutoRecording = o;
        }),
        [`${ff}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.automaticCloudRecordingEnable = o;
        }),
        [`${yf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isZoomIQ = o;
        }),
        [`${Sf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.zoomIQChanging = o;
        }),
        [`${bf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.localStatus = o;
        }),
        [`${Ef}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.supportLocalRecording = o;
        }),
        [`${If}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.localGrantPermissionOption = o;
        }),
        [`${Af}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.localPermissionUserList = o;
        }),
        [`${Cf}`]: ()=>({
                ...fD
            })
    }, fD);
    var SD, bD, ED, ID, AD, CD, _D, RD, wD;
    const TD = ia.createAgent(), OD = mT("Recording");
    let DD = (SD = uT("recording"), bD = uT("recording"), ED = uT("recording"), ID = uT("recording"), AD = uT("recording"), CD = uT("recording"), _D = uT("recording"), RD = uT("recording"), wD = class extends vT {
        startRecording() {
            const e = this[oT](), { meeting: { bIbDisableRecording: t1, recordingEnable: o }, recording: { cmrStatus: r } } = e;
            return t1 ? Promise.reject({
                type: Kl,
                reason: "Rejected by Information Barrier"
            }) : o ? r === qa.Start ? Promise.resolve("") : (TD.recordMeeting(!0, !1), ip(Ya, (e)=>e.cmrServerStatus === qa.Start)) : Promise.reject({
                type: Kl,
                reason: "The account of the meeting disabled the cloud recording"
            });
        }
        pauseRecording() {
            const e = this[oT](), { recording: { cmrStatus: t1, allowStopAutoRecording: o } } = e;
            return t1 === qa.Pause ? Promise.resolve("") : t1 !== qa.Start ? Promise.reject({
                type: Kl,
                reason: "Recording is not started"
            }) : o ? (TD.recordMeeting(!1, !0), ip(Ya, (e)=>e.cmrServerStatus === qa.Pause)) : Promise.reject({
                type: Kl,
                reason: "Cannot pause cloud recording due to web setting config"
            });
        }
        stopRecording() {
            const e = this[oT](), { recording: { cmrStatus: t1, allowStopAutoRecording: o } } = e;
            return t1 === qa.Stop ? Promise.resolve("") : o ? (TD.recordMeeting(!1, !1), ip(Ya, (e)=>e.cmrServerStatus === qa.Stop)) : Promise.reject({
                type: Kl,
                reason: "Cannot stop cloud recording due to web setting config"
            });
        }
        accept() {
            const e = this[oT](), { recording: { cmrStatus: t1, recordingIsoEnable: o } } = e, r = ah(e);
            return o ? t1 !== qa.Start && t1 !== qa.Pause ? Promise.reject({
                type: Kl,
                reason: "Recording is not started"
            }) : null != r && r.bAllowISORecord ? Promise.resolve("You accepted ISO recording") : (TD.allowSelfRecord(!0), ip(Xa, (e)=>(null == e ? void 0 : e.userId) === (null == r ? void 0 : r.userId) && (null == e ? void 0 : e.status) === za.Accept)) : Promise.reject({
                type: Kl,
                reason: "ISO Recording is not enabled"
            });
        }
        decline() {
            const e = this[oT](), { recording: { cmrStatus: t1, recordingIsoEnable: o } } = e, r = ah(e);
            return o ? t1 !== qa.Start && t1 !== qa.Pause ? Promise.reject({
                type: Kl,
                reason: "Recording is not started"
            }) : !0 === (null == r ? void 0 : r.bAllowISORecord) ? Promise.reject({
                type: Kl,
                reason: "You had accept ISO recording, cant change it"
            }) : (TD.allowSelfRecord(!1), Promise.resolve("")) : Promise.reject({
                type: Kl,
                reason: "ISO Recording is not enabled"
            });
        }
        getRecordingStatus() {
            const e = this[oT](), { recording: { cmrStatus: t1 } } = e, o = fh(e);
            return t1 === qa.Start ? za.Recording : t1 === qa.Pause ? za.Paused : o ? za.Recording : za.Stopped;
        }
        isRecordingEnabled() {
            const e = this[oT](), { recording: { recordingEnable: t1 } } = e;
            return t1;
        }
        isAllowedToStopAutoRecording() {
            const e = this[oT](), { recording: { allowStopAutoRecording: t1 } } = e;
            return t1;
        }
        isAutomaticCloudRecordingEnabled() {
            const e = this[oT](), { recording: { automaticCloudRecordingEnable: t1 } } = e;
            return t1;
        }
        enableRecordingWithIQ(e) {
            const { [oT]: t1, [rT]: o } = this, r = t1(), { recording: { isZoomIQ: i, zoomIQChanging: n }, meeting: { meetingOptions: s } } = t1();
            return s.isEnableKiwiRecording ? dh(r) ? n ? Promise.reject({
                type: Kl,
                reason: "We are changing, please wait"
            }) : e === i ? Promise.reject({
                type: Kl,
                reason: `You have ${e ? "enable" : "disable"} Zoom IQ, don't need change`
            }) : (o(Sf(!n)), o(yf(!i)), TD.enableZoomIQRecord(e), ip(rd, (e)=>null == e ? void 0 : e.success)) : Promise.reject({
                type: Kl,
                reason: "Only Host or co-host can enable/disable Zoom IQ"
            }) : Promise.reject({
                type: Kl,
                reason: "You not have zoom IQ license or not enable zoom IQ, please check and retry"
            });
        }
        isSupportLocalRecording() {
            const e = this[oT](), { meeting: { meetingOptions: t1, isWebinar: o }, breakoutRoom: r } = e;
            if ((null == r ? void 0 : r.currentRoom.status) === Qp.InRoom) return !1;
            const i = ah(e);
            return (!o || !Kp(i.userRole)) && (null == t1 ? void 0 : t1.isLocalRecordingEnabled);
        }
        isSupportLocalRecordingPermission() {
            const e = this[oT](), { recording: { supportLocalRecording: t1 } } = e;
            if (!this.isSupportLocalRecording()) return !1;
            const o = ah(e);
            return !(null == o || !o.isHost) || t1 === Qa.Allow;
        }
        askLocalRecordingPermission() {
            const { [oT]: e } = this, { recording: { supportLocalRecording: t1 } } = e();
            return this.isSupportLocalRecording() ? t1 === Qa.None ? (TD.localRecordingRequestPermission(), Promise.resolve("")) : t1 === Qa.Allow ? Promise.resolve("") : Promise.reject("permission is denied") : Promise.reject("not support");
        }
        startLocalRecording(e) {
            const { [oT]: t1, [rT]: o } = this, r = t1(), { recording: { localStatus: i, supportLocalRecording: n }, meeting: { userId: s } } = r;
            if (!(e in Ja)) return Promise.reject({
                type: Kl,
                reason: "not support you parameter, only support type are 0(stop)/1(start)/2(pause)."
            });
            if (!this.isSupportLocalRecording()) return Promise.reject({
                type: Kl,
                reason: "not support local recording"
            });
            if (e === i) return Promise.resolve(`you currently status is ${i}, do nothing`);
            const a = ah(r);
            return n === Qa.Allow || null != a && a.isHost ? (TD.localRecordingMeeting(e), ip(ed, (t1)=>(null == t1 ? void 0 : t1.userId) === s && (o(bf(t1.bLocalRecord)), t1.bLocalRecord === e), 1e3)) : Promise.reject({
                type: Kl,
                reason: "you not have local recording permission, please use askLocalRecordingPermission request it first"
            });
        }
        isSupportLocalRecordingGrantPermission() {
            const e = this[oT]();
            if (!this.isSupportLocalRecording()) return !1;
            const t1 = ah(e);
            return !(null == t1 || !t1.isHost) && !!nS(t1.caps);
        }
        grantLocalRecordingPermission(e, t1, o) {
            const { [oT]: r, [rT]: i } = this, n = r(), { recording: { localPermissionUserList: s } } = n;
            if (!this.isSupportLocalRecording()) return Promise.resolve(!1);
            const a = ah(n);
            if (!nS(a.caps)) return Promise.reject({
                type: Kl,
                reason: "you can not grant permission"
            });
            let d = !1;
            if (o && (d = !0), s.filter((t1)=>t1 === e).length > 0) {
                if (t1 === Qa.Allow) TD.localRecordingGrantPermission(e, !0, d);
                else {
                    if (t1 !== Qa.Deny) return Promise.reject({
                        type: Kl,
                        reason: "only support DENY(1)/ALLOW(2)"
                    });
                    TD.localRecordingGrantPermission(e, !1, d);
                }
                return i(Af(s.filter((t1)=>t1 !== e))), tp(td, {
                    type: "answer",
                    value: t1 === Qa.Allow
                }), Promise.resolve(!1);
            }
            return t1 !== Qa.Deny ? Promise.reject({
                type: Kl,
                reason: "Direct grant only support DENY(1)"
            }) : (TD.hostGrantPermission(e, !1), ip(td, (o)=>(null == o ? void 0 : o.value) === e && (t1 === Qa.Allow ? (i(Af([
                    ...s,
                    e
                ])), !0 === (null == o ? void 0 : o.canRecord)) : (i(Af(s.filter((t1)=>t1 !== e))), !1 === (null == o ? void 0 : o.canRecord))), 1e3));
        }
        getLocalRecordingPermissionUserList() {
            const e = this[oT](), { recording: { localPermissionUserList: t1 } } = e;
            if (!this.isSupportLocalRecording()) return [];
            const o = ah(e);
            return nS(o.caps) ? t1 : Promise.reject({
                type: Kl,
                reason: "you can not grant permission"
            });
        }
        getLocalRecordingPermissionOperation() {
            const e = this[oT](), { recording: { localGrantPermissionOption: t1 } } = e;
            if (!this.isSupportLocalRecording()) return null;
            const o = ah(e);
            return nS(o.caps) ? t1 : null;
        }
    }, eT(wD.prototype, "startRecording", [
        aT,
        sT,
        SD,
        OD
    ], Object.getOwnPropertyDescriptor(wD.prototype, "startRecording"), wD.prototype), eT(wD.prototype, "pauseRecording", [
        aT,
        sT,
        bD,
        OD
    ], Object.getOwnPropertyDescriptor(wD.prototype, "pauseRecording"), wD.prototype), eT(wD.prototype, "stopRecording", [
        aT,
        sT,
        ED,
        OD
    ], Object.getOwnPropertyDescriptor(wD.prototype, "stopRecording"), wD.prototype), eT(wD.prototype, "accept", [
        sT,
        ID,
        OD
    ], Object.getOwnPropertyDescriptor(wD.prototype, "accept"), wD.prototype), eT(wD.prototype, "decline", [
        sT,
        AD,
        OD
    ], Object.getOwnPropertyDescriptor(wD.prototype, "decline"), wD.prototype), eT(wD.prototype, "askLocalRecordingPermission", [
        sT,
        CD
    ], Object.getOwnPropertyDescriptor(wD.prototype, "askLocalRecordingPermission"), wD.prototype), eT(wD.prototype, "startLocalRecording", [
        sT,
        _D
    ], Object.getOwnPropertyDescriptor(wD.prototype, "startLocalRecording"), wD.prototype), eT(wD.prototype, "grantLocalRecordingPermission", [
        sT,
        dT,
        RD
    ], Object.getOwnPropertyDescriptor(wD.prototype, "grantLocalRecordingPermission"), wD.prototype), wD);
    const PD = {
        moduleEpics0: (e)=>e.pipe(Dt(`${pn}`), Le((e)=>{
                const { payload: { recordingEnable: t1 } } = e;
                return mf(t1);
            })),
        moduleEpics1: (e, t1)=>nr(e, Ms).pipe(ot((e)=>{
                var t1, o, r;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.cmrServerStatus) || void 0 !== (null === (o = e.payload.body) || void 0 === o ? void 0 : o.disAllowClientStopAutoCmr) || void 0 !== (null === (r = e.payload.body) || void 0 === r ? void 0 : r.enableAutomicRecordingCloud);
            }), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { cmrServerStatus: r, disAllowClientStopAutoCmr: i, enableAutomicRecordingCloud: n } = t1.payload.body, s = [];
                return void 0 !== r && (r !== qa.Init && (tp(Ya, {
                    cmrServerStatus: r
                }), o.recording.recordingIsoEnable && r === qa.Start && tp(Xa, {
                    status: za.Ask
                })), s.push(hf(r))), void 0 !== i && s.push(vf(!i)), void 0 !== n && s.push(ff(n)), _e(s);
            })),
        moduleEpics2: (e)=>nr(e, Ms).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.bCmrIsoEnble);
            }), Le((e)=>{
                const { bCmrIsoEnble: t1 } = e.payload.body;
                return gf(t1);
            })),
        moduleEpics3: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [t1] = e;
                const { payload: { body: { update: o, add: r } } } = t1;
                return (null == o ? void 0 : o.some((e)=>void 0 !== e.bLocalRecordStatus || void 0 !== e.canRecord)) || (null == r ? void 0 : r.some((e)=>void 0 !== e.bLocalRecordStatus || void 0 !== e.canRecord));
            }), Fe((e)=>{
                let [t1, o] = e;
                const { payload: { body: { update: r, add: i } } } = t1, { meeting: { userId: n, isHost: s }, recording: { supportLocalRecording: a }, participants: { attendeesList: d } } = o, u = [];
                return null == r || r.concat(i || []).filter((e)=>void 0 !== e.bLocalRecordStatus || void 0 !== e.canRecord).forEach((e)=>{
                    if (void 0 !== e.canRecord) {
                        const t1 = Boolean(e.canRecord);
                        if (n === e.id || s) {
                            const o = d.find((e)=>e.userId === n);
                            !t1 && null != o && o.bLocalRecord && (tp(td, {
                                type: "revoke",
                                value: e.id,
                                canRecord: t1
                            }), vD.localRecordingMeeting(Ja.Stop)), !t1 || null != o && o.bLocalRecord || tp(td, {
                                type: "grant",
                                value: e.id,
                                canRecord: t1
                            });
                        }
                        n === e.id && ((a !== Qa.None || t1) && u.push(Ef(t1 ? Qa.Allow : Qa.Deny)), t1 || u.push(bf(Ja.Stop)));
                    } else tp(ed, {
                        userId: e.id,
                        bLocalRecord: e.bLocalRecordStatus
                    });
                }), _e(u);
            })),
        moduleEpics4: (e, t1)=>nr(e, Ps).pipe(Le((e)=>xA(e.payload.body)), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const r = [], { recording: { localPermissionUserList: i } } = o;
                return t1.remove && t1.remove.forEach((e)=>{
                    i.filter((t1)=>t1 === (null == e ? void 0 : e.userId)) && (r.push(Af(i.filter((t1)=>t1 !== (null == e ? void 0 : e.userId)))), tp(td, {
                        type: "remove",
                        value: null == e ? void 0 : e.userId
                    }));
                }), _e(r);
            })),
        moduleEpics5: (e)=>nr(e, Ps).pipe(ot((e)=>{
                const { payload: { body: { update: t1 } } } = e;
                return null == t1 ? void 0 : t1.some((e)=>void 0 !== e.bAllowISORecord);
            }), vt((e)=>{
                const { payload: { body: { update: t1 } } } = e;
                t1.filter((e)=>void 0 !== e.bAllowISORecord).forEach((e)=>{
                    tp(Xa, {
                        userId: e.id,
                        status: e.bAllowISORecord ? za.Accept : za.Decline
                    });
                });
            }), ut(ne)),
        moduleEpics6: (e)=>nr(e, Ms).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.SalesRecordingAnalytics);
            }), Le((e)=>{
                const { SalesRecordingAnalytics: t1 } = e.payload.body;
                return tp(od, {
                    isZoomIQ: t1
                }), yf(t1);
            })),
        moduleEpics7: (e, t1)=>nr(e, 4319).pipe(ft(t1), ot((e)=>{
                var t1;
                let [o] = e;
                return void 0 !== (null === (t1 = o.payload.body) || void 0 === t1 ? void 0 : t1.success);
            }), Fe((e)=>{
                let [t1, o] = e;
                const r = [], { success: i } = t1.payload.body, { recording: { zoomIQChanging: n } } = o;
                return tp(rd, {
                    success: i
                }), i && r.push(Sf(!n)), _e(r);
            })),
        moduleEpics8: (e, t1)=>nr(e, 4344).pipe(ft(t1), ot((e)=>{
                var t1;
                let [o] = e;
                return void 0 !== (null === (t1 = o.payload.body) || void 0 === t1 ? void 0 : t1.cmdType);
            }), Fe((e)=>{
                var t1;
                let [o, r] = e;
                const i = [], { cmdType: n } = o.payload.body, { recording: { localPermissionUserList: s }, meeting: { isHost: a } } = r;
                var d, u, l, c;
                ("permission_req_option" === n && (tp(td, {
                    type: "option",
                    value: null === (d = o.payload.body) || void 0 === d ? void 0 : d.option
                }), i.push(If(null === (u = o.payload.body) || void 0 === u ? void 0 : u.option))), "request_permission" === n && null !== (t1 = o.payload.body) && void 0 !== t1 && t1.userId) && (a && tp(td, {
                    type: "request",
                    value: null === (c = o.payload.body) || void 0 === c ? void 0 : c.userId
                }), i.push(Af([
                    ...s,
                    null === (l = o.payload.body) || void 0 === l ? void 0 : l.userId
                ])));
                return "permission_request_answer" === n && (tp(td, {
                    type: "answer",
                    value: o.payload.body.agreed
                }), i.push(Ef(o.payload.body.agreed ? Qa.Allow : Qa.Deny))), _e(i);
            }))
    }, MD = ir(PD);
    let kD = function(e) {
        return e[e.All = 1] = "All", e[e.Private = 2] = "Private", e;
    }({}), LD = function(e) {
        return e.SUCCESS = "success", e;
    }({}), ND = function(e) {
        return e.CustomizedKey = "__zoom_internal_message_customized_key__@@", e.SpeakerOnly = "__zoom_internal_message_speaker_only__@@", e;
    }({});
    const VD = jI.getInstance(), UD = (e, t1, o)=>{
        const { meeting: { encType: r } } = o, i = t1, n = Gr(e), s = i ? kD.Private : kD.All;
        return r === As.AES_GCM ? Ts.beginEncrypt({
            text: n,
            type: Cs.XMPP_CHAT
        }).then((e)=>{
            VD.sendWebinarMseeage(e, i, s, !0);
        }) : VD.sendWebinarMseeage(n, i, s, !1);
    };
    function jD(e, t1) {
        const { cmd: { jids: o } } = t1;
        return Object.prototype.hasOwnProperty.call(o, e) ? Promise.resolve() : Oe(np(fa).pipe(ct((t1)=>-1 === t1.findIndex((t1)=>Number(t1.userId) === e)), nt(1), Ie(te)));
    }
    function xD(e) {
        const { cmd: { connectionStatus: t1 } } = e;
        return t1 === LD.SUCCESS ? Promise.resolve(!0) : Oe(np(Wa, 1)).then((e)=>e === Yn.Connected || Promise.reject({
                type: Kl,
                reason: "Cannot establish the command channel"
            }));
    }
    function BD(e, t1) {
        for (const [o, r] of Object.entries(e))if (r.jid === t1) return o;
    }
    const FD = {
        connectionStatus: "initial",
        jids: {}
    }, HD = bo({
        [`${Tf}`]: ()=>({
                ...FD
            }),
        [`${_f}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { data: r, attendees: i } = o;
            r.forEach((t1)=>{
                const { jid: o, node: r } = t1;
                if (!e.jids[r] || e.jids[r].jid !== o) {
                    const t1 = i.find((e)=>e.userId === Number(r));
                    e.jids[r] = {
                        jid: o,
                        userGuid: null == t1 ? void 0 : t1.userGUID
                    };
                }
            });
        }),
        [`${Rf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            o.forEach((t1)=>{
                const { jid: o } = t1, r = BD(e.jids, o);
                r && delete e.jids[r];
            });
        }),
        [`${wf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.connectionStatus = o;
        })
    }, FD);
    var $D;
    let WD = ($D = class extends vT {
        send(e, t1) {
            if (!e) return Promise.reject({
                type: Zl,
                reason: "Text is empty"
            });
            if ("string" != typeof e) return Promise.reject({
                type: Zl,
                reason: "Text is not a string"
            });
            if (e.length > 512) return Promise.reject({
                type: Zl,
                reason: "Text exceeds the max length(512)."
            });
            const { [oT]: o } = this, r = o(), { socket: { xmppSocketStatus: i }, meeting: { userId: n } } = r;
            return i !== Sh.Connected ? Promise.reject({
                type: Ql,
                reason: "Command channel is not ready"
            }) : xD(r).then(()=>t1 ? -1 !== ph(o()).findIndex((e)=>e.userId === t1) ? jD(t1, r).then(()=>{
                    const { cmd: { jids: r } } = o();
                    return r[t1] ? (UD(e, r[t1].jid, o()), {
                        timestamp: (new Date).getTime(),
                        text: e,
                        receiverId: t1,
                        senderId: n
                    }) : Promise.reject({
                        type: zl
                    });
                }).catch(()=>{}) : Promise.reject({
                    type: Zl,
                    reason: "Cannot find the user"
                }) : (UD(e, "", r), {
                    timestamp: (new Date).getTime(),
                    text: e,
                    receiverId: 0,
                    senderId: n
                })).catch(()=>{});
        }
        getJids() {
            const { [oT]: e } = this, t1 = e(), { cmd: { jids: o } } = t1;
            return o;
        }
    }, eT($D.prototype, "send", [
        sT
    ], Object.getOwnPropertyDescriptor($D.prototype, "send"), $D.prototype), $D);
    const GD = {
        extraEpics0: (e, t1)=>e.pipe(Dt(`${Xh}`), ht((e)=>{
                const { payload: { speakerOnly: o } } = e, r = ah(t1.value);
                return (void 0 !== (null == r ? void 0 : r.audio) ? _e([
                    r.audio
                ]) : np(ha).pipe(ot((e)=>void 0 !== e.audio), nt(1))).pipe(vt(()=>{
                    xD(t1.value).then(()=>{
                        UD(`${ND.SpeakerOnly}${o ? 1 : 0}`, "", t1.value);
                    });
                }), ut(ne));
            })),
        extraEpics1: (e, t1)=>nr(e, Ps).pipe(ot((e)=>{
                var o;
                const { payload: { body: r } } = e;
                return !!r.add && !(null === (o = t1.value.audio) || void 0 === o || null === (o = o.customizeAudioOption) || void 0 === o || !o.speakerOnly);
            }), Ie(te), vt(async (e)=>{
                const { payload: { body: { add: o } } } = e, r = t1.value, { meeting: { userId: i } } = r;
                for(let e = 0; e < o.length; e++){
                    const { id: r } = o[e];
                    if (r !== i) {
                        await jD(r, t1.value);
                        const { cmd: { jids: e }, participants: { attendeesList: o } } = t1.value;
                        e[r] && setTimeout(()=>{
                            UD(`${ND.SpeakerOnly}1`, e[r].jid, t1.value);
                        }, Math.floor(Math.random() * Math.log10(o.length) * 1e3));
                    }
                }
            }), ut(ne))
    }, KD = {
        epics0: (e, t1)=>ar(e, 24577).pipe(ft(t1), Le((e)=>{
                let [t1] = e;
                const { payload: { body: { status: o } } } = t1;
                return o === LD.SUCCESS && tp(Wa, Yn.Connected), wf(o);
            })),
        epics1: (e, t1)=>ar(e, 24583).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { meeting: { userId: r, encType: i }, cmd: { jids: n } } = o, { payload: { body: { senderName: s, senderJid: a, text: d, type: u, receiver: l, msgid: c, sn: p } } } = t1, h = BD(n, l), m = i === As.AES_GCM, g = BD(n, a), v = (new Date).getTime();
                let f = Promise.resolve({
                    message: d
                });
                return m && (f = Ts.beginDecrypt({
                    decryptedText: d,
                    type: Cs.XMPP_CHAT,
                    zoomId: p
                })), f.then((e)=>{
                    let { message: t1 } = e;
                    if (u === kD.Private && Number(h) === r || u === kD.All) {
                        const e = Wr(t1);
                        if (null != e && e.startsWith(ND.SpeakerOnly)) {
                            const t1 = e.substring(ND.SpeakerOnly.length), o = 1 === Number(t1);
                            return Pp({
                                userId: Number(g),
                                key: "isSpeakerOnly",
                                value: o
                            });
                        }
                        {
                            var o;
                            const t1 = g && (null === (o = n[g]) || void 0 === o ? void 0 : o.userGuid);
                            tp($a, {
                                senderId: g,
                                senderName: s,
                                senderGuid: t1,
                                text: e,
                                timestamp: v,
                                msgid: c
                            });
                        }
                    }
                    return "";
                });
            }), ot((e)=>"object" == typeof e && null !== e && void 0 !== e.type), vt((e)=>{
                const { payload: { userId: t1, key: o, value: r } } = e;
                tp(ga, [
                    {
                        userId: t1,
                        [`${o}`]: r
                    }
                ]);
            })),
        epics2: (e, t1)=>ar(e, 24595).pipe(Fe((e)=>{
                const { payload: { body: { action: o, data: r } } } = e, i = [];
                if ([
                    VI.List,
                    VI.Add,
                    VI.update
                ].includes(o) && r) {
                    const { breakoutRoom: e, participants: { attendeesList: o } } = t1.value, n = (null == e ? void 0 : e.currentRoom.status) === Qp.InRoom ? o.concat(e.mainSessionAttendeeList) : o;
                    i.push(_f({
                        data: r,
                        attendees: n
                    }));
                }
                return o === VI.Remove && r && i.push(Rf(r)), _e(i);
            }))
    }, zD = ir(KD, GD), qD = (e, t1, o, r)=>{
        const { getState: i, dispatch: n } = o, s = i(), { participants: { attendeesList: a }, audio: { localShareAudioUserMutedList: d }, share: { isReceiveSharingFromMainSession: u }, breakoutRoom: l } = s, c = (u ? null == l ? void 0 : l.mainSessionAttendeeList : a).find((t1)=>t1.userId == e);
        if (c) {
            if (c.bShareAudioOn) {
                const o = d.find((t1)=>t1.userId === e);
                return o && o.muted === !t1 && n(GC(r, e, t1, s)), Promise.resolve("");
            }
            return Promise.reject({
                type: Kl,
                reason: `Cannot ${t1 ? "mute" : "unmute"} share audio when the user's share audio is not enable.`
            });
        }
        return Promise.reject({
            type: Zl,
            reason: "Cannot find the user"
        });
    }, JD = (e, t1)=>{
        const { store: { getState: o }, rwgAgent: r } = e, { share: { sharePrivilege: i } } = o();
        return i === t1 ? Promise.resolve("") : Object.values(fd).includes(t1) ? (r.lockSharing(t1), By("lockShare", t1)) : Promise.reject({
            type: Zl
        });
    }, QD = Vp([
        ph
    ], (e)=>e.filter((e)=>e.bVideoOn)), ZD = Vp([
        QD
    ], (e)=>e.filter((e)=>(e.caps & oS) === oS)), YD = (e, t1)=>{
        const o = e.store.getState(), r = uS(o).find((e)=>e.userId === t1);
        if (r) {
            const { caps: e } = r;
            return ((e)=>!(512 & ~e))(e);
        }
        return !1;
    };
    var XD, eP, tP, oP, rP, iP, nP, sP, aP, dP, uP, lP, cP, pP, hP, mP, gP, vP, fP, yP, SP, bP, EP, IP, AP, CP, _P, RP, wP, TP, OP, DP, PP, MP, kP, LP, NP, VP, UP, jP, xP, BP, FP, HP, $P, WP, GP, KP, zP, qP, JP, QP, ZP, YP, XP, eM, tM, oM, rM, iM, nM, sM, aM, dM, uM, lM, cM, pM, hM, mM, gM, vM, fM, yM, SM, bM, EM, IM, AM, CM, _M, RM, wM;
    const TM = mT("Audio"), OM = mT("Video"), DM = mT("Sharing"), PM = mT("CameraControl"), MM = mT("Remote Control"), kM = gT(HTMLCanvasElement, 0), LM = gT([
        HTMLCanvasElement,
        HTMLVideoElement
    ], 0), NM = gT(HTMLCanvasElement, 0, [
        "id"
    ]), VM = gT([
        HTMLCanvasElement,
        HTMLVideoElement
    ], 0, [
        "id"
    ]);
    let UM = (XD = uT("audio"), eP = uT("audio"), tP = uT("audio"), oP = uT("audio"), rP = uT("audio"), iP = mT("Audio", [
        1,
        2,
        3
    ]), nP = uT("audio"), sP = mT("Audio", [
        1,
        2
    ]), aP = uT("audio"), dP = uT("audio"), uP = uT("audio"), lP = uT("audio"), cP = uT("share"), pP = uT("audio"), hP = uT("share"), mP = uT("audio"), gP = uT("audio"), vP = uT("audio"), fP = uT("audio"), yP = uT("audio"), SP = uT("audio"), bP = mT("Audio", [
        1,
        2
    ]), EP = uT("audio"), IP = mT("Audio", [
        1,
        2
    ]), AP = uT("audio"), CP = uT("audio"), _P = uT("audio"), RP = uT("video"), wP = uT("video"), TP = uT("video"), OP = uT("video"), DP = uT("video"), PP = uT("video"), MP = uT("video"), kP = uT("video"), LP = uT("video"), NP = uT("video"), VP = uT("video"), UP = uT("video"), jP = uT("video"), xP = uT("video"), BP = uT("video"), FP = uT("video"), HP = uT("video"), $P = uT("video"), WP = uT("video"), GP = uT("video"), KP = uT("video"), zP = uT("video"), qP = uT("video"), JP = uT("video"), QP = uT("video"), ZP = uT("video"), YP = uT("video"), XP = uT("video"), eM = uT("video"), tM = uT("share"), oM = uT("share"), rM = uT("share"), iM = uT("share"), nM = uT("share"), sM = uT("share"), aM = uT("share"), dM = uT("share"), uM = lT("isShareOptionLocked"), lM = lT("isShareOptionLocked"), cM = uT("share"), pM = uT("share"), hM = uT("share"), mM = uT("share"), gM = uT("share"), vM = uT("share"), fM = uT("share"), yM = uT("share"), SM = uT("share"), bM = uT("share"), EM = uT("share"), IM = uT("share"), AM = uT("share"), CM = uT("share"), _M = uT("share"), RM = uT("share"), wM = class extends vT {
        constructor(e){
            super(e), this[nT] = void 0, this[tT].dispatch(Uo()), this[nT] = {
                store: e,
                mediaAgent: Py(yE(ca.getInstance())),
                rwgAgent: ia.createAgent()
            };
        }
        startAudio(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), a = ah(s);
                if ((null == a ? void 0 : a.audio) === Wd.Computer) return Promise.resolve("");
                if ((null == a ? void 0 : a.audio) === Wd.Phone) return Promise.reject({
                    type: Kl,
                    reason: "joined by phone"
                });
                {
                    const { audio: { isAllowToTalk: e, isComputerAudioLoading: d, canPlayAudio: u, customizeAudioOption: { speakerOnly: l } }, media: { audioDecodeStatus: c, audioEncodeStatus: p } } = s;
                    if (d) return Promise.reject({
                        type: Kl,
                        reason: "Computer audio has been loading, please wait."
                    });
                    const h = function(e) {
                        const t1 = e ? {
                            ...e
                        } : void 0;
                        if (XC(vs()) || !0 !== (null == t1 ? void 0 : t1.backgroundNoiseSuppression) || (console.warn("Background noise suppression requires SharedArrayBuffer and is only supported on desktop browser"), Object.assign(t1, {
                            backgroundNoiseSuppression: void 0
                        })), void 0 !== (null == t1 ? void 0 : t1.originalSound)) {
                            t1.backgroundNoiseSuppression && t1.originalSound && (console.warn("Enabling original sound will disable background noise suppression."), Object.assign(t1, {
                                backgroundNoiseSuppression: !1
                            }));
                            const { originalSound: e } = t1;
                            "object" == typeof e && e.stereo && !e_() && (console.warn("Cannot enable stereo audio on current platform due to the browser limitation"), Object.assign(e, {
                                stereo: !1
                            }));
                        }
                        return t_() || !0 !== (null == t1 ? void 0 : t1.syncButtonsOnHeadset) || (console.warn("Sync buttons on headset is not supported on the current platform"), Object.assign(t1, {
                            syncButtonsOnHeadset: void 0
                        })), null != t1 && t1.mediaFile && !ca.isSupportMediaPlaybackAsVideoInput() && (console.warn("Cannot use media file as audio input due to the browser limitation"), Object.assign(t1, {
                            mediaFile: void 0
                        })), t1;
                    }(t1);
                    r(Xh(null != h ? h : {}));
                    const { speakerOnly: m, autoStartAudioInSafari: g } = h || {};
                    if (!!l != !!m && r(Pp({
                        userId: s.meeting.userId,
                        key: "isSpeakerOnly",
                        value: !!m
                    })), !a) return Promise.reject({
                        type: Kl,
                        reason: "Please call `startAudio` method after the `join` has been resolved"
                    });
                    {
                        const t1 = Kp(a.userRole) && !e || m, { encodeInitStatus: d, decodeInitStatus: l } = o_(s, a, m);
                        if (QC() && ("success" !== l || "success" !== d)) return Promise.reject({
                            type: Kl,
                            reason: "It is required to wait for the audio encoding and decoding to be ready before calling `startAudio` method"
                        });
                        r(jh(!0)), Iy("audio", d, l).subscribe((s)=>{
                            let [d, l] = s;
                            if (d && l) {
                                let s = u || (QC() || gs.isIOSMobile) && !g ? Promise.resolve() : function() {
                                    const e = URL.createObjectURL(md), t1 = new Audio(e);
                                    t1.muted = !1;
                                    const o = Xr(()=>Promise.reject(), 3e3), r = gs.isIOSMobile ? new Promise((e, o)=>{
                                        var r;
                                        t1.addEventListener("canplaythrough", ()=>{
                                            t1.play().then(()=>{
                                                e(!0);
                                            }).catch((e)=>{
                                                o(e);
                                            });
                                        }), null === (r = t1.load) || void 0 === r || r.call(t1);
                                    }) : t1.play();
                                    return Promise.race([
                                        r,
                                        o
                                    ]).finally(()=>{
                                        URL.revokeObjectURL(e);
                                    });
                                }();
                                void 0 === s && (s = Promise.resolve()), s.then(()=>Cy("audio", o())).then(()=>{
                                    const s = o(), { audio: { isSharingAudio: d } } = s;
                                    r_(i, s, t1), d && !YC() || KC(n, s, !t1), Kp(a.userRole) && e && r(xh(!0)), r(Vh(!0));
                                }).catch(()=>{
                                    r(Vh(!1)), r(jh(!1));
                                });
                            } else r(jh(!1));
                        });
                    }
                    return "failed" === p || "failed" === c ? (r(jh(!1)), Promise.reject({
                        type: zl,
                        reason: "audio encode or decode error"
                    })) : new Promise((e, t1)=>{
                        rt(np(ml.JoinComputerAudio.success, 1), Xe(...ml.JoinComputerAudio.fail.map((e)=>np(e, 1).pipe(Fe(()=>we({
                                    type: Jl,
                                    reason: e
                                }))))), Ze(45e3).pipe(Fe(()=>we({
                                type: ql
                            })))).subscribe({
                            next: ()=>{
                                r(jh(!1)), e("");
                            },
                            error: (e)=>{
                                ca.getInstance().leaveComputerAudio();
                                const n = ah(o());
                                (null == n ? void 0 : n.audio) !== Wd.Phone && (r(um(cd.MicrophoneError)), i.joinOrLeaveVoip(!1)), r(jh(!1)), t1(e);
                            }
                        });
                    });
                }
            })(this[nT], e);
        }
        stopAudio() {
            return (async (e)=>{
                const { store: { getState: t1, dispatch: o }, mediaAgent: r, rwgAgent: i } = e, n = t1(), { audio: { isComputerAudioLoading: s, isShareAudioEnabled: a, isSharingAudio: d, isUsingMediaPlayback: u, customizeAudioOption: { speakerOnly: l } } } = n, c = ah(n);
                if (s) return Promise.reject({
                    type: Kl,
                    reason: "Computer audio has not finished joining, please wait."
                });
                if (a) {
                    if (d && !YC()) return Promise.reject({
                        type: Kl,
                        reason: "Cannot stop audio during sharing with audio"
                    });
                    o($h(void 0)), o(Bh(void 0));
                }
                return (null == c ? void 0 : c.audio) === Wd.Computer ? (o(um(cd.Active)), await r.leaveComputerAudio(), i.joinOrLeaveVoip(!1), l && o(Pp({
                    userId: n.meeting.userId,
                    key: "isSpeakerOnly",
                    value: void 0
                })), u && Wy.getInstance().stopAudioElement(), o(Ph(0)), ip($u)) : Promise.resolve("");
            })(this[nT]);
        }
        muteAudio(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), a = ah(s);
                if (null == t1 || t1 === (null == a ? void 0 : a.userId)) return "" === (null == a ? void 0 : a.audio) || null === (null == a ? void 0 : a.audio) ? Promise.reject({
                    type: Kl,
                    reason: "no audio joined"
                }) : !0 === (null == a ? void 0 : a.muted) ? Promise.resolve("") : (r(sm(ud.Active)), i.mute(a.userId, !0), n.muteAudio(), s.audio.isShareAudioEnabled && !YC() && r(Bh(!0)), ip(Wu).then(()=>""));
                if (dh(s)) {
                    const { participants: { allowTalkAttendeesList: e, attendeesList: o } } = s, r = e.concat(o).find((e)=>e.userId === t1);
                    return r ? "" === r.audio || null === r ? Promise.reject({
                        type: Kl,
                        reason: "no audio joined"
                    }) : !1 === r.muted ? (i.mute(t1, !0), ip(Ku, (e)=>e.id === t1 && 1 == e.muted)) : Promise.resolve("") : Promise.reject({
                        type: Zl,
                        reason: "no matching user"
                    });
                }
                return Promise.reject({
                    type: Jl
                });
            })(this[nT], e);
        }
        unmuteAudio(e) {
            return (async (e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), a = ah(s);
                if (void 0 === t1 || t1 === (null == a ? void 0 : a.userId)) {
                    if ("" === (null == a ? void 0 : a.audio) || null === (null == a ? void 0 : a.audio)) return Promise.reject({
                        type: Kl,
                        reason: "no audio joined"
                    });
                    if (!1 === (null == a ? void 0 : a.muted)) return Promise.resolve("");
                    if (s.audio.isShareAudioEnabled && !YC()) {
                        if (s.audio.isSharingAudio) return Promise.reject({
                            type: Kl,
                            reason: "Cannot unmute audio during sharing with audio"
                        });
                        r(Bh(!1));
                    }
                    if (s.audio.bCanUnmute || null != a && a.isHost || null != a && a.bCoHost) {
                        if (Kp(a.userRole)) {
                            const { audio: { isAllowToTalk: e, isAllowToTalkAttendeeConnected: t1 } } = s;
                            e ? t1 || (await n.leaveComputerAudio(), await KC(n, s, !0), r(xh(!0))) : Promise.reject({
                                type: Kl,
                                reason: "Webinar attendee cannot unmute self audio."
                            });
                        }
                        return r(am(ld.Active)), i.mute(a.userId, !1), n.unmuteAudio(), ip(Gu).then(()=>"");
                    }
                    return Promise.reject({
                        type: Jl,
                        reason: "host not allow unmute themselves"
                    });
                }
                if (dh(s)) {
                    const { participants: { allowTalkAttendeesList: e, attendeesList: o } } = s, r = e.concat(o).find((e)=>e.userId === t1);
                    return r ? "" === r.audio || null === r ? Promise.reject({
                        type: Kl,
                        reason: "no audio joined"
                    }) : (!0 === r.muted && i.mute(t1, !1), Promise.resolve("")) : Promise.reject({
                        type: Zl,
                        reason: "no matching user"
                    });
                }
                return Promise.reject({
                    type: Jl
                });
            })(this[nT], e);
        }
        dialOut(e, t1, o, r) {
            return ((e, t1, o, r, i)=>{
                const { store: { getState: n, dispatch: s }, rwgAgent: a } = e, d = n(), { meeting: { callOutCountry: u, isSupportCallOut: l } } = d;
                if (l && Array.isArray(u) && u.findIndex((e)=>e.code === t1) > -1) {
                    const { seq: e } = a.audioDialout(t1 + o, r, !(null == i || !i.callMe), !(null == i || !i.pressingOne), !(null == i || !i.greeting));
                    return s(Ch({
                        sequence: e,
                        phoneNumber: t1 + o
                    })), rp(ml.JoinAudioByCallMe);
                }
                return Promise.reject({
                    type: Zl,
                    reason: "no matching country code"
                });
            })(this[nT], e, t1, o, r);
        }
        cancelDialOut(e, t1, o) {
            return ((e, t1, o, r)=>{
                const { rwgAgent: i } = e;
                return i.audioCancelDialout(t1 + o, !(null == r || !r.callMe)), rp(ml.cancelDialOut);
            })(this[nT], e, t1, o);
        }
        hangup() {
            return ((e)=>{
                const { store: { getState: t1 }, rwgAgent: o } = e, r = t1(), i = ah(r);
                return (null == i ? void 0 : i.audio) === Wd.Phone && null !== i.userId ? (o.audioDrop(i.userId), rp(ml.hangup)) : Promise.reject({
                    type: Kl,
                    reason: "not joined audio by phone"
                });
            })(this[nT]);
        }
        switchMicrophone(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { audio: { microphoneDevicesList: s, activeMicrophone: a, mediaPlaybackFile: d, isUsingMediaPlayback: u } } = n, l = s.find((e)=>e.deviceId === t1);
                if ("default" === t1 || "string" != typeof t1 || l) {
                    const e = ah(n);
                    if ((null == e ? void 0 : e.audio) === Wd.Computer) {
                        let o = !1;
                        if ("string" == typeof t1) t1 !== a && (i.changeMicrophone(t1, null == l ? void 0 : l.label, !(null == e || !e.muted)), r(om(void 0)), Wy.getInstance().stopAudioElement(), o = !0);
                        else if (t1 && (!u || (null == d ? void 0 : d.url) !== t1.url)) {
                            const n = Wy.getInstance();
                            n.setAudioElement(t1).then(()=>{
                                void 0 !== t1.playback && (i.enablePlayAudioFileLocally(!!t1.playback), n.audioElement.dataset.playback = t1.playback ? "1" : "0"), i.changeMicrophone(n.audioElement, void 0, !(null == e || !e.muted)), r(om(t1));
                            }), o = !0;
                        }
                        if (o) return rp(ml.JoinComputerAudio);
                    } else "string" == typeof t1 && r(Lh(t1));
                    return Promise.resolve("");
                }
                return Promise.reject({
                    type: ol
                });
            })(this[nT], e);
        }
        switchSpeaker(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { audio: { speakerDevicesList: n, activeSpeaker: s } } = o();
                if ("default" !== t1 && -1 == n.findIndex((e)=>e.deviceId === t1)) return Promise.reject({
                    type: ol
                });
                var a;
                if ((null === (a = ah(o())) || void 0 === a ? void 0 : a.audio) === Wd.Computer) {
                    if (t1 !== s) return i.changeSpeaker(t1), ip(al, (e)=>e);
                } else r(Nh(t1));
                return Promise.resolve("");
            })(this[nT], e);
        }
        muteShareAudio(e) {
            return ((e, t1)=>{
                const { mediaAgent: o, rwgAgent: r, store: { getState: i, dispatch: n } } = e, s = i(), { meeting: { userId: a } } = s;
                if (t1 && t1 !== a) return qD(t1, !0, e.store, o);
                {
                    const { audio: { isSharingAudio: e, isShareAudioEnabled: t1, isShareAudioMuted: i } } = s;
                    if (!t1) return Promise.reject({
                        type: Kl,
                        reason: "Cannot mute sharing audio when sharing audio is not enable"
                    });
                    if (i) return Promise.resolve("");
                    {
                        r.muteShareAudio(!0);
                        let t1 = Promise.resolve();
                        var d;
                        return e && (t1 = null === (d = o.leaveSharingAudio(!0)) || void 0 === d ? void 0 : d.then(()=>zC(o, r, s).then((e)=>{
                                e.forEach((e)=>n(e));
                            }))), GC(o, a, !0, s), Promise.all([
                            ip({
                                event: ha,
                                operations: [
                                    ot((e)=>void 0 !== e.bShareAudioOn),
                                    nt(1)
                                ]
                            }, (e)=>!1 === e.bShareAudioOn),
                            t1
                        ]).then(()=>(n(Gh(!0)), e && (n(Kh(!1)), tp(il, {
                                state: "off"
                            })), ""));
                    }
                }
            })(this[nT], e);
        }
        unmuteShareAudio(e) {
            return ((e, t1)=>{
                const { mediaAgent: o, rwgAgent: r, store: { getState: i, dispatch: n } } = e, s = i(), { meeting: { userId: a } } = s;
                if (t1 && t1 !== a) return qD(t1, !1, e.store, o);
                {
                    const { audio: { isSharingAudio: e, isShareAudioEnabled: t1, isShareAudioMuted: i }, share: { status: d } } = s;
                    if (!t1) return Promise.reject({
                        type: Kl,
                        reason: "Cannot unmute sharing audio when sharing audio is not enable"
                    });
                    if (!1 === i) return Promise.resolve("");
                    {
                        r.muteShareAudio(!1);
                        let t1 = Promise.resolve();
                        return !1 === e && d === yd.Sharing && (t1 = JC(o, r, s).then((e)=>{
                            e.forEach((e)=>n(e));
                        })), GC(o, a, !1, s), Promise.all([
                            ip({
                                event: ha,
                                operations: [
                                    ot((e)=>void 0 !== e.bShareAudioOn),
                                    nt(1)
                                ]
                            }, (e)=>!0 === e.bShareAudioOn),
                            t1
                        ]).then(()=>(n(Gh(!1)), !1 === e && d === yd.Sharing && (n(Kh(!0)), tp(il, {
                                state: "on"
                            })), ""));
                    }
                }
            })(this[nT], e);
        }
        subscribeAudioStatisticData(e) {
            return (async (e, t1)=>{
                const { mediaAgent: o, store: { getState: r } } = e, i = r(), n = ah(i), s = !t1 || t1.decode, a = !t1 || t1.encode;
                if (!n) return Promise.reject({
                    type: Kl,
                    reason: "Call this function after the 'join' method resolved."
                });
                {
                    var d;
                    const { encodeInitStatus: e, decodeInitStatus: t1 } = o_(i, n);
                    (vs() ? Vy(i, !(null !== (d = i.audio.customizeAudioOption) && void 0 !== d && d.speakerOnly)) : Iy("audio", e, t1)).subscribe((e)=>{
                        let [t1, r] = e;
                        t1 && r && (s && o.subscribeToQos([
                            ua.AudioDecode
                        ], Od), a && o.subscribeToQos([
                            ua.AudioEncode
                        ], Od));
                    });
                }
                return "";
            })(this[nT], e);
        }
        unsubscribeAudioStatisticData(e) {
            return (async (e, t1)=>{
                const { mediaAgent: o, store: { dispatch: r } } = e, i = !t1 || t1.decode, n = !t1 || t1.encode;
                return i && (o.unsubscribeFromQos([
                    ua.AudioDecode
                ]), r(zh(Nd))), n && (o.unsubscribeFromQos([
                    ua.AudioEncode
                ]), r(qh(Nd))), null;
            })(this[nT], e);
        }
        enableBackgroundNoiseSuppression(e) {
            return ((e, t1)=>{
                const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { audio: { isBackgroundNoiseSuppression: n, originalSound: s } } = r();
                let a = t1;
                return a === !!n || (a && !XC(vs()) ? (console.warn("Background noise suppression requires SharedArrayBuffer and is only supported on desktop browser"), a = !1) : (a && s && (console.warn("Enabling noise suppression will disable original sound."), i(dm(!1))), i(em(a)), o.changeAudioProfile(WC(r())))), Promise.resolve("");
            })(this[nT], e);
        }
        enableSyncButtonsOnHeadset(e) {
            return ((e, t1)=>{
                const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, n = r(), { audio: { isHIDEnabled: s, microphoneDevicesList: a, activeMicrophone: d } } = n;
                if (t1 === !!s) return Promise.resolve("");
                {
                    const e = ah(n);
                    var u;
                    return e ? (t1 && !t_() ? console.warn("Sync buttons on headset is not supported on the current platform") : (o.enableSyncButtonsOnHeadset(t1, null === (u = a.find((e)=>e.deviceId === d)) || void 0 === u ? void 0 : u.label, e.muted), i(tm(t1))), Promise.resolve("")) : Promise.reject({
                        type: Kl,
                        reason: "Please call `enableSyncButtonsOnHeadset` method after the `join` has been resolved"
                    });
                }
            })(this[nT], e);
        }
        enableOriginalSound(e) {
            return ((e, t1)=>{
                const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { audio: { isBackgroundNoiseSuppression: n, originalSound: s } } = r(), a = t1;
                return a === s || "object" == typeof t1 && Zr(t1, s) || ("object" != typeof a || !0 !== (null == a ? void 0 : a.stereo) || e_() || (console.warn("Cannot enable stereo audio on current platform due to the browser limitation"), a.stereo = !1), n && a && (console.warn("Enabling original sound will disable background noise suppression."), i(em(!1))), i(dm(a)), o.changeAudioProfile(WC(r()))), Promise.resolve("");
            })(this[nT], e);
        }
        callCRCDevice(e, t1) {
            return ((e, t1, o)=>{
                const { rwgAgent: r, store: { dispatch: i, getState: n } } = e, { seq: s } = r.inviteCRCDevice(t1, o);
                return i(cm({
                    sequence: s,
                    ip: t1,
                    protocol: o
                })), rp(ml.crcCallOut).then(()=>{
                    var e;
                    const { audio: { crcDevice: r } } = n();
                    return null === (e = r.find((e)=>e.ip === t1 && e.protocol === o && e.sequence === s)) || void 0 === e ? void 0 : e.uuid;
                });
            })(this[nT], e, t1);
        }
        cancelCallCRCDevice(e, t1) {
            return ((e, t1, o)=>{
                const { rwgAgent: r, store: { getState: i } } = e, { audio: { crcDevice: n } } = i(), s = n.find((e)=>e.ip === t1 && e.protocol === o);
                return s && s.returnCode === tu.Ringing ? (r.cancelInviteCRCDevice(s.transId), Promise.resolve("")) : Promise.reject({
                    type: Kl,
                    reason: "Cannot cancel call out "
                });
            })(this[nT], e, t1);
        }
        muteAllAudio() {
            return ((e)=>{
                const { rwgAgent: t1 } = e;
                return t1.audioMuteAll(!0), By("bMutedAll", !0);
            })(this[nT]);
        }
        unmuteAllAudio() {
            return ((e)=>{
                const { rwgAgent: t1 } = e;
                return t1.audioMuteAll(!1), By("bMutedAll", !1);
            })(this[nT]);
        }
        muteAudioUponEntry() {
            let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            return function(e) {
                let t1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                const { store: { getState: o }, rwgAgent: r } = e, { audio: { bMutedUponEntry: i } } = o();
                return i === t1 ? Promise.resolve("") : (r.setMuteOnEntry(t1), By("bMutedUponEntry", t1));
            }(this[nT], e);
        }
        getMicList() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const o = t1();
                return o.audio ? [
                    ...o.audio.microphoneDevicesList
                ] : [];
            })(this[nT]);
        }
        getSpeakerList() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const o = t1();
                return o.audio ? [
                    ...o.audio.speakerDevicesList
                ] : [];
            })(this[nT]);
        }
        getAudioState(e) {
            return ((e, t1)=>{
                let { store: { getState: o } } = e;
                const r = o(), { meeting: { isWebinar: i } } = r;
                let n = null;
                return null == t1 ? n = ah(r) : (n = r.participants.attendeesList.find((e)=>e.userId === t1), i && !n && (n = r.participants.xmppAttendeeList.find((e)=>e.userId === t1))), n ? n.audio : null;
            })(this[nT], e);
        }
        isAudioMuted(e) {
            return ((e, t1)=>{
                let { store: { getState: o } } = e;
                const r = o(), { meeting: { isWebinar: i } } = r;
                let n = null;
                return void 0 === t1 ? n = ah(r) : (n = r.participants.attendeesList.find((e)=>e.userId === t1), i && !n && (n = r.participants.xmppAttendeeList.find((e)=>e.userId === t1))), !!n && !!n.muted;
            })(this[nT], e);
        }
        getActiveMicrophone() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const o = t1();
                return o.audio ? o.audio.activeMicrophone : null;
            })(this[nT]);
        }
        getActiveSpeaker() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const o = t1();
                return o.audio ? o.audio.activeSpeaker : null;
            })(this[nT]);
        }
        isSupportCallOut() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { meeting: { isSupportCallOut: o, callOutCountry: r } } = t1();
                return o && Array.isArray(r) && (null == r ? void 0 : r.length) > 0;
            })(this[nT]);
        }
        getDialOutStatus() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { audio: o } = t1();
                return null == o ? void 0 : o.dialout[o.dialout.length - 1].returnCode;
            })(this[nT]);
        }
        getDialOutCountries() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { meeting: { callOutCountry: o } } = t1();
                return Array.isArray(o) ? o : [];
            })(this[nT]);
        }
        getShareAudioStatus() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { audio: { isShareAudioEnabled: o, isShareAudioMuted: r, isSharingAudio: i } } = t1();
                return {
                    isShareAudioEnabled: o,
                    isShareAudioMuted: r,
                    isSharingAudio: i
                };
            })(this[nT]);
        }
        isOthersShareAudioMutedLocally(e) {
            return ((e, t1)=>{
                var o;
                let { store: { getState: r } } = e;
                const { audio: { localShareAudioUserMutedList: i } } = r();
                return null === (o = i.find((e)=>e.userId === t1)) || void 0 === o ? void 0 : o.muted;
            })(this[nT], e);
        }
        getAudioStatisticData() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { audio: { statistic: o } } = t1();
                return {
                    ...o
                };
            })(this[nT]);
        }
        getDialInInfo() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { meeting: { meetingNumber: o, tollNumbers: r, participantID: i, h323Password: n } } = t1();
                return void 0 === r ? null : {
                    meetingId: o,
                    participantId: i,
                    password: n || "",
                    tollNumbers: r.map((e)=>({
                            ...e
                        }))
                };
            })(this[nT]);
        }
        isSupportMicrophoneAndShareAudioSimultaneously() {
            return YC();
        }
        getAudioMediaPlaybackController() {
            return ((e)=>{
                let { store: { getState: t1 }, mediaAgent: o } = e;
                const r = t1(), { audio: { isUsingMediaPlayback: i } } = r;
                if (i) {
                    const { audioElement: e } = Wy.getInstance();
                    return Fy(e, "audio", r, o);
                }
                return null;
            })(this[nT]);
        }
        startVideo(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { media: { videoDecodeStatus: s, videoEncodeStatus: a, enforceVirtualBackground: d }, video: { isCaptureCameraLoading: u, isCurrentUserStartedVideo: l, isVideoMuted: c } } = n, p = t1 ? {
                    ...t1
                } : void 0;
                if (l) return Promise.reject({
                    type: Kl,
                    reason: "Video is started"
                });
                if (u) return Promise.reject({
                    type: Kl,
                    reason: "Camera is starting,please wait."
                });
                if (c && !dh(n)) return Promise.reject({
                    type: Kl,
                    reason: "Video is muted by the host"
                });
                if (aw(d)) if ((null == p ? void 0 : p.videoElement) instanceof HTMLVideoElement) console.warn('The "videoElement" option will be removed in version 2.x. Please use the "attachVideo" or "renderVideo" method to render the self-view.');
                else {
                    console.warn('Rendering self-view on Chromium browser, Android browser without SharedArrayBuffer or iOS browser requires video tag, Please use "attachVideo" or pass a video element instead of a canvas element in the "renderVideo" method');
                    let e = document.body.querySelector(`#${Ld}`);
                    if (!e) {
                        e = document.createElement("video");
                        const t1 = gs.isSafari || gs.isIOSMobile ? "position:fixed;top:-10000px;left:-10000px" : "display:none";
                        e.setAttribute("style", t1), e.muted = !0, e.playsInline = !0, e.autoplay = !0, e.id = Ld, document.body.appendChild(e);
                    }
                    p && Object.assign(p, {
                        videoElement: e
                    });
                }
                return !My(d) && null != p && p.virtualBackground ? Promise.reject({
                    type: Zl,
                    reason: "Virtual background only compatible with Chrome and Edge with SharedArrayBuffer enabled."
                }) : (r(sg(!0)), Iy("video", a, s).subscribe((e)=>{
                    let [t1] = e;
                    if (t1) {
                        const e = o(), { video: { activeCamera: t1, isSupportHDVideo: n, virtualBackground: { imageSrc: s }, mask: { imageSrc: a } } } = e, { cameraId: d = t1, captureWidth: u = 0, captureHeight: l = 0, mirrored: c, hd: h, fullHd: m, virtualBackground: g, mask: v } = p || {};
                        c && i.mirrorVideo(c), (h || m) && (console.log("HD support is currently limited, and comes with a number of restrictions and limitations. Please visit https://developers.zoom.us/docs/video-sdk/web/video/#720p-video for more details"), n && ca.isCompatibleHardwareForEncode() && ca.isSupportVideoEncodeHardwareAcceleration().then((e)=>{
                            e && (i.enableHardwareAccelerationForVideoEncode(!0), r(Cg({
                                encode: e
                            })));
                        }), n || console.warn("Cannot capture HD video due to either account restriction and/or hardware limitation"));
                        const f = g || void 0 === g && !!s && void 0 === v, y = v || void 0 === v && !!a;
                        let S = Promise.resolve({});
                        if (f) {
                            const t1 = g || {
                                imageUrl: void 0,
                                cropped: void 0
                            };
                            S = yw({
                                ...t1,
                                captureWidth: u,
                                captureHeight: l,
                                cameraId: d,
                                hd: h
                            }, i, e).then(()=>t1);
                        } else if (y) {
                            const t1 = v || {
                                imageUrl: void 0,
                                cropped: void 0,
                                clip: void 0,
                                rootWidth: void 0,
                                rootHeight: void 0
                            };
                            t1.rootWidth || Object.assign(t1, {
                                rootWidth: 1280
                            }), t1.rootHeight || Object.assign(t1, {
                                rootHeight: 720
                            }), S = Sw({
                                ...t1,
                                captureWidth: u,
                                captureHeight: l,
                                cameraId: d,
                                hd: h
                            }, i, e).then(()=>t1);
                        }
                        null != p && p.mediaFile && !ca.isSupportMediaPlaybackAsVideoInput() && (console.warn("Cannot use media file as video input due to the browser limitation."), Object.assign(p, {
                            mediaFile: void 0
                        })), S.then((e)=>Cy("video", o()).then(()=>e)).then((t1)=>{
                            ow(i, e, p).forEach((e)=>{
                                r(e);
                            }), f ? r(Eg(t1)) : y && r(jg(t1));
                        }).catch((e)=>{
                            r(sg(!1)), tp(pu, {
                                reason: e
                            });
                        });
                    } else r(sg(!1));
                }), rp(Vu.startCaptureVideo).then(()=>{
                    r(ag(!1)), r(rg(!1));
                }).finally(()=>{
                    r(sg(!1));
                }));
            })(this[nT], e);
        }
        stopVideo() {
            return ((e)=>{
                const { store: { getState: t1 }, mediaAgent: o } = e, { video: { isCaptureCameraLoading: r, isCurrentUserStartedVideo: i, isUsingMediaPlayback: n } } = t1();
                return r ? Promise.reject({
                    type: Kl,
                    reason: "Camera is starting,please wait."
                }) : i ? (o.stopCaptureVideo(), n && Wy.getInstance().stopVideoElement(), ip(gu, (e)=>!0 !== (null == e ? void 0 : e.failed))) : Promise.reject({
                    type: Kl,
                    reason: "camera is closed"
                });
            })(this[nT]);
        }
        switchCamera(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { video: { cameraDevicesList: s, isCurrentUserStartedVideo: a, virtualBackground: d, mask: u, mediaPlaybackFile: l, isUsingMediaPlayback: c, customizedVideoOption: p } } = n;
                if ("string" == typeof t1 && !ew(t1, s)) return Promise.reject({
                    type: Zl,
                    reason: "Cannot find cameraDeviceId in camera devices list."
                });
                if (a || null != d && d.isVBConfigured || u.isMaskConfigured) {
                    if ("string" == typeof t1) {
                        const { captureWidth: e, captureHeight: o } = XR(p);
                        i.changeCamera(t1, Td.includes(t1), {
                            width: e,
                            height: o
                        }), r(Fg(void 0)), Wy.getInstance().stopVideoElement();
                    } else if (t1 && (!c || (null == l ? void 0 : l.url) !== t1.url)) {
                        const e = Wy.getInstance();
                        e.setVideoElement(t1).then(()=>{
                            i.changeCamera(e.videoElement), r(Fg(t1));
                        });
                    }
                    return rp(Vu.switchCameraVideo).then(()=>{
                        r(ag(!1)), r(rg(!1));
                    }).catch((e)=>(i.stopCaptureVideo(), Promise.reject(e)));
                }
                return Promise.resolve();
            })(this[nT], e);
        }
        renderVideo(e, t1, o, r, i, n, s, a, d) {
            return ((e, t1, o, r, i, n, s, a, d, u)=>{
                const { store: { getState: l, dispatch: c }, mediaAgent: p, rwgAgent: h } = e, m = l(), { meeting: { userId: g }, media: { enforceMultipleVideos: v, enforceVirtualBackground: f, disableRenderLimits: y }, video: { subscribedVideoList: S, renderedVideoList: b } } = m, E = Ss(!!v, y), I = aw(f) && o === g;
                if (t1 instanceof HTMLCanvasElement && !S.includes(o) && S.length >= E && new Set(b.map((e)=>e.canvasId)).has(t1.id)) return Promise.reject({
                    type: Kl,
                    reason: `subscribe video counts greater than maximum size (${E})`
                });
                if (-1 === QD(m).findIndex((e)=>e.userId === o)) return Promise.reject({
                    type: Zl,
                    reason: "user is not send video"
                });
                if (t1.id || (t1.id = ei("__ZOOM_SDK_VIDEO_CANVAS_@__")), I) {
                    if (t1 instanceof HTMLVideoElement) {
                        t1.playsInline = !0, t1.muted = !0, t1.autoplay = !0, gs.isIOSMobile && (p.switchCanvasForVideoCapture(t1), c(Yg())), p.renderVideo(t1, o, d || Pd, r, i, n, s, a, !0, u || "", !1), c(lg(o)), c(Zg(t1.id));
                        const e = document.querySelector(`#${Ld}`);
                        return e && e.remove(), Promise.resolve("");
                    }
                    return Promise.reject({
                        type: Zl,
                        reason: "You must use a <video> element to render self video for Chromium browser, Android browser without SharedArrayBuffer or iOS browser "
                    });
                }
                const A = !!u, { media: { videoDecodeStatus: C } } = m;
                return Iy("video", "success", C).subscribe(async (e)=>{
                    let [m, v] = e;
                    if (v) {
                        const { video: { ensuredCanvas: e, renderedVideoList: m } } = l();
                        let v = t1;
                        e.includes(t1.id) || (v = wy(t1), c(Bg(t1.id)));
                        const f = o === g, [y, b] = dw(o, a, l()), E = d || Pd, I = await async function(e, t1) {
                            const { video: { prefetchedVideo: o } } = t1;
                            return (null == o ? void 0 : o.userId) !== e || o.loaded ? "" : Oe(rt(np(Mu, 1), Ze(1e3).pipe(at(""))));
                        }(o, l());
                        m.some((e)=>e.userId === o && e.key === E && e.canvasId === v.id) || p.renderVideo(v, o, E, r, i, n, s, b, f, u || "", A), o !== g && h.subscribeVideo(o, b, !1), S.includes(o) || c(lg(o)), I && c(Hg(void 0)), c(mg({
                            userId: o,
                            key: E,
                            canvasId: v.id,
                            videoQuality: y,
                            aspectRatio: i ? r / i : 0
                        }));
                    }
                }), "failed" === C ? Promise.reject({
                    type: zl,
                    reason: "Video  decode status is failed"
                }) : Promise.resolve("");
            })(this[nT], e, t1, o, r, i, n, s, a, d);
        }
        stopRenderVideo(e, t1, o, r) {
            let i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = arguments.length > 5 ? arguments[5] : void 0;
            return function(e, t1, o, r, i) {
                let n = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], s = arguments.length > 6 ? arguments[6] : void 0;
                const { store: { getState: a, dispatch: d }, mediaAgent: u, rwgAgent: l } = e, c = a(), { video: { subscribedVideoList: p, renderedVideoList: h }, meeting: { userId: m }, media: { enforceVirtualBackground: g } } = c;
                if (p.includes(o)) {
                    const e = r || Pd;
                    if (aw(g) && o === m && t1 instanceof HTMLVideoElement) return t1.pause(), d(cg(o)), d(Yg(t1.id)), Promise.resolve("");
                    if (h.find((r)=>r.userId === o && r.key === e && r.canvasId === t1.id) && (u.stopRenderVideo(t1.id, o, e, YR(i), n), 1 == h.filter((e)=>e.userId === o).length && (o !== m && l.unsubscribeVideo(o), d(cg(o))), d(gg({
                        userId: o,
                        key: e,
                        canvasId: t1.id
                    }))), s && m !== s) {
                        const { video: { subscribedVideoList: e, prefetchedVideo: t1 } } = a();
                        QD(c).find((e)=>e.userId === s) && !e.includes(s) && (null == t1 ? void 0 : t1.userId) !== s && d(Hg({
                            userId: s,
                            lastCopy: t1
                        }));
                    }
                }
                return Promise.resolve("");
            }(this[nT], e, t1, o, r, i, n);
        }
        updateVideoCanvasDimension(e, t1, o) {
            return ((e, t1, o, r)=>{
                const { mediaAgent: i } = e;
                return o >= 0 && r >= 0 && i.updateRenderedVideoCanvasDimension(t1, o, r), Promise.resolve("");
            })(this[nT], e, t1, o);
        }
        adjustRenderedVideoPosition(e, t1, o, r, i, n, s) {
            return ((e, t1, o, r, i, n, s, a)=>{
                const { store: { getState: d, dispatch: u }, mediaAgent: l } = e, { video: { subscribedVideoList: c } } = d();
                if (c.includes(o)) {
                    if (t1 instanceof HTMLVideoElement) return Promise.resolve("");
                    const e = a || Pd;
                    l.adjustRenderedVideoPosition(t1.id, o, e, n, s, r, i, YR("#000")), u(mg({
                        userId: o,
                        key: e,
                        canvasId: t1.id,
                        aspectRatio: i ? r / i : 0
                    }));
                } else console.warn("Cannot adjust the size or position of the video as the video has not been rendered yet.");
                return Promise.resolve("");
            })(this[nT], e, t1, o, r, i, n, s);
        }
        clearVideoCanvas(e, t1) {
            return ((e, t1, o)=>{
                const { mediaAgent: r } = e;
                return r.clearVideoCanvas(t1.id, YR(o)), Promise.resolve("");
            })(this[nT], e, t1);
        }
        mirrorVideo(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { media: { enforceVirtualBackground: n }, video: { isCurrentUserStartedVideo: s, virtualBackground: a, selfPreviewVideoList: d, customizedVideoOption: u, videoAttachments: l, isMirrored: c }, meeting: { userId: p } } = o();
                if (c === t1) return Promise.resolve("");
                if (s || null != a && a.isVBConfigured) {
                    if (aw(n)) {
                        const e = [];
                        d.length > 0 && d.forEach((t1)=>{
                            e.push(document.getElementById(t1));
                        }), null != u && u.videoElement && e.push(document.querySelector(null == u ? void 0 : u.videoElement)), l && l[`${p}`] && l[`${p}`].forEach((t1)=>{
                            var o;
                            e.push(null == t1 || null === (o = t1.render) || void 0 === o ? void 0 : o.el);
                        }), e.filter((e)=>!!e).forEach((e)=>{
                            e && tw(e, t1);
                        });
                    } else i.mirrorVideo(t1);
                    r(Qg(t1));
                }
                return Promise.resolve("");
            })(this[nT], e);
        }
        enableHardwareAcceleration(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { video: { isSupportHDVideo: n } } = o();
                if ("boolean" == typeof t1 || void 0 !== t1.decode) {
                    const e = "boolean" == typeof t1 ? t1 : !!t1.decode;
                    return e ? ca.isSupportVideoDecodeHardwareAcceleration().then((e)=>(e && i.enableHardwareAccelerationForVideoDecode(e), r(Cg({
                            decode: e
                        })), e)) : (i.enableHardwareAccelerationForVideoDecode(e), r(Cg({
                        decode: e
                    })), Promise.resolve(!0));
                }
                if ("boolean" == typeof t1 || void 0 !== t1.encode) {
                    const e = "boolean" == typeof t1 ? t1 : !!t1.encode;
                    if (n) {
                        if (!e) return i.enableHardwareAccelerationForVideoEncode(!1), r(Cg({
                            encode: !1
                        })), Promise.resolve(!0);
                        if (ca.isCompatibleHardwareForEncode()) return ca.isSupportVideoEncodeHardwareAcceleration().then((e)=>(e && i.enableHardwareAccelerationForVideoEncode(e), r(Cg({
                                encode: e
                            })), e));
                        console.warn("Can not turn on hardware acceleration with your graphic card due to the technical limitation");
                    } else "boolean" != typeof t1 && null != t1 && t1.encode && console.warn("Can not use the hardware acceleration for video encoding due to the account restriction");
                }
                return Promise.resolve(!1);
            })(this[nT], e);
        }
        subscribeVideoStatisticData(e) {
            return (async (e, t1)=>{
                const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { media: { videoDecodeStatus: n, videoEncodeStatus: s }, video: { subscriptionStatus: a } } = r(), d = !t1 || t1.decode, u = !t1 || t1.encode;
                return Iy("video", s, n).subscribe((e)=>{
                    let [r, n] = e;
                    const s = {};
                    d && n && !a.decode && (o.subscribeToQos([
                        ua.VideoDecode
                    ], Od), Object.assign(s, {
                        decode: !0
                    })), u && r && !a.encode && (o.subscribeToQos([
                        ua.VideoEncode
                    ], Od), Object.assign(s, {
                        encode: !0
                    })), null != t1 && t1.detailed && n && !a.detailed && (o.enableVideoObserver(!0), Object.assign(s, {
                        detailed: !0
                    })), i($g(s));
                }), null;
            })(this[nT], e);
        }
        unsubscribeVideoStatisticData(e) {
            return (async (e, t1)=>{
                const { mediaAgent: o, store: { dispatch: r } } = e, i = !t1 || t1.decode, n = !t1 || t1.encode, s = {};
                return i && (o.unsubscribeFromQos([
                    ua.VideoDecode
                ]), r(Ig(Vd)), Object.assign(s, {
                    decode: !1
                })), n && (o.unsubscribeFromQos([
                    ua.VideoEncode
                ]), r(Ag(Vd)), Object.assign(s, {
                    encode: !1
                })), null != t1 && t1.detailed && (o.enableVideoObserver(!1), Object.assign(s, {
                    detailed: !1
                })), r($g(s)), null;
            })(this[nT], e);
        }
        previewVirtualBackground(e, t1, o, r) {
            return ((e, t1, o, r, i)=>{
                const { store: { getState: n, dispatch: s }, mediaAgent: a } = e, d = n();
                return yw({
                    imageUrl: o,
                    cropped: r,
                    cameraId: i
                }, a, d, t1).then((e)=>("object" == typeof e && null != e && e.type && s(e), s(Eg({
                        imageUrl: o,
                        cropped: r
                    })), !0)).catch((e)=>Promise.reject({
                        type: Kl,
                        reason: e
                    }));
            })(this[nT], e, t1, o, r);
        }
        updateVirtualBackgroundImage(e, t1) {
            return ((e, t1, o)=>{
                const { store: { getState: r, dispatch: i }, mediaAgent: n } = e, s = r(), { video: { virtualBackground: { imageSrc: a, cropped: d }, backgroundMode: u } } = s;
                return t1 === a && o === d ? Promise.resolve(!0) : u === $d.Mask ? Promise.reject({
                    type: Kl,
                    reason: "Cannot update virtual background in the mask mode"
                }) : yw({
                    imageUrl: t1,
                    cropped: o
                }, n, s).then((e)=>("object" == typeof e && null != e && e.type && i(e), i(Eg({
                        imageUrl: t1,
                        cropped: o
                    })), !0)).catch((e)=>Promise.reject({
                        type: Kl,
                        reason: e
                    }));
            })(this[nT], e, t1);
        }
        stopPreviewVirtualBackground() {
            return ((e)=>{
                const { store: { getState: t1 }, mediaAgent: o } = e, { video: { virtualBackground: { isVBConfigured: r } } } = t1();
                return r ? (o.stopVirtualBackgroundSetting(), Promise.resolve(!0)) : Promise.reject({
                    type: Kl,
                    reason: "Cannot stop preview virtual background before start"
                });
            })(this[nT]);
        }
        previewVideoMask(e, t1) {
            return ((e, t1, o)=>{
                const { store: { getState: r, dispatch: i }, mediaAgent: n } = e, s = r();
                return o.rootWidth && o.rootHeight || Object.assign(o, {
                    rootWidth: t1.width,
                    rootHeight: t1.height
                }), Sw(o, n, s, t1).then((e)=>("object" == typeof e && null != e && e.type && i(e), i(jg(o)), !0)).catch((e)=>Promise.reject({
                        type: Kl,
                        reason: e
                    }));
            })(this[nT], e, t1);
        }
        updateVideoMask(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { video: { mask: s, backgroundMode: a } } = n, { isMaskConfigured: d } = s;
                if (a === $d.VirtualBackground) return Promise.reject({
                    type: Kl,
                    reason: "Cannot update mask in the virtual background mode"
                });
                if (d) {
                    const e = {
                        ...t1
                    };
                    return [
                        "imageUrl",
                        "cropped",
                        "clip",
                        "rootHeight",
                        "rootWidth"
                    ].forEach((o)=>{
                        void 0 === (null == t1 ? void 0 : t1[o]) && ("imageUrl" === o ? Object.assign(e, {
                            imageUrl: s.imageSrc
                        }) : Object.assign(e, {
                            [`${o}`]: s[o]
                        }));
                    }), Sw(e, i, n).then((t1)=>("object" == typeof t1 && null != t1 && t1.type && r(t1), r(jg(e)), !0)).catch((e)=>Promise.reject({
                            type: Kl,
                            reason: e
                        }));
                }
                return Promise.reject({
                    type: Kl,
                    reason: "Cannot update mask"
                });
            })(this[nT], e);
        }
        stopPreviewVideoMask() {
            return ((e)=>{
                const { store: { getState: t1 }, mediaAgent: o } = e, { video: { mask: { isMaskConfigured: r } } } = t1();
                return r ? (o.stopMaskSetting(), Promise.resolve(!0)) : Promise.reject({
                    type: Kl,
                    reason: "Cannot stop preview mask before start"
                });
            })(this[nT]);
        }
        requestFarEndCameraControl(e) {
            return ((e, t1)=>{
                const { store: { getState: o }, rwgAgent: r } = e, i = o(), { meeting: { userId: n }, video: { farEndCameraControlStatus: { controlledUserList: s } } } = i;
                return n === t1 ? Promise.reject({
                    type: Kl,
                    reason: 'Using "stream.controlCamera" method to control self camera'
                }) : -1 !== ZD(i).findIndex((e)=>e.userId === t1) ? (s.includes(t1) || r.sendFarEndCameraControl(Ud.Request, t1), Promise.resolve("")) : Promise.reject({
                    type: Zl,
                    reason: "Cannot request control camera with video off"
                });
            })(this[nT], e);
        }
        approveFarEndCameraControl(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, { video: { currentCameraControlStatus: { isRequested: n, isInControl: s, controllingUserId: a }, ptz: d, activeCamera: u } } = o();
                if (n) {
                    if (s && (!a || t1 === a)) return Promise.resolve("");
                    i.sendFarEndCameraControl(Ud.Approve, t1);
                    const e = null == d ? void 0 : d[u];
                    return void 0 !== e && i.sendCameraAblity({
                        pan: !!e.pan,
                        tilt: !!e.tilt,
                        zoom: !!e.zoom
                    }), r(Tg(!1)), r(Og({
                        isInControl: !0,
                        userId: t1
                    })), tp(Tu, {
                        isControlled: !0,
                        userId: t1
                    }), Promise.resolve("");
                }
                return Promise.reject({
                    type: Kl,
                    reason: "Cannot approve before request"
                });
            })(this[nT], e);
        }
        declineFarEndCameraControl(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, { video: { currentCameraControlStatus: { isInControl: n, isRequested: s } } } = o();
                return s || n ? (i.sendFarEndCameraControl(Ud.Decline, t1), r(Tg(!1)), r(Og({
                    isInControl: !1,
                    userId: 0
                })), tp(Tu, {
                    isControlled: !1
                }), Promise.resolve("")) : Promise.reject({
                    type: Kl,
                    reason: "Cannot decline before request"
                });
            })(this[nT], e);
        }
        giveUpFarEndCameraControl(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, { video: { farEndCameraControlStatus: { controlledUserList: n } } } = o();
                return n.includes(t1) ? (i.sendFarEndCameraControl(Ud.GiveUp, t1), r(Pg(t1)), Promise.resolve("")) : Promise.reject({
                    type: Kl,
                    reason: "Cannot give up control befire aquired"
                });
            })(this[nT], e);
        }
        controlCamera(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, { video: { isCurrentUserStartedVideo: n, ptz: s, activeCamera: a } } = o();
                if (n) {
                    const { cmd: e, range: o, reset: n } = t1, d = s[a];
                    if (d) {
                        const t1 = nw(d) || {}, { key: s, range: u } = iw(e, o);
                        if (d[s]) return Object.assign(t1, {
                            [s]: n ? 0 : rw(d[s].capability, d[s].value, u)
                        }), i.movePTZCamera(t1).then(()=>{
                            r(kg({
                                constraints: t1,
                                deviceId: a
                            }));
                        }).catch((e)=>Promise.reject({
                                type: Kl,
                                reason: e
                            }));
                    }
                    return Promise.resolve("");
                }
                return Promise.reject({
                    type: Kl,
                    reason: "Cannot control the camera before it's started"
                });
            })(this[nT], e);
        }
        controlFarEndCamera(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, n = o(), { video: { farEndCameraControlStatus: { controlledUserList: s, isControlling: a } } } = n, { userId: d, cmd: u, range: l } = t1;
                if (a) return Promise.reject({
                    type: Kl,
                    reason: "Cannot send new command while the previous control is not done"
                });
                if (s.includes(d)) {
                    if (u === jd.SwitchCamera) return i.sendFarEndCameraControl(Ud.SwitchCamera, d, jd.SwitchCamera), Promise.resolve("");
                    {
                        const e = ZD(n).find((e)=>e.userId === d);
                        if (null == e || !e.nFECC) return Promise.reject({
                            type: Kl,
                            reason: "The far end camera does not support PTZ"
                        });
                        if (l && l > 0) {
                            const e = l / 100 * 1e4;
                            return i.sendFarEndCameraControl(Ud.StartControl, d, u), r(Lg(!0)), Ye(200).pipe(mt(Ze(e - 100).pipe(nt(1)))).subscribe(()=>{
                                i.sendFarEndCameraControl(Ud.ContinueControl, d, u);
                            }), Oe(Ze(e).pipe(vt(()=>{
                                i.sendFarEndCameraControl(Ud.StopControl, d, u), r(Lg(!1));
                            }))).then(()=>"");
                        }
                        return Promise.reject({
                            type: Zl,
                            reason: "Range cannot be negative or 0"
                        });
                    }
                }
                return Promise.reject({
                    type: Kl,
                    reason: "Cannot control before request granted"
                });
            })(this[nT], e);
        }
        attachVideo(e, t1, o) {
            return ((e, t1, o, r)=>{
                const { store: { getState: i, dispatch: n }, rwgAgent: s } = e, a = i(), { meeting: { userId: d }, media: { enforceMultipleVideos: u, alternativeNameForVideoPlayer: l, enforceVirtualBackground: c, disableRenderLimits: p }, video: { videoAttachments: h, subscribedVideoList: m } } = a, g = Ss(!!u, p);
                if (g > 1 && m.length > g) throw Promise.reject({
                    type: Kl,
                    reason: `subscribe video counts greater than maximum size (${g})`
                });
                if (-1 === QD(a).findIndex((e)=>e.userId === t1)) return Promise.reject({
                    type: Zl,
                    reason: "user is not send video"
                });
                const { media: { videoDecodeStatus: v } } = a;
                let f;
                const y = null != l ? l : "video-player";
                if (r) {
                    var S, b;
                    if ("string" == typeof r) {
                        if (f = document.querySelector(r), !f) return Promise.reject({
                            type: "INVALID_PARAMETERS",
                            reason: "Cannot find the element"
                        });
                    } else f = r;
                    if ((null === (S = f) || void 0 === S || null === (S = S.tagName) || void 0 === S ? void 0 : S.toUpperCase()) !== y.toUpperCase()) return Promise.reject({
                        type: "INVALID_PARAMETERS",
                        reason: "Invalid element type"
                    });
                    const e = Number(null !== (b = f.getAttribute("node-id")) && void 0 !== b ? b : "0");
                    if (e !== t1 && aw(c) && [
                        e,
                        t1
                    ].includes(d)) {
                        var E;
                        const t1 = document.createElement(y);
                        for (const e of f.attributes)t1.setAttribute(e.name, e.value);
                        e && (f.setAttribute("node-id", "0"), n(Kg({
                            userId: e,
                            element: f
                        }))), null === (E = f.parentElement) || void 0 === E || E.replaceChild(t1, f), f = t1;
                    }
                } else f = document.createElement(y);
                return Iy("video", "success", v).subscribe(async (e)=>{
                    let [r, a] = e;
                    if (a) {
                        const [e, r] = dw(t1, o, i()), a = h[`${t1}`];
                        var u;
                        f && a && -1 !== a.findIndex((e)=>e === f) ? f.setAttribute("video-quality", `${r}`) : null === (u = f) || void 0 === u || u.setAttribute("node-id", `${t1}`), n(Gg({
                            userId: t1,
                            element: f
                        })), t1 !== d && s.subscribeVideo(t1, r, !1), m.includes(t1) || n(lg(t1)), n(mg({
                            userId: t1,
                            key: Pd,
                            canvasId: kd,
                            videoQuality: e,
                            aspectRatio: 16 / 9
                        }));
                    }
                }), Promise.resolve(f);
            })(this[nT], e, t1, o);
        }
        detachVideo(e, t1) {
            return ((e, t1, o)=>{
                const { store: { getState: r, dispatch: i }, rwgAgent: n } = e, s = r(), { video: { subscribedVideoList: a, videoAttachments: d }, meeting: { userId: u }, media: { alternativeNameForVideoPlayer: l } } = s;
                if (a.includes(t1)) {
                    let e;
                    const s = null != l ? l : "video-player";
                    var c;
                    o && (e = "string" == typeof o ? document.querySelector(o) : o, (null === (c = e) || void 0 === c || null === (c = c.tagName) || void 0 === c ? void 0 : c.toUpperCase()) !== s.toUpperCase() && (e = void 0));
                    const a = d[`${t1}`];
                    let h;
                    if (a && 0 !== a.length) {
                        var p;
                        e ? -1 !== a.findIndex((t1)=>t1 === e) ? (h = e, h.setAttribute("node-id", "0"), i(Kg({
                            userId: t1,
                            element: h
                        }))) : console.warn(`${o} has not been attached with userID:${t1}`) : (h = [
                            ...a
                        ], h.forEach((e)=>{
                            e.setAttribute("node-id", "0");
                        }), i(Kg({
                            userId: t1,
                            element: h
                        })));
                        const { video: { videoAttachments: s, renderedVideoList: d } } = r();
                        0 === (null === (p = s[`${t1}`]) || void 0 === p ? void 0 : p.length) && (0 === d.filter((e)=>e.userId === t1 && e.canvasId !== kd).length && (t1 !== u && n.unsubscribeVideo(t1), i(cg(t1))), i(gg({
                            userId: t1,
                            key: Pd,
                            canvasId: kd
                        })));
                    } else console.warn(`UserId:${t1} has not been attached.`);
                    return Promise.resolve(h);
                }
                return Promise.resolve(void 0);
            })(this[nT], e, t1);
        }
        spotlight(e, t1) {
            return ((e, t1, o)=>{
                const { store: { getState: r }, rwgAgent: i } = e, n = r(), { video: { spotlightUserList: s } } = n;
                return s.includes(t1) ? Promise.reject({
                    type: Zl,
                    reason: `userId:${t1} has already spotlighted`
                }) : -1 === QD(n).findIndex((e)=>e.userId === t1) ? Promise.reject({
                    type: Zl,
                    reason: `userId:${t1} has not started video`
                }) : (i.spotlightVideo(t1, {
                    bReplace: o,
                    bSpotlight: !0,
                    bUnSpotlightAll: !1
                }), ip(vu, (e)=>{
                    const { spotlightList: o } = e;
                    return o.includes(t1);
                }));
            })(this[nT], e, t1);
        }
        removeSpotlight(e) {
            return ((e, t1)=>{
                const { store: { getState: o }, rwgAgent: r } = e, i = o(), { meeting: { userId: n }, video: { spotlightUserList: s } } = i, a = t1 || n, d = ph(i);
                if (!s.includes(a) || -1 === d.findIndex((e)=>e.userId === a)) return Promise.reject({
                    type: Zl,
                    reason: `userId:${t1} is not spotlighted`
                });
                const u = dh(i);
                if (s.length > 1 && a === n && !u) return Promise.reject({
                    type: Kl,
                    reason: "Cannot remove spotlight for self when the host has multiple spotlighted videos"
                });
                if (a !== n && !u) return Promise.reject({
                    type: Jl,
                    reason: "only host or co-host can cancel others spotlight"
                });
                r.spotlightVideo(a, {
                    bReplace: !1,
                    bSpotlight: !1,
                    bUnSpotlightAll: !1
                });
                const l = a === n && 1 === s.length ? Nu : vu;
                return ip(l, (e)=>{
                    const { spotlightList: t1 } = e;
                    return !t1.includes(a);
                });
            })(this[nT], e);
        }
        removeAllSpotlights() {
            return ((e)=>{
                const { store: { getState: t1 }, rwgAgent: o } = e, { video: { spotlightUserList: r } } = t1();
                return 0 === r.length ? Promise.resolve("") : (o.spotlightVideo(null, {
                    bUnSpotlightAll: !0
                }), ip(vu, (e)=>{
                    const { spotlightList: t1 } = e;
                    return 0 === t1.length;
                }));
            })(this[nT]);
        }
        isCapturingVideo() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.video && o.video.isCurrentUserStartedVideo;
            })(this[nT]);
        }
        isCameraTaken() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.video && o.video.isCameraTaken;
            })(this[nT]);
        }
        isCaptureForbidden() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.video && o.video.isCaptureForbidden;
            })(this[nT]);
        }
        getCameraList() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                if (!o.video) return [];
                const { video: { cameraDevicesList: r } } = o;
                return r.map((e)=>Object.assign({}, e));
            })(this[nT]);
        }
        getActiveCamera() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.video ? o.video.activeCamera : "";
            })(this[nT]);
        }
        getActiveVideoId() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.video ? o.video.activeVideoId : 0;
            })(this[nT]);
        }
        getVideoMaxQuality() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.video ? o.video.receivedVideoMaxQuality : Sd.Video_90P;
            })(this[nT]);
        }
        getReceivedVideoDimension() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.video ? o.video.receivedVideoDimension : null;
            })(this[nT]);
        }
        getCapturedVideoResolution() {
            return ((e)=>{
                const { store: { getState: t1 } } = e;
                return {
                    ...t1().video.capturedVideoDimension
                };
            })(this[nT]);
        }
        isSupportMultipleVideos() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, { media: { enforceMultipleVideos: o } } = t1();
                return ys() || !!o && !gs.isSupportSharedArrayBuffer && Ss(o) > 1;
            })(this[nT]);
        }
        isSupportHDVideo() {
            return ((e)=>{
                var t1;
                const { store: { getState: o } } = e;
                return null === (t1 = o().video) || void 0 === t1 ? void 0 : t1.isSupportHDVideo;
            })(this[nT]);
        }
        getHardwareAccelerationStatus() {
            return ((e)=>{
                var t1;
                const { store: { getState: o } } = e;
                return null === (t1 = o().video) || void 0 === t1 ? void 0 : t1.hardwareAcceleration;
            })(this[nT]);
        }
        getVideoStatisticData() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { video: { statistic: o } } = t1();
                return {
                    ...o
                };
            })(this[nT]);
        }
        isSupportVirtualBackground() {
            return ((e)=>{
                const { store: { getState: t1 } } = e;
                return My(t1().media.enforceVirtualBackground);
            })(this[nT]);
        }
        getVirtualbackgroundStatus() {
            return ((e)=>{
                const { store: { getState: t1 } } = e;
                return {
                    ...t1().video.virtualBackground
                };
            })(this[nT]);
        }
        isRenderSelfViewWithVideoElement() {
            return aw(this[tT].getState().media.enforceVirtualBackground);
        }
        getNetworkQuality(e) {
            return ((e, t1)=>{
                var o;
                const { store: { getState: r } } = e, i = r(), { video: n, meeting: { userId: s } } = i, a = null != t1 ? t1 : s, d = null == n || null === (o = n.networkQuality) || void 0 === o ? void 0 : o[`${a}`];
                if (d) {
                    const e = {};
                    return d.uplink && Object.assign(e, {
                        uplink: d.uplink.level
                    }), d.downlink && Object.assign(e, {
                        downlink: d.downlink.level
                    }), e;
                }
                return null;
            })(this[nT], e);
        }
        getFarEndCameraPTZCapability(e) {
            return ((e, t1)=>{
                const { store: { getState: o } } = e, r = ZD(o()).find((e)=>e.userId === t1);
                return void 0 !== (null == r ? void 0 : r.nFECC) ? sw(null == r ? void 0 : r.nFECC) : {
                    pan: !1,
                    tilt: !1,
                    zoom: !1
                };
            })(this[nT], e);
        }
        getCameraPTZCapability(e) {
            return ((e, t1)=>{
                const { store: { getState: o } } = e, { video: { ptz: r, activeCamera: i } } = o(), n = r[null != t1 ? t1 : i];
                return {
                    pan: !(null == n || !n.pan),
                    tilt: !(null == n || !n.tilt),
                    zoom: !(null == n || !n.zoom)
                };
            })(this[nT], e);
        }
        isBrowserSupportPTZ() {
            const { pan: e, tilt: t1, zoom: o } = ca.getPTZCapability();
            return e || t1 || o;
        }
        getVideoMaskStatus() {
            return ((e)=>{
                var t1;
                const { store: { getState: o } } = e, r = o(), { isMaskConfigured: i, imageSrc: n, ...s } = (null === (t1 = r.video) || void 0 === t1 ? void 0 : t1.mask) || {};
                return {
                    ...s,
                    imageUrl: n
                };
            })(this[nT]);
        }
        isVideoMirrored() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, { video: { isMirrored: o } } = t1();
                return o;
            })(this[nT]);
        }
        getSpotlightedUserList() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                if (!o.video) return [];
                const { video: { spotlightUserList: r } } = o;
                return ph(o).filter((e)=>r.includes(e.userId)).map((e)=>yT(e));
            })(this[nT]);
        }
        getVideoMediaPlaybackController() {
            return ((e)=>{
                let { store: { getState: t1 }, mediaAgent: o } = e;
                const r = t1(), { video: { isUsingMediaPlayback: i } } = r;
                if (i) {
                    const { videoElement: e } = Wy.getInstance();
                    return Fy(e, "video", r, o);
                }
                return null;
            })(this[nT]);
        }
        startShareView(e, t1, o) {
            return ((e, t1, o, r)=>{
                const { store: { getState: i, dispatch: n }, mediaAgent: s, rwgAgent: a } = e, { share: { isReceiveSharing: d, isRemoteSharingActive: u, activeNodeId: l, activeSsrc: c, status: p, renderedEnsuredCanvas: h, isReceiveSharingFromMainSession: m }, media: { sharingDecodeStatus: g } } = i();
                if (!t1 || o !== l) return Promise.reject({
                    type: Zl,
                    reason: ""
                });
                if (!u || d || p !== yd.End) return Promise.reject({
                    type: Kl,
                    reason: ""
                });
                t1.id || (t1.id = ei("__ZOOM_SDK_SHARE_CANVAS_@__"));
                const v = !!r;
                return Iy("sharing", "success", g).subscribe((e)=>{
                    let [, d] = e;
                    if (d) {
                        let e = t1;
                        h.includes(t1.id) || (e = wy(t1), n(Lm(t1.id))), n(gm(!0)), EE(a, i(), o), s.renderSharing(c, e, v, r, m), DE(o, i(), s);
                    }
                }), "failed" === g ? Promise.reject({
                    type: zl,
                    reason: ""
                }) : ip(bl, (e)=>!!e, 6e4);
            })(this[nT], e, t1, o);
        }
        stopShareView() {
            return ((e)=>{
                const { store: { dispatch: t1, getState: o }, rwgAgent: r, mediaAgent: i } = e, { share: { isReceiveSharing: n, activeNodeId: s }, breakoutRoom: a } = o();
                if (!n) return Promise.resolve("");
                let d = !1;
                return (null == a ? void 0 : a.currentRoom.status) === Qp.InRoom && a.mainSessionAttendeeList.length > 0 && (d = a.mainSessionAttendeeList.findIndex((e)=>e.userId === s) > -1), i.stopRenderSharing(), r.unsubscribeSharing(s, d), t1(gm(!1)), Promise.resolve("");
            })(this[nT]);
        }
        switchShareView(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i, mediaAgent: n } = e, s = o(), { share: { isReceiveSharing: a, activeNodeId: d, isReceiveSharingFromMainSession: u, remoteControlledUserList: l, isGrabRemoteControl: c }, breakoutRoom: p } = s;
                if (!a) return Promise.reject({
                    type: Kl
                });
                if (t1 === d) return Promise.resolve("");
                let h = [];
                return h = u ? p.mainSessionAttendeeList.filter((e)=>e.bShareToBORooms && e.sharerOn) : uS(s), h.findIndex((e)=>e.userId === d) > -1 ? (l.includes(d) && (c && i.subscribeGrabRemoteControl(d, !1), n.updateRemoteControlProperties({
                    isControllerNow: !1
                })), i.unsubscribeSharing(d, u), EE(i, o(), t1), n.switchSharingSource(t1, u), l.includes(t1) && TE(t1, void 0, s, i, n), DE(t1, o(), n), r(mm({
                    bStatus: 1,
                    activeNodeID: t1,
                    ssrc: t1
                })), tp(Tl, {
                    userId: t1
                }), Promise.resolve("")) : Promise.reject({
                    type: Zl,
                    reason: "no matching user id"
                });
            })(this[nT], e);
        }
        updateSharingCanvasDimension(e, t1) {
            return ((e, t1, o)=>{
                const { store: { getState: r }, mediaAgent: i } = e, n = r(), { share: { isReceiveSharing: s, isGrabRemoteControl: a, remoteControlViewportDomSelector: d } } = n;
                if (s && (i.updateRenderedSharingDimension(t1, o), a && d)) {
                    const e = document.querySelector(d);
                    i.updateRemoteControlProperties({
                        dimension: e && Ry(e)
                    });
                }
                return Promise.resolve("");
            })(this[nT], e, t1);
        }
        startShareScreen(e, t1) {
            return ((e, t1, o)=>{
                var r;
                const { store: { getState: i, dispatch: n }, mediaAgent: s } = e, a = i(), { meeting: { bIbDisableShare: d, meetingOptions: u }, share: { sharePrivilege: l, ssrc: c, isChromeExtensionInstalled: p, capturedEnsuredCanvas: h, isReceiveSharingFromMainSession: m }, media: { sharingEncodeStatus: g }, breakoutRoom: v } = a, { isSupportMediaStreamTrackProcessor: f, isLegacyChrome: y } = gs;
                if (d) return Promise.reject({
                    type: Kl,
                    reason: "information barrier"
                });
                if ("function" != typeof (null === (r = navigator.mediaDevices) || void 0 === r ? void 0 : r.getDisplayMedia)) return Promise.reject({
                    type: Kl,
                    reason: "Unable to share your screen due to the technical limitation"
                });
                if (m) return Promise.reject({
                    type: Kl,
                    reason: "Unable to share your screen while someone is sharing from the main session"
                });
                var S;
                if (f) {
                    if (!(t1 instanceof HTMLVideoElement)) return Promise.reject({
                        type: Zl,
                        reason: "Use Video element instead of Canvas element when WebCodecs enabled"
                    });
                } else if (!(t1 instanceof HTMLCanvasElement)) return Promise.reject({
                    type: Zl,
                    reason: `Expected to accept HTMLCanvasElement, but actual it is ${"object" == typeof t1 && null !== t1 ? null === (S = Object.getPrototypeOf(t1)) || void 0 === S ? void 0 : S.constructor.name : t1}`
                });
                const b = dh(a);
                if (null != o && o.broadcastToBreakoutRoom) {
                    if (!b || (null == v ? void 0 : v.currentRoom.status) === Qp.InRoom) return b ? Promise.reject({
                        type: Kl,
                        reason: "Unable to share screen to breakout room when in the room"
                    }) : Promise.reject({
                        type: Jl
                    });
                    n(Rm(!0));
                } else n(Rm(!1));
                void 0 !== (null == o ? void 0 : o.requestReadReceipt) && n(Om(null == o ? void 0 : o.requestReadReceipt)), void 0 !== (null == o ? void 0 : o.optimizedForSharedVideo) && l !== fd.MultipleShare && n(Dm((null == o ? void 0 : o.optimizedForSharedVideo) && ca.isSupportVideoShareSend()));
                const E = uS(a);
                if (l === fd.OnlyHost && !b) return Promise.reject({
                    type: Jl,
                    reason: "only host can start screen share"
                });
                if (l === fd.HostGrab && !b && E.length > 0) return Promise.reject({
                    type: Jl,
                    reason: "only host can grab screen share"
                });
                const I = ah(a);
                if (!0 === (null == I ? void 0 : I.sharerOn)) return Promise.reject({
                    type: Kl,
                    reason: "you have already started screen share."
                });
                let A = Re(!0);
                return y && !p && (s.checkChromeSharingExtension(), A = np(fl, 1)), t1.id || (t1.id = ei("__ZOOM_SDK_SELF_SHARE_CANVAS_@__")), We([
                    Iy("sharing", g, "success"),
                    A
                ]).subscribe((e)=>{
                    let [r, i] = e;
                    const [a] = r;
                    if (a && i) {
                        h.includes(t1.id) || (wy(t1), n(km(t1.id)));
                        let e = document.querySelector(`#${Dd}`);
                        e && "VIDEO" === e.tagName || (e = document.createElement("video"), e.id = Dd, e.style.display = "none", document.body.appendChild(e));
                        const r = null != o && o.secondaryCameraId ? {
                            cameraId: o.secondaryCameraId,
                            width: o.captureWidth,
                            height: o.captureHeight
                        } : void 0, i = !(null != o && o.hideShareAudioOption);
                        s.startDesktopSharing(c, t1, e, r, null != u && u.isDisableShareAudioIntoBo ? i && !(null != o && o.broadcastToBreakoutRoom) : i, null == o ? void 0 : o.displaySurface, null == o ? void 0 : o.sourceId, null == o ? void 0 : o.controls), n(lm(void 0)), n(wm(!!r));
                    }
                }), new Promise((e, t1)=>{
                    rt(np(ha).pipe(ot((e)=>void 0 !== e.sharerOn), nt(1)), np(fl).pipe(ot((e)=>!e), nt(1), ut(we({
                        reason: "required extension",
                        extensionUrl: "https://chrome.google.com/webstore/detail/zoom-scheduler/kgjfgplpablkjnlkjmjdecgdpfankdle"
                    }))), np(yl, 1).pipe(Fe((e)=>we({
                            reason: e.reason || "user deny screen share"
                        })))).subscribe((o)=>{
                        if (!0 === o.sharerOn) {
                            const { share: { isSharingToBreakoutRoom: t1 }, meeting: { meetingOptions: o } } = i(), r = !(null != o && o.isDisableShareAudioIntoBo || !t1);
                            s.enableShareAudioToBreakoutRoom(r), e("");
                        } else t1({
                            type: zl
                        });
                    }, (e)=>{
                        t1({
                            type: Kl,
                            ...e
                        });
                    });
                });
            })(this[nT], e, t1);
        }
        stopShareScreen() {
            return ((e)=>{
                const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, { share: { status: n }, meeting: { userId: s } } = t1();
                return n === yd.End ? Promise.resolve("") : (o(Sm(yd.End)), r.stopSharing(s), i.stopDesktopSharing(), ip(ha, (e)=>!1 === e.sharerOn));
            })(this[nT]);
        }
        pauseShareScreen() {
            return ((e)=>{
                const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, n = t1(), { share: { status: s }, breakoutRoom: a } = n;
                if (s === yd.Sharing) {
                    if (r.pauseSharing(), i.pauseDesktopSharing(), a && AT(n)) {
                        const e = ah(n);
                        return Promise.resolve("").then(()=>{
                            if (e) {
                                const { userId: t1, sharerOn: r, bShareAudioOn: i, bVideoShare: n } = e, s = {
                                    userId: t1,
                                    sharerOn: r,
                                    sharerPause: !0,
                                    bShareAudioOn: i,
                                    bVideoShare: n
                                };
                                o(bp({
                                    update: [
                                        s
                                    ]
                                })), o(Sm(yd.Paused)), tp(ha, s);
                            }
                        });
                    }
                    return ip(ha, (e)=>!0 === e.sharerPause).then(()=>(o(Sm(yd.Paused)), ""));
                }
                return Promise.reject({
                    type: Kl
                });
            })(this[nT]);
        }
        resumeShareScreen() {
            return ((e)=>{
                const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, n = t1(), { share: { status: s }, breakoutRoom: a } = n;
                if (s === yd.Paused) {
                    if (r.resumeSharing(), i.resumeDesktopSharing(), a && AT(n)) {
                        const e = ah(n);
                        return Promise.resolve("").then(()=>{
                            if (e) {
                                const { userId: t1, sharerOn: r, bShareAudioOn: i, bVideoShare: n } = e, s = {
                                    userId: t1,
                                    sharerOn: r,
                                    sharerPause: !1,
                                    bShareAudioOn: i,
                                    bVideoShare: n
                                };
                                o(bp({
                                    update: [
                                        s
                                    ]
                                })), o(Sm(yd.Sharing)), tp(ha, s);
                            }
                        });
                    }
                    return ip(ha, (e)=>!0 === e.sharerOn && !1 === e.sharerPause).then(()=>(o(Sm(yd.Sharing)), ""));
                }
                return Promise.reject({
                    type: Kl
                });
            })(this[nT]);
        }
        setSharePrivilege(e) {
            return JD(this[nT], e);
        }
        lockShare(e) {
            return ((e, t1)=>JD(e, t1 ? fd.OnlyHost : fd.HostGrab))(this[nT], e);
        }
        shareToBreakoutRoom() {
            return ((e)=>{
                const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, { meeting: { userId: n }, breakoutRoom: s, share: { isSharingToBreakoutRoom: a, status: d } } = t1();
                return d === yd.End ? Promise.reject({
                    type: Kl,
                    reason: "Invalid sharing status"
                }) : a ? Promise.resolve("") : s.currentRoom.status === Qp.InRoom ? Promise.reject({
                    type: Kl,
                    reason: "Unable to share screen to breakout room when in the room"
                }) : (r.startShareToBreakoutRoom(n), o(Rm(!0)), i.enableShareAudioToBreakoutRoom(!0), Promise.resolve(""));
            })(this[nT]);
        }
        stopShareToBreakoutRoom() {
            return ((e)=>{
                const { store: { getState: t1, dispatch: o }, rwgAgent: r, mediaAgent: i } = e, { meeting: { userId: n }, share: { isSharingToBreakoutRoom: s } } = t1();
                return s && (r.stopShareToBreakoutRoom(n), o(Rm(!1)), i.enableShareAudioToBreakoutRoom(!1)), Promise.resolve("");
            })(this[nT]);
        }
        muteOthersScreenShare(e) {
            return ((e, t1)=>{
                const { store: { getState: o }, rwgAgent: r } = e, i = o(), { meeting: { userId: n } } = i, s = uS(i);
                return t1 === n ? Promise.reject({
                    type: Kl,
                    reason: "Cannot mute self share, use 'stopScreenShare' instead"
                }) : -1 === s.findIndex((e)=>e.userId === t1) ? Promise.reject({
                    type: Zl,
                    reason: "Target user is not sharing"
                }) : (r.stopSharing(t1), ip(ga, (e)=>e.some((e)=>e.userId === t1 && !1 === e.sharerOn)));
            })(this[nT], e);
        }
        enableOptimizeForSharedVideo(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i, rwgAgent: n } = e, { share: { status: s, isOptimizedForSharedVideo: a, isSharingToBreakoutRoom: d, sharePrivilege: u }, audio: { isSharingAudio: l }, meeting: { userId: c } } = o();
                return s !== yd.End ? a === t1 ? Promise.resolve("") : u !== fd.MultipleShare ? t1 && !ca.isSupportVideoShareSend() ? Promise.reject({
                    type: Kl,
                    reason: "Cannot enable optimize for shared video due to the platform is not supported "
                }) : (n.startSharing(c, {
                    bShareAudio: l,
                    bShareToBO: d,
                    bShareVideo: t1
                }), i.switchSharingMode(t1 ? Hd.VideoMode : Hd.Normal), ip({
                    event: ha,
                    operations: [
                        ot((e)=>void 0 !== e.bVideoShare),
                        nt(1)
                    ]
                }, (e)=>e.bVideoShare === t1).then(()=>(r(Dm(t1)), ""))) : Promise.reject({
                    type: Kl,
                    reason: "Cannot enable optimize for shared video when enabling multiple screen shares"
                }) : Promise.reject({
                    type: Kl,
                    reason: "Cannot enable optimize for shared video when screen share is not started"
                });
            })(this[nT], e);
        }
        updateSharedVideoQuality(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, rwgAgent: i } = e, n = o(), { share: { shareQuality: s, activeNodeId: a, isReceiveSharing: d } } = n, u = lS(n);
                return d && 0 !== a ? (u && s !== t1 && (EE(i, n, a, t1), r(Em(t1))), Promise.resolve("")) : Promise.reject({
                    type: Kl,
                    reason: "Cannot update shared video quality when screen share is not started"
                });
            })(this[nT], e);
        }
        subscribeShareStatisticData(e) {
            return (async (e, t1)=>{
                const { mediaAgent: o, store: { getState: r } } = e, i = r(), { media: { sharingEncodeStatus: n, sharingDecodeStatus: s } } = r(), a = ah(i), d = !t1 || t1.decode, u = !t1 || t1.encode;
                if (!a) return Promise.reject({
                    type: Kl,
                    reason: "Call this function after the 'join' method resolved."
                });
                {
                    const e = Kp(a.userRole) || !gs.isSupportSendScreenSharing ? "failed" : n;
                    Iy("sharing", e, s).subscribe((e)=>{
                        let [t1, r] = e;
                        d && r && o.subscribeToQos([
                            ua.SharingDecode
                        ], Od), u && t1 && o.subscribeToQos([
                            ua.SharingEncode
                        ], Od);
                    });
                }
                return "";
            })(this[nT], e);
        }
        unsubscribeShareStatisticData(e) {
            return (async (e, t1)=>{
                const { mediaAgent: o, store: { dispatch: r } } = e, i = !t1 || t1.decode, n = !t1 || t1.encode;
                return i && (o.unsubscribeFromQos([
                    ua.SharingDecode
                ]), r(Mm(Vd))), n && (o.unsubscribeFromQos([
                    ua.SharingEncode
                ]), r(Mm(Vd))), null;
            })(this[nT], e);
        }
        getShareUserList() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                if (!o.share) return [];
                const { share: { isReceiveSharingFromMainSession: r } } = o;
                if (r) {
                    const { breakoutRoom: { mainSessionAttendeeList: e } } = o;
                    return e.filter((e)=>e.bShareToBORooms && (e.sharerOn || e.sharerPause)).map((e)=>yT(e));
                }
                return uS(o).map((e)=>yT(e));
            })(this[nT]);
        }
        getActiveShareUserId() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.share && o.share.isRemoteSharingActive ? o.share.activeNodeId : 0;
            })(this[nT]);
        }
        isReceiveSharing() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.share && o.share.isReceiveSharing;
            })(this[nT]);
        }
        getShareViewDimension() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                if (o.share) {
                    if (o.share.status !== yd.End) return {
                        ...o.share.shareDimension
                    };
                    {
                        const { share: { receivedShareDimension: e } } = o;
                        return {
                            width: e.width,
                            height: e.height
                        };
                    }
                }
                return null;
            })(this[nT]);
        }
        getShareStatus() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.share ? o.share.status : null;
            })(this[nT]);
        }
        isShareLocked() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.share && o.share.sharePrivilege === fd.OnlyHost;
            })(this[nT]);
        }
        isReceiveSharingFromMainSession() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.share && o.share.isReceiveSharingFromMainSession;
            })(this[nT]);
        }
        getSharePrivilege() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.share ? o.share.sharePrivilege : null;
            })(this[nT]);
        }
        isStartShareScreenWithVideoElement() {
            return gs.isSupportMediaStreamTrackProcessor;
        }
        isOptimizeForSharedVideoEnabled() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.share && o.share.isOptimizedForSharedVideo;
            })(this[nT]);
        }
        isSupportOptimizedForSharedVideo() {
            return ca.isSupportVideoShareSend();
        }
        getShareStatisticData() {
            return ((e)=>{
                let { store: { getState: t1 } } = e;
                const { share: { statistic: o } } = t1();
                return {
                    ...o
                };
            })(this[nT]);
        }
        requestRemoteControl() {
            return ((e)=>{
                const { store: { getState: t1 }, rwgAgent: o } = e, { share: { isReceiveSharing: r, activeNodeId: i, isRemoteControlEnabled: n } } = t1();
                return n ? YD(e, i) ? r ? cS(t1()) ? Promise.reject({
                    type: Kl,
                    reason: "Already get the approval"
                }) : (o.sharingRequestRemoteControl(i, !0), new Promise((e)=>{
                    np(Ol, 1).subscribe((t1)=>{
                        e(t1);
                    });
                })) : Promise.reject({
                    type: Kl,
                    reason: "Cannot request control due to no sharing available"
                }) : Promise.reject({
                    type: Zl
                }) : Promise.reject({
                    type: Kl,
                    reason: "Cannot request control due to the feature is not enabled."
                });
            })(this[nT]);
        }
        giveUpRemoteControl() {
            return ((e)=>{
                const { store: { getState: t1 }, rwgAgent: o } = e, { share: { isGrabRemoteControl: r, activeNodeId: i } } = t1();
                return cS(t1()) ? (r && o.subscribeGrabRemoteControl(i, !1), o.sharingRequestRemoteControl(i, !1), ip(Ol, (e)=>!1 === e)) : Promise.reject({
                    type: Kl
                });
            })(this[nT]);
        }
        startRemoteControl(e) {
            return (async (e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i, rwgAgent: n } = e, { share: { isSDKGrabControl: s, activeNodeId: a } } = o();
                return cS(o()) ? (await TE(a, t1, o(), n, i), t1.dataset.zmrvId || t1.setAttribute("data-zmrv-id", ei("__ZOOM_SDK_RC_VIEWPORT_DATA_ID_@__")), r(qm(`${t1.tagName}[data-zmrv-id="${t1.dataset.zmrvId}"]`)), s ? ip(Dl, (e)=>!!e) : rp({
                    success: Ml,
                    fail: [
                        kl
                    ]
                })) : Promise.reject({
                    type: Kl,
                    reason: "required to be approved"
                });
            })(this[nT], e);
        }
        grabRemoteControl() {
            return ((e)=>{
                const { store: { getState: t1 }, rwgAgent: o } = e, { share: { isGrabRemoteControl: r, activeNodeId: i } } = t1();
                return cS(t1()) ? r ? Promise.resolve("") : (o.subscribeGrabRemoteControl(i, !0), ip(Dl, (e)=>!!e)) : Promise.reject({
                    type: Kl,
                    reason: "should be approved before grab"
                });
            })(this[nT]);
        }
        updateRemoteControlViewportDimension(e) {
            return ((e, t1)=>{
                const { store: { getState: o }, mediaAgent: r } = e;
                return cS(o()) && r.updateRemoteControlProperties({
                    dimension: {
                        scaleWidth: t1.width,
                        scaleHeight: t1.height,
                        srcOffsetX: t1.left,
                        srcOffsetY: t1.top
                    }
                }), Promise.resolve("");
            })(this[nT], e);
        }
        approveRemoteControl(e, t1) {
            return ((e, t1, o)=>{
                const { store: { getState: r, dispatch: i }, rwgAgent: n, mediaAgent: s } = e, a = r(), { share: { status: d, isEnableAutoDeleteRcApp: u, remoteControllingSsrc: l, userSsrcMapping: c }, meeting: { userId: p } } = a;
                if (d === yd.End) return Promise.reject({
                    type: Kl,
                    reason: "Cannot approve remote control when sharing is not ongoing."
                });
                if (d === yd.Paused && (n.resumeSharing(), s.resumeDesktopSharing(), i(Sm(yd.Sharing))), s.isSharingEntireScreen()) {
                    var h, m;
                    l && !Yr(l, t1) && (wE(a, n), i($m("")));
                    const e = null !== (h = c[`${t1}`]) && void 0 !== h ? h : t1, { isMacOS: r } = gs, d = null === (m = ph(a).find((t1)=>Yr(t1.userId, e))) || void 0 === m ? void 0 : m.displayName;
                    return n.remoteControlConsent(Gd.Approve, e, p, {
                        ...s.getShareStreamInfo(),
                        platform: gs.isMacOS ? "mac" : "win",
                        controllerName: d ? $r(d) : ""
                    }, u, r ? void 0 : o ? 1 : 0), i(Um(e)), ip(Bl);
                }
                return Promise.reject({
                    type: Kl,
                    reason: "Cannot approve remote control when not sharing entire screen."
                });
            })(this[nT], e, t1);
        }
        declineRemoteControl(e) {
            return ((e, t1)=>{
                var o;
                const { store: { getState: r }, rwgAgent: i, mediaAgent: n } = e, s = r(), { meeting: { userId: a }, share: { isEnableAutoDeleteRcApp: d, userSsrcMapping: u } } = s, l = null !== (o = u[`${t1}`]) && void 0 !== o ? o : t1;
                return i.remoteControlConsent(Gd.Decline, l, a, {
                    ...n.getShareStreamInfo(),
                    platform: gs.isMacOS ? "mac" : "win"
                }, d), Promise.resolve("");
            })(this[nT], e);
        }
        stopRemoteControl() {
            return ((e)=>{
                const { store: { getState: t1, dispatch: o }, rwgAgent: r } = e;
                return wE(t1(), r), o($m("")), o(Um(0)), Promise.resolve("");
            })(this[nT]);
        }
        launchRemoteControlApp(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r } } = e, i = o(), { share: { remoteControlAppLaunchSheme: n } } = i;
                return n ? (r($m(t1 ? `${n}&bAutoDelete=1` : n)), r(xm(Kd.Unknown)), Promise.resolve("")) : Promise.reject({
                    type: Kl,
                    reason: "Cannot launch app due to no permission"
                });
            })(this[nT], e);
        }
        isRemoteControlEnabled() {
            return ((e)=>{
                var t1;
                const { store: { getState: o } } = e;
                return !(null === (t1 = o().share) || void 0 === t1 || !t1.isRemoteControlEnabled);
            })(this[nT]);
        }
        getRemoteControlAppDownloadUrl() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return o.share ? o.share.remoteControlAppDownloadUrl : null;
            })(this[nT]);
        }
        isTargetShareSupportRemoteControl(e) {
            return YD(this[nT], e);
        }
        isRemotelyControlApproved() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.share && cS(o);
            })(this[nT]);
        }
        isControllingUserRemotely() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                return !!o.share && o.share.isGrabRemoteControl;
            })(this[nT]);
        }
        getRemotelyControllingUser() {
            return ((e)=>{
                const { store: { getState: t1 } } = e, o = t1();
                if (o.share) {
                    const { remoteControllingSsrc: e } = o.share;
                    if (e) return ph(o).find((t1)=>Yr(t1.userId, e));
                }
                return null;
            })(this[nT]);
        }
    }, eT(wM.prototype, "startAudio", [
        sT,
        XD,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "startAudio"), wM.prototype), eT(wM.prototype, "stopAudio", [
        sT,
        eP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopAudio"), wM.prototype), eT(wM.prototype, "muteAudio", [
        sT,
        tP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "muteAudio"), wM.prototype), eT(wM.prototype, "unmuteAudio", [
        sT,
        oP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "unmuteAudio"), wM.prototype), eT(wM.prototype, "dialOut", [
        sT,
        rP,
        iP
    ], Object.getOwnPropertyDescriptor(wM.prototype, "dialOut"), wM.prototype), eT(wM.prototype, "cancelDialOut", [
        sT,
        nP,
        sP
    ], Object.getOwnPropertyDescriptor(wM.prototype, "cancelDialOut"), wM.prototype), eT(wM.prototype, "hangup", [
        sT,
        aP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "hangup"), wM.prototype), eT(wM.prototype, "switchMicrophone", [
        sT,
        dP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "switchMicrophone"), wM.prototype), eT(wM.prototype, "switchSpeaker", [
        sT,
        uP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "switchSpeaker"), wM.prototype), eT(wM.prototype, "muteShareAudio", [
        sT,
        lP,
        cP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "muteShareAudio"), wM.prototype), eT(wM.prototype, "unmuteShareAudio", [
        sT,
        pP,
        hP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "unmuteShareAudio"), wM.prototype), eT(wM.prototype, "subscribeAudioStatisticData", [
        sT,
        mP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "subscribeAudioStatisticData"), wM.prototype), eT(wM.prototype, "unsubscribeAudioStatisticData", [
        sT,
        gP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "unsubscribeAudioStatisticData"), wM.prototype), eT(wM.prototype, "enableBackgroundNoiseSuppression", [
        sT,
        vP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "enableBackgroundNoiseSuppression"), wM.prototype), eT(wM.prototype, "enableSyncButtonsOnHeadset", [
        sT,
        fP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "enableSyncButtonsOnHeadset"), wM.prototype), eT(wM.prototype, "enableOriginalSound", [
        sT,
        yP,
        TM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "enableOriginalSound"), wM.prototype), eT(wM.prototype, "callCRCDevice", [
        sT,
        SP,
        bP
    ], Object.getOwnPropertyDescriptor(wM.prototype, "callCRCDevice"), wM.prototype), eT(wM.prototype, "cancelCallCRCDevice", [
        sT,
        EP,
        IP
    ], Object.getOwnPropertyDescriptor(wM.prototype, "cancelCallCRCDevice"), wM.prototype), eT(wM.prototype, "muteAllAudio", [
        aT,
        sT,
        AP
    ], Object.getOwnPropertyDescriptor(wM.prototype, "muteAllAudio"), wM.prototype), eT(wM.prototype, "unmuteAllAudio", [
        aT,
        sT,
        CP
    ], Object.getOwnPropertyDescriptor(wM.prototype, "unmuteAllAudio"), wM.prototype), eT(wM.prototype, "muteAudioUponEntry", [
        aT,
        sT,
        _P
    ], Object.getOwnPropertyDescriptor(wM.prototype, "muteAudioUponEntry"), wM.prototype), eT(wM.prototype, "startVideo", [
        sT,
        RP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "startVideo"), wM.prototype), eT(wM.prototype, "stopVideo", [
        sT,
        wP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopVideo"), wM.prototype), eT(wM.prototype, "switchCamera", [
        sT,
        TP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "switchCamera"), wM.prototype), eT(wM.prototype, "renderVideo", [
        LM,
        sT,
        OP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "renderVideo"), wM.prototype), eT(wM.prototype, "stopRenderVideo", [
        VM,
        sT,
        DP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopRenderVideo"), wM.prototype), eT(wM.prototype, "updateVideoCanvasDimension", [
        NM,
        sT,
        PP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "updateVideoCanvasDimension"), wM.prototype), eT(wM.prototype, "adjustRenderedVideoPosition", [
        VM,
        sT,
        MP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "adjustRenderedVideoPosition"), wM.prototype), eT(wM.prototype, "clearVideoCanvas", [
        NM,
        sT,
        kP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "clearVideoCanvas"), wM.prototype), eT(wM.prototype, "mirrorVideo", [
        sT,
        LP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "mirrorVideo"), wM.prototype), eT(wM.prototype, "enableHardwareAcceleration", [
        sT,
        NP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "enableHardwareAcceleration"), wM.prototype), eT(wM.prototype, "subscribeVideoStatisticData", [
        sT,
        VP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "subscribeVideoStatisticData"), wM.prototype), eT(wM.prototype, "unsubscribeVideoStatisticData", [
        sT,
        UP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "unsubscribeVideoStatisticData"), wM.prototype), eT(wM.prototype, "previewVirtualBackground", [
        kM,
        sT,
        jP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "previewVirtualBackground"), wM.prototype), eT(wM.prototype, "updateVirtualBackgroundImage", [
        sT,
        xP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "updateVirtualBackgroundImage"), wM.prototype), eT(wM.prototype, "stopPreviewVirtualBackground", [
        sT,
        BP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopPreviewVirtualBackground"), wM.prototype), eT(wM.prototype, "previewVideoMask", [
        kM,
        sT,
        FP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "previewVideoMask"), wM.prototype), eT(wM.prototype, "updateVideoMask", [
        sT,
        HP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "updateVideoMask"), wM.prototype), eT(wM.prototype, "stopPreviewVideoMask", [
        sT,
        $P,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopPreviewVideoMask"), wM.prototype), eT(wM.prototype, "requestFarEndCameraControl", [
        sT,
        WP,
        PM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "requestFarEndCameraControl"), wM.prototype), eT(wM.prototype, "approveFarEndCameraControl", [
        sT,
        GP,
        PM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "approveFarEndCameraControl"), wM.prototype), eT(wM.prototype, "declineFarEndCameraControl", [
        sT,
        KP,
        PM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "declineFarEndCameraControl"), wM.prototype), eT(wM.prototype, "giveUpFarEndCameraControl", [
        sT,
        zP,
        PM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "giveUpFarEndCameraControl"), wM.prototype), eT(wM.prototype, "controlCamera", [
        sT,
        qP,
        PM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "controlCamera"), wM.prototype), eT(wM.prototype, "controlFarEndCamera", [
        sT,
        JP,
        PM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "controlFarEndCamera"), wM.prototype), eT(wM.prototype, "attachVideo", [
        sT,
        QP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "attachVideo"), wM.prototype), eT(wM.prototype, "detachVideo", [
        sT,
        ZP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "detachVideo"), wM.prototype), eT(wM.prototype, "spotlight", [
        aT,
        sT,
        YP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "spotlight"), wM.prototype), eT(wM.prototype, "removeSpotlight", [
        sT,
        XP,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "removeSpotlight"), wM.prototype), eT(wM.prototype, "removeAllSpotlights", [
        dT,
        sT,
        eM,
        OM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "removeAllSpotlights"), wM.prototype), eT(wM.prototype, "startShareView", [
        kM,
        sT,
        tM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "startShareView"), wM.prototype), eT(wM.prototype, "stopShareView", [
        sT,
        oM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopShareView"), wM.prototype), eT(wM.prototype, "switchShareView", [
        sT,
        rM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "switchShareView"), wM.prototype), eT(wM.prototype, "updateSharingCanvasDimension", [
        sT,
        iM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "updateSharingCanvasDimension"), wM.prototype), eT(wM.prototype, "startShareScreen", [
        sT,
        nM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "startShareScreen"), wM.prototype), eT(wM.prototype, "stopShareScreen", [
        sT,
        sM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopShareScreen"), wM.prototype), eT(wM.prototype, "pauseShareScreen", [
        sT,
        aM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "pauseShareScreen"), wM.prototype), eT(wM.prototype, "resumeShareScreen", [
        sT,
        dM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "resumeShareScreen"), wM.prototype), eT(wM.prototype, "setSharePrivilege", [
        aT,
        uM,
        sT,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "setSharePrivilege"), wM.prototype), eT(wM.prototype, "lockShare", [
        aT,
        lM,
        sT,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "lockShare"), wM.prototype), eT(wM.prototype, "shareToBreakoutRoom", [
        sT,
        aT,
        cM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "shareToBreakoutRoom"), wM.prototype), eT(wM.prototype, "stopShareToBreakoutRoom", [
        sT,
        aT,
        pM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopShareToBreakoutRoom"), wM.prototype), eT(wM.prototype, "muteOthersScreenShare", [
        sT,
        aT,
        hM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "muteOthersScreenShare"), wM.prototype), eT(wM.prototype, "enableOptimizeForSharedVideo", [
        sT,
        mM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "enableOptimizeForSharedVideo"), wM.prototype), eT(wM.prototype, "updateSharedVideoQuality", [
        sT,
        gM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "updateSharedVideoQuality"), wM.prototype), eT(wM.prototype, "subscribeShareStatisticData", [
        sT,
        vM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "subscribeShareStatisticData"), wM.prototype), eT(wM.prototype, "unsubscribeShareStatisticData", [
        sT,
        fM,
        DM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "unsubscribeShareStatisticData"), wM.prototype), eT(wM.prototype, "requestRemoteControl", [
        sT,
        yM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "requestRemoteControl"), wM.prototype), eT(wM.prototype, "giveUpRemoteControl", [
        sT,
        SM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "giveUpRemoteControl"), wM.prototype), eT(wM.prototype, "startRemoteControl", [
        sT,
        bM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "startRemoteControl"), wM.prototype), eT(wM.prototype, "grabRemoteControl", [
        sT,
        EM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "grabRemoteControl"), wM.prototype), eT(wM.prototype, "updateRemoteControlViewportDimension", [
        sT,
        IM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "updateRemoteControlViewportDimension"), wM.prototype), eT(wM.prototype, "approveRemoteControl", [
        sT,
        AM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "approveRemoteControl"), wM.prototype), eT(wM.prototype, "declineRemoteControl", [
        sT,
        CM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "declineRemoteControl"), wM.prototype), eT(wM.prototype, "stopRemoteControl", [
        sT,
        _M,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "stopRemoteControl"), wM.prototype), eT(wM.prototype, "launchRemoteControlApp", [
        sT,
        RM,
        MM
    ], Object.getOwnPropertyDescriptor(wM.prototype, "launchRemoteControlApp"), wM.prototype), wM);
    var jM, xM, BM, FM, HM, $M, WM, GM, KM;
    const zM = mT("Audio"), qM = mT("Sharing");
    let JM = (jM = uT("share"), xM = uT("audio"), BM = uT("audio"), FM = uT("audio"), HM = uT("audio"), $M = uT("audio"), WM = uT("audio"), GM = uT("audio"), KM = class extends UM {
        switchSharingSecondaryCamera(e) {
            return ((e, t1)=>{
                const { store: { getState: o, dispatch: r }, mediaAgent: i } = e, n = o(), { video: { cameraDevicesList: s }, share: { status: a, isSharingWithSecondCamera: d } } = n;
                return "default" !== t1 && -1 === s.map((e)=>e.deviceId).indexOf(t1) ? Promise.reject({
                    type: Zl,
                    reason: "Cannot find cameraDeviceId in camera devices list."
                }) : (a === yd.Sharing && d && i.changeSharingSecondCamera(t1), r(Tm(t1)), Promise.resolve());
            })(this[nT], e);
        }
        muteUserAudioLocally(e) {
            return ((e, t1)=>{
                const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, n = r(), { audio: { locallyMutedAudioList: s } } = n, a = ph(n).filter((e)=>e.audio === Wd.Computer);
                return s.includes(t1) || -1 === a.findIndex((e)=>e.userId === t1) || (o.muteOrUnmuteOtherAudio(t1, !0), i(Jh(t1))), Promise.resolve("");
            })(this[nT], e);
        }
        unmuteUserAudioLocally(e) {
            return ((e, t1)=>{
                const { mediaAgent: o, store: { getState: r, dispatch: i } } = e, { audio: { locallyMutedAudioList: n } } = r();
                return n.includes(t1) ? (o.muteOrUnmuteOtherAudio(t1, !1), i(Qh(t1)), Promise.resolve("")) : Promise.resolve("");
            })(this[nT], e);
        }
        adjustUserAudioVolumeLocally(e, t1) {
            return ((e, t1, o)=>{
                const { mediaAgent: r, store: { getState: i, dispatch: n } } = e, s = i();
                return -1 !== ph(s).findIndex((e)=>e.userId === t1) && (r.adjustOtherAudioVolume(t1, o), n(Zh({
                    userId: t1,
                    volume: o
                }))), Promise.resolve("");
            })(this[nT], e, t1);
        }
        muteAllUserAudioLocally() {
            return ((e)=>{
                const { mediaAgent: t1, store: { getState: o, dispatch: r } } = e, { audio: { isStopAllImcomingAudio: i } } = o();
                return i || (t1.stopAllIncomingAudio(!0), r(rm(!0))), Promise.resolve("");
            })(this[nT]);
        }
        unmuteAllUserAudioLocally() {
            return ((e)=>{
                const { mediaAgent: t1, store: { getState: o, dispatch: r } } = e, { audio: { isStopAllImcomingAudio: i, locallyMutedAudioList: n } } = o();
                return i && (t1.stopAllIncomingAudio(!1), r(rm(!1)), n.length > 0 && n.forEach((e)=>{
                    t1.muteOrUnmuteOtherAudio(e, !1), r(Qh(e));
                })), Promise.resolve("");
            })(this[nT]);
        }
        startSecondaryAudio(e, t1) {
            return (async (e, t1, o)=>{
                const { mediaAgent: r, rwgAgent: i, store: { getState: n, dispatch: s } } = e, a = n(), { audio: { microphoneDevicesList: d, activeMicrophone: u }, share: { status: l } } = a, c = ah(a);
                if (!ca.isSupportShare2ndAudioDevice(vs())) return Promise.reject({
                    type: Kl,
                    reason: "Cannot start secondary audio due to platform is not supported"
                });
                if ((null == c ? void 0 : c.audio) === Wd.Computer && u === t1) return Promise.reject({
                    type: Kl,
                    reason: "Cannot start secondary audio with the same microphone"
                });
                if (l !== yd.End) return Promise.reject({
                    type: Kl,
                    reason: "Cannot start secondary audio while screen sharing is in progress"
                });
                let p = d;
                if (0 === d.length) {
                    const { microphones: e } = await Oe(_y());
                    p = e;
                }
                return t1 && -1 === p.findIndex((e)=>e.deviceId === t1) ? Promise.reject({
                    type: Zl,
                    reason: "Cannot find the microphone"
                }) : (i.muteShareAudio(!1, !0), r.share2ndAudio(t1, o), s(lm(t1)), ip(dl));
            })(this[nT], e, t1);
        }
        stopSecondaryAudio() {
            return (async (e)=>{
                const { mediaAgent: t1, rwgAgent: o, store: { getState: r, dispatch: i } } = e, n = r(), { audio: { secondaryAudioMicrophoneId: s } } = n;
                if (!s) return Promise.reject({
                    type: Kl,
                    reason: "Cannot stop secondary audio due to not started "
                });
                o.muteShareAudio(!0, !0), t1.leaveSharingAudio(!1), i(lm(void 0));
            })(this[nT]);
        }
        isUserAudioMutedLocally(e) {
            return ((e, t1)=>{
                let { store: { getState: o } } = e;
                const { audio: { locallyMutedAudioList: r } } = o();
                return r.includes(t1);
            })(this[nT], e);
        }
        getUserVolumeLocally(e) {
            return ((e, t1)=>{
                var o, r;
                let { store: { getState: i } } = e;
                const { audio: { localUserAudioVolumeList: n, locallyMutedAudioList: s } } = i();
                return null !== (o = null === (r = n.find((e)=>e.userId === t1)) || void 0 === r ? void 0 : r.volume) && void 0 !== o ? o : s.includes(t1) ? 0 : 100;
            })(this[nT], e);
        }
    }, eT(KM.prototype, "switchSharingSecondaryCamera", [
        sT,
        jM,
        qM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "switchSharingSecondaryCamera"), KM.prototype), eT(KM.prototype, "muteUserAudioLocally", [
        sT,
        xM,
        zM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "muteUserAudioLocally"), KM.prototype), eT(KM.prototype, "unmuteUserAudioLocally", [
        sT,
        BM,
        zM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "unmuteUserAudioLocally"), KM.prototype), eT(KM.prototype, "adjustUserAudioVolumeLocally", [
        sT,
        FM,
        zM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "adjustUserAudioVolumeLocally"), KM.prototype), eT(KM.prototype, "muteAllUserAudioLocally", [
        sT,
        HM,
        zM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "muteAllUserAudioLocally"), KM.prototype), eT(KM.prototype, "unmuteAllUserAudioLocally", [
        sT,
        $M,
        zM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "unmuteAllUserAudioLocally"), KM.prototype), eT(KM.prototype, "startSecondaryAudio", [
        sT,
        WM,
        zM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "startSecondaryAudio"), KM.prototype), eT(KM.prototype, "stopSecondaryAudio", [
        sT,
        GM,
        zM
    ], Object.getOwnPropertyDescriptor(KM.prototype, "stopSecondaryAudio"), KM.prototype), KM);
    const QM = {
        controlStatus: qp.NotStarted,
        sequenceId: 1,
        rooms: [],
        isHugeBO: !1,
        allocationPattern: zp.Automatically,
        currentRoom: {
            status: Qp.Initial,
            boStatus: Jp.NoToken,
            boConfId: "",
            boId: "",
            name: "",
            boToken: ""
        },
        options: {
            isAutoJoinRoom: !1,
            isBackToMainSessionEnabled: !0,
            isTimerEnabled: !1,
            timerDuration: 1800,
            isTimerAutoEnabled: !1,
            waitSeconds: 60,
            isAutoMovetoMainSession: !1,
            isRoomSelectionEnabled: !1
        },
        mainSessionAttendeeList: [],
        preAssignedRooms: [],
        meetingElapsedTime: 0,
        startRoomElapsedTime: 0,
        closingRoomTime: 0,
        broadcastMessage: "",
        hostReplyToQuestionerType: void 0,
        hostReplyToRequestId: void 0,
        isUserRoleUpdated: !1,
        mainSessionConfId: "",
        isEnableBOBroadcast: !1,
        isEnableBreakoutRoom: !1,
        isEnableBOViewActivityStatus: !1,
        inRoomUserActivityStatusMap: {},
        isEnableBOBroadcastVoice: !1,
        isBroadcastVoice: !1
    }, ZM = bo({
        [`${Hv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            Array.isArray(o) ? e.rooms.push(...o) : e.rooms.push(o);
        }),
        [`${$v}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.allocationPattern = o;
        }),
        [`${Wv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.sequenceId = o;
        }),
        [`${Gv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.meetingElapsedTime = o;
        }),
        [`${Kv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.startRoomElapsedTime = o;
        }),
        [`${zv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { options: r } = e;
            Object.assign(r, o);
        }),
        [`${qv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.controlStatus = o;
        }),
        [`${Jv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.rooms = o;
        }),
        [`${Qv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { currentRoom: r } = e;
            Object.assign(r, o);
        }),
        [`${Zv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { currentRoom: r } = e;
            r.status = o;
        }),
        [`${Yv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { currentRoom: r } = e;
            r.boConfId = o;
        }),
        [`${Xv}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { currentRoom: r } = e;
            r.boToken = o;
        }),
        [`${tf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.closingRoomTime = o;
        }),
        [`${of}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.broadcastMessage = o;
        }),
        [`${rf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.hostReplyToQuestionerType = o;
        }),
        [`${nf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.hostReplyToRequestId = o;
        }),
        [`${sf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            void 0 !== o.add && o.add.length > 0 && o.add.forEach((t1)=>{
                const o = e.mainSessionAttendeeList.find((e)=>e.userId === t1.userId);
                void 0 !== o ? Object.assign(o, t1) : Gp(t1.userRole) || e.mainSessionAttendeeList.push(t1);
            }), void 0 !== o.update && o.update.length > 0 && o.update.forEach((t1)=>{
                const o = e.mainSessionAttendeeList.find((e)=>e.userId === t1.userId);
                void 0 !== o && Object.assign(o, t1);
            }), void 0 !== o.remove && o.remove.length > 0 && o.remove.forEach((t1)=>{
                const o = e.mainSessionAttendeeList.findIndex((e)=>e.userId === t1.userId);
                -1 !== o && e.mainSessionAttendeeList.splice(o, 1);
            });
        }),
        [`${af}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isHugeBO = o;
        }),
        [`${uf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isUserRoleUpdated = o;
        }),
        [`${df}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.preAssignedRooms = o;
        }),
        [`${lf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isEnableBreakoutRoom = o.isEnableBreakoutRoom, e.isEnableBOBroadcast = o.isEnableBOBroadcast, e.isEnableBOViewActivityStatus = o.isEnableBOViewActivityStatus, e.isEnableBOBroadcastVoice = o.isEnableBOBroadcastVoice;
        }),
        [`${cf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { userGuid: r, status: i } = o, { inRoomUserActivityStatusMap: n } = e;
            n[`${r}`] = i;
        }),
        [`${pf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isBroadcastVoice = o;
        }),
        [`${ef}`]: (e)=>{
            const { currentRoom: { status: t1 } } = e;
            return t1 === Qp.Joining ? {
                ...QM,
                preAssignedRooms: e.preAssignedRooms,
                currentRoom: e.currentRoom,
                closingRoomTime: e.closingRoomTime
            } : t1 === Qp.Leaving ? {
                ...QM,
                preAssignedRooms: e.preAssignedRooms,
                closingRoomTime: e.closingRoomTime
            } : {
                ...QM,
                preAssignedRooms: e.preAssignedRooms
            };
        }
    }, QM);
    var YM = Uint8Array, XM = Uint16Array, ek = Uint32Array, tk = new YM([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        0,
        0,
        0
    ]), ok = new YM([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        0,
        0
    ]), rk = new YM([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]), ik = function(e, t1) {
        for(var o = new XM(31), r = 0; r < 31; ++r)o[r] = t1 += 1 << e[r - 1];
        var i = new ek(o[30]);
        for(r = 1; r < 30; ++r)for(var n = o[r]; n < o[r + 1]; ++n)i[n] = n - o[r] << 5 | r;
        return [
            o,
            i
        ];
    }, nk = ik(tk, 2), sk = nk[0], ak = nk[1];
    sk[28] = 258, ak[258] = 28;
    for(var dk = ik(ok, 0), uk = dk[0], lk = dk[1], ck = new XM(32768), pk = 0; pk < 32768; ++pk){
        var hk = (43690 & pk) >>> 1 | (21845 & pk) << 1;
        hk = (61680 & (hk = (52428 & hk) >>> 2 | (13107 & hk) << 2)) >>> 4 | (3855 & hk) << 4, ck[pk] = ((65280 & hk) >>> 8 | (255 & hk) << 8) >>> 1;
    }
    var mk = function(e, t1, o) {
        for(var r = e.length, i = 0, n = new XM(t1); i < r; ++i)e[i] && ++n[e[i] - 1];
        var s, a = new XM(t1);
        for(i = 0; i < t1; ++i)a[i] = a[i - 1] + n[i - 1] << 1;
        if (o) {
            s = new XM(1 << t1);
            var d = 15 - t1;
            for(i = 0; i < r; ++i)if (e[i]) for(var u = i << 4 | e[i], l = t1 - e[i], c = a[e[i] - 1]++ << l, p = c | (1 << l) - 1; c <= p; ++c)s[ck[c] >>> d] = u;
        } else for(s = new XM(r), i = 0; i < r; ++i)e[i] && (s[i] = ck[a[e[i] - 1]++] >>> 15 - e[i]);
        return s;
    }, gk = new YM(288);
    for(pk = 0; pk < 144; ++pk)gk[pk] = 8;
    for(pk = 144; pk < 256; ++pk)gk[pk] = 9;
    for(pk = 256; pk < 280; ++pk)gk[pk] = 7;
    for(pk = 280; pk < 288; ++pk)gk[pk] = 8;
    var vk = new YM(32);
    for(pk = 0; pk < 32; ++pk)vk[pk] = 5;
    var fk = mk(gk, 9, 0), yk = mk(gk, 9, 1), Sk = mk(vk, 5, 0), bk = mk(vk, 5, 1), Ek = function(e) {
        for(var t1 = e[0], o = 1; o < e.length; ++o)e[o] > t1 && (t1 = e[o]);
        return t1;
    }, Ik = function(e, t1, o) {
        var r = t1 / 8 | 0;
        return (e[r] | e[r + 1] << 8) >> (7 & t1) & o;
    }, Ak = function(e, t1) {
        var o = t1 / 8 | 0;
        return (e[o] | e[o + 1] << 8 | e[o + 2] << 16) >> (7 & t1);
    }, Ck = function(e) {
        return (e + 7) / 8 | 0;
    }, _k = function(e, t1, o) {
        (null == t1 || t1 < 0) && (t1 = 0), (null == o || o > e.length) && (o = e.length);
        var r = new (2 == e.BYTES_PER_ELEMENT ? XM : 4 == e.BYTES_PER_ELEMENT ? ek : YM)(o - t1);
        return r.set(e.subarray(t1, o)), r;
    }, Rk = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data"
    ], wk = function(e, t1, o) {
        var r = new Error(t1 || Rk[e]);
        if (r.code = e, Error.captureStackTrace && Error.captureStackTrace(r, wk), !o) throw r;
        return r;
    }, Tk = function(e, t1, o) {
        o <<= 7 & t1;
        var r = t1 / 8 | 0;
        e[r] |= o, e[r + 1] |= o >>> 8;
    }, Ok = function(e, t1, o) {
        o <<= 7 & t1;
        var r = t1 / 8 | 0;
        e[r] |= o, e[r + 1] |= o >>> 8, e[r + 2] |= o >>> 16;
    }, Dk = function(e, t1) {
        for(var o = [], r = 0; r < e.length; ++r)e[r] && o.push({
            s: r,
            f: e[r]
        });
        var i = o.length, n = o.slice();
        if (!i) return [
            Uk,
            0
        ];
        if (1 == i) {
            var s = new YM(o[0].s + 1);
            return s[o[0].s] = 1, [
                s,
                1
            ];
        }
        o.sort(function(e, t1) {
            return e.f - t1.f;
        }), o.push({
            s: -1,
            f: 25001
        });
        var a = o[0], d = o[1], u = 0, l = 1, c = 2;
        for(o[0] = {
            s: -1,
            f: a.f + d.f,
            l: a,
            r: d
        }; l != i - 1;)a = o[o[u].f < o[c].f ? u++ : c++], d = o[u != l && o[u].f < o[c].f ? u++ : c++], o[l++] = {
            s: -1,
            f: a.f + d.f,
            l: a,
            r: d
        };
        var p = n[0].s;
        for(r = 1; r < i; ++r)n[r].s > p && (p = n[r].s);
        var h = new XM(p + 1), m = Pk(o[l - 1], h, 0);
        if (m > t1) {
            r = 0;
            var g = 0, v = m - t1, f = 1 << v;
            for(n.sort(function(e, t1) {
                return h[t1.s] - h[e.s] || e.f - t1.f;
            }); r < i; ++r){
                var y = n[r].s;
                if (!(h[y] > t1)) break;
                g += f - (1 << m - h[y]), h[y] = t1;
            }
            for(g >>>= v; g > 0;){
                var S = n[r].s;
                h[S] < t1 ? g -= 1 << t1 - h[S]++ - 1 : ++r;
            }
            for(; r >= 0 && g; --r){
                var b = n[r].s;
                h[b] == t1 && (--h[b], ++g);
            }
            m = t1;
        }
        return [
            new YM(h),
            m
        ];
    }, Pk = function(e, t1, o) {
        return -1 == e.s ? Math.max(Pk(e.l, t1, o + 1), Pk(e.r, t1, o + 1)) : t1[e.s] = o;
    }, Mk = function(e) {
        for(var t1 = e.length; t1 && !e[--t1];);
        for(var o = new XM(++t1), r = 0, i = e[0], n = 1, s = function(e) {
            o[r++] = e;
        }, a = 1; a <= t1; ++a)if (e[a] == i && a != t1) ++n;
        else {
            if (!i && n > 2) {
                for(; n > 138; n -= 138)s(32754);
                n > 2 && (s(n > 10 ? n - 11 << 5 | 28690 : n - 3 << 5 | 12305), n = 0);
            } else if (n > 3) {
                for(s(i), --n; n > 6; n -= 6)s(8304);
                n > 2 && (s(n - 3 << 5 | 8208), n = 0);
            }
            for(; n--;)s(i);
            n = 1, i = e[a];
        }
        return [
            o.subarray(0, r),
            t1
        ];
    }, kk = function(e, t1) {
        for(var o = 0, r = 0; r < t1.length; ++r)o += e[r] * t1[r];
        return o;
    }, Lk = function(e, t1, o) {
        var r = o.length, i = Ck(t1 + 2);
        e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];
        for(var n = 0; n < r; ++n)e[i + n + 4] = o[n];
        return 8 * (i + 4 + r);
    }, Nk = function(e, t1, o, r, i, n, s, a, d, u, l) {
        Tk(t1, l++, o), ++i[256];
        for(var c = Dk(i, 15), p = c[0], h = c[1], m = Dk(n, 15), g = m[0], v = m[1], f = Mk(p), y = f[0], S = f[1], b = Mk(g), E = b[0], I = b[1], A = new XM(19), C = 0; C < y.length; ++C)A[31 & y[C]]++;
        for(C = 0; C < E.length; ++C)A[31 & E[C]]++;
        for(var _ = Dk(A, 7), R = _[0], w = _[1], T = 19; T > 4 && !R[rk[T - 1]]; --T);
        var O, D, P, M, k = u + 5 << 3, L = kk(i, gk) + kk(n, vk) + s, N = kk(i, p) + kk(n, g) + s + 14 + 3 * T + kk(A, R) + (2 * A[16] + 3 * A[17] + 7 * A[18]);
        if (k <= L && k <= N) return Lk(t1, l, e.subarray(d, d + u));
        if (Tk(t1, l, 1 + (N < L)), l += 2, N < L) {
            O = mk(p, h, 0), D = p, P = mk(g, v, 0), M = g;
            var V = mk(R, w, 0);
            for(Tk(t1, l, S - 257), Tk(t1, l + 5, I - 1), Tk(t1, l + 10, T - 4), l += 14, C = 0; C < T; ++C)Tk(t1, l + 3 * C, R[rk[C]]);
            l += 3 * T;
            for(var U = [
                y,
                E
            ], j = 0; j < 2; ++j){
                var x = U[j];
                for(C = 0; C < x.length; ++C){
                    var B = 31 & x[C];
                    Tk(t1, l, V[B]), l += R[B], B > 15 && (Tk(t1, l, x[C] >>> 5 & 127), l += x[C] >>> 12);
                }
            }
        } else O = fk, D = gk, P = Sk, M = vk;
        for(C = 0; C < a; ++C)if (r[C] > 255) {
            B = r[C] >>> 18 & 31, Ok(t1, l, O[B + 257]), l += D[B + 257], B > 7 && (Tk(t1, l, r[C] >>> 23 & 31), l += tk[B]);
            var F = 31 & r[C];
            Ok(t1, l, P[F]), l += M[F], F > 3 && (Ok(t1, l, r[C] >>> 5 & 8191), l += ok[F]);
        } else Ok(t1, l, O[r[C]]), l += D[r[C]];
        return Ok(t1, l, O[256]), l + D[256];
    }, Vk = new ek([
        65540,
        131080,
        131088,
        131104,
        262176,
        1048704,
        1048832,
        2114560,
        2117632
    ]), Uk = new YM(0), jk = function() {
        for(var e = new Int32Array(256), t1 = 0; t1 < 256; ++t1){
            for(var o = t1, r = 9; --r;)o = (1 & o && -306674912) ^ o >>> 1;
            e[t1] = o;
        }
        return e;
    }(), xk = function(e, t1, o) {
        for(; o; ++t1)e[t1] = o, o >>>= 8;
    };
    function Bk(e, t1) {
        t1 || (t1 = {});
        var o = function() {
            var e = -1;
            return {
                p: function(t1) {
                    for(var o = e, r = 0; r < t1.length; ++r)o = jk[255 & o ^ t1[r]] ^ o >>> 8;
                    e = o;
                },
                d: function() {
                    return ~e;
                }
            };
        }(), r = e.length;
        o.p(e);
        var i = function(e, t1, o, r) {
            return function(e, t1, o, r, i, n) {
                var s = e.length, a = new YM(r + s + 5 * (1 + Math.ceil(s / 7e3)) + i), d = a.subarray(r, a.length - i), u = 0;
                if (!t1 || s < 8) for(var l = 0; l <= s; l += 65535){
                    var c = l + 65535;
                    c >= s && (d[u >> 3] = n), u = Lk(d, u + 1, e.subarray(l, c));
                }
                else {
                    for(var p = Vk[t1 - 1], h = p >>> 13, m = 8191 & p, g = (1 << o) - 1, v = new XM(32768), f = new XM(g + 1), y = Math.ceil(o / 3), S = 2 * y, b = function(t1) {
                        return (e[t1] ^ e[t1 + 1] << y ^ e[t1 + 2] << S) & g;
                    }, E = new ek(25e3), I = new XM(288), A = new XM(32), C = 0, _ = 0, R = (l = 0, 0), w = 0, T = 0; l < s; ++l){
                        var O = b(l), D = 32767 & l, P = f[O];
                        if (v[D] = P, f[O] = D, w <= l) {
                            var M = s - l;
                            if ((C > 7e3 || R > 24576) && M > 423) {
                                u = Nk(e, d, 0, E, I, A, _, R, T, l - T, u), R = C = _ = 0, T = l;
                                for(var k = 0; k < 286; ++k)I[k] = 0;
                                for(k = 0; k < 30; ++k)A[k] = 0;
                            }
                            var L = 2, N = 0, V = m, U = D - P & 32767;
                            if (M > 2 && O == b(l - U)) for(var j = Math.min(h, M) - 1, x = Math.min(32767, l), B = Math.min(258, M); U <= x && --V && D != P;){
                                if (e[l + L] == e[l + L - U]) {
                                    for(var F = 0; F < B && e[l + F] == e[l + F - U]; ++F);
                                    if (F > L) {
                                        if (L = F, N = U, F > j) break;
                                        var H = Math.min(U, F - 2), $ = 0;
                                        for(k = 0; k < H; ++k){
                                            var W = l - U + k + 32768 & 32767, G = W - v[W] + 32768 & 32767;
                                            G > $ && ($ = G, P = W);
                                        }
                                    }
                                }
                                U += (D = P) - (P = v[D]) + 32768 & 32767;
                            }
                            if (N) {
                                E[R++] = 268435456 | ak[L] << 18 | lk[N];
                                var K = 31 & ak[L], z = 31 & lk[N];
                                _ += tk[K] + ok[z], ++I[257 + K], ++A[z], w = l + L, ++C;
                            } else E[R++] = e[l], ++I[e[l]];
                        }
                    }
                    u = Nk(e, d, n, E, I, A, _, R, T, l - T, u);
                }
                return _k(a, 0, r + Ck(u) + i);
            }(e, null == t1.level ? 6 : t1.level, null == t1.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t1.mem, o, r, !0);
        }(e, t1, function(e) {
            return 10 + (e.filename && e.filename.length + 1 || 0);
        }(t1), 8), n = i.length;
        return function(e, t1) {
            var o = t1.filename;
            if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t1.level < 2 ? 4 : 9 == t1.level ? 2 : 0, e[9] = 3, 0 != t1.mtime && xk(e, 4, Math.floor(new Date(t1.mtime || Date.now()) / 1e3)), o) {
                e[3] = 8;
                for(var r = 0; r <= o.length; ++r)e[r + 10] = o.charCodeAt(r);
            }
        }(i, t1), xk(i, n - 8, o.d()), xk(i, n - 4, r), i;
    }
    var Fk = "undefined" != typeof TextEncoder && new TextEncoder, Hk = "undefined" != typeof TextDecoder && new TextDecoder;
    try {
        Hk.decode(Uk, {
            stream: !0
        });
    } catch (t1) {}
    const { WebclientBreakoutRoomAttendeeStatus: $k, WebclientBreakoutRoomCommand: Wk } = ss, Gk = yE(ca.getInstance());
    function Kk(e, t1) {
        let o = 0;
        for(; o < e.length; o++){
            const r = e[o], { attendeeGuidList: i } = r;
            if (null != i && i.includes(t1)) break;
        }
        return o < e.length ? e[o] : void 0;
    }
    function zk() {
        ns.remove($k), ns.remove(Wk);
    }
    function qk() {
        return ia.createAgent().leaveBO(1), tp(Ea, {
            reason: Jn.BackToMainSession
        }), zk(), [
            Zv(Qp.Leaving),
            sn(ts.NormalCase)
        ];
    }
    function Jk(e, t1) {
        return tp(Ea, {
            reason: Jn.JoinBreakoutRoom,
            roomName: e
        }), t1 === Qp.InRoom && ia.createAgent().leaveBO(1), [
            Zv(Qp.Joining),
            sn(ts.NormalCase)
        ];
    }
    function Qk(e) {
        return tp(Ea, {
            reason: Jn.MoveToBreakoutRoom,
            roomName: e
        }), ia.createAgent().leaveBO(1), [
            Zv(Qp.Joining),
            sn(ts.NormalCase)
        ];
    }
    function Zk(e) {
        return e !== Qp.InRoom && e !== Qp.Joining && e !== Qp.Leaving;
    }
    function Yk(e) {
        const t1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? Qp.InRoom : Qp.Invited;
        return ns.set($k, JSON.stringify({
            status: t1,
            boId: e.boId
        }), rs.SessionStorage), Qv({
            status: t1,
            boId: e.boId,
            name: e.name,
            boStatus: e.boStatus
        });
    }
    function Xk(e) {
        const { breakoutRoom: { isUserRoleUpdated: t1, currentRoom: { boConfId: o } } } = e.value, r = ah(e.value);
        if (r && (!o || o && t1)) return Re(r.isHost);
        {
            const t1 = o ? np(Tc, 1) : np(pa, 1).pipe(Fe((e)=>$p(e.userRole) ? _e([
                    1
                ]) : rt(np(ha).pipe(ot((e)=>void 0 !== e.userRole && void 0 === e.displayName || void 0 !== e.bVideoConnect), nt(1)), np(ma).pipe(ot((e)=>e.some((e)=>$p(e.userRole))), nt(1)), Ze(3e3))));
            return t1.pipe(Ie(ee), ft(e), Le((e)=>{
                let [, t1] = e;
                return ah(t1).isHost;
            }));
        }
    }
    function eL(e) {
        return We({
            boIdList: np(yc).pipe(lt((e, t1)=>[
                    ...e,
                    t1
                ], []), nt(e))
        }).pipe(Me(1e4));
    }
    const tL = [
        {
            mask: oh.Connect,
            key: "audio",
            value: ""
        },
        {
            mask: oh.Voip,
            key: "audio",
            value: "computer"
        },
        {
            mask: oh.Muted,
            key: "muted",
            value: !0
        },
        {
            mask: rh.Connect,
            key: "bVideoOn",
            value: !1
        },
        {
            mask: rh.On,
            key: "bVideoOn",
            value: !0
        },
        {
            mask: ih.Share,
            key: "sharerOn",
            value: !0
        },
        {
            mask: ih.ShareAudio,
            key: "bShareAudioOn",
            value: !0
        }
    ];
    function oL(e, t1) {
        const o = (AT(t1) ? t1.breakoutRoom.mainSessionAttendeeList : t1.participants.attendeesList).find((t1)=>t1.userId === Number(e));
        return o ? {
            inviterId: o.userId,
            inviterGuid: o.userGUID,
            inviterName: o.displayName
        } : {};
    }
    const rL = ia.createAgent(), iL = [
        "userRole",
        "bCoHost",
        "bCCEditor",
        "bHold"
    ], nL = ia.createAgent(), sL = yE(ca.getInstance());
    var aL;
    const dL = ia.createAgent(), uL = yE(ca.getInstance()), lL = mT("Breakout Room");
    let cL = (aL = class extends vT {
        createRooms(e, t1) {
            const o = this[oT](), r = this[rT], { breakoutRoom: { isHugeBO: i, sequenceId: n, rooms: s, controlStatus: a, isEnableBreakoutRoom: d } } = o;
            if (!d) return Promise.reject({
                type: Kl,
                reason: "Breakout room feature is not enabled."
            });
            if (a === qp.InProgress || a === qp.Closing) return Promise.resolve({
                type: Kl,
                reason: "breakout room has started!"
            });
            let u;
            u = "string" == typeof e ? [
                e
            ] : "number" == typeof e ? Array.from({
                length: e
            }).map((e, t1)=>`${Yp} ${t1 + n}`) : e;
            const l = i ? 100 : 50;
            return u.length < 1 || s.length + u.length > l ? Promise.reject({
                type: Zl,
                reason: "exceed maximum size"
            }) : (dL.batchCreateBOToken(u), new Promise((e, i)=>{
                eL(u.length).subscribe({
                    next (i) {
                        let { boIdList: s } = i, a = s.map((e, t1)=>({
                                boId: e,
                                name: u[t1]
                            }));
                        if (t1 === zp.Automatically) {
                            const e = CT(o), t1 = a.length, r = e.length;
                            a = a.map((o, i)=>{
                                const n = [];
                                let s = i;
                                for(; s < r;)n.push(e[s]), s += t1;
                                return {
                                    ...o,
                                    attendeeList: n
                                };
                            });
                        }
                        const d = a.map((e)=>{
                            let { boId: t1, name: o, attendeeList: r } = e;
                            return {
                                boId: t1,
                                name: o,
                                attendeeGuidList: r && r.map((e)=>e.userGUID)
                            };
                        });
                        if (r(Hv(d)), r($v(t1)), r(Wv(n + a.length)), t1 === zp.Automatically) {
                            const t1 = a.map((e)=>({
                                    roomId: e.boId,
                                    name: e.name,
                                    attendeeList: e.attendeeList.map((e)=>({
                                            userId: e.userId,
                                            avatar: e.avatar,
                                            displayName: e.displayName
                                        }))
                                }));
                            e(t1);
                        } else e(a.map((e)=>({
                                roomId: e.boId,
                                name: e.name,
                                attendeeList: []
                            })));
                    },
                    error () {
                        i({
                            type: zl
                        });
                    }
                });
            }));
        }
        recreateRooms(e, t1) {
            const o = this[oT](), r = this[rT], { breakoutRoom: { isHugeBO: i, sequenceId: n, rooms: s, controlStatus: a, isEnableBreakoutRoom: d } } = o;
            if (!d) return Promise.reject({
                type: Kl,
                reason: "Breakout room feature is not enabled."
            });
            if (a === qp.InProgress || a === qp.Closing) return Promise.resolve({
                type: Kl,
                reason: "breakout room has started!"
            });
            let u;
            u = "string" == typeof e ? [
                e
            ] : "number" == typeof e ? Array.from({
                length: e
            }).map((e, t1)=>`${Yp} ${t1 + n}`) : e;
            const l = i ? 100 : 50;
            return u.length < 1 || s.length + u.length > l ? Promise.reject({
                type: Zl,
                reason: "exceed maximum size"
            }) : (dL.batchCreateBOToken(u), new Promise((e, i)=>{
                eL(u.length).subscribe((i)=>{
                    let { boIdList: s } = i, a = s.map((e, t1)=>({
                            boId: e,
                            name: u[t1]
                        }));
                    if (t1 === zp.Automatically) {
                        const e = a.length, t1 = _T(o), r = t1.length;
                        a = a.map((o, i)=>{
                            const n = [];
                            let s = i;
                            for(; s < r;)n.push(t1[s]), s += e;
                            return {
                                ...o,
                                attendeeList: n
                            };
                        });
                    }
                    const d = a.map((e)=>{
                        let { boId: t1, name: o, attendeeList: r } = e;
                        return {
                            boId: t1,
                            name: o,
                            attendeeGuidList: r && r.map((e)=>e.userGUID)
                        };
                    });
                    if (r(Jv(d)), r($v(t1)), r(Wv(n + a.length)), t1 === zp.Automatically) {
                        const t1 = a.map((e)=>({
                                roomId: e.boId,
                                name: e.name,
                                attendeeList: e.attendeeList.map((e)=>({
                                        userId: e.userId,
                                        avatar: e.avatar,
                                        displayName: e.displayName
                                    }))
                            }));
                        e(t1);
                    } else e(a.map((e)=>({
                            roomId: e.boId,
                            name: e.name,
                            attendeeList: []
                        })));
                }, ()=>{
                    i({
                        type: zl
                    });
                });
            }));
        }
        openRooms(e, t1) {
            var o;
            const r = this[oT](), i = {
                isAutoJoinRoom: !1,
                isBackToMainSessionEnabled: !0,
                isTimerEnabled: !1,
                timerDuration: 1800,
                isTimerAutoEnabled: !1,
                waitSeconds: 60,
                isAutoMoveBackToMainSession: !1,
                isRoomSelectionEnabled: !1
            }, { breakoutRoom: { controlStatus: n, rooms: s, sequenceId: a, isHugeBO: d } } = r;
            if (n === qp.InProgress || n === qp.Closing) return Promise.resolve({
                type: Kl,
                reason: "breakout room has started!"
            });
            if (e.some((e)=>-1 === s.findIndex((t1)=>t1.boId === e.roomId))) return Promise.reject({
                type: Zl,
                reason: "roomId is wrong"
            });
            const u = ph(r);
            if (e.reduce((e, t1)=>e.concat(t1.attendeeList), []).some((e)=>-1 === u.findIndex((t1)=>t1.userId === e.userId))) return Promise.reject({
                type: Zl,
                reason: "bad user"
            });
            const l = e.map((e)=>{
                const { attendeeList: t1 } = e, o = t1.map((e)=>{
                    const t1 = u.find((t1)=>t1.userId === e.userId);
                    return null == t1 ? void 0 : t1.userGUID;
                });
                return {
                    BID: e.roomId,
                    MeetingTitle: e.name,
                    MeetingToken: void 0,
                    Status: Jp.Started,
                    HostID: "",
                    ParticipantList: o
                };
            }), c = t1 ? {
                ...i,
                ...t1
            } : i, p = {
                ControlStatus: qp.InProgress,
                NameIndex: a,
                IsAutoJoinEnabled: +c.isAutoJoinRoom,
                IsBackToMainSessionEnabled: +c.isBackToMainSessionEnabled,
                IsTimerEnabled: +c.isTimerEnabled,
                TimerDuration: c.timerDuration,
                IsTimerAutoEndEnabled: +c.isTimerAutoEnabled,
                WaitSeconds: c.waitSeconds < 0 ? 0 : c.waitSeconds,
                StartTimeOnMMR: void 0,
                ItemList: l,
                IsAutoMovetoMainSessionEnabled: c.isAutoMoveBackToMainSession,
                IsParticipantsChooseRoomEnabled: +c.isRoomSelectionEnabled
            };
            let h = Gr(JSON.stringify(p));
            if (d && (h = ((e)=>Hr(Bk(function(e) {
                    if (Fk) return Fk.encode(e);
                    for(var t1 = e.length, o = new YM(e.length + (e.length >> 1)), r = 0, i = function(e) {
                        o[r++] = e;
                    }, n = 0; n < t1; ++n){
                        if (r + 5 > o.length) {
                            var s = new YM(r + 8 + (t1 - n << 1));
                            s.set(o), o = s;
                        }
                        var a = e.charCodeAt(n);
                        a < 128 ? i(a) : a < 2048 ? (i(192 | a >> 6), i(128 | 63 & a)) : a > 55295 && a < 57344 ? (i(240 | (a = 65536 + (1047552 & a) | 1023 & e.charCodeAt(++n)) >> 18), i(128 | a >> 12 & 63), i(128 | a >> 6 & 63), i(128 | 63 & a)) : (i(224 | a >> 12), i(128 | a >> 6 & 63), i(128 | 63 & a));
                    }
                    return _k(o, 0, r);
                }(e))))(h)), null !== (o = ah(r)) && void 0 !== o && o.isHost) dL.startBO(h);
            else {
                const e = RT(r);
                e && dL.coHostStartBO(h, e.userId);
            }
            return ip(_c, (e)=>e.controlStatus === qp.InProgress);
        }
        joinRoom(e) {
            const t1 = this[oT](), o = ah(t1), { breakoutRoom: { controlStatus: r, rooms: i, options: { isRoomSelectionEnabled: n }, currentRoom: { status: s, boId: a } }, meeting: { userGUID: d } } = t1;
            if (r !== qp.InProgress) return Promise.reject({
                type: Ql,
                reason: "Breakout room is not started"
            });
            if (null != o && o.isHost) {
                const t1 = i.find((t1)=>t1.boId === e);
                if (!t1) return Promise.reject({
                    type: Zl,
                    reason: "Room ID is not correct"
                });
                dL.joinBO(t1.boId);
            } else if (null != o && o.bCoHost) {
                const o = i.find((t1)=>t1.boId === e);
                if (!o) return Promise.reject({
                    type: Zl,
                    reason: "Room ID is not correct"
                });
                {
                    const o = RT(t1);
                    if (!o) return Promise.reject({
                        type: Kl,
                        reason: "No host in the meeting, cannot join the room"
                    });
                    dL.wantJoinBO(null == o ? void 0 : o.userId, e);
                }
            } else {
                if (s === Qp.InRoom && a === e) return Promise.resolve("");
                {
                    let o = !1;
                    const r = Kk(i, d);
                    if (r && r.boId === e) dL.joinBO(r.boId);
                    else if (n) if (-1 !== i.findIndex((t1)=>t1.boId === e)) {
                        const o = RT(t1);
                        if (!o) return Promise.reject({
                            type: Kl,
                            reason: "No host in the meeting, cannot join the room"
                        });
                        dL.wantJoinBO(o.userId, e);
                    } else o = !0;
                    else o = !0;
                    if (o) return Promise.reject({
                        type: Zl,
                        reason: "Room ID is not correct"
                    });
                }
            }
            return ip(Rc, (t1)=>t1.boId === e);
        }
        leaveRoom() {
            const e = this[oT](), t1 = this[rT], { breakoutRoom: { controlStatus: o, options: r, currentRoom: { status: i } } } = e;
            if (o !== qp.InProgress && o !== qp.Closing || i !== Qp.InRoom) return Promise.reject({
                type: Kl
            });
            {
                const o = dh(e);
                if (!r.isBackToMainSessionEnabled && !o) return Promise.reject({
                    type: Jl,
                    reason: "Can not return main session during the breakout room"
                });
                qk().forEach((e)=>t1(e));
            }
            return Promise.resolve("");
        }
        askForHelp() {
            const e = this[oT](), { breakoutRoom: { controlStatus: t1, mainSessionAttendeeList: o, currentRoom: { status: r } }, participants: { attendeesList: i } } = e, n = dh(e);
            if (t1 !== qp.InProgress || r !== Qp.InRoom) return Promise.reject({
                type: Kl,
                reason: "you are not in breakout room"
            });
            if (n) return Promise.reject({
                type: Kl,
                reason: "host or co-host can not ask for help"
            });
            {
                const e = o.find((e)=>e.isHost);
                if (e) {
                    if (i.findIndex((t1)=>t1.zoomID === e.zoomID) > -1) return Promise.reject({
                        type: Kl,
                        reason: "host is in room"
                    });
                    dL.askForHelpBO(e.userId);
                }
            }
            return ip(Cc, (e)=>e.result === Xp.Received);
        }
        postponeHelping(e) {
            const t1 = this[oT](), o = this[rT], { breakoutRoom: { mainSessionAttendeeList: r, currentRoom: { status: i } }, participants: { attendeesList: n } } = t1;
            let s = n;
            return i === Qp.InRoom && (s = r), s.findIndex((t1)=>t1.userId === e) > -1 ? (dL.askForHelpResultBO(e, Xp.Ignore), o(rf(Xp.Ignore)), Promise.resolve("")) : Promise.reject({
                type: Zl,
                reason: "user id is not correct"
            });
        }
        broadcast(e) {
            const { breakoutRoom: { isEnableBOBroadcast: t1 } } = this[oT]();
            return t1 ? e ? Ts.beginEncrypt({
                text: e,
                type: Cs.BO_BROADCAST
            }).then((e)=>(dL.broadcastBO(e), Promise.resolve(""))) : Promise.reject({
                type: Zl,
                reason: "content empty"
            }) : Promise.reject({
                type: Kl,
                reason: "Cannot broadcast message due to the feature is not enable"
            });
        }
        startBroadcastVoice() {
            const e = this[oT](), t1 = this[rT], { breakoutRoom: { isEnableBOBroadcast: o, isEnableBOBroadcastVoice: r, isBroadcastVoice: i } } = e;
            if (o && r) {
                if (AT(e)) return Promise.reject({
                    type: Kl,
                    reason: "Cannot broadcast voice in the room"
                });
                {
                    if (i) return Promise.resolve("");
                    const o = ah(e);
                    return (null == o ? void 0 : o.audio) === Wd.Computer && !1 === o.muted ? (dL.broadcastVoiceReq(!0), uL.broadcastVoiceToBreakoutRoom(!0), t1(pf(!0)), Promise.resolve("")) : Promise.reject({
                        type: Kl,
                        reason: "Start audio and unmute to broadcast"
                    });
                }
            }
            return Promise.reject({
                type: Kl,
                reason: "Cannot broadcast voice due to the feature is not enable"
            });
        }
        stopBroadcastVoice() {
            const e = this[oT](), t1 = this[rT], { breakoutRoom: { isBroadcastVoice: o } } = e;
            return o ? (dL.broadcastVoiceReq(!1), uL.broadcastVoiceToBreakoutRoom(!1), t1(pf(!1)), Promise.resolve("")) : Promise.reject({
                type: Kl,
                reason: "Cannot stop broadcast voice due to it is not started"
            });
        }
        assignUserToRoom(e, t1) {
            const o = this[oT](), { breakoutRoom: { rooms: r } } = o, i = CT(o).find((t1)=>t1.userId === e);
            if (!(i && r.findIndex((e)=>e.boId === t1) > -1)) return Promise.reject({
                type: Zl,
                reason: ""
            });
            var n;
            if (null !== (n = ah(o)) && void 0 !== n && n.isHost) dL.assignToBO(e, t1);
            else {
                const e = RT(o);
                e && dL.coHostAssignToBO(i.userGUID, t1, e.userId);
            }
            return ip(_c, (e)=>{
                const { controlStatus: o, roomList: r } = e, n = r.find((e)=>e.boId === t1);
                return o === qp.InProgress && n && n.attendeeGuidList.includes(i.userGUID);
            });
        }
        moveUserToRoom(e, t1) {
            const o = this[oT](), { breakoutRoom: { rooms: r, mainSessionAttendeeList: i }, participants: { attendeesList: n } } = o, s = (AT(o) ? i : n).find((t1)=>t1.userId === e);
            if (!s) return Promise.reject({
                type: Zl,
                reason: "user id not correct"
            });
            {
                const i = Kk(r, s.userGUID);
                if (!i) return Promise.reject({
                    type: Kl,
                    reason: "user not in a room"
                });
                if (i.boId === t1) return Promise.reject({
                    type: Kl,
                    reason: "user already in the target room"
                });
                {
                    const i = r.find((e)=>e.boId === t1);
                    if (!i) return Promise.reject({
                        type: Zl,
                        reason: "invalid room id"
                    });
                    var a;
                    if (null !== (a = ah(o)) && void 0 !== a && a.isHost) dL.switchBO(e, i.boId);
                    else {
                        const e = RT(o);
                        e && dL.coHostAssignToBO(s.userGUID, i.boId, e.userId);
                    }
                }
            }
            return ip(_c, (e)=>{
                const { controlStatus: o, roomList: r } = e, i = r.find((e)=>e.boId === t1);
                return o === qp.InProgress && i && i.attendeeGuidList.includes(s.userGUID);
            });
        }
        moveBackToMainSession(e) {
            const t1 = this[oT](), { breakoutRoom: { rooms: o, mainSessionAttendeeList: r }, participants: { attendeesList: i } } = t1, n = (AT(t1) ? r : i).find((t1)=>t1.userId === e);
            if (!n) return Promise.reject({
                type: Zl,
                reason: "user id not correct"
            });
            if (!Kk(o, n.userGUID)) return Promise.reject({
                type: Kl,
                reason: "user not in a room"
            });
            var s;
            if (null !== (s = ah(t1)) && void 0 !== s && s.isHost) dL.moveToMainSession(n.userGUID);
            else {
                const e = RT(t1);
                e && dL.coHostMoveToMainSession(n.userGUID, e.userId);
            }
            return ip(_c, (e)=>{
                const { controlStatus: t1, roomList: o } = e;
                return t1 === qp.InProgress && o.some((e)=>{
                    const { attendeeGuidList: t1 } = e;
                    return t1.includes(n.userGUID);
                });
            });
        }
        closeRoom() {
            const e = this[oT](), { breakoutRoom: { controlStatus: t1 } } = e;
            if (t1 !== qp.InProgress) return Promise.reject({
                type: Kl,
                reason: "room is not started"
            });
            var o;
            if (null !== (o = ah(e)) && void 0 !== o && o.isHost) dL.stopBO(qp.Closing);
            else {
                const t1 = RT(e);
                t1 && dL.coHostStopBO(qp.Closing, t1.userId);
            }
            return ip(_c, (e)=>e.controlStatus === qp.Closing);
        }
        loadPreAssignedRooms() {
            const e = this[oT](), { meeting: { meetingOptions: t1 }, breakoutRoom: { controlStatus: o } } = e;
            return !t1.isAllowBreakoutRoomPreAssign || o !== qp.NotStarted && o !== qp.Closed ? Promise.reject({
                type: Kl
            }) : (dL.preAssignBreakoutRoom(), ip(Oc));
        }
        getUnassignedAttendeeList() {
            const e = this[oT](), t1 = ah(e);
            return null != t1 && t1.isHost || null != t1 && t1.bCoHost ? CT(e).map((e)=>yT(e)) : [];
        }
        getRoomList() {
            const e = this[oT](), { breakoutRoom: { rooms: t1, currentRoom: { status: o, boId: r }, mainSessionAttendeeList: i, inRoomUserActivityStatusMap: n, options: { isRoomSelectionEnabled: s } }, participants: { attendeesList: a } } = e, d = ah(e);
            if (d && (d.isHost || d.bCoHost || s)) {
                const e = o === Qp.InRoom, s = e ? i : a;
                return t1.map((t1)=>{
                    const { attendeeGuidList: o, boId: i, name: a } = t1, u = (o || []).map((e)=>s.find((t1)=>t1.userGUID === e)).filter((e)=>!(null != e && e.isHost)).filter(Boolean);
                    return e && d.isHost && i === r && u.unshift(d), {
                        roomId: i,
                        name: a,
                        attendeeList: u.filter((e)=>!!e).map((e)=>{
                            var t1;
                            const o = null !== (t1 = n[e.userGUID]) && void 0 !== t1 ? t1 : {};
                            return {
                                userId: e.userId,
                                displayName: e.displayName,
                                avatar: e.avatar,
                                isInRoom: e.bid === i,
                                userGuid: e.userGUID,
                                ...o
                            };
                        })
                    };
                });
            }
            return e.breakoutRoom.rooms.map((e)=>{
                const { boId: t1, name: o } = e;
                return {
                    roomId: t1,
                    name: o,
                    attendeeList: []
                };
            });
        }
        getAttendeeStatus() {
            return this[oT]().breakoutRoom.currentRoom.status;
        }
        getRoomStatus() {
            return this[oT]().breakoutRoom.controlStatus;
        }
        getCurrentRoom() {
            const e = this[oT](), { breakoutRoom: { currentRoom: { status: t1, name: o, boId: r } } } = e;
            return {
                attendeeStatus: t1,
                name: o,
                roomId: r
            };
        }
        getRoomOptions() {
            const e = this[oT](), { breakoutRoom: { options: t1 } } = e, { whoStart: o, whoStop: r, ...i } = t1;
            return {
                ...i
            };
        }
    }, eT(aL.prototype, "createRooms", [
        sT,
        aT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "createRooms"), aL.prototype), eT(aL.prototype, "recreateRooms", [
        sT,
        aT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "recreateRooms"), aL.prototype), eT(aL.prototype, "openRooms", [
        sT,
        aT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "openRooms"), aL.prototype), eT(aL.prototype, "joinRoom", [
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "joinRoom"), aL.prototype), eT(aL.prototype, "leaveRoom", [
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "leaveRoom"), aL.prototype), eT(aL.prototype, "askForHelp", [
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "askForHelp"), aL.prototype), eT(aL.prototype, "postponeHelping", [
        dT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "postponeHelping"), aL.prototype), eT(aL.prototype, "broadcast", [
        aT,
        sT
    ], Object.getOwnPropertyDescriptor(aL.prototype, "broadcast"), aL.prototype), eT(aL.prototype, "startBroadcastVoice", [
        dT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "startBroadcastVoice"), aL.prototype), eT(aL.prototype, "stopBroadcastVoice", [
        dT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "stopBroadcastVoice"), aL.prototype), eT(aL.prototype, "assignUserToRoom", [
        aT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "assignUserToRoom"), aL.prototype), eT(aL.prototype, "moveUserToRoom", [
        aT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "moveUserToRoom"), aL.prototype), eT(aL.prototype, "moveBackToMainSession", [
        aT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "moveBackToMainSession"), aL.prototype), eT(aL.prototype, "closeRoom", [
        aT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "closeRoom"), aL.prototype), eT(aL.prototype, "loadPreAssignedRooms", [
        dT,
        sT,
        lL
    ], Object.getOwnPropertyDescriptor(aL.prototype, "loadPreAssignedRooms"), aL.prototype), aL);
    const pL = {
        breakoutRoomSharingEpics0: (e, t1)=>sr(e, Ps).pipe(ot((e)=>{
                var t1;
                const { payload: { body: o } } = e;
                return null == o || null === (t1 = o.update) || void 0 === t1 ? void 0 : t1.some((e)=>void 0 !== e.bShareToBORooms || void 0 !== e.bShareOn);
            }), ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { payload: { body: { update: r } } } = t1, { breakoutRoom: { mainSessionAttendeeList: i } } = o, n = r.filter((e)=>e.bShareOn && e.bShareToBORooms), s = r.filter((e)=>!e.bShareOn || !e.bShareToBORooms), a = i.filter((e)=>e.sharerOn && e.bShareToBORooms);
                return n.length > 0 && n.forEach((e)=>{
                    -1 === a.findIndex((t1)=>t1.userId === e.id) && tp(Cl, {
                        ...e,
                        isFromMainSession: !0
                    });
                }), s.length > 0 && s.forEach((e)=>{
                    tp(_l, {
                        ...e,
                        isFromMainSession: !0
                    });
                }), r.map((e)=>{
                    if (e.bShareOn && e.bShareToBORooms) {
                        if (0 === i.filter((t1)=>t1.sharerOn && t1.bShareToBORooms && t1.userId !== e.id).length) return {
                            activeNodeID: e.id,
                            bStatus: 1,
                            ssrc: e.shareSsrc
                        };
                        {
                            const t1 = i.find((t1)=>t1.userId === e.id);
                            if (null != t1 && t1.isHost) return {
                                activeNodeID: e.id,
                                bStatus: 1,
                                ssrc: e.shareSsrc
                            };
                        }
                    } else if (!e.bShareOn || !e.bShareToBORooms) {
                        const t1 = i.filter((e)=>e.bShareToBORooms && e.sharerOn);
                        if (1 === t1.length && t1[0].userId === e.id) return {
                            activeNodeID: e.id,
                            bStatus: 0,
                            ssrc: 0
                        };
                        {
                            const o = t1.filter((t1)=>t1.userId !== e.id), r = o.find((e)=>e.isHost);
                            if (r) return {
                                activeNodeID: r.userId,
                                bStatus: 1,
                                ssrc: r.shareSsrc
                            };
                            {
                                const e = o[0];
                                if (e) return {
                                    activeNodeID: e.userId,
                                    bStatus: 1,
                                    ssrc: e.shareSsrc
                                };
                            }
                        }
                    }
                }).filter(Boolean);
            }), Fe((e)=>{
                const { share: { status: o }, meeting: { userId: r } } = t1.value, i = [];
                return e.map((e)=>{
                    const { activeNodeID: n, bStatus: s, ssrc: a } = e, d = 1 === s;
                    i.push(_m(d)), d && o !== yd.End && (nL.stopSharing(r), sL.stopDesktopSharing(), i.push(Sm(yd.End)), tp(Al));
                    let u = {
                        activeNodeID: n,
                        bStatus: s,
                        ssrc: a,
                        fromMainSession: !0
                    };
                    if (!d) {
                        const { participants: { attendeesList: e } } = t1.value, o = e.filter((e)=>e.sharerOn);
                        if (o.length > 0) {
                            const e = o[0];
                            u = {
                                activeNodeID: e.userId,
                                bStatus: 1,
                                ssrc: e.shareSsrc || 0
                            };
                        }
                    }
                    i.push(_o({
                        evt: Os,
                        body: u
                    }));
                }), _e(i);
            })),
        breakoutRoomSharingEpics1: (e, t1)=>sr(e, Ns).pipe(ht((o)=>{
                const { payload: { body: { userID: r, confID: i } } } = o;
                return Xe(...[
                    "sharing",
                    "audio"
                ].map((o)=>(function(e, t1, o, r, i) {
                        return sr(t1, "audio" === e ? ks : Ds).pipe(nt(1), vt((t1)=>{
                            const { payload: { body: { encryptKey: n, additionalType: s } } } = t1, { media: { sharingDecodeStatus: a, audioDecodeStatus: d }, meeting: { svcUrl: u, meetingNumber: l, conId: c, zoomId: p, meetingId: h } } = o.value;
                            Iy(e, "success", "audio" === e ? d : a).subscribe((t1)=>{
                                let [, a] = t1;
                                if (a) {
                                    const t1 = `wss://${u}/wc/media/${l}?type=${"audio" === e ? "ma" : "ms"}&cid=${c}&mode=1`;
                                    Gk.createMainSessionChannel(e, t1), Gk.updateMediaParams({
                                        iVType: "audio" === e ? Is.AUDIO_DECODE : Is.SHARING_DECODE,
                                        isFromMainSession: !0,
                                        updateParams: {
                                            userId: r,
                                            sn: zr(p),
                                            confId: i,
                                            encryptType: s,
                                            encryptKey: zr(n),
                                            meetingId: h,
                                            meetingNumber: l
                                        }
                                    });
                                    const { breakoutRoom: { mainSessionAttendeeList: a } } = o.value;
                                    if ((null == a ? void 0 : a.length) > 0) {
                                        const t1 = a.map((e)=>({
                                                userid: e.userId,
                                                sn: e.zoomID && zr(e.zoomID)
                                            }));
                                        Gk.updateUserMediaSN({
                                            added: t1,
                                            isFromMainSession: !0,
                                            iVType: "audio" === e ? Is.AUDIO_DECODE : Is.SHARING_DECODE
                                        });
                                    }
                                }
                            });
                        }), Fe(()=>ne));
                    })(o, e, t1, r, i)));
            }))
    }, hL = {
        epics0: (e, t1)=>e.pipe(Dt(`${bn}`), ht((e)=>{
                const { breakoutRoom: o, meeting: { meetingOptions: r } } = t1.value, { payload: { hugeBO: i, elapsed: n } } = e, s = [];
                return o && (r && (s.push(af(i && !0 === r.isBO100Enabled)), s.push(lf({
                    isEnableBreakoutRoom: r.isEnableBreakoutRoom,
                    isEnableBOBroadcast: r.isEnableBOBroadcast,
                    isEnableBOViewActivityStatus: r.isEnableBOViewActivityStatus,
                    isEnableBOBroadcastVoice: r.isEnableBOBroadcastVoice
                }))), o.currentRoom.boConfId && s.push(To()), void 0 !== n && s.push(Gv(n))), _e(s);
            })),
        epics1: (e)=>nr(e, 4174).pipe(vt((e)=>{
                tp(yc, e.payload.body.bid);
            }), ut(ne)),
        epics2: (e, t1)=>dr(e, 7950).pipe(ft(t1), ht((e)=>{
                let [o, r] = e;
                const { payload: { body: { proto: i } } } = o, { breakoutRoom: { isHugeBO: n, currentRoom: { status: s, boId: a } }, meeting: { userGUID: d } } = r;
                let u = i;
                n && (u = function(e) {
                    if (Hk) return Hk.decode(e);
                    var t1 = function(e) {
                        for(var t1 = "", o = 0;;){
                            var r = e[o++], i = (r > 127) + (r > 223) + (r > 239);
                            if (o + i > e.length) return [
                                t1,
                                _k(e, o - 1)
                            ];
                            i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[o++]) << 12 | (63 & e[o++]) << 6 | 63 & e[o++]) - 65536, t1 += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t1 += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[o++]) : String.fromCharCode((15 & r) << 12 | (63 & e[o++]) << 6 | 63 & e[o++]) : t1 += String.fromCharCode(r);
                        }
                    }(e), o = t1[0];
                    return t1[1].length && wk(8), o;
                }(function(e) {
                    return function(e, t1, o) {
                        var r = e.length;
                        if (!r || o && o.f && !o.l) return t1 || new YM(0);
                        var i = !t1 || o, n = !o || o.i;
                        o || (o = {}), t1 || (t1 = new YM(3 * r));
                        var s = function(e) {
                            var o = t1.length;
                            if (e > o) {
                                var r = new YM(Math.max(2 * o, e));
                                r.set(t1), t1 = r;
                            }
                        }, a = o.f || 0, d = o.p || 0, u = o.b || 0, l = o.l, c = o.d, p = o.m, h = o.n, m = 8 * r;
                        do {
                            if (!l) {
                                a = Ik(e, d, 1);
                                var g = Ik(e, d + 1, 3);
                                if (d += 3, !g) {
                                    var v = e[(w = Ck(d) + 4) - 4] | e[w - 3] << 8, f = w + v;
                                    if (f > r) {
                                        n && wk(0);
                                        break;
                                    }
                                    i && s(u + v), t1.set(e.subarray(w, f), u), o.b = u += v, o.p = d = 8 * f, o.f = a;
                                    continue;
                                }
                                if (1 == g) l = yk, c = bk, p = 9, h = 5;
                                else if (2 == g) {
                                    var y = Ik(e, d, 31) + 257, S = Ik(e, d + 10, 15) + 4, b = y + Ik(e, d + 5, 31) + 1;
                                    d += 14;
                                    for(var E = new YM(b), I = new YM(19), A = 0; A < S; ++A)I[rk[A]] = Ik(e, d + 3 * A, 7);
                                    d += 3 * S;
                                    var C = Ek(I), _ = (1 << C) - 1, R = mk(I, C, 1);
                                    for(A = 0; A < b;){
                                        var w, T = R[Ik(e, d, _)];
                                        if (d += 15 & T, (w = T >>> 4) < 16) E[A++] = w;
                                        else {
                                            var O = 0, D = 0;
                                            for(16 == w ? (D = 3 + Ik(e, d, 3), d += 2, O = E[A - 1]) : 17 == w ? (D = 3 + Ik(e, d, 7), d += 3) : 18 == w && (D = 11 + Ik(e, d, 127), d += 7); D--;)E[A++] = O;
                                        }
                                    }
                                    var P = E.subarray(0, y), M = E.subarray(y);
                                    p = Ek(P), h = Ek(M), l = mk(P, p, 1), c = mk(M, h, 1);
                                } else wk(1);
                                if (d > m) {
                                    n && wk(0);
                                    break;
                                }
                            }
                            i && s(u + 131072);
                            for(var k = (1 << p) - 1, L = (1 << h) - 1, N = d;; N = d){
                                var V = (O = l[Ak(e, d) & k]) >>> 4;
                                if ((d += 15 & O) > m) {
                                    n && wk(0);
                                    break;
                                }
                                if (O || wk(2), V < 256) t1[u++] = V;
                                else {
                                    if (256 == V) {
                                        N = d, l = null;
                                        break;
                                    }
                                    var U = V - 254;
                                    if (V > 264) {
                                        var j = tk[A = V - 257];
                                        U = Ik(e, d, (1 << j) - 1) + sk[A], d += j;
                                    }
                                    var x = c[Ak(e, d) & L], B = x >>> 4;
                                    if (x || wk(3), d += 15 & x, M = uk[B], B > 3 && (j = ok[B], M += Ak(e, d) & (1 << j) - 1, d += j), d > m) {
                                        n && wk(0);
                                        break;
                                    }
                                    i && s(u + 131072);
                                    for(var F = u + U; u < F; u += 4)t1[u] = t1[u - M], t1[u + 1] = t1[u + 1 - M], t1[u + 2] = t1[u + 2 - M], t1[u + 3] = t1[u + 3 - M];
                                    u = F;
                                }
                            }
                            o.l = l, o.p = N, o.b = u, o.f = a, l && (a = 1, o.m = p, o.d = c, o.n = h);
                        }while (!a)
                        return u == t1.length ? t1 : _k(t1, 0, u);
                    }(e.subarray(function(e) {
                        31 == e[0] && 139 == e[1] && 8 == e[2] || wk(6, "invalid gzip data");
                        var t1 = e[3], o = 10;
                        4 & t1 && (o += e[10] | 2 + (e[11] << 8));
                        for(var r = (t1 >> 3 & 1) + (t1 >> 4 & 1); r > 0; r -= !e[o++]);
                        return o + (2 & t1);
                    }(e), -8), new YM(function(e) {
                        var t1 = e.length;
                        return (e[t1 - 4] | e[t1 - 3] << 8 | e[t1 - 2] << 16 | e[t1 - 1] << 24) >>> 0;
                    }(e)));
                }(zr(i))));
                const l = [];
                let c;
                try {
                    const e = JSON.parse(Wr(u)), { ControlStatus: r, NameIndex: i, IsAutoJoinEnabled: n, IsBackToMainSessionEnabled: p, IsParticipantsChooseRoomEnabled: h, IsTimerEnabled: m, TimerDuration: g, IsTimerAutoEndEnabled: v, WaitSeconds: f, StartTimeOnMMR: y, ItemList: S, WhoStart: b, WhoStop: E, IsAutoMovetoMainSessionEnabled: I } = e, A = {
                        isAutoJoinRoom: n,
                        isBackToMainSessionEnabled: p,
                        isTimerEnabled: m,
                        timerDuration: g,
                        isTimerAutoEnabled: v,
                        waitSeconds: f,
                        isAutoMoveBackToMainSession: I,
                        isRoomSelectionEnabled: h,
                        whoStart: b,
                        whoStop: E
                    };
                    l.push(zv(A)), l.push(Kv(y)), l.push(Wv(i)), l.push(qv(r));
                    const C = S && S.map((e)=>({
                            boId: e.BID,
                            name: e.MeetingTitle,
                            boStatus: e.Status,
                            hostId: e.HostID,
                            attendeeGuidList: e.ParticipantList || []
                        })) || [];
                    switch(l.push(Jv(C)), tp(_c, {
                        controlStatus: r,
                        roomList: C
                    }), r){
                        case qp.InProgress:
                            if (s !== Qp.InRoom && s !== Qp.Joining) {
                                const e = function(e, t1) {
                                    const { meeting: { isHost: o, userGUID: r }, breakoutRoom: { currentRoom: { status: i, boId: n } } } = t1.value, s = ns.get($k), a = [];
                                    if (s) try {
                                        const { status: d, boId: u } = JSON.parse(s);
                                        if (d === Qp.Invited) if (o) zk();
                                        else {
                                            const t1 = Kk(e, r);
                                            t1 && (a.push(Yk(t1)), i !== Qp.Initial && n === t1.boId || tp(Sc, {
                                                roomId: t1.boId,
                                                name: t1.name
                                            }));
                                        }
                                        else if (d === Qp.InRoom) {
                                            let i;
                                            if (i = o ? e.find((e)=>e.boId === u) : Kk(e, r), i) {
                                                a.push(Yk(i));
                                                const e = i.boId;
                                                Ay(t1).subscribe(()=>{
                                                    ia.createAgent().joinBO(e);
                                                });
                                            }
                                            zk();
                                        }
                                    } catch (e) {
                                        console.error(e);
                                    }
                                    return a;
                                }(C, t1);
                                if (0 === e.length) {
                                    const e = Kk(C, d);
                                    e && l.push(Yk(e));
                                } else l.push(...e);
                            } else if (s === Qp.InRoom && o.type === `${Do}`) {
                                const e = Kk(C, d);
                                e && Xk(t1).subscribe((t1)=>{
                                    a === e.boId || t1 || rL.joinBO(e.boId);
                                });
                            }
                            A.isTimerEnabled && A.timerDuration > 0 && (c = function(e, t1, o) {
                                return Xk(e).pipe(ft(e), ht((r)=>{
                                    let [i, n] = r;
                                    const { breakoutRoom: { currentRoom: { status: s }, meetingElapsedTime: a }, meeting: { joinMeetingTimeStamp: d } } = n, u = d - 1e3 * a + 1e3 * o + 1e3 * t1;
                                    if (performance.now() < u) {
                                        if (i) return Ye(1e3).pipe(Le(()=>Math.floor((u - performance.now()) / 1e3)), ft(e), gt((e)=>{
                                            let [t1, o] = e;
                                            const { breakoutRoom: { controlStatus: r, currentRoom: { status: i } }, socket: { zoomSocketStatus: n }, meeting: { isHost: s } } = o;
                                            return t1 >= 0 && s && r === qp.InProgress && (i === Qp.InRoom || i === Qp.MainSession || i === Qp.Initial) && n === Sh.Connected;
                                        }), vt((e)=>{
                                            let [t1] = e;
                                            tp(Ec, {
                                                countdown: t1
                                            });
                                        }), ot((e)=>{
                                            let [t1] = e;
                                            return 0 === t1;
                                        }), vt((e)=>{
                                            let [, t1] = e;
                                            const { breakoutRoom: { options: o } } = t1;
                                            o.isTimerAutoEnabled ? ia.createAgent().stopBO(qp.Closing) : tp(wc);
                                        }), Fe(()=>ne));
                                        if (s === Qp.InRoom) return Ye(1e3).pipe(Le(()=>Math.floor((u - performance.now()) / 1e3)), ft(e), gt((e)=>{
                                            let [t1, o] = e;
                                            const { breakoutRoom: { currentRoom: { status: r } }, meeting: { isHost: i }, socket: { zoomSocketStatus: n } } = o;
                                            return t1 >= 0 && r === Qp.InRoom && !i && n === Sh.Connected;
                                        }), vt((e)=>{
                                            let [t1] = e;
                                            tp(Ec, {
                                                countdown: t1
                                            });
                                        }), Fe(()=>ne));
                                    }
                                    return ne;
                                }));
                            }(t1, A.timerDuration, y));
                            break;
                        case qp.Closing:
                            c = Xk(t1).pipe(ot((e)=>e), Fe(()=>{
                                const e = [], { breakoutRoom: { closingRoomTime: o, currentRoom: { status: r } }, participants: { attendeesList: i } } = t1.value;
                                let n = A.waitSeconds;
                                if (0 !== o && A.waitSeconds > 0) {
                                    const e = Math.floor((performance.now() - o) / 1e3);
                                    n = Math.max(A.waitSeconds - e, 0);
                                }
                                if (0 === n) return rL.stopBO(qp.Closed), ne;
                                {
                                    if (r !== Qp.InRoom && i.length > 1 && i.every((e)=>!e.bid)) return rL.stopBO(qp.Closed), ne;
                                    o || e.push(tf(performance.now()));
                                    const s = performance.now() + 1e3 * n;
                                    return Xe(_e(e), Ze(0, 1e3).pipe(Le(()=>Math.floor((s - performance.now()) / 1e3)), ft(t1), gt((e)=>{
                                        let [, t1] = e;
                                        const { breakoutRoom: { controlStatus: o }, meeting: { isHost: r }, socket: { zoomSocketStatus: i } } = t1;
                                        return o === qp.Closing && i === Sh.Connected && r;
                                    }), vt((e)=>{
                                        let [t1] = e;
                                        t1 >= 0 && tp(bc, {
                                            countdown: t1
                                        });
                                    }), ot((e)=>{
                                        let [t1] = e;
                                        return t1 <= 0;
                                    }), vt(()=>{
                                        rL.stopBO(qp.Closed);
                                    }), Fe(()=>ne)));
                                }
                            }));
                            break;
                        case qp.Closed:
                            l.push(tf(0)), s === Qp.Leaving ? l.push(Zv(Qp.MainSession)) : s === Qp.Invited ? l.push(Zv(Qp.Initial)) : s !== Qp.InRoom && s !== Qp.Joining || l.push(...qk()), zk();
                    }
                } catch (e) {
                    console.error(e);
                }
                return c ? Xe(_e(l), c) : _e(l);
            })),
        epics3: (e, t1)=>dr(e, 4194).pipe(ft(t1), ht((e)=>{
                let [t1, o] = e;
                const { payload: { body: { bid: r, botoken: i, confID: n } } } = t1, { meeting: { isHost: s }, breakoutRoom: { rooms: a, currentRoom: { status: d } } } = o, u = [], l = a.find((e)=>e.boId === r);
                return l && (u.push(Yk(l, s)), u.push(Yv(n)), u.push(Xv(i)), s || d !== Qp.InRoom ? u.push(...Jk(l.name, d)) : u.push(...Qk(l.name))), tp(Rc, {
                    boId: r
                }), _e(u);
            })),
        epics4: (e, t1)=>e.pipe(Dt(`${_o}`, `${Do}`), ot((e)=>7949 === e.payload.evt), ft(t1), Fe((e)=>{
                var o;
                let [r, i] = e;
                const { payload: { body: n } } = r, { meeting: { userGUID: s }, breakoutRoom: { rooms: a, options: { isAutoJoinRoom: d, isAutoMovetoMainSession: u }, currentRoom: { status: l }, mainSessionAttendeeList: c }, participants: { attendeesList: p } } = i, { commandType: h } = n, m = [];
                let g;
                const v = null === (o = (Zk(l) ? p : c).find((e)=>e.userGUID === s)) || void 0 === o ? void 0 : o.userId;
                switch(h){
                    case Zp.Join:
                        {
                            const { targetBID: e, botoken: t1, confID: o, joinReason: r, requestSourceID: u } = n, l = Kk(a, s);
                            if (l && l.boId === e) {
                                m.push(Yv(o)), m.push(Xv(t1));
                                const n = Number(r) === th.Active && v === Number(u);
                                d || n ? (n && tp(Rc, {
                                    boId: e
                                }), m.push(...Jk(l.name))) : (ns.set(ss.WebclientBreakoutRoomCommand, h, rs.SessionStorage), tp(Sc, {
                                    roomId: e,
                                    name: l.name,
                                    ...oL(u, i)
                                }));
                            }
                            break;
                        }
                    case Zp.Switch:
                        {
                            const { targetBID: e, botoken: t1, confID: o, joinMethod: r, requestSourceID: u } = n, c = Kk(a, s);
                            if (c && c.boId === e) {
                                m.push(Qv({
                                    boId: c.boId,
                                    boToken: t1,
                                    boConfId: o,
                                    name: c.name
                                }));
                                const n = v === Number(u) && Number(r) === eh.AskToLeave;
                                l === Qp.Invited ? (ns.set(ss.WebclientBreakoutRoomCommand, h, rs.SessionStorage), d || v === Number(u) ? m.push(...Jk(c.name)) : tp(Sc, {
                                    roomId: e,
                                    name: c.name,
                                    ...oL(u, i)
                                })) : m.push(...Qk(c.name)), n && tp(Rc, {
                                    boId: e
                                });
                            }
                            break;
                        }
                    case Zp.Leave:
                        {
                            const { waitTime: e, joinMethod: o } = n;
                            if (Zk(l)) m.push(Qv({
                                boId: "",
                                boToken: "",
                                boConfId: "",
                                status: Qp.Initial
                            }));
                            else {
                                const r = Number(e);
                                if (r > 0) {
                                    const e = performance.now() + 1e3 * r;
                                    g = Ze(0, 1e3).pipe(Le(()=>Math.floor((e - performance.now()) / 1e3)), ft(t1), gt((e)=>{
                                        let [t1, o] = e;
                                        const { breakoutRoom: { controlStatus: r, currentRoom: { status: i } }, meeting: { isHost: n }, socket: { zoomSocketStatus: s } } = o;
                                        return t1 >= 0 && s === Sh.Connected && r === qp.Closing && i === Qp.InRoom && !n;
                                    }), vt((e)=>{
                                        let [t1] = e;
                                        t1 >= 0 && tp(bc, {
                                            countdown: t1
                                        });
                                    }), ut(ne));
                                } else if (Number(o) !== eh.AskToLeave || u) m.push(...qk());
                                else {
                                    var f, y, S;
                                    const { requestSourceID: e } = n, t1 = Number(e), { participants: { attendeesList: o } } = i;
                                    let r = o.find((e)=>e.userId === t1);
                                    if (!r) {
                                        const { breakoutRoom: { mainSessionAttendeeList: e } } = i;
                                        r = e.find((e)=>e.userId === t1);
                                    }
                                    tp(Pc, {
                                        inviterId: null === (f = r) || void 0 === f ? void 0 : f.userId,
                                        inviterGuid: null === (y = r) || void 0 === y ? void 0 : y.userGUID,
                                        inviterName: null === (S = r) || void 0 === S ? void 0 : S.displayName
                                    });
                                }
                                zk();
                            }
                            break;
                        }
                    case Zp.Broadcast:
                        {
                            const { textContent: e, requestID: t1 } = n;
                            if (e) {
                                const { meeting: { encType: o }, participants: { attendeesList: r }, breakoutRoom: { mainSessionAttendeeList: n } } = i;
                                let s = "";
                                if (o === As.AES_GCM) {
                                    const e = (Zk(l) ? r : n).find((e)=>e.userId === Number(t1));
                                    e && (s = e.zoomID);
                                }
                                g = _e(Ts.beginDecrypt({
                                    decryptedText: e,
                                    type: Cs.BO_BROADCAST,
                                    zoomId: s
                                }).then((e)=>{
                                    let { message: t1 } = e;
                                    return tp(Ic, {
                                        message: t1
                                    }), of(t1);
                                }));
                            }
                            break;
                        }
                    case Zp.HelpReq:
                        {
                            const { requestID: e } = n, { breakoutRoom: { mainSessionAttendeeList: t1, rooms: o, currentRoom: { boId: r }, hostReplyToQuestionerType: s, hostReplyToRequestId: a }, participants: { attendeesList: d } } = i;
                            if (e) {
                                if (l === Qp.InRoom) {
                                    const o = t1.find((t1)=>t1.userId === e);
                                    if (o && o.bid === r) {
                                        rL.askForHelpResultBO(e, Xp.AlreadyInRoom);
                                        break;
                                    }
                                }
                                if (s === Xp.Received && a !== e) rL.askForHelpResultBO(e, Xp.Busy);
                                else {
                                    rL.askForHelpResultBO(e, Xp.Received), m.push(rf(Xp.Received), nf(e));
                                    const r = (l === Qp.InRoom ? t1 : d).find((t1)=>t1.userId === e);
                                    if (r) {
                                        const t1 = r.bid, i = o.find((e)=>e.boId === t1);
                                        i && tp(Ac, {
                                            userId: e,
                                            userGuid: r.userGUID,
                                            displayName: r.displayName,
                                            roomName: i.name,
                                            roomId: i.boId
                                        });
                                    }
                                }
                            }
                            break;
                        }
                    case Zp.HelpRes:
                        {
                            const { helpResult: e } = n;
                            tp(Cc, {
                                result: Number(e)
                            });
                            break;
                        }
                    case Zp.BOActivity:
                        {
                            var b;
                            const { activityRoster: e, activityTalking: t1, requestID: o } = n, r = null === (b = (AT(i) ? i.breakoutRoom.mainSessionAttendeeList : i.participants.attendeesList).find((e)=>e.userId === o)) || void 0 === b ? void 0 : b.userGUID;
                            if (r) {
                                const { breakoutRoom: { rooms: n } } = i, s = Kk(n, r), a = function(e, t1) {
                                    const o = {
                                        isTalking: 1 === t1
                                    };
                                    return tL.forEach((t1)=>{
                                        const { mask: r, key: i, value: n } = t1;
                                        return (r & e) === r && Object.assign(o, {
                                            [`${i}`]: n
                                        }), o;
                                    }), o;
                                }(Number(e), Number(t1));
                                m.push(cf({
                                    userGuid: r,
                                    status: a
                                })), tp(Mc, {
                                    ...a,
                                    userId: o,
                                    userGuid: r,
                                    roomId: null == s ? void 0 : s.boId,
                                    roomName: null == s ? void 0 : s.name
                                });
                            }
                            break;
                        }
                }
                return g ? Xe(_e(m), g) : _e(m);
            })),
        epics5: (e, t1)=>sr(e, Ns).pipe(ft(t1), ht((e)=>{
                let [t1, o] = e;
                const { payload: { body: { res: r, elapsed: i } } } = t1, n = [];
                return r === li.MeetingHasClosed || r === li.UserHasBeenRemoved ? (zk(), n.push(...Gy(o, !1))) : r === li.Success && (n.push(Gv(i)), n.push(Zv(Qp.InRoom)), ns.set(ss.WebclientBreakoutRoomAttendeeStatus, JSON.stringify({
                    status: Qp.InRoom,
                    boId: o.breakoutRoom.currentRoom.boId
                }), rs.SessionStorage)), _e(n);
            })),
        epics6: (e)=>sr(e, Ps).pipe(Le((e)=>xA(e.payload.body)), Fe((e)=>{
                const t1 = [
                    sf(e)
                ];
                return tp(Dc), _e(t1);
            })),
        epics7: (e, t1)=>sr(e, Ps).pipe(Le((e)=>xA(e.payload.body)), Le((e)=>{
                const t1 = [];
                return [
                    "add",
                    "update"
                ].forEach((o)=>e[o] && t1.push(...e[o])), t1.filter((e)=>[
                        ...iL,
                        "bAudioUnencrytped"
                    ].some((t1)=>void 0 !== e[t1]));
            }), ot((e)=>e.length > 0), Ie(ee), Fe((e)=>{
                const o = [], { participants: { attendeesList: r }, breakoutRoom: { mainSessionAttendeeList: i, isUserRoleUpdated: n }, meeting: { userId: s } } = t1.value, a = e.map((e)=>{
                    const t1 = i.find((t1)=>t1.userId === e.userId), a = r.find((e)=>e.userGUID === (null == t1 ? void 0 : t1.userGUID));
                    if (a) {
                        if (void 0 !== e.bCCEditor && o.push(Rv({
                            editorId: e.bCCEditor ? a.userId : "",
                            isEditor: !!e.bCCEditor,
                            editorZoomId: e.bCCEditor ? a.zoomID : ""
                        })), delete e.bRaiseHand, delete e.bCapsPinMultiVideo, !n && a.userId === s) {
                            const r = {};
                            $p(e.userRole) ? Object.assign(r, e) : (i.some((e)=>e.isHost) || void 0 !== e.bAudioUnencrytped) && Object.assign(r, t1), void 0 !== r.userId && (o.push(uf(!0)), tp(Tc, e));
                        }
                        return {
                            ...e,
                            userId: a.userId
                        };
                    }
                }).filter((e)=>!!e && iL.some((t1)=>void 0 !== e[t1]));
                return a.length > 0 && (tp(ga, a), o.push(bp({
                    update: a
                }))), _e(o);
            })),
        epics8: (e)=>sr(e, Ms).pipe(ot((e)=>{
                const { payload: { body: t1 } } = e;
                return void 0 !== (null == t1 ? void 0 : t1.bAllowAttendeeRename) || void 0 !== (null == t1 ? void 0 : t1.chatPriviledge) || void 0 !== (null == t1 ? void 0 : t1.lockShare);
            }), Le((e)=>{
                const { payload: { body: t1 } } = e;
                return void 0 !== t1.bAllowAttendeeRename ? En(e.payload.body) : void 0 !== t1.chatPriviledge ? pv(t1.chatPriviledge) : void 0 !== t1.lockShare ? hm(t1.lockShare) : void 0;
            })),
        epics9: (e, t1)=>nr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [, t1] = e;
                const { meeting: { isHost: o }, breakoutRoom: { controlStatus: r, currentRoom: { status: i } } } = t1;
                return o && r === qp.Closing && i !== Qp.InRoom;
            }), Ie(ee), vt(()=>{
                const { participants: { attendeesList: e } } = t1.value;
                e.every((e)=>!e.bid) && e.length > 1 && rL.stopBO(qp.Closed);
            }), ut(ne)),
        epics10: (e, t1)=>nr(e, 4214).pipe(ft(t1), ht((e)=>{
                let [o, r] = e;
                const { payload: { body: { proto: i } } } = o, { breakoutRoom: { rooms: n, isHugeBO: s } } = r;
                try {
                    const e = JSON.parse(Wr(i)), o = [];
                    if (e && e.PreAssignBoList && Array.isArray(e.PreAssignBoList)) {
                        const r = e.PreAssignBoList.map((e)=>({
                                name: e.BoName,
                                emails: e.email
                            }));
                        o.push(df(r));
                        const i = s ? 100 : 50;
                        if (n.length + r.length < i) {
                            const e = r.map((e)=>e.name);
                            return rL.batchCreateBOToken(e), Xe(_e(o), eL(e.length).pipe(ft(t1), Fe((e)=>{
                                let [{ boIdList: t1 }, o] = e;
                                const i = ph(o), n = r.map((e, o)=>{
                                    const { emails: r, name: n } = e;
                                    let s = [];
                                    return r && Array.isArray(r) && (s = r.map((e)=>i.filter((t1)=>t1.userEmail === e).map((e)=>e.userGUID)).reduce((e, t1)=>[
                                            ...e,
                                            ...t1
                                        ], [])), {
                                        boId: t1[o],
                                        name: n,
                                        attendeeGuidList: s
                                    };
                                }), s = n.map((e, t1)=>({
                                        roomId: e.boId,
                                        name: e.name,
                                        emails: r[t1].emails
                                    }));
                                return tp(Oc, {
                                    rooms: s
                                }), _e([
                                    Jv(n),
                                    df(s)
                                ]);
                            })));
                        }
                        return _e(o);
                    }
                } catch (e) {
                    console.error("pre assign proto is not valid");
                }
                return ne;
            })),
        epics11: (e, t1)=>dr(e, Ps).pipe(ft(t1), ot((e)=>{
                let [t1, o] = e;
                const { meeting: { isHost: r, meetingStatus: i, meetingOptions: n }, breakoutRoom: { controlStatus: s } } = o, { payload: { body: a } } = t1;
                return i === Xn.Joined && (null == n ? void 0 : n.isAllowBreakoutRoomPreAssign) && r && (s === qp.NotStarted || s === qp.InProgress) && Array.isArray(a.add);
            }), Fe((e)=>{
                let [t1, o] = e;
                const { breakoutRoom: { controlStatus: r, rooms: i, preAssignedRooms: n, currentRoom: { status: s } }, participants: { failoverAttendeesList: a } } = o, d = null == n ? void 0 : n.filter((e)=>i.findIndex((t1)=>t1.boId === e.roomId) > -1), { payload: { body: { add: u } } } = t1, l = [];
                return d.length > 0 && u.filter((e)=>e.userEmail && e.userGUID).filter((e)=>-1 === a.findIndex((t1)=>t1.zoomID === e.zoomID)).forEach((e)=>{
                    if (!Kk(i, e.userGUID)) for(let o = 0; o < (null == d ? void 0 : d.length); o++){
                        const n = d[o];
                        if (n.emails.includes(e.userEmail)) {
                            if (r === qp.NotStarted) {
                                const t1 = OI(i, (t1)=>{
                                    const o = t1.find((e)=>e.boId === n.roomId);
                                    null == o || o.attendeeGuidList.push(e.userGUID);
                                });
                                l.push(Jv(t1));
                            } else r === qp.InProgress && (s === Qp.InRoom && t1.type === `${Do}` ? rL.assignToBO(e.id, String(n.roomId)) : s !== Qp.Initial && s !== Qp.MainSession || rL.assignToBO(e.id, String(n.roomId)));
                            break;
                        }
                    }
                }), _e(l);
            })),
        epics12: (e, t1)=>nr(e, Ps).pipe(ot((e)=>{
                const { breakoutRoom: { mainSessionAttendeeList: o } } = t1.value, { payload: { body: r } } = e;
                return o.length > 0 && (void 0 !== r.add || void 0 !== r.update);
            }), Ie(te), Le((e)=>xA(e.payload.body)), Fe((e)=>{
                const { breakoutRoom: { mainSessionAttendeeList: o, isUserRoleUpdated: r }, participants: { attendeesList: i } } = t1.value;
                let n = [];
                const s = [];
                [
                    "add",
                    "update"
                ].forEach((t1)=>e[t1] && n.push(...e[t1]));
                const a = [
                    ...iL,
                    "isHost"
                ];
                n = n.filter((e)=>a.some((t1)=>void 0 !== e[t1]));
                const d = n.filter((e)=>void 0 !== e.zoomID);
                return n = n.map((e)=>{
                    var t1, n, u, l;
                    const c = null !== (t1 = null !== (n = e.zoomID) && void 0 !== n ? n : null === (u = d.find((t1)=>t1.userId === e.userId)) || void 0 === u ? void 0 : u.zoomID) && void 0 !== t1 ? t1 : null === (l = i.find((t1)=>t1.userId === e.userId)) || void 0 === l ? void 0 : l.zoomID;
                    if (c) {
                        const t1 = o.find((e)=>e.zoomID === c);
                        if (t1) return r || (s.push(uf(!0)), tp(Tc, t1)), Object.keys(e).filter((t1)=>Object.prototype.hasOwnProperty.call(e, t1)).filter((e)=>a.includes(e)).reduce((o, r)=>{
                            const i = t1[r];
                            if (void 0 !== i || "bCoHost" === r) {
                                const t1 = "boolean" == typeof e[r] ? !!i : i;
                                Object.assign(o, {
                                    [r]: t1
                                });
                            }
                            return o;
                        }, {
                            userId: e.userId
                        });
                    }
                }).filter(Boolean), n.length > 0 && (tp(ga, n), s.push(bp({
                    update: n
                }))), _e(s);
            })),
        epics13: (e)=>sr(e, 7999).pipe(vt((e)=>{
                const { payload: { body: { bStatus: t1 } } } = e;
                tp(kc, {
                    status: !!t1
                });
            }), Fe(()=>ne)),
        epics14: (e, t1)=>nr(e, 7940).pipe(Fe((e)=>{
                const { payload: { body: { bHost: o } } } = e, { breakoutRoom: { isBroadcastVoice: r } } = t1.value, i = [];
                return !o && r && (ca.getInstance().broadcastVoiceToBreakoutRoom(!1), i.push(pf(!1))), _e(i);
            }))
    }, mL = ir(hL, pL);
    let gL = function(e) {
        return e[e.Ready = 0] = "Ready", e[e.UserSub = 1] = "UserSub", e[e.ManualCaptionerEnabled = 2] = "ManualCaptionerEnabled", e[e.ManualCaptionerDisabled = 3] = "ManualCaptionerDisabled", e;
    }({}), vL = function(e) {
        return e[e.Unspecified = -1] = "Unspecified", e[e.English = 0] = "English", e[e["Chinese (Simplified)"] = 1] = "Chinese (Simplified)", e[e.Japanese = 2] = "Japanese", e[e.German = 3] = "German", e[e.French = 4] = "French", e[e.Russian = 5] = "Russian", e[e.Portuguese = 6] = "Portuguese", e[e.Spanish = 7] = "Spanish", e[e.Korean = 8] = "Korean", e[e.Italian = 9] = "Italian", e[e.Reserved = 10] = "Reserved", e[e.Vietnamese = 11] = "Vietnamese", e[e.Dutch = 12] = "Dutch", e[e.Ukrainian = 13] = "Ukrainian", e[e.Arabic = 14] = "Arabic", e[e["Chinese (Traditional)"] = 16] = "Chinese (Traditional)", e[e.Czech = 17] = "Czech", e[e.Estonian = 18] = "Estonian", e[e.Finnish = 19] = "Finnish", e[e.Hebrew = 21] = "Hebrew", e[e.Hindi = 22] = "Hindi", e[e.Hungarian = 23] = "Hungarian", e[e.Indonesian = 24] = "Indonesian", e[e.Malay = 25] = "Malay", e[e.Persian = 26] = "Persian", e[e.Polish = 27] = "Polish", e[e.Romanian = 28] = "Romanian", e[e.Swedish = 29] = "Swedish", e[e.Tamil = 30] = "Tamil", e[e.Telugu = 31] = "Telugu", e[e.Tagalog = 32] = "Tagalog", e[e.Turkish = 33] = "Turkish", e[e["French (Canada)"] = 34] = "French (Canada)", e[e.Danish = 35] = "Danish", e[e.Thai = 37] = "Thai", e[e.Cantonese = 44] = "Cantonese", e[e.NoTranslation = 400] = "NoTranslation", e[e.DefaultManualInput = 401] = "DefaultManualInput", e[e.Customized = 500] = "Customized", e;
    }({}), fL = function(e) {
        return e[e.Unknown = 0] = "Unknown", e[e.Close = 1] = "Close", e[e.New = 2] = "New", e[e.Insert = 3] = "Insert", e[e.Delete = 4] = "Delete", e[e.Reset = 5] = "Reset", e[e.Audiodesc = 6] = "Audiodesc", e[e.Speaker = 7] = "Speaker", e[e.Error = 8] = "Error", e;
    }({}), yL = function(e) {
        return e[e.TranslateNotSupport = 1] = "TranslateNotSupport", e;
    }({}), SL = function(e) {
        return e[e.Unspecified = 0] = "Unspecified", e[e.InMeetingManual = 1] = "InMeetingManual", e[e.ExternalCaptioner = 2] = "ExternalCaptioner", e[e.ASR = 4] = "ASR", e;
    }({});
    const bL = {
        en: 0,
        zh: 1,
        ja: 2,
        de: 3,
        fr: 4,
        ru: 5,
        pt: 6,
        es: 7,
        ko: 8,
        it: 9,
        en1: 10,
        vi: 11,
        nl: 12,
        uk: 13,
        ar: 14,
        "zh-hant": 16,
        cs: 17,
        et: 18,
        fi: 19,
        he: 21,
        hi: 22,
        hu: 23,
        id: 24,
        ms: 25,
        fa: 26,
        pl: 27,
        ro: 28,
        sv: 29,
        ta: 30,
        te: 31,
        tl: 32,
        tr: 33,
        "fr-ca": 34,
        da: 35,
        th: 37,
        "zh-yue": 44,
        ca: 48
    }, EL = Object.keys(vL).filter((e)=>/\d+/.test(vL[e])).reduce((e, t1)=>({
            ...e,
            [`${vL[t1]}`]: t1
        }), {}), IL = Object.keys(bL).reduce((e, t1)=>(Object.assign(e, {
            [`${bL[`${t1}`]}`]: t1
        }), e), {}), AL = "zoom-sdk-live-trasncription", CL = "live-trasncription";
    let _L = function(e) {
        return e[e.English = 0] = "English", e[e.Chinese = 1] = "Chinese", e[e.Japanese = 2] = "Japanese", e[e.German = 3] = "German", e[e.French = 4] = "French", e[e.Russian = 5] = "Russian", e[e.Portuguese = 6] = "Portuguese", e[e.Spanish = 7] = "Spanish", e[e.Korean = 8] = "Korean", e[e.Italian = 9] = "Italian", e[e.Reserved = 10] = "Reserved", e[e.Vietnamese = 11] = "Vietnamese", e[e.Dutch = 12] = "Dutch", e[e.Ukrainian = 13] = "Ukrainian", e[e.Arabic = 14] = "Arabic", e[e["Chinese (Traditional)"] = 16] = "Chinese (Traditional)", e[e.Czech = 17] = "Czech", e[e.Estonian = 18] = "Estonian", e[e.Finnish = 19] = "Finnish", e[e.Hebrew = 21] = "Hebrew", e[e.Hindi = 22] = "Hindi", e[e.Hungarian = 23] = "Hungarian", e[e.Indonesian = 24] = "Indonesian", e[e.Malay = 25] = "Malay", e[e.Persian = 26] = "Persian", e[e.Polish = 27] = "Polish", e[e.Romanian = 28] = "Romanian", e[e.Swedish = 29] = "Swedish", e[e.Tamil = 30] = "Tamil", e[e.Telugu = 31] = "Telugu", e[e.Tagalog = 32] = "Tagalog", e[e.Turkish = 33] = "Turkish", e[e["French (Canada)"] = 34] = "French (Canada)", e[e.Danish = 35] = "Danish", e[e.Thai = 37] = "Thai", e[e.Cantonese = 44] = "Cantonese", e[e.Catalan = 48] = "Catalan", e[e.NoTranslation = 400] = "NoTranslation", e[e.DefaultManualInput = 401] = "DefaultManualInput", e;
    }({}), RL = function(e) {
        return e.English = "en", e["Chinese (Simplified)"] = "zh", e.Japanese = "ja", e.German = "de", e.French = "fr", e.Russian = "ru", e.Portuguese = "pt", e.Spanish = "es", e.Korean = "ko", e.Italian = "it", e.Reserved = "en1", e.Vietnamese = "vi", e.Dutch = "nl", e.Ukrainian = "uk", e.Arabic = "ar", e["Chinese (Traditional)"] = "zh-hant", e.Czech = "cs", e.Estonian = "et", e.Finnish = "fi", e.Hebrew = "he", e.Hindi = "hi", e.Hungarian = "hu", e.Indonesian = "id", e.Malay = "ms", e.Persian = "fa", e.Polish = "pl", e.Romanian = "ro", e.Swedish = "sv", e.Tamil = "ta", e.Telugu = "te", e.Tagalog = "tl", e.Turkish = "tr", e["French (Canada)"] = "fr-ca", e.Danish = "da", e.Thai = "th", e.Cantonese = "zh-yue", e.Catalan = "ca", e;
    }({});
    function wL(e) {
        const t1 = e === vL.Unspecified ? vL.Reserved : e;
        ca.getInstance().selectLanguageChannelForNewLTT(t1);
    }
    const TL = Np(Lp, function(e, t1) {
        return JR(e, t1);
    })([
        ph,
        (e)=>{
            let { meeting: { gatewayUserList: t1 } } = e;
            return t1;
        }
    ], (e, t1)=>{
        const o = {};
        return e.forEach((e)=>{
            Object.assign(o, {
                [`${e.userId}`]: e.zoomID
            });
        }), null == t1 || t1.forEach((e)=>{
            Object.assign(o, {
                [`${e.userId}`]: e.sn
            });
        }), o;
    }), OL = Vp([
        ph
    ], (e)=>e.find((e)=>!0 === e.bCCEditor)), DL = Vp([
        ph,
        jp
    ], (e, t1)=>e.some((e)=>!0 === e.bCCEditor && e.userId === t1)), PL = ia.createAgent(), ML = {
        isEnableTranslatedCaptions: !1,
        isHostLockSpeakingLanguage: !1,
        transcriptionLang: [],
        isEnableAutomatedCaptions: !1,
        supportedTranscriptionLanguage: [],
        isLiveTranscriptionEnabled: !1,
        isHostDisableCaptions: !1,
        isManualCaptionerEnabled: !1,
        gatewayId: void 0,
        isLiveTranscriptionSubscribed: !1,
        messageRecords: [],
        isRecordsReduced: !1,
        reducedRecordsCount: 0
    }, kL = bo({
        [`${Uf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isLiveTranscriptionEnabled = o;
        }),
        [`${jf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { transcriptionLang: r, translatedSetting: i, ...n } = o;
            r && (e.transcriptionLang = r.split(";").map((e)=>{
                const t1 = e && bL[e];
                return void 0 !== t1 ? {
                    lang: e,
                    code: t1
                } : null;
            }).filter(Boolean)), i && (e.translatedSetting = Object.keys(i).map((e)=>{
                const t1 = i[e];
                if (t1) {
                    const o = t1.split(";").map((e)=>{
                        const t1 = e && bL[e];
                        return void 0 !== t1 ? {
                            lang: e,
                            code: t1
                        } : null;
                    }).filter(Boolean);
                    return {
                        lang: e,
                        code: bL[e],
                        translatedToLanguage: o
                    };
                }
                return null;
            }).filter(Boolean)), Object.assign(e, n);
        }),
        [`${xf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isManualCaptionerEnabled = o;
        }),
        [`${Bf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.gatewayId = o;
        }),
        [`${Yf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isHostDisableCaptions = o;
        }),
        [`${Ff}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.supportedTranscriptionLanguage = o;
        }),
        [`${$f}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.currentTranscriptionLang = o;
        }),
        [`${Wf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.currentTranslationLang = o;
        }),
        [`${Gf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.messageRecords.push(o);
        }),
        [`${Kf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const r = e.messageRecords.find((e)=>e.msgId === o.msgId);
            r && Object.assign(r, o);
        }),
        [`${zf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            const { remains: r, reducedRecordsCount: i } = o, n = e.messageRecords.length - r;
            e.isRecordsReduced = !0, e.reducedRecordsCount = i, e.messageRecords.splice(0, n);
        }),
        [`${Hf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isLiveTranscriptionSubscribed = o;
        }),
        [`${qf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.liveTransEngineType = o;
        }),
        [`${Jf}`]: OI((e)=>{
            e.stateBeforeFailover = void 0;
        }),
        [`${Qf}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.lastManualCaption = o;
        }),
        [`${Zf}`]: (e, t1)=>{
            let { payload: o } = t1;
            return o ? {
                ...ML,
                stateBeforeFailover: {
                    currentTranscriptionLang: e.currentTranscriptionLang,
                    currentTranslationLang: e.currentTranslationLang,
                    isLiveTranscriptionSubscribed: e.isLiveTranscriptionSubscribed
                },
                messageRecords: e.messageRecords,
                isRecordsReduced: e.isRecordsReduced,
                reducedRecordsCount: e.reducedRecordsCount
            } : {
                ...ML
            };
        }
    }, ML);
    var LL;
    const NL = ia.createAgent(), VL = mT("Live transcription");
    let UL = (LL = class extends vT {
        startLiveTranscription() {
            const { [oT]: e, [rT]: t1 } = this, { liveTranscription: { isLiveTranscriptionEnabled: o, isEnableTranslatedCaptions: r, isLiveTranscriptionSubscribed: i, isHostLockSpeakingLanguage: n, isHostDisableCaptions: s } } = e();
            return i ? Promise.resolve("") : s ? Promise.reject({
                type: Kl,
                reason: "Captions has been disabled by host."
            }) : o ? (NL.enableNewLLT(), ip(Pa).then(()=>(n ? NL.setSpokenLanguage(vL.English) : wL(vL.Unspecified), t1($f(vL.English)), r && NL.setTranslationLanguage(), ip({
                    event: Pa,
                    operations: [
                        ot((e)=>!0 === e.autoCaption && void 0 !== e.lang)
                    ]
                })))) : Promise.reject({
                type: Kl,
                reason: "Live transcription is not enabled."
            });
        }
        disableCaptions(e) {
            const { [oT]: t1 } = this, { liveTranscription: { isHostDisableCaptions: o } } = t1();
            return e ? o ? Promise.resolve() : (NL.disableCaptions(!0), ip(ka)) : o ? (NL.disableCaptions(!1), ip(ka)) : Promise.resolve();
        }
        setSpeakingLanguage(e) {
            const { [oT]: t1, [rT]: o } = this, { liveTranscription: { isLiveTranscriptionSubscribed: r, isHostLockSpeakingLanguage: i, transcriptionLang: n } } = t1(), s = n.find((t1)=>t1.lang === e);
            if (s) {
                const { code: e } = s;
                return r ? (i ? NL.setSpokenLanguage(e) : wL(e), o($f(e)), Promise.resolve("")) : Promise.reject({
                    type: Kl,
                    reason: "Cannot set speaking language before starting live transcription"
                });
            }
            return Promise.reject({
                type: Zl,
                reason: "Unsupported transcription language"
            });
        }
        setTranslationLanguage(e) {
            const { [oT]: t1, [rT]: o } = this, r = t1(), { liveTranscription: { isEnableTranslatedCaptions: i, isLiveTranscriptionSubscribed: n, translatedSetting: s, currentTranscriptionLang: a } } = r;
            if (!i) return Promise.reject({
                type: Kl,
                reason: "Live translation is not enabled."
            });
            if (!n) return Promise.reject({
                type: Kl,
                reason: "Cannot set translation language before starting live transcription"
            });
            if (e) {
                const t1 = null == s ? void 0 : s.find((e)=>e.code === a);
                if (t1) {
                    const { translatedToLanguage: o } = t1, r = o.find((t1)=>t1.lang === e);
                    if (r) return NL.setTranslationLanguage(r.code), ip({
                        event: Pa,
                        operations: [
                            ot((e)=>!0 === e.autoCaption && e.lang === r.code),
                            nt(1)
                        ]
                    }, (e)=>{
                        let { lang: t1 } = e;
                        return t1 === r.code;
                    });
                }
                return Promise.reject({
                    type: Kl,
                    reason: `Cannot support translating ${EL[a || 0]} to ${e}`
                });
            }
            return NL.setTranslationLanguage(), o(Wf(void 0)), Promise.resolve("");
        }
        enableManualCaptioner() {
            const { [oT]: e } = this, { meeting: { meetingOptions: t1 }, liveTranscription: { isManualCaptionerEnabled: o, isHostDisableCaptions: r } } = e();
            if (r) return Promise.reject({
                type: Kl,
                reason: "Captions has been disabled by host."
            });
            const { isEnableManualCaptions: i, isEnableClosedCaption: n } = t1;
            return (null != i ? i : n) ? o ? Promise.resolve() : (NL.enableManualCaption(!0), ip(Pa, (e)=>{
                let { autoCaption: t1 } = e;
                return !1 === t1;
            })) : Promise.reject({
                type: Kl,
                reason: "Manual caption is not enabled."
            });
        }
        disableManualCaptioner() {
            const { [oT]: e } = this, { liveTranscription: { isManualCaptionerEnabled: t1 } } = e();
            return t1 ? (NL.enableManualCaption(!1), ip(Pa, (e)=>{
                let { autoCaption: t1 } = e;
                return !0 === t1;
            })) : Promise.resolve();
        }
        assignManualCaption(e) {
            var t1;
            const { [oT]: o } = this, r = o(), { liveTranscription: { isManualCaptionerEnabled: i }, participants: { attendeesList: n }, meeting: { userId: s } } = r;
            if (!i) return Promise.reject({
                type: Kl,
                reason: "Cannot assign caption editor due to the manual captioner is not enabled."
            });
            if ((null === (t1 = OL(r)) || void 0 === t1 ? void 0 : t1.userId) === e) return Promise.resolve("");
            const a = n.find((t1)=>t1.userId === e);
            return a ? (NL.assignCC(e, !0), ip({
                event: s === e ? ha : ga,
                operations: [
                    ot((t1)=>t1.userId === e),
                    nt(1)
                ]
            }, (e)=>!0 === e.bCCEditor)) : Promise.reject({
                type: Zl,
                reason: "Cannot find the user"
            });
        }
        sendCaptionTextManually(e, t1) {
            var o;
            const { [oT]: r, [rT]: i } = this, n = r(), { liveTranscription: { lastManualCaption: s }, meeting: { userId: a } } = n, d = ah(n);
            let u = Promise.resolve();
            const l = null === (o = OL(n)) || void 0 === o ? void 0 : o.userId;
            return null != d && d.isHost && l !== a && (u = this.assignManualCaption(a)), u.then(()=>DL(r()) ? function(e, t1, o) {
                    const r = e.length, i = [];
                    var n;
                    if (o) i.push({
                        op: "close",
                        text: e,
                        msgId: null !== (n = null == t1 ? void 0 : t1.msgId) && void 0 !== n ? n : Qr()
                    });
                    else if (t1 && null != t1 && t1.text) {
                        const o = t1.text.length;
                        let n = 0, s = 0;
                        for(; e[n] === t1.text[n] && n < r;)s += qr(e[n]), n += 1;
                        n === o && n === r ? i.push({
                            op: "same"
                        }) : n === o && n < r ? i.push({
                            op: "insert",
                            text: e.slice(n),
                            size: 0,
                            pos: s,
                            msgId: t1.msgId
                        }) : n < o && n === r ? i.push({
                            op: "delete",
                            size: 0,
                            pos: s,
                            msgId: t1.msgId
                        }) : (i.push({
                            op: "delete",
                            size: 0,
                            pos: s,
                            msgId: t1.msgId
                        }), i.push({
                            op: "insert",
                            text: e.slice(n),
                            pos: s,
                            msgId: t1.msgId
                        }));
                    } else r > 0 && i.push({
                        op: "start",
                        text: e,
                        pos: 0,
                        size: 0,
                        msgId: Qr()
                    });
                    return i.filter((e)=>"same" !== e.op);
                }(e, s, t1) : Promise.reject({
                    type: Jl,
                    reason: "Cannot type caption "
                })).then((e)=>Array.isArray(e) ? (e.forEach((e)=>{
                    const { text: o, ...r } = e;
                    Ts.beginEncrypt({
                        text: null != o ? o : "",
                        type: Cs.CC_MESSAGE
                    }).then((n)=>{
                        NL.sendManualCaption({
                            text: n,
                            ...r
                        });
                        const s = t1 ? void 0 : {
                            text: o,
                            msgId: e.msgId
                        };
                        i(Qf(s));
                    });
                }), ip(Da, (e)=>e.source === SL.InMeetingManual)) : "");
        }
        getLiveTranscriptionStatus() {
            const { [oT]: e } = this, { liveTranscription: { isLiveTranscriptionEnabled: t1, isEnableTranslatedCaptions: o, isManualCaptionerEnabled: r, transcriptionLang: i, translatedSetting: n, isHostDisableCaptions: s } } = e();
            return {
                isLiveTranscriptionEnabled: t1,
                isLiveTranslationEnabled: o,
                isHostDisableCaptions: s,
                isManualCaptionerEnabled: r,
                transcriptionLanguage: i.map((e)=>e.lang).join(";"),
                translationLanguage: null == n ? void 0 : n.map((e)=>({
                        speakingLanguage: e.lang,
                        translatedToLanguage: e.translatedToLanguage.map((e)=>e.lang).join(";")
                    }))
            };
        }
        getLiveTranscriptionSetting() {
            const { [oT]: e } = this, { meeting: { meetingOptions: t1 } } = e(), { isEnableManualCaptions: o, isEnableLiveTranscription: r, isEnableClosedCaption: i, isEnableAllowThirdPartyCCToken: n, isEnableViewFullTranscript: s, isEnableSaveCaptions: a } = t1 || {};
            return {
                isEnableManualCaptions: o,
                isEnableLiveTranscription: r,
                isEnableClosedCaption: i,
                isEnableAllowThirdPartyCCToken: n,
                isEnableViewFullTranscript: s,
                isEnableSaveCaptions: a
            };
        }
        getCurrentTranscriptionLanguage() {
            const { [oT]: e } = this, { liveTranscription: { currentTranscriptionLang: t1 } } = e();
            return void 0 !== t1 ? {
                code: IL[t1],
                name: EL[t1]
            } : null;
        }
        getCurrentTranslationLanguage() {
            const { [oT]: e } = this, { liveTranscription: { currentTranslationLang: t1 } } = e();
            return void 0 !== t1 ? {
                code: IL[t1],
                name: EL[t1]
            } : null;
        }
        getLatestTranscription() {
            const { [oT]: e } = this, { liveTranscription: { messageRecords: t1, isManualCaptionerEnabled: o } } = e(), r = o ? vL.DefaultManualInput : vL.NoTranslation, i = t1.filter((e)=>e.language === r);
            return i.length ? i[i.length - 1].text : "";
        }
        getLatestTranslation() {
            const { [oT]: e } = this, { liveTranscription: { messageRecords: t1, currentTranslationLang: o, isEnableTranslatedCaptions: r } } = e();
            if (r || void 0 !== o) {
                const e = t1.filter((e)=>e.language === o);
                return e.length ? e[e.length - 1].text : "";
            }
            return "";
        }
        getFullTranscriptionHistory() {
            const { [oT]: e } = this, t1 = e(), { liveTranscription: { messageRecords: o, isRecordsReduced: r } } = t1;
            return r ? (function(e) {
                return void 0 !== window.indexedDB ? new Promise((t1)=>{
                    const o = window.indexedDB.open(AL, 1);
                    o.addEventListener("success", ()=>{
                        const r = o.result;
                        if (r.objectStoreNames.contains(CL)) {
                            const o = r.transaction([
                                CL
                            ], "readonly").objectStore(CL), i = [], n = e.meeting.meetingId, s = o.openCursor();
                            s.onsuccess = ()=>{
                                const e = s.result;
                                e ? (e.value.mid === n && i.push(...e.value.records), e.continue()) : (t1(i), r.close());
                            };
                        } else t1("");
                    });
                }) : Promise.resolve("");
            })(t1).then((e)=>Array.isArray(e) ? e.concat(o) : [
                    ...o
                ]) : [
                ...o
            ];
        }
        getManualCaptionEditor() {
            const { [oT]: e } = this, t1 = e(), { closedCaption: { editorId: o } } = t1;
            let r;
            if (!o) return {};
            if (r = ph(t1).find((e)=>e.userId === o), !r) return {};
            const { userId: i, isHost: n, displayName: s, avatar: a, bCoHost: d, zoomID: u } = r;
            return {
                userId: i,
                isHost: n,
                displayName: s,
                avatar: a,
                bCoHost: d,
                zoomID: u
            };
        }
        getManualCaptionUrl() {
            const { [oT]: e } = this, { meeting: { meetingOptions: t1, ccUrl: o } } = e(), { isEnableManualCaptions: r } = t1 || {};
            return r ? o : (console.warn("you not enable manual caption"), "");
        }
    }, eT(LL.prototype, "startLiveTranscription", [
        sT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "startLiveTranscription"), LL.prototype), eT(LL.prototype, "disableCaptions", [
        dT,
        sT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "disableCaptions"), LL.prototype), eT(LL.prototype, "setSpeakingLanguage", [
        sT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "setSpeakingLanguage"), LL.prototype), eT(LL.prototype, "setTranslationLanguage", [
        sT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "setTranslationLanguage"), LL.prototype), eT(LL.prototype, "enableManualCaptioner", [
        dT,
        sT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "enableManualCaptioner"), LL.prototype), eT(LL.prototype, "disableManualCaptioner", [
        dT,
        sT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "disableManualCaptioner"), LL.prototype), eT(LL.prototype, "assignManualCaption", [
        sT,
        dT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "assignManualCaption"), LL.prototype), eT(LL.prototype, "sendCaptionTextManually", [
        sT,
        VL
    ], Object.getOwnPropertyDescriptor(LL.prototype, "sendCaptionTextManually"), LL.prototype), LL);
    const jL = {
        epics0: (e)=>e.pipe(Dt(`${pn}`), Le((e)=>{
                const { payload: { liveTranscription: t1 } } = e;
                return jf(t1);
            })),
        epics1: (e, t1)=>nr(e, Ms).pipe(ot((e)=>{
                var t1, o;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.NewLttAvaliable) || void 0 !== (null === (o = e.payload.body) || void 0 === o ? void 0 : o.LiveTransEngineType);
            }), Le((e)=>{
                const { payload: { body: { NewLttAvaliable: o, LiveTransEngineType: r } } } = e, { liveTranscription: { isEnableAutomatedCaptions: i } } = t1.value;
                return void 0 !== o ? (tp(Ma, !!o), Uf(i && !!o)) : qf(r);
            })),
        epics2: (e, t1)=>nr(e, 7982).pipe(Fe((e)=>{
                const { payload: { body: { status: o, gwId: r } } } = e, i = [];
                switch(o){
                    case gL.Ready:
                        i.push(Bf(r));
                        break;
                    case gL.ManualCaptionerEnabled:
                        tp(Pa, {
                            autoCaption: !1
                        }), i.push(xf(!0));
                        break;
                    case gL.ManualCaptionerDisabled:
                        tp(Pa, {
                            autoCaption: !0
                        }), i.push(Rv({
                            editorId: "",
                            isEditor: !1,
                            editorZoomId: ""
                        })), i.push(xf(!1));
                        break;
                    case gL.UserSub:
                        {
                            tp(Pa, {
                                autoCaption: t1.value.liveTranscription.isLiveTranscriptionEnabled
                            });
                            const { liveTranscription: { stateBeforeFailover: e } } = t1.value;
                            if (null != e && e.isLiveTranscriptionSubscribed) {
                                var n;
                                PL.enableNewLLT();
                                const t1 = null !== (n = e.currentTranscriptionLang) && void 0 !== n ? n : vL.Unspecified;
                                wL(t1), i.push($f(t1)), void 0 !== e.currentTranslationLang && PL.setTranslationLanguage(e.currentTranslationLang), i.push(Jf());
                            }
                            break;
                        }
                }
                return _e(i);
            })),
        epics3: (e)=>nr(e, 7984).pipe(Le((e)=>{
                const { payload: { body: { langs: t1 } } } = e;
                return Ff(t1);
            })),
        epics4: (e)=>nr(e, 8011).pipe(Fe((e)=>{
                const { payload: { body: { disabled: t1 } } } = e, o = [];
                return tp(ka, t1), o.push(Yf(t1)), t1 && o.push(Hf(!1)), _e(o);
            })),
        epics5: (e)=>nr(e, 7985).pipe(ot((e)=>{
                var t1;
                return !0 === (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.success);
            }), Fe((e)=>{
                const { payload: { body: { src: t1, lang: o, success: r } } } = e, i = [];
                return r && i.push(Hf(!0)), t1 === SL.ASR ? (o === vL.NoTranslation ? i.push(Wf(void 0)) : i.push(Wf(o)), tp(Pa, {
                    autoCaption: !0,
                    lang: o
                })) : [
                    SL.InMeetingManual,
                    SL.ExternalCaptioner
                ].includes(t1) && tp(Pa, {
                    autoCaption: !1
                }), _e(i);
            })),
        epics6: (e, t1)=>nr(e, 7986).pipe(ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const r = ah(o), { liveTranscription: { currentTranscriptionLang: i } } = o, { payload: { body: n } } = t1, s = [];
                if (void 0 !== (null == n ? void 0 : n.lang)) {
                    const { lang: e } = n;
                    "computer" === (null == r ? void 0 : r.audio) && i !== e && wL(e), s.push($f(e));
                }
                return _e(s);
            })),
        epics7: (e, t1)=>ur(e, sd.JoinComputerAudioComplete).pipe(ot(()=>t1.value.liveTranscription.isLiveTranscriptionSubscribed), vt(()=>{
                const { liveTranscription: { currentTranscriptionLang: e } } = t1.value;
                e && wL(e);
            }), ut(ne)),
        epics8: (e, t1)=>nr(e, 7983).pipe(ot((e)=>void 0 !== e.payload.body), Fe((e)=>{
                const { payload: { body: { msgType: o, errorCode: r, language: i, source: n, content: s, keyNodeId: a, msgId: d, nodeId: u, pos: l, size: c, audioLanguage: p } } } = e;
                if (o === fL.Error) {
                    if (r === yL.TranslateNotSupport) {
                        const { liveTranscription: { currentTranslationLang: e } } = t1.value;
                        e && tp(Da, {
                            error: yL.TranslateNotSupport,
                            errorMessage: `${EL[p]} to ${EL[e]} translation is not supported!`,
                            audioLanguage: p,
                            translationLang: e
                        });
                    }
                } else {
                    const e = t1.value, r = ph(e), { liveTranscription: { isManualCaptionerEnabled: p } } = e;
                    if (p && n === SL.ASR) return Promise.resolve();
                    if (function(e, t1) {
                        const { liveTranscription: { isEnableTranslatedCaptions: o, isLiveTranscriptionEnabled: r }, meeting: { meetingOptions: i } } = t1, { isEnableManualCaptions: n, isEnableAllowHostAssignTypeCC: s, isEnableClosedCaption: a, isEnableAllowThirdPartyCCToken: d } = i;
                        return e === SL.ASR ? o || r : e === SL.InMeetingManual ? n && s || void 0 === n && a : e === SL.ExternalCaptioner ? d : void 0;
                    }(n, e) && s && a) {
                        const h = TL(e)[a];
                        if (h) return Ts.beginDecrypt({
                            decryptedText: s,
                            type: Cs.CC_MESSAGE,
                            zoomId: h
                        }).then((e)=>{
                            let { message: s } = e;
                            const { liveTranscription: { messageRecords: a } } = t1.value, h = [], m = a.find((e)=>e.msgId === d);
                            if (m) {
                                const { text: e } = m, t1 = ((e, t1)=>{
                                    if (!e || 0 === t1) return "";
                                    let o = 0;
                                    for(let r = 0; r < e.length; r++)if (o += qr(e[r]), o === t1) return e.slice(0, r + 1);
                                    return e;
                                })(e, l);
                                let r;
                                o === fL.Insert && 0 === c || o === fL.Delete && 0 === c ? r = {
                                    ...m,
                                    text: t1 + s,
                                    msgType: o
                                } : o === fL.Close && (r = {
                                    ...m,
                                    text: s,
                                    msgType: o,
                                    done: !0
                                }), r && (h.push(Kf(r)), tp(Da, r));
                            } else if ([
                                fL.New,
                                fL.Close
                            ].includes(o) || p && o === fL.Insert) {
                                const e = r.find((e)=>e.userId === u), t1 = {
                                    msgId: d,
                                    userId: u,
                                    displayName: null == e ? void 0 : e.displayName,
                                    avatar: null == e ? void 0 : e.avatar,
                                    text: s,
                                    source: n,
                                    language: i,
                                    timestamp: (new Date).getTime(),
                                    done: o === fL.Close
                                };
                                h.push(Gf({
                                    ...t1,
                                    msgType: o
                                })), tp(Da, t1);
                            }
                            return h;
                        });
                    }
                }
                return Promise.resolve();
            }), Fe((e)=>Array.isArray(e) ? _e(e) : ne)),
        epics9: (e, t1)=>e.pipe(Dt(`${Gf}`), Ie(ee), Fe(()=>{
                const { liveTranscription: { messageRecords: e } } = t1.value;
                return e.length >= 1e5 ? function(e) {
                    const { meeting: { meetingId: t1 }, liveTranscription: { messageRecords: o, reducedRecordsCount: r } } = e;
                    return void 0 !== window.indexedDB ? new Promise((e)=>{
                        const i = window.indexedDB.open(AL, 1);
                        i.addEventListener("upgradeneeded", ()=>{
                            const e = i.result;
                            if (!e.objectStoreNames.contains(CL)) {
                                const t1 = e.createObjectStore(CL, {
                                    keyPath: [
                                        "startIndex",
                                        "mid"
                                    ],
                                    autoIncrement: !1
                                });
                                t1.createIndex("mid", "mid", {
                                    unique: !1
                                }), t1.transaction.oncomplete = ()=>{
                                    console.log(`Create objectStore [${CL}] complete`);
                                };
                            }
                        }), i.addEventListener("success", ()=>{
                            const n = i.result, s = o.length, a = .9 * s, d = s - a, u = o.slice(0, a), l = r + u.length, c = n.transaction([
                                CL
                            ], "readwrite");
                            c.objectStore(CL).put({
                                startIndex: r,
                                mid: t1,
                                records: u
                            }), c.oncomplete = ()=>{
                                e(zf({
                                    remains: d,
                                    reducedRecordsCount: l
                                })), n.close();
                            }, c.onerror = ()=>{
                                e(""), n.close();
                            };
                        });
                    }) : Promise.resolve("");
                }(t1.value) : Promise.resolve("");
            }), ot((e)=>"object" == typeof e)),
        epics10: (e, t1)=>e.pipe(Dt(`${an}`, `${un}`), ot(()=>t1.value.liveTranscription.isRecordsReduced), vt(()=>{
                !function() {
                    if (void 0 !== window.indexedDB) {
                        const e = window.indexedDB.open(AL, 1);
                        e.addEventListener("success", ()=>{
                            const t1 = e.result;
                            t1.objectStoreNames.contains(CL) && (window.indexedDB.deleteDatabase(AL), t1.close());
                        });
                    }
                }();
            }), ut(ne)),
        epics11: (e, t1)=>ur(e, [
                sd.AudiobridgeSetCcLangSuccess,
                sd.AudiobridgeSetCcLangFailure
            ]).pipe(Fe((e)=>{
                const { payload: { type: o, data: r } } = e, { liveTranscription: { currentTranscriptionLang: i } } = t1.value, n = [];
                return o === sd.AudiobridgeSetCcLangSuccess && r !== i ? n.push($f(r)) : o === sd.AudiobridgeSetCcLangFailure && n.push($f(void 0)), _e(n);
            }))
    }, xL = ir(jL), BL = {
        isLiveStreamEnable: !1,
        status: 0
    }, FL = bo({
        [`${py}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.isLiveStreamEnable = o;
        }),
        [`${hy}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.status = o;
        }),
        [`${my}`]: (e, t1)=>{
            let { payload: o } = t1;
            return o ? {
                ...e
            } : {
                ...BL
            };
        }
    }, BL);
    let HL = function(e) {
        return e[e.Ended = 0] = "Ended", e[e.InProgress = 1] = "InProgress", e[e.Connecting = 2] = "Connecting", e[e.Timeout = 3] = "Timeout", e;
    }({});
    var $L;
    const WL = ia.createAgent();
    let GL = (eT(($L = class extends vT {
        startLiveStream(e, t1, o) {
            const { [oT]: r, [rT]: i } = this, { liveStream: { isLiveStreamEnable: n, status: s } } = r();
            return s === HL.InProgress ? Promise.reject({
                type: Kl,
                reason: "Live stream is already on"
            }) : n ? e && t1 && o ? (WL.startLiveStream(e, t1, o), ip({
                event: Kc,
                operations: [
                    ot((e)=>e === HL.InProgress),
                    nt(1)
                ]
            }, void 0, 3e4).then(()=>"").catch(()=>{
                const { liveStream: { status: e } } = r();
                return e === HL.Connecting ? (tp(Kc, HL.Timeout), i(hy(HL.Timeout)), Promise.reject({
                    type: zl
                })) : Promise.resolve("");
            })) : Promise.reject({
                type: Zl,
                reason: "parameter cannot be empty"
            }) : Promise.reject({
                type: Kl,
                reason: "Live stream is not enabled"
            });
        }
        stopLiveStream() {
            const { [oT]: e, [rT]: t1 } = this, { liveStream: { status: o } } = e();
            return o === HL.InProgress && (WL.stopLiveStream(), tp(Kc, HL.Ended), t1(hy(HL.Ended))), Promise.resolve("");
        }
        isLiveStreamEnabled() {
            var e;
            const { [oT]: t1 } = this;
            return !(null === (e = t1().liveStream) || void 0 === e || !e.isLiveStreamEnable);
        }
        getLiveStreamStatus() {
            var e;
            const { [oT]: t1 } = this;
            return null === (e = t1().liveStream) || void 0 === e ? void 0 : e.status;
        }
    }).prototype, "startLiveStream", [
        dT
    ], Object.getOwnPropertyDescriptor($L.prototype, "startLiveStream"), $L.prototype), eT($L.prototype, "stopLiveStream", [
        dT
    ], Object.getOwnPropertyDescriptor($L.prototype, "stopLiveStream"), $L.prototype), $L);
    const KL = ir({
        epics0: (e)=>e.pipe(Dt(`${pn}`), Le((e)=>{
                const { payload: { liveStreamInfo: t1 } } = e;
                return py(!(null == t1 || !t1.isEnabledLiveStream));
            })),
        epics1: (e)=>nr(e, 7970).pipe(Le((e)=>{
                const { payload: { body: { channelName: t1, liveStreamOn: o, isApiCall: r, status: i, viewerUrl: n } } } = e;
                return tp(Kc, i), hy(i);
            }))
    }), { setSummaryEnable: zL, setSmartSummaryStatus: qL, resetSummary: JL } = go("SET_SUMMARY_ENABLE", "SET_SMART_SUMMARY_STATUS", "RESET_SUMMARY"), { setMeetingQueryEnable: QL, setMeetingQueryStatus: ZL } = go("SET_MEETING_QUERY_ENABLE", "SET_MEETING_QUERY_STATUS");
    let YL = function(e) {
        return e.Default = "", e.Start = "Start", e.Paused = "Paused", e.Stopped = "Stopped", e;
    }({}), XL = function(e) {
        return e[e.GW_IND_NONE = 0] = "GW_IND_NONE", e[e.GW_IND_START = 1] = "GW_IND_START", e[e.GW_IND_PAUSE = 2] = "GW_IND_PAUSE", e[e.GW_IND_STOP = 3] = "GW_IND_STOP", e;
    }({}), eN = function(e) {
        return e.Default = "", e.Start = "Start", e.Paused = "Paused", e.Stopped = "Stopped", e;
    }({}), tN = function(e) {
        return e[e.GW_IND_NONE = 0] = "GW_IND_NONE", e[e.GW_IND_START = 1] = "GW_IND_START", e[e.GW_IND_PAUSE = 2] = "GW_IND_PAUSE", e[e.GW_IND_STOP = 3] = "GW_IND_STOP", e;
    }({});
    const oN = {
        summaryStatus: XL.GW_IND_STOP,
        summaryEnable: !1,
        meetingQueryStatus: tN.GW_IND_STOP,
        meetingQueryEnable: !1
    }, rN = bo({
        [`${zL}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.summaryEnable = o;
        }),
        [`${qL}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.summaryStatus = o;
        }),
        [`${QL}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.meetingQueryEnable = o;
        }),
        [`${ZL}`]: OI((e, t1)=>{
            let { payload: o } = t1;
            e.meetingQueryStatus = o;
        }),
        [`${JL}`]: ()=>({
                ...oN
            })
    }, oN);
    var iN, nN, sN, aN, dN;
    const uN = ia.createAgent();
    let lN = (iN = uT("summary"), nN = uT("summary"), sN = uT("summary"), aN = uT("summary"), eT((dN = class extends vT {
        startSummary() {
            const e = this[oT](), { summary: { summaryEnable: t1, summaryStatus: o } } = e;
            return t1 ? o === XL.GW_IND_START ? Promise.resolve("") : (uN.summaryMeeting(!0), ip(Hc, (e)=>e.status === YL.Start)) : Promise.reject({
                type: Kl,
                reason: "The account of the meeting disabled the smart summary"
            });
        }
        stopSummary() {
            const e = this[oT](), { summary: { summaryStatus: t1 } } = e;
            return t1 !== XL.GW_IND_START ? Promise.resolve("not start summary, do nothing") : (uN.summaryMeeting(!1), ip(Hc, (e)=>e.status === YL.Stopped));
        }
        getSummaryStatus() {
            const e = this[oT](), { summary: { summaryStatus: t1 } } = e;
            return t1 === XL.GW_IND_START ? YL.Start : t1 === XL.GW_IND_STOP ? YL.Stopped : YL.Default;
        }
        isSummaryEnabled() {
            const e = this[oT](), { summary: { summaryEnable: t1 } } = e;
            return t1;
        }
        startMeetingQuery() {
            const e = this[oT](), { summary: { meetingQueryEnable: t1, meetingQueryStatus: o } } = e;
            return t1 ? o === tN.GW_IND_START ? Promise.resolve("") : (uN.startMeetingQuery(!0), ip($c, (e)=>e.status === eN.Start)) : Promise.reject({
                type: Kl,
                reason: "The account of the meeting disabled the smart summary"
            });
        }
        stopMeetingQuery() {
            const e = this[oT](), { summary: { meetingQueryStatus: t1 } } = e;
            return t1 !== tN.GW_IND_START ? Promise.resolve("not start meeting query, do nothing") : (uN.startMeetingQuery(!1), ip($c, (e)=>e.status === eN.Stopped));
        }
        getMeetingQueryStatus() {
            const e = this[oT](), { summary: { meetingQueryStatus: t1 } } = e;
            return t1 === tN.GW_IND_START ? eN.Start : t1 === tN.GW_IND_STOP ? eN.Stopped : eN.Default;
        }
        isMeetingQueryEnabled() {
            const e = this[oT](), { summary: { meetingQueryEnable: t1 } } = e;
            return t1;
        }
    }).prototype, "startSummary", [
        dT,
        sT,
        iN
    ], Object.getOwnPropertyDescriptor(dN.prototype, "startSummary"), dN.prototype), eT(dN.prototype, "stopSummary", [
        dT,
        sT,
        nN
    ], Object.getOwnPropertyDescriptor(dN.prototype, "stopSummary"), dN.prototype), eT(dN.prototype, "startMeetingQuery", [
        dT,
        sT,
        sN
    ], Object.getOwnPropertyDescriptor(dN.prototype, "startMeetingQuery"), dN.prototype), eT(dN.prototype, "stopMeetingQuery", [
        dT,
        sT,
        aN
    ], Object.getOwnPropertyDescriptor(dN.prototype, "stopMeetingQuery"), dN.prototype), dN);
    const cN = ir({
        moduleEpics0: (e)=>nr(e, 8007).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.supported);
            }), Le((e)=>{
                const { supported: t1 } = e.payload.body;
                return tp(Hc, {
                    supported: t1
                }), zL(t1);
            })),
        moduleEpics1: (e, t1)=>nr(e, 8008).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.status);
            }), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { status: r } = t1.payload.body, { summary: { summaryStatus: i } } = o, n = [];
                if (r !== i) switch(r){
                    case XL.GW_IND_START:
                        tp(Hc, {
                            status: YL.Start
                        });
                        break;
                    case XL.GW_IND_PAUSE:
                        tp(Hc, {
                            status: YL.Paused
                        });
                        break;
                    case XL.GW_IND_STOP:
                        tp(Hc, {
                            status: YL.Stopped
                        });
                        break;
                    default:
                        tp(Hc, {
                            status: ""
                        });
                }
                return n.push(qL(r)), _e(n);
            })),
        moduleEpics2: (e, t1)=>nr(e, 8015).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.supported);
            }), ft(t1), Le((e)=>{
                let [t1, o] = e;
                const { supported: r } = t1.payload.body;
                tp($c, {
                    supported: r
                });
                const { meeting: { zlkJwtToken: i } } = o;
                if (i) {
                    const { auto_transcription: e } = oi(i);
                    e && (r ? ia.createAgent().startMeetingQuery(!0) : console.warn("You account don't support auto transcription"));
                }
                return QL(r);
            })),
        moduleEpics3: (e, t1)=>nr(e, 8016).pipe(ot((e)=>{
                var t1;
                return void 0 !== (null === (t1 = e.payload.body) || void 0 === t1 ? void 0 : t1.status);
            }), ft(t1), Fe((e)=>{
                let [t1, o] = e;
                const { status: r } = t1.payload.body, { summary: { meetingQueryStatus: i } } = o, n = [];
                if (r !== i) switch(r){
                    case tN.GW_IND_START:
                        tp($c, {
                            status: eN.Start
                        });
                        break;
                    case tN.GW_IND_PAUSE:
                        tp($c, {
                            status: eN.Paused
                        });
                        break;
                    case tN.GW_IND_STOP:
                        tp($c, {
                            status: eN.Stopped
                        });
                        break;
                    default:
                        tp($c, {
                            status: ""
                        });
                }
                return n.push(ZL(r)), _e(n);
            }))
    });
    var pN;
    const hN = {
        chat: {
            epic: lO,
            reducer: nO,
            Client: dO
        },
        logger: {
            epic: gD,
            reducer: cD,
            Client: class extends vT {
                getLogs(e) {
                    return uD.getLogs(this[tT], e);
                }
                getStore() {
                    return uD.doNotUseDirtyGetStore();
                }
                setLogOptions(e) {
                    e && this[tT].dispatch(uy(e));
                }
                isAutoReportInAccountSettingEnabled() {
                    const { meeting: { zlkJwtToken: e, enableAutoLog: t1, collectionToggleEnable: o, zsk: r } } = this[tT].getState();
                    return !!e || (r ? t1 && o : t1);
                }
                reportMeetingProblem(e) {
                    var t1;
                    const { product: o, problem: r, timeOfOccurrence: i, description: n, ticket: s, isLogIncluded: a } = e, { meeting: { userId: d, confId: u, conId: l, svcUrl: c } } = this[tT].getState(), p = `'product':${o}\n'problem':${r}\n'timeOfOccurrence':${i}\n'description':${n}\n'ticketID':${s}\n'isLogIncluded':${a ? "Logs included" : ""}\n'nodeId':${d}\n'confId':${u}\n'conId':${l}\n'svcUrl':${c}`, h = [
                        "REPORT_NOTIFICATION"
                    ];
                    return null === (t1 = uD.makeLogger(h).logWithExtraProperties("", {
                        IM_NOTIFICATION: `${p}\nTrackingId:${uD.trackingId}`
                    })) || void 0 === t1 ? void 0 : t1.then(()=>{
                        uD.reportToGlobalTracing(a ? void 0 : h, !0);
                    });
                }
                reportToGlobalTracing(e) {
                    return uD.reportToGlobalTracing(e, !0);
                }
                reportRating(e, t1) {
                    const { meeting: o, media: r, socket: i } = this[tT].getState();
                    if (o) {
                        var n, s, a, d;
                        const { zlkJwtToken: u, meetingStatus: l } = o, { assetsPath: c, enforceMultipleVideos: p, enforceVirtualBackground: h, disableRenderLimits: m } = r;
                        uD.report(`rating:${e}, feedback:${t1}, appKey:${u ? null === (n = oi(u)) || void 0 === n ? void 0 : n.app_key : ""}, CPU:${navigator.hardwareConcurrency}, GPU:${null !== (s = gs.gpu) && void 0 !== s ? s : ""}, browser:${gs.browser} ${gs.browserVersion}, OS:${gs.os} ${gs.osVersion}, SharedArrayBuffer:${!!gs.isSupportSharedArrayBuffer},\n         assetPath:${c},\n          enforceMultipleVideos:${p},\n          disableRenderLimits:${m},\n          enforceVirtualBackground:${h}, ${l === Xn.Joined ? `session duration:${Math.floor((performance.now() - (null !== (a = null == o ? void 0 : o.pingRWCTimestamp) && void 0 !== a ? a : 0)) / 1e3)}, rwg:${null == i || null === (d = i.rwgServerList) || void 0 === d || null === (d = d[i.retryCount]) || void 0 === d ? void 0 : d.rwg}, failover count:${null == o ? void 0 : o.failover.count}` : ""}`, "User Rating", "info"), Number(e) <= 2 && this.reportToGlobalTracing();
                    }
                    return Promise.resolve();
                }
            }
        },
        recording: {
            epic: MD,
            reducer: yD,
            Client: DD
        },
        cmd: {
            epic: zD,
            reducer: HD,
            Client: WD
        },
        breakoutRoom: {
            epic: mL,
            reducer: ZM,
            Client: cL
        },
        liveTranscription: {
            epic: xL,
            reducer: kL,
            Client: UL
        },
        liveStream: {
            epic: KL,
            reducer: FL,
            Client: GL
        },
        summary: {
            epic: cN,
            reducer: rN,
            Client: lN
        }
    }, mN = ia.createAgent();
    let gN = (pN = class extends MT {
        constructor(e){
            super(e), this.mediaStream = void 0, this[iT] = hN;
        }
        getMediaStream() {
            return void 0 === this.mediaStream && (this.mediaStream = new JM(this[tT])), this.mediaStream;
        }
        joinInstant(e, t1, o, r, i, n) {
            const { [oT]: s, [rT]: a } = this, { meeting: { lang: d, meetingStatus: u }, socket: { zoomSocketStatus: l } } = s();
            return t1 ? u !== Xn.Joined && l === Sh.Closed ? (a(rn({
                topic: e,
                password: i || "",
                userName: o,
                zlk: t1,
                lang: d,
                cv: r
            })), n && a(Vn(n)), rp(Ta.JoinMeeting)) : Promise.reject({
                type: Kl,
                reason: "duplicated operation"
            }) : Promise.reject({
                type: Kl,
                reason: "invalid  signature"
            });
        }
        removeUser(e) {
            const t1 = this[tT].getState(), { participants: { attendeesList: o } } = t1, r = o.find((t1)=>t1.userId === e);
            return r ? (mN.expel(e), ip(va, (t1)=>t1.some((t1)=>t1.userId === e))) : Promise.reject({
                type: Zl,
                reason: "no matched user"
            });
        }
    }, eT(pN.prototype, "removeUser", [
        aT,
        sT
    ], Object.getOwnPropertyDescriptor(pN.prototype, "removeUser"), pN.prototype), pN);
    class vN {
        constructor(e){
            this.instant = void 0, this.context = void 0, this.script = void 0, this.mic = void 0, this.instant = 0, this.context = e, this.mic = null, this.script = e.createScriptProcessor(2048, 1, 1), this.script.onaudioprocess = (e)=>{
                const t1 = e.inputBuffer.getChannelData(0);
                let o, r = 0;
                for(o = 0; o < t1.length; ++o)r += t1[o] * t1[o];
                this.instant = Math.sqrt(r / t1.length);
            };
        }
        connectToSource(e) {
            console.log("InputMicDetector is listening");
            try {
                var t1;
                this.mic = this.context.createMediaStreamSource(e), this.mic.connect(this.script), null === (t1 = this.script) || void 0 === t1 || t1.connect(this.context.destination);
            } catch (e) {
                console.error(e);
            }
        }
        stop() {
            var e, t1;
            console.log("Audio Previewer stopped"), null === (e = this.mic) || void 0 === e || e.disconnect(), this.mic = null, null === (t1 = this.script) || void 0 === t1 || t1.disconnect(), this.script = null;
        }
        getMicVolume() {
            return this.instant;
        }
    }
    const fN = "https://st1.zoom.us/web_client/4qu8baa/audio/ring.mp3";
    class yN {
        constructor(){
            this.sampleAudio = void 0, this.audioCtx = void 0, this.destinationNode = void 0, this.audioPlayer = void 0, this.analyzserInterval = void 0, this.analyserNode = void 0, this.analyserNodeBufferDataArray = void 0, this.analyserCallback = void 0, this.sourceNode = void 0, this.mAudioStream = void 0, this.mSourceNode = void 0, this.mediaRecorder = void 0, this.isRecording = void 0, this.recorderChunks = [], this.recorderObjUrl = void 0, this.recorderPlayer = void 0, this.maximumRecordingTimer = void 0, this.shouldPlayAfterRecording = !0, this.isRunning = !1;
        }
        testSpeaker(e) {
            var t1;
            if ("function" != typeof AudioContext || "function" != typeof MediaStreamAudioDestinationNode || !AudioContext.prototype.decodeAudioData) return void console.warn("Cannot test the speaker due to the browser capability");
            const { speakerId: o, sampleAudioUrl: r = fN, onAnalyseFrequency: i } = e || {};
            if (this.isRunning) return void console.warn("A tester is running,please stop it first");
            this.isRunning = !0, this.initAudioContext(), ((null === (t1 = this.sampleAudio) || void 0 === t1 ? void 0 : t1.url) === r && this.sampleAudio.data ? Promise.resolve(this.sampleAudio.data) : window.fetch(r).then((e)=>e.arrayBuffer()).then((e)=>this.audioCtx.decodeAudioData(e)).then((e)=>(this.sampleAudio = {
                    url: r,
                    data: e
                }, e))).then((e)=>{
                var t1, r, n;
                this.sourceNode = this.audioCtx.createBufferSource(), this.sourceNode.buffer = e, this.sourceNode.loop = !0, o && null !== (t1 = this.audioPlayer) && void 0 !== t1 && t1.setSinkId && this.audioPlayer.setSinkId(o), i ? "function" == typeof AudioContext.prototype.createAnalyser ? (this.analyzserInterval && window.clearInterval(this.analyzserInterval), this.analyserCallback = i, this.initAnalyserNode(), this.analyserNode && this.sourceNode.connect(this.analyserNode)) : (this.sourceNode.connect(this.destinationNode), console.warn("Cannot analyze the stream due to the browser capability")) : (this.analyserCallback = void 0, this.sourceNode.connect(this.destinationNode)), this.sourceNode.start(0), "running" !== (null === (r = this.audioCtx) || void 0 === r ? void 0 : r.state) && (null === (n = this.audioCtx) || void 0 === n || n.resume()), this.audioPlayer && (this.audioPlayer.muted = !1, this.audioPlayer.currentTime = 0, this.audioPlayer.play());
            });
            const n = ()=>{
                this.isRunning = !1, this.audioPlayer && (this.audioPlayer.currentTime = 0, this.audioPlayer.pause()), this.analyserNode && this.analyzserInterval && (window.clearInterval(this.analyzserInterval), this.analyzserInterval = void 0, this.analyserNodeBufferDataArray = void 0), this.sourceNode && (this.sourceNode.stop(0), this.sourceNode.disconnect(), this.sourceNode.buffer = null, this.sourceNode = void 0);
            };
            return {
                stop: n,
                destroy: ()=>{
                    var e;
                    n(), this.analyserNode && this.destinationNode && (this.analyserNode.disconnect(this.destinationNode), this.analyserNode = void 0), null === (e = this.audioCtx) || void 0 === e || e.close(), this.audioCtx = void 0;
                }
            };
        }
        testMicrophone(e) {
            var t1;
            if ("function" != typeof AudioContext || "function" != typeof MediaStreamAudioDestinationNode || "function" != typeof AudioContext.prototype.createMediaStreamSource || "function" != typeof (null === (t1 = navigator.mediaDevices) || void 0 === t1 ? void 0 : t1.getUserMedia)) return void console.warn("Cannot test the microphone due to the browser capability");
            const { microphoneId: o, speakerId: r, recordAndPlay: i, maxRecordDuration: n, onAnalyseFrequency: s, onStartRecording: a, onStopRecording: d, onStartPlayRecording: u, onStopPlayRecording: l } = e || {};
            if (this.isRunning) return void console.warn("A tester is running,please stop it first");
            this.isRunning = !0, this.initAudioContext();
            const c = ()=>{
                i && this.mediaRecorder && this.isRecording && (this.shouldPlayAfterRecording = !0, "inactive" !== this.mediaRecorder.state && this.mediaRecorder.stop());
            };
            window.navigator.mediaDevices.getUserMedia({
                audio: !o || {
                    deviceId: {
                        exact: o
                    }
                }
            }).then((e)=>{
                var t1, o, p, h;
                this.mAudioStream = e, this.mSourceNode = null === (t1 = this.audioCtx) || void 0 === t1 ? void 0 : t1.createMediaStreamSource(e), this.audioPlayer.muted = !0, s ? (this.analyzserInterval && window.clearInterval(this.analyzserInterval), this.analyserCallback = s, this.initAnalyserNode(), this.analyserNode && (null === (p = this.mSourceNode) || void 0 === p || p.connect(this.analyserNode))) : this.analyserCallback = void 0, i && ("function" == typeof MediaRecorder ? (this.recorderObjUrl && window.URL.revokeObjectURL(this.recorderObjUrl), this.mediaRecorder = new MediaRecorder(this.mAudioStream), this.mediaRecorder.ondataavailable = (e)=>{
                    e.data && this.recorderChunks.push(e.data);
                }, this.mediaRecorder.onstop = ()=>{
                    if (this.isRecording = !1, this.maximumRecordingTimer && (window.clearTimeout(this.maximumRecordingTimer), this.maximumRecordingTimer = void 0), null == d || d(), this.recorderChunks.length > 0) {
                        var e;
                        const t1 = new Blob(this.recorderChunks, {
                            type: (null === (e = this.recorderChunks[0]) || void 0 === e ? void 0 : e.type) || "audio/ogg; codecs=opus"
                        });
                        this.recorderObjUrl = window.URL.createObjectURL(t1), this.shouldPlayAfterRecording && this.playRecording(this.recorderObjUrl, r, u, l).catch((e)=>{
                            this.analyzserInterval && (window.clearInterval(this.analyzserInterval), this.analyzserInterval = void 0, this.analyserNodeBufferDataArray = void 0), console.warn(e);
                        }), this.recorderChunks = [], this.mediaRecorder && (this.mediaRecorder.ondataavailable = null, this.mediaRecorder.onstop = null, this.mediaRecorder = void 0);
                    }
                }, this.mediaRecorder.start(), this.isRecording = !0, null == a || a(), this.maximumRecordingTimer = window.setTimeout(()=>{
                    c();
                }, n || 1e4)) : console.warn("Cannot record the sound due to the browser capability")), "running" !== (null === (o = this.audioCtx) || void 0 === o ? void 0 : o.state) && (null === (h = this.audioCtx) || void 0 === h || h.resume()), this.audioPlayer && (this.audioPlayer.currentTime = 0, this.audioPlayer.play());
            });
            const p = ()=>{
                this.isRunning = !1, this.maximumRecordingTimer && (window.clearTimeout(this.maximumRecordingTimer), this.maximumRecordingTimer = void 0), this.audioPlayer && (this.audioPlayer.currentTime = 0, this.audioPlayer.pause()), this.analyserNode && this.analyzserInterval && (window.clearInterval(this.analyzserInterval), this.analyzserInterval = void 0, this.analyserNodeBufferDataArray = void 0), this.mSourceNode && (s && this.analyserNode && this.mSourceNode.disconnect(this.analyserNode), this.mSourceNode = void 0), this.mAudioStream && (this.mAudioStream.getAudioTracks().forEach((e)=>{
                    e.stop();
                }), this.mAudioStream = void 0), this.mediaRecorder && (this.shouldPlayAfterRecording = !1, this.mediaRecorder.ondataavailable = null, this.mediaRecorder.onstop = null, "inactive" !== this.mediaRecorder.state && this.mediaRecorder.stop(), this.isRecording = !1, this.mediaRecorder = void 0, this.recorderChunks = []), this.recorderPlayer && (this.recorderPlayer.currentTime = 0, this.recorderPlayer.pause());
            };
            return {
                stop: p,
                stopRecording: c,
                destroy: ()=>{
                    var e;
                    p(), this.analyserNode && this.destinationNode && (this.analyserNode.disconnect(this.destinationNode), this.analyserNode = void 0), null === (e = this.audioCtx) || void 0 === e || e.close(), this.audioCtx = void 0;
                }
            };
        }
        initAudioContext() {
            this.audioCtx && this.audioPlayer || (this.audioCtx = new AudioContext, this.destinationNode = new MediaStreamAudioDestinationNode(this.audioCtx), this.audioPlayer = new Audio, this.audioPlayer.loop = !0, this.audioPlayer.srcObject = this.destinationNode.stream);
        }
        initAnalyserNode() {
            if (!this.audioCtx) return;
            this.analyserNode || (this.analyserNode = this.audioCtx.createAnalyser(), this.analyserNode.connect(this.destinationNode), this.analyserNode.fftSize = 1024);
            const e = this.analyserNode.frequencyBinCount;
            this.analyserNodeBufferDataArray = new Uint8Array(e), this.analyzserInterval = window.setInterval(this.audioAnalyserCallback.bind(this), 20);
        }
        audioAnalyserCallback() {
            if (this.analyserNodeBufferDataArray && this.analyserNode && this.analyserCallback) {
                this.analyserNode.getByteFrequencyData(this.analyserNodeBufferDataArray);
                let e = 0;
                for (const t1 of this.analyserNodeBufferDataArray)e += t1;
                const t1 = e / this.analyserNodeBufferDataArray.length;
                this.analyserCallback(t1);
            }
        }
        playRecording(e, t1, o, r) {
            this.recorderPlayer = new Audio, this.recorderPlayer.src = e, this.recorderPlayer.currentTime = 0, this.recorderPlayer.setSinkId && t1 && this.recorderPlayer.setSinkId(t1);
            const i = ()=>{
                null == r || r(), this.recorderPlayer && (this.recorderPlayer.onpause = null, this.recorderPlayer.onended = null, this.recorderPlayer = void 0, this.isRunning = !1);
            };
            return new Promise((e, t1)=>{
                this.recorderPlayer && (this.recorderPlayer.onpause = ()=>{
                    e(!0);
                }, this.recorderPlayer.onended = ()=>{
                    e(!0);
                }, this.recorderPlayer.onerror = t1, null == o || o(), this.recorderPlayer.play().catch(t1));
            }).finally(()=>{
                window.URL.revokeObjectURL(e), i();
            });
        }
    }
    const SN = "AudioNotStartedError";
    class bN {
        constructor(){
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            this.audioContext = void 0, this.inputMicDetector = void 0, this.isMicUnmuted = void 0, this.isAudioStarted = void 0, this.audioStream = void 0, this.deviceId = void 0, this.tester = void 0, this.audioContext = null, this.inputMicDetector = null, this.isMicUnmuted = !1, this.isAudioStarted = !1, this.audioStream = null, this.deviceId = e, this.tester = new yN;
        }
        async start() {
            if (this.audioStream || this.isAudioStarted) throw new Error("AudioAlreadyStartedError");
            try {
                const e = await navigator.mediaDevices.getUserMedia(this.getAudioConstraints());
                this.audioStream = e, this.isAudioStarted = !0;
            } catch (e) {
                throw e;
            }
        }
        async unmute() {
            if (!this.audioStream || !this.isAudioStarted) throw new Error(SN);
            if (this.isMicUnmuted) throw new Error("AudioAlreadyUnmutedError");
            return this.toggleMicIsMuted(!0);
        }
        async mute() {
            if (!this.audioStream || !this.isAudioStarted) throw new Error(SN);
            if (!this.isMicUnmuted) throw new Error("AudioAlreadyMutedError");
            return this.toggleMicIsMuted(!1);
        }
        getCurrentVolume() {
            return this.inputMicDetector ? this.inputMicDetector.getMicVolume() : 0;
        }
        async stop() {
            if (!this.audioStream || !this.isAudioStarted) throw new Error(SN);
            this.audioStream.getAudioTracks().forEach((e)=>e.stop()), this.audioStream = null, this.isAudioStarted = !1;
        }
        async toggleMicIsMuted(e) {
            if (e) {
                if (!this.audioContext) {
                    const e = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new e;
                }
                this.inputMicDetector = new vN(this.audioContext), this.inputMicDetector.connectToSource(this.audioStream);
            } else this.inputMicDetector && this.inputMicDetector.stop(), this.inputMicDetector = null;
            this.isMicUnmuted = e;
        }
        getAudioConstraints() {
            return {
                audio: "" === this.deviceId || {
                    deviceId: {
                        exact: this.deviceId
                    }
                },
                video: !1
            };
        }
        testSpeaker(e) {
            return this.tester.testSpeaker(e);
        }
        testMicrophone(e) {
            return this.tester.testMicrophone(e);
        }
    }
    const EN = {
        width: {
            min: 1024,
            ideal: 1280,
            max: 1920
        },
        height: {
            min: 576,
            ideal: 720,
            max: 1080
        },
        aspectRatio: {
            ideal: 1.777777778
        }
    };
    class IN {
        constructor(){
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            this.isVideoStarted = void 0, this.videoStream = void 0, this.deviceId = void 0, this.localPreview = void 0, this.vbPreviewInProgress = void 0, this.videoParams = void 0, this.isVideoStarted = !1, this.videoStream = null, this.vbPreviewInProgress = !1, this.deviceId = e, this.localPreview = new Lw;
        }
        async start(e, t1) {
            if (!e) throw new Error("Video DOM element is falsy");
            if (this.isVideoStarted || this.videoStream) throw new Error("VideoAlreadyStartedError");
            this.videoParams = {
                videoDOMElement: e,
                virtualBackground: t1
            };
            const o = async (t1)=>{
                if (!t1 || "OverconstrainedError" !== t1.name && "ConstraintNotSatisfiedError" !== t1.name) throw t1;
                console.log(`Warning: detected ${t1.name} -- trying to fall back to lower aspect ratio`);
                try {
                    const t1 = await navigator.mediaDevices.getUserMedia(this.getVideoConstraints(!0));
                    return this.tryPlayVideo(e, t1);
                } catch (e) {
                    throw e;
                }
            };
            if (!(e instanceof HTMLVideoElement)) {
                if (e instanceof HTMLCanvasElement) return this.localPreview.setup().then(()=>this.localPreview.startPreview(e, {
                        ...t1,
                        deviceId: this.deviceId
                    })).then(()=>{
                    this.vbPreviewInProgress = !0, this.isVideoStarted = !0;
                });
                throw new Error("Cannot start video with virtual background");
            }
            try {
                const t1 = await navigator.mediaDevices.getUserMedia(this.getVideoConstraints());
                return this.tryPlayVideo(e, t1);
            } catch (e) {
                return o(e);
            }
        }
        async stop() {
            if (this.vbPreviewInProgress) await this.localPreview.stopPreview(), this.vbPreviewInProgress = !1, this.isVideoStarted = !1;
            else {
                if (!this.videoStream || !this.isVideoStarted) throw new Error("VideoNotStartedError");
                this.videoStream.getVideoTracks().forEach((e)=>e.stop()), this.videoStream = null, this.isVideoStarted = !1;
            }
        }
        async switchCamera(e) {
            e !== this.deviceId && (this.deviceId = e, await this.stop(), this.videoParams && await this.start(this.videoParams.videoDOMElement, this.videoParams.virtualBackground));
        }
        async updateVirtualBackground(e, t1) {
            this.vbPreviewInProgress && await this.localPreview.updatePreview(e, t1);
        }
        getVideoConstraints() {
            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t1 = EN;
            return Td.includes(this.deviceId) ? {
                audio: !1,
                video: {
                    facingMode: this.deviceId
                }
            } : (e ? t1 = "" === this.deviceId || {
                deviceId: {
                    exact: this.deviceId
                }
            } : "" !== this.deviceId && (t1.deviceId = {
                exact: this.deviceId
            }), {
                audio: !1,
                video: t1
            });
        }
        async tryPlayVideo(e, t1) {
            if (!e) throw new Error("Video DOM element is falsy");
            try {
                this.videoStream = t1, e.muted = !0, e.playsInline = !0, e.srcObject = this.videoStream, await e.play(), this.isVideoStarted = !0;
            } catch (e) {
                throw e;
            }
        }
    }
    class AN {
        static createClient() {
            if (!this.meetingClient) {
                const e = function() {
                    const e = function(e) {
                        void 0 === e && (e = {});
                        var t1, o = new ie.constructor(ie.schedulerActionCtor), r = new j, i = function(i) {
                            t1 = i;
                            var n = new j, s = new j, a = n.asObservable().pipe(Ie(o)), d = new Tt(s.pipe(Ie(o)), t1.getState());
                            return r.pipe(Le(function(t1) {
                                var o = t1(a, d, e.dependencies);
                                if (!o) throw new TypeError('Your root Epic "' + (t1.name || "<anonymous>") + "\" does not return a stream. Double check you're not missing a return statement!");
                                return o;
                            }), Fe(function(e) {
                                return _e(e).pipe(Ae(o), Ie(o));
                            })).subscribe(t1.dispatch), function(e) {
                                return function(o) {
                                    var r = e(o);
                                    return s.next(t1.getState()), n.next(o), r;
                                };
                            };
                        };
                        return i.run = function(e) {
                            r.next(e);
                        }, i;
                    }(), { epicSubject: t1, rootEpic: o } = function() {
                        const e = new B(rr(vA, UA, GA, Qw));
                        return {
                            epicSubject: e,
                            rootEpic: (t1, o, r)=>e.pipe(mt(t1.pipe(Dt(`${cn}`))), Fe((e)=>e(t1, o, r)))
                        };
                    }(), r = [
                        e
                    ], i = Rt(Xw(), Yw(function() {
                        for(var e = arguments.length, t1 = new Array(e), o = 0; o < e; o++)t1[o] = arguments[o];
                        return function(e) {
                            return function() {
                                var o = e.apply(void 0, arguments), r = function() {
                                    throw new Error(It(15));
                                }, i = {
                                    getState: o.getState,
                                    dispatch: function() {
                                        return r.apply(void 0, arguments);
                                    }
                                }, n = t1.map(function(e) {
                                    return e(i);
                                });
                                return r = wt.apply(void 0, n)(o.dispatch), Et(Et({}, o), {}, {
                                    dispatch: r
                                });
                            };
                        };
                    }(...r)));
                    return i.asyncReducers = {}, i.injectReducer = (e, t1)=>{
                        void 0 === i.asyncReducers[e] && (i.asyncReducers[e] = t1, i.replaceReducer(Xw(i.asyncReducers)));
                    }, i.injectEpic = (e)=>{
                        t1.next(e);
                    }, e.run(o), i;
                }();
                this.meetingClient = new gN(e);
            }
            return this.meetingClient;
        }
        static destroyClient() {
            if (this.meetingClient) {
                const e = this.meetingClient[rT];
                this.meetingClient.leave().then(()=>{
                    Ze(500).subscribe(()=>{
                        null == e || e(cn()), ap();
                    });
                }), this.meetingClient = null;
            }
        }
        static checkFeatureRequirements() {
            return function() {
                const e = [], t1 = [], { isAndroidOrIOSBrowser: o, browser: r, browserVersion: i, os: n, osVersion: s, isChrome: a, isFirefox: d, isSafari: u } = gs;
                !o && (a || d || u) && Es() ? e.push("Virtual Background") : t1.push("Virtual Background"), (o || a) && Es() ? e.push("Share Chrome Tab Audio") : t1.push("Share Chrome Tab Audio"), !o && Es() ? (e.push("Screen Share (send)"), e.push("720p Video (receive)"), e.push("Share 2nd Camera")) : (t1.push("Screen Share (send)"), t1.push("720p Video (receive)"), t1.push("Share 2nd Camera")), Es() ? (e.push("Audio"), e.push("Video"), e.push("Screen Share (receive)"), e.push("Chat"), e.push("Closed Captioning"), e.push("Live Transcription"), e.push("Live Translation"), e.push("Cloud Recording"), e.push("Call Out (PSTN)"), e.push("Command Channel"), e.push("RTMP Live Streaming"), e.push("Encryption"), e.push("720p Video (send)"), e.push("Render Multiple Videos")) : (t1.push("Audio"), t1.push("Video"), t1.push("Screen Share (receive)"), t1.push("Chat"), t1.push("Closed Captioning"), t1.push("Live Transcription"), t1.push("Live Translation"), t1.push("Cloud Recording"), t1.push("Call Out (PSTN)"), t1.push("Command Channel"), t1.push("RTMP Live Streaming"), t1.push("Encryption"), e.push("720p Video (send)"), e.push("Render Multiple Videos"));
                const l = o ? `${n}${s}` : `${r}${i}`;
                return t1.length > 0 && console.log("Some features are not supported on your platform, please refer to https://developers.zoom.us/docs/video-sdk/web/browser-support/"), {
                    platform: l,
                    supportFeatures: e,
                    unSupportFeatures: t1
                };
            }();
        }
        static checkSystemRequirements() {
            return ST();
        }
        static getDevices(e) {
            return e ? navigator.mediaDevices.enumerateDevices() : navigator.mediaDevices.getUserMedia({
                audio: !0,
                video: !0
            }).then((e)=>(e.getTracks().forEach((e)=>e.stop()), navigator.mediaDevices.enumerateDevices())).catch((e)=>(console.warn(e), navigator.mediaDevices.enumerateDevices()));
        }
        static createLocalAudioTrack() {
            return new bN(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "");
        }
        static createLocalVideoTrack() {
            return new IN(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "");
        }
        static preloadDependentAssets(e) {
            (async (e)=>{
                const t1 = e || fr, o = `${t1}/${Qn}`, r = [], i = [], n = `${t1}/`;
                if (Oy()) {
                    const { workers: e, wasms: t1 } = Ly("audio", "simd", n);
                    r.push(...e), i.push(...t1);
                } else {
                    const { workers: e, wasms: t1 } = Ly("audio", "", n);
                    r.push(...e), i.push(...t1);
                }
                if (Oy() && function() {
                    const { browser: e, browserVersion: t1, isAndroidBrowser: o, isSupportSharedArrayBuffer: r } = gs;
                    return !o && "chrome" === e.toLowerCase() && Jr(t1, "100") > 0 && r;
                }()) {
                    const { workers: e, wasms: t1 } = Ly([
                        "video",
                        "sharing"
                    ], "videoShare", n);
                    r.push(...e), i.push(...t1);
                } else if (Oy() && Ty()) {
                    const { workers: e, wasms: t1 } = Ly([
                        "video",
                        "sharing"
                    ], "simd,thread", n);
                    r.push(...e), i.push(...t1);
                } else if (Ty()) {
                    const { workers: e, wasms: t1 } = Ly([
                        "video",
                        "sharing"
                    ], "thread", n);
                    r.push(...e), i.push(...t1);
                } else if (Oy()) {
                    const { workers: e, wasms: t1 } = Ly([
                        "video",
                        "sharing"
                    ], "simd", n);
                    r.push(...e), i.push(...t1);
                } else {
                    const { workers: e, wasms: t1 } = Ly([
                        "video",
                        "sharing"
                    ], "", n);
                    r.push(...e), i.push(...t1);
                }
                const s = [
                    ky(o, "script")
                ];
                r.forEach((e)=>{
                    s.push(ky(e, "fetch"));
                }), i.forEach((e)=>{
                    s.push(ky(e, "fetch"));
                });
                try {
                    document.head.append(...s);
                } catch (e) {}
            })(e);
        }
    }
    AN.meetingClient = void 0, AN.VERSION = gr;
    const CN = "1.12.17", _N = "INVALID_PARAMETERS", RN = `https://dmogdx0jrul3u.cloudfront.net/videosdk/${CN}/lib`, wN = `https://source.zoom.us/videosdk/${CN}/lib`, TN = `https://jssdk.zoomus.cn/videosdk/${CN}/lib`, ON = (e)=>"string" == typeof e && e.length > 0, DN = (e)=>{
        let t1 = "";
        switch(e){
            case "Global":
                t1 = wN;
                break;
            case "CN":
                t1 = TN;
                break;
            case "CDN":
                t1 = RN;
                break;
            default:
                t1 = e;
        }
        return t1;
    }, PN = [
        "userId",
        "avatar",
        "displayName",
        "isHost",
        "audio",
        "muted",
        "bVideoOn",
        "sharerOn",
        "sharerPause",
        "userIdentity",
        "isSpeakerOnly",
        "bVideoShare",
        "bShareAudioOn",
        "userGuid",
        "isPhoneUser",
        "isInFailover",
        {
            from: "isCoHost",
            to: "isManager"
        },
        {
            from: "bAllowISORecord",
            to: "isAllowIndividualRecording"
        },
        {
            from: "bVideoConnect",
            to: "isVideoConnect"
        },
        {
            from: "bShareToBORooms",
            to: "bShareToSubsession"
        },
        {
            from: "bid",
            to: "subsessionId"
        },
        {
            from: "phoneNumber",
            to: (e)=>void 0 === e ? {} : {
                    phoneNumber: e
                }
        }
    ], MN = [
        ...PN,
        {
            from: "userGUID",
            to: "userGuid"
        },
        {
            from: "bCoHost",
            to: (e)=>({
                    isManager: !!e
                })
        },
        {
            from: "userType",
            to: (e)=>({
                    isPhoneUser: !(5 & ~e)
                })
        },
        {
            from: "bid",
            to: (e)=>e ? {
                    subsessionId: e
                } : {}
        }
    ], kN = MN.map((e)=>"string" == typeof e ? e : e.from);
    function LN(e, t1) {
        return "string" == typeof e ? {
            [`${e}`]: t1
        } : "string" == typeof e.to ? {
            [`${e.to}`]: t1
        } : e.to(t1);
    }
    function NN(e) {
        if (e) return PN.reduce((t1, o)=>{
            const r = "string" == typeof o ? o : o.from;
            return {
                ...t1,
                ...LN(o, e[r])
            };
        }, {});
    }
    function VN(e) {
        if (e) return Object.keys(e).reduce((t1, o)=>{
            const r = kN.indexOf(o);
            if (r > -1) {
                const o = MN[r], i = "string" == typeof o ? o : o.from, n = LN(o, e[i]);
                return {
                    ...t1,
                    ...n
                };
            }
            return t1;
        }, {});
    }
    const UN = Symbol("stream");
    class jN {
        constructor(e){
            this[UN] = void 0, this[UN] = e;
        }
        startAudio(e) {
            return this[UN].startAudio(e);
        }
        stopAudio() {
            return this[UN].stopAudio();
        }
        muteAudio(e) {
            return this[UN].muteAudio(e);
        }
        unmuteAudio(e) {
            return this[UN].unmuteAudio(e);
        }
        inviteByPhone(e, t1, o, r) {
            return this[UN].dialOut(e, t1, o, r);
        }
        cancelInviteByPhone(e, t1, o) {
            return this[UN].cancelDialOut(e, t1, o);
        }
        hangup() {
            return this[UN].hangup();
        }
        getCurrentSessionCallinInfo() {
            return this[UN].getDialInInfo();
        }
        muteShareAudio(e) {
            return this[UN].muteShareAudio(e);
        }
        unmuteShareAudio(e) {
            return this[UN].unmuteShareAudio(e);
        }
        subscribeAudioStatisticData(e) {
            return this[UN].subscribeAudioStatisticData(e);
        }
        unsubscribeAudioStatisticData(e) {
            return this[UN].unsubscribeAudioStatisticData(e);
        }
        muteUserAudioLocally(e) {
            return this[UN].muteUserAudioLocally(e);
        }
        unmuteUserAudioLocally(e) {
            return this[UN].unmuteUserAudioLocally(e);
        }
        adjustUserAudioVolumeLocally(e, t1) {
            return this[UN].adjustUserAudioVolumeLocally(e, t1);
        }
        enableBackgroundNoiseSuppression(e) {
            return this[UN].enableBackgroundNoiseSuppression(e);
        }
        enableSyncButtonsOnHeadset(e) {
            return this[UN].enableSyncButtonsOnHeadset(e);
        }
        muteAllUserAudioLocally() {
            return this[UN].muteAllUserAudioLocally();
        }
        unmuteAllUserAudioLocally() {
            return this[UN].unmuteAllUserAudioLocally();
        }
        enableOriginalSound(e) {
            return this[UN].enableOriginalSound(e);
        }
        callCRCDevice(e, t1) {
            return this[UN].callCRCDevice(e, t1);
        }
        cancelCallCRCDevice(e, t1) {
            return this[UN].cancelCallCRCDevice(e, t1);
        }
        startSecondaryAudio(e, t1) {
            return this[UN].startSecondaryAudio(e, t1);
        }
        stopSecondaryAudio() {
            return this[UN].stopSecondaryAudio();
        }
        muteAllAudio() {
            return this[UN].muteAllAudio();
        }
        unmuteAllAudio() {
            return this[UN].unmuteAllAudio();
        }
        muteAudioUponStartAudio(e) {
            return this[UN].muteAudioUponEntry(e);
        }
        isAudioMuted(e) {
            return this[UN].isAudioMuted(e);
        }
        getMicList() {
            return this[UN].getMicList();
        }
        getSpeakerList() {
            return this[UN].getSpeakerList();
        }
        getActiveMicrophone() {
            return this[UN].getActiveMicrophone();
        }
        getActiveSpeaker() {
            return this[UN].getActiveSpeaker();
        }
        switchMicrophone(e) {
            return this[UN].switchMicrophone(e);
        }
        switchSpeaker(e) {
            return this[UN].switchSpeaker(e);
        }
        isSupportPhoneFeature() {
            return this[UN].isSupportCallOut();
        }
        getSupportCountryInfo() {
            return this[UN].getDialOutCountries();
        }
        getInviteByPhoneStatus() {
            return this[UN].getDialOutStatus();
        }
        getShareAudioStatus() {
            return this[UN].getShareAudioStatus();
        }
        isOthersShareAudioMutedLocally(e) {
            return this[UN].isOthersShareAudioMutedLocally(e);
        }
        getAudioStatisticData() {
            return this[UN].getAudioStatisticData();
        }
        isUserAudioMutedLocally(e) {
            return this[UN].isUserAudioMutedLocally(e);
        }
        getUserVolumeLocally(e) {
            return this[UN].getUserVolumeLocally(e);
        }
        isSupportMicrophoneAndShareAudioSimultaneously() {
            return this[UN].isSupportMicrophoneAndShareAudioSimultaneously();
        }
        getAudioMediaPlaybackController() {
            return this[UN].getAudioMediaPlaybackController();
        }
        startVideo(e) {
            return this[UN].startVideo(e);
        }
        stopVideo() {
            return this[UN].stopVideo();
        }
        renderVideo(e, t1, o, r, i, n, s, a) {
            return this[UN].renderVideo(e, t1, o, r, i, n, s, a);
        }
        stopRenderVideo(e, t1, o, r) {
            let i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = arguments.length > 5 ? arguments[5] : void 0;
            return this[UN].stopRenderVideo(e, t1, o, r, i, n);
        }
        updateVideoCanvasDimension(e, t1, o) {
            return this[UN].updateVideoCanvasDimension(e, t1, o);
        }
        adjustRenderedVideoPosition(e, t1, o, r, i, n, s) {
            return this[UN].adjustRenderedVideoPosition(e, t1, o, r, i, n, s);
        }
        clearVideoCanvas(e, t1) {
            return this[UN].clearVideoCanvas(e, t1);
        }
        mirrorVideo(e) {
            return this[UN].mirrorVideo(e);
        }
        enableHardwareAcceleration(e) {
            return this[UN].enableHardwareAcceleration(e);
        }
        previewVirtualBackground(e, t1, o, r) {
            return this[UN].previewVirtualBackground(e, t1, o, r);
        }
        updateVirtualBackgroundImage(e, t1) {
            return this[UN].updateVirtualBackgroundImage(e, t1);
        }
        stopPreviewVirtualBackground() {
            return this[UN].stopPreviewVirtualBackground();
        }
        previewVideoMask(e, t1) {
            return this[UN].previewVideoMask(e, t1);
        }
        updateVideoMask(e) {
            return this[UN].updateVideoMask(e);
        }
        stopPreviewVideoMask() {
            return this[UN].stopPreviewVideoMask();
        }
        switchCamera(e) {
            return this[UN].switchCamera(e);
        }
        subscribeVideoStatisticData(e) {
            return this[UN].subscribeVideoStatisticData(e);
        }
        unsubscribeVideoStatisticData(e) {
            return this[UN].unsubscribeVideoStatisticData(e);
        }
        attachVideo(e, t1, o) {
            return this[UN].attachVideo(e, t1, o);
        }
        detachVideo(e, t1) {
            return this[UN].detachVideo(e, t1);
        }
        spotlightVideo(e, t1) {
            return this[UN].spotlight(e, null != t1 && t1);
        }
        removeSpotlightedVideo(e) {
            return this[UN].removeSpotlight(e);
        }
        removeAllSpotlightedVideos() {
            return this[UN].removeAllSpotlights();
        }
        isCapturingVideo() {
            return this[UN].isCapturingVideo();
        }
        isCameraTaken() {
            return this[UN].isCameraTaken();
        }
        getActiveVideoId() {
            return this[UN].getActiveVideoId();
        }
        getActiveCamera() {
            return this[UN].getActiveCamera();
        }
        getCameraList() {
            return this[UN].getCameraList();
        }
        isCaptureForbidden() {
            return this[UN].isCaptureForbidden();
        }
        getVideoMaxQuality() {
            return this[UN].getVideoMaxQuality();
        }
        getReceivedVideoDimension() {
            return this[UN].getReceivedVideoDimension();
        }
        isSupportMultipleVideos() {
            return this[UN].isSupportMultipleVideos();
        }
        isSupportHDVideo() {
            return this[UN].isSupportHDVideo();
        }
        isSupportVirtualBackground() {
            return this[UN].isSupportVirtualBackground();
        }
        getVirtualbackgroundStatus() {
            return this[UN].getVirtualbackgroundStatus();
        }
        getVideoStatisticData() {
            return this[UN].getVideoStatisticData();
        }
        isRenderSelfViewWithVideoElement() {
            return this[UN].isRenderSelfViewWithVideoElement();
        }
        getCapturedVideoResolution() {
            return this[UN].getCapturedVideoResolution();
        }
        getVideoMaskStatus() {
            return this[UN].getVideoMaskStatus();
        }
        isVideoMirrored() {
            return this[UN].isVideoMirrored();
        }
        getSpotlightedUserList() {
            return this[UN].getSpotlightedUserList().map((e)=>NN(e));
        }
        getVideoMediaPlaybackController() {
            return this[UN].getVideoMediaPlaybackController();
        }
        startShareView(e, t1) {
            return this[UN].startShareView(e, t1);
        }
        stopShareView() {
            return this[UN].stopShareView();
        }
        switchShareView(e) {
            return this[UN].switchShareView(e);
        }
        startShareScreen(e, t1) {
            return void 0 !== (null == t1 ? void 0 : t1.broadcastToSubsession) && Object.assign(t1 || {}, {
                broadcastToBreakoutRoom: null == t1 ? void 0 : t1.broadcastToSubsession
            }), this[UN].startShareScreen(e, t1);
        }
        pauseShareScreen() {
            return this[UN].pauseShareScreen();
        }
        resumeShareScreen() {
            return this[UN].resumeShareScreen();
        }
        stopShareScreen() {
            return this[UN].stopShareScreen();
        }
        lockShare(e) {
            return this[UN].lockShare(e);
        }
        updateSharingCanvasDimension(e, t1) {
            return this[UN].updateSharingCanvasDimension(e, t1);
        }
        switchSharingSecondaryCamera(e) {
            return this[UN].switchSharingSecondaryCamera(e);
        }
        setSharePrivilege(e) {
            return this[UN].setSharePrivilege(e);
        }
        shareToSubsession() {
            return this[UN].shareToBreakoutRoom();
        }
        stopShareToSubsession() {
            return this[UN].stopShareToBreakoutRoom();
        }
        enableOptimizeForSharedVideo(e) {
            return this[UN].enableOptimizeForSharedVideo(e);
        }
        updateSharedVideoQuality(e) {
            return this[UN].updateSharedVideoQuality(e);
        }
        subscribeShareStatisticData(e) {
            return this[UN].subscribeShareStatisticData(e);
        }
        unsubscribeShareStatisticData(e) {
            return this[UN].unsubscribeShareStatisticData(e);
        }
        isShareLocked() {
            return this[UN].isShareLocked();
        }
        getSharePrivilege() {
            return this[UN].getSharePrivilege();
        }
        getActiveShareUserId() {
            return this[UN].getActiveShareUserId();
        }
        getShareStatus() {
            return this[UN].getShareStatus();
        }
        getShareUserList() {
            return this[UN].getShareUserList().map((e)=>NN(e));
        }
        isStartShareScreenWithVideoElement() {
            return this[UN].isStartShareScreenWithVideoElement();
        }
        isOptimizeForSharedVideoEnabled() {
            return this[UN].isOptimizeForSharedVideoEnabled();
        }
        isSupportOptimizedForSharedVideo() {
            return this[UN].isSupportOptimizedForSharedVideo();
        }
        getShareStatisticData() {
            return this[UN].getShareStatisticData();
        }
        requestFarEndCameraControl(e) {
            return this[UN].requestFarEndCameraControl(e);
        }
        approveFarEndCameraControl(e) {
            return this[UN].approveFarEndCameraControl(e);
        }
        declineFarEndCameraControl(e) {
            return this[UN].declineFarEndCameraControl(e);
        }
        giveUpFarEndCameraControl(e) {
            return this[UN].giveUpFarEndCameraControl(e);
        }
        controlCamera(e) {
            return this[UN].controlCamera(e);
        }
        controlFarEndCamera(e) {
            return this[UN].controlFarEndCamera(e);
        }
        getFarEndCameraPTZCapability(e) {
            return this[UN].getFarEndCameraPTZCapability(e);
        }
        getCameraPTZCapability(e) {
            return this[UN].getCameraPTZCapability(e);
        }
        isBrowserSupportPTZ() {
            return this[UN].isBrowserSupportPTZ();
        }
        getNetworkQuality(e) {
            return this[UN].getNetworkQuality(e);
        }
        requestRemoteControl() {
            return this[UN].requestRemoteControl();
        }
        giveUpRemoteControl() {
            return this[UN].giveUpRemoteControl();
        }
        startRemoteControl(e) {
            return this[UN].startRemoteControl(e);
        }
        grabRemoteControl() {
            return this[UN].grabRemoteControl();
        }
        approveRemoteControl(e, t1) {
            return this[UN].approveRemoteControl(e, t1);
        }
        declineRemoteControl(e) {
            return this[UN].declineRemoteControl(e);
        }
        stopRemoteControl() {
            return this[UN].stopRemoteControl();
        }
        launchRemoteControlApp(e) {
            return this[UN].launchRemoteControlApp(e);
        }
        isRemotelyControlApproved() {
            return this[UN].isRemotelyControlApproved();
        }
        isControllingUserRemotely() {
            return this[UN].isControllingUserRemotely();
        }
        isTargetShareSupportRemoteControl(e) {
            return this[UN].isTargetShareSupportRemoteControl(e);
        }
        getRemoteControlAppDownloadUrl() {
            return this[UN].getRemoteControlAppDownloadUrl();
        }
        getRemotelyControllingUser() {
            return this[UN].getRemotelyControllingUser();
        }
        isRemoteControlEnabled() {
            return this[UN].isRemoteControlEnabled();
        }
    }
    const xN = Symbol("chat");
    class BN {
        constructor(e){
            this[xN] = void 0, this[xN] = e;
        }
        send(e, t1) {
            return this[xN].send(e, t1);
        }
        sendToAll(e) {
            return this[xN].send(e, Fs.All);
        }
        sendFile(e, t1) {
            return this[xN].sendFile(e, t1);
        }
        downloadFile(e, t1, o) {
            return this[xN].downloadFile(e, t1, o);
        }
        setPrivilege(e) {
            return this[xN].setPrivilege(e);
        }
        getPrivilege() {
            return this[xN].getPrivilege();
        }
        getReceivers() {
            return this[xN].getReceivers().map((e)=>{
                const { isCoHost: t1, ...o } = e;
                return {
                    isManager: t1,
                    ...o
                };
            });
        }
        getHistory() {
            return this[xN].getHistory();
        }
        isFileTransferEnabled() {
            return this[xN].isFileTransferEnabled();
        }
        getFileTransferSetting() {
            return this[xN].getFileTransferSetting();
        }
    }
    const FN = Symbol("recording");
    class HN {
        constructor(e){
            this[FN] = void 0, this[FN] = e;
        }
        canStartRecording() {
            return this[FN].isRecordingEnabled();
        }
        startCloudRecording() {
            return this[FN].startRecording();
        }
        pauseCloudRecording() {
            return this[FN].pauseRecording();
        }
        resumeCloudRecording() {
            return this[FN].startRecording();
        }
        stopCloudRecording() {
            return this[FN].stopRecording();
        }
        getCloudRecordingStatus() {
            return this[FN].getRecordingStatus();
        }
        acceptIndividualRecording() {
            return this[FN].accept();
        }
        declineIndividualRecording() {
            return this[FN].decline();
        }
    }
    const $N = Symbol("command");
    class WN {
        constructor(e){
            this[$N] = void 0, this[$N] = e;
        }
        send(e, t1) {
            return this[$N].send(e, t1);
        }
    }
    const GN = Symbol("breakout-room");
    class KN {
        constructor(e){
            this[GN] = void 0, this[GN] = e;
        }
        createSubsessions(e, t1) {
            return this[GN].createRooms(e, t1).then((e)=>e.map((e)=>({
                        subsessionId: e.roomId,
                        subsessionName: e.name,
                        userList: e.attendeeList
                    })));
        }
        openSubsessions(e, t1) {
            const o = t1 ? {
                ...t1,
                isAutoJoinRoom: t1.isAutoJoinSubsession,
                isRoomSelectionEnabled: t1.isSubsessionSelectionEnabled
            } : void 0, r = e.map((e)=>({
                    roomId: e.subsessionId,
                    name: e.subsessionName,
                    attendeeList: e.userList
                }));
            return this[GN].openRooms(r, o);
        }
        joinSubsession(e) {
            return this[GN].joinRoom(e);
        }
        leaveSubsession() {
            return this[GN].leaveRoom();
        }
        askForHelp() {
            return this[GN].askForHelp();
        }
        postponeHelping(e) {
            return this[GN].postponeHelping(e);
        }
        broadcast(e) {
            return this[GN].broadcast(e);
        }
        assignUserToSubsession(e, t1) {
            return this[GN].assignUserToRoom(e, t1);
        }
        moveUserToSubsession(e, t1) {
            return this[GN].moveUserToRoom(e, t1);
        }
        moveBackToMainSession(e) {
            return this[GN].moveBackToMainSession(e);
        }
        closeAllSubsessions() {
            return this[GN].closeRoom();
        }
        startBroadcastVoice() {
            return this[GN].startBroadcastVoice();
        }
        stopBroadcastVoice() {
            return this[GN].stopBroadcastVoice();
        }
        getUnassignedUserList() {
            return this[GN].getUnassignedAttendeeList().map((e)=>NN(e));
        }
        getSubsessionList() {
            return this[GN].getRoomList().map((e)=>{
                const { roomId: t1, name: o, attendeeList: r } = e;
                return {
                    subsessionId: t1,
                    subsessionName: o,
                    userList: r.map((e)=>{
                        const { isInRoom: t1, ...o } = e;
                        return {
                            isInSubsession: t1,
                            ...o
                        };
                    })
                };
            });
        }
        getUserStatus() {
            return this[GN].getAttendeeStatus();
        }
        getSubsessionStatus() {
            return this[GN].getRoomStatus();
        }
        getCurrentSubsession() {
            const { attendeeStatus: e, name: t1, roomId: o } = this[GN].getCurrentRoom();
            return {
                userStatus: e,
                subsessionName: t1,
                subsessionId: o
            };
        }
        getSubsessionOptions() {
            const { isAutoJoinRoom: e, isRoomSelectionEnabled: t1, ...o } = this[GN].getRoomOptions();
            return {
                isAutoJoinSubsession: e,
                isSubsessionSelectionEnabled: t1,
                ...o
            };
        }
    }
    const zN = Symbol("liveTranscription");
    class qN {
        constructor(e){
            this[zN] = void 0, this[zN] = e;
        }
        startLiveTranscription() {
            return this[zN].startLiveTranscription();
        }
        setSpeakingLanguage(e) {
            return this[zN].setSpeakingLanguage(e);
        }
        setTranslationLanguage(e) {
            return this[zN].setTranslationLanguage(e);
        }
        getLiveTranscriptionStatus() {
            return this[zN].getLiveTranscriptionStatus();
        }
        getCurrentTranscriptionLanguage() {
            return this[zN].getCurrentTranscriptionLanguage();
        }
        getCurrentTranslationLanguage() {
            return this[zN].getCurrentTranslationLanguage();
        }
        getLatestTranscription() {
            return this[zN].getLatestTranscription();
        }
        getLatestTranslation() {
            return this[zN].getLatestTranslation();
        }
        getFullTranscriptionHistory() {
            return this[zN].getFullTranscriptionHistory();
        }
        disableCaptions(e) {
            return this[zN].disableCaptions(e);
        }
    }
    const JN = Symbol("liveStream");
    class QN {
        constructor(e){
            this[JN] = void 0, this[JN] = e;
        }
        startLiveStream(e, t1, o) {
            return this[JN].startLiveStream(e, t1, o);
        }
        stopLiveStream() {
            return this[JN].stopLiveStream();
        }
        isLiveStreamEnabled() {
            return this[JN].isLiveStreamEnabled();
        }
        getLiveStreamStatus() {
            return this[JN].getLiveStreamStatus();
        }
    }
    const ZN = Symbol("logger");
    class YN {
        constructor(e, t1){
            if (this[ZN] = void 0, this[ZN] = e, t1) {
                const { debugMode: e, trackingId: o } = t1;
                this[ZN].setLogOptions({
                    debugMode: e,
                    trackingId: o
                });
            }
        }
        reportToGlobalTracing(e) {
            return this[ZN].reportToGlobalTracing(e);
        }
        reportRating(e, t1) {
            return this[ZN].reportRating(e, t1);
        }
    }
    const XN = [
        {
            event: "connection-change",
            originalEvent: "connection-change",
            payloadTransform: (e)=>{
                const { roomName: t1, ...o } = e;
                return t1 ? {
                    ...o,
                    subsessionName: t1
                } : e;
            }
        },
        {
            event: "user-added",
            originalEvent: "user-added",
            payloadTransform: (e)=>e.map((e)=>VN(e))
        },
        {
            event: "user-updated",
            originalEvent: "user-updated",
            payloadTransform: (e)=>e.map((e)=>VN(e))
        },
        {
            event: "user-removed",
            originalEvent: "user-removed",
            payloadTransform: (e)=>e.map((e)=>VN(e))
        },
        {
            event: "subsession-invite-to-join",
            originalEvent: "invite-to-join",
            payloadTransform: (e)=>({
                    subsessionId: e.roomId,
                    subsessionName: e.name
                })
        },
        {
            event: "subsession-countdown",
            originalEvent: "room-countdown"
        },
        {
            event: "subsession-time-up",
            originalEvent: "room-time-up"
        },
        {
            event: "closing-subsession-countdown",
            originalEvent: "closing-room-countdown"
        },
        {
            event: "subsession-broadcast-message",
            originalEvent: "broadcast-message"
        },
        {
            event: "subsession-broadcast-voice",
            originalEvent: "broadcast-voice"
        },
        {
            event: "subsession-ask-for-help",
            originalEvent: "ask-for-help",
            payloadTransform: (e)=>({
                    userId: e.userId,
                    userGuid: e.userGuid,
                    displayName: e.displayName,
                    subsessionId: e.roomId,
                    subsessionName: e.roomName
                })
        },
        {
            event: "subsession-ask-for-help-response",
            originalEvent: "ask-for-help-response"
        },
        {
            event: "subsession-invite-back-to-main-session",
            originalEvent: "invite-back-to-main-session"
        },
        {
            event: "subsession-state-change",
            originalEvent: "room-state-change"
        },
        {
            event: "host-ask-unmute-audio",
            originalEvent: "unmute-audio-consent"
        },
        {
            event: "subsession-user-update",
            originalEvent: "room-user-update",
            payloadTransform: (e)=>{
                const { roomId: t1, roomName: o, ...r } = e;
                return {
                    subsessionId: t1,
                    subsessionName: o,
                    ...r
                };
            }
        },
        {
            event: "active-media-failed",
            originalEvent: "media-internal-error"
        }
    ], eV = Symbol("summary");
    class tV {
        constructor(e){
            this[eV] = void 0, this[eV] = e;
        }
        startSummary() {
            return this[eV].startSummary();
        }
        stopSummary() {
            return this[eV].stopSummary();
        }
        isSummaryEnabled() {
            return this[eV].isSummaryEnabled();
        }
        getSummaryStatus() {
            return this[eV].getSummaryStatus();
        }
        startMeetingQuery() {
            return this[eV].startMeetingQuery();
        }
        stopMeetingQuery() {
            return this[eV].stopMeetingQuery();
        }
        isMeetingQueryEnabled() {
            return this[eV].isMeetingQueryEnabled();
        }
        getMeetingQueryStatus() {
            return this[eV].getMeetingQueryStatus();
        }
    }
    const oV = Symbol("Client"), rV = new WeakMap;
    class iV {
        constructor(){
            this[oV] = void 0, this.stream = void 0, this.chat = void 0, this.command = void 0, this.recording = void 0, this.subsession = void 0, this.liveTranscription = void 0, this.logger = void 0, this.liveStream = void 0, this.aiClient = void 0, this[oV] = AN.createClient(), rV.set(this, new Map);
        }
        init() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "en-US", t1 = arguments.length > 2 ? arguments[2] : void 0;
            const o = DN(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Global");
            return !1 === window.isSecureContext && console.warn("The page is not in a secure context, to use audio, video, screen, a secure context must be enabled."), function() {
                const e = "__ZOOM_VIDEO_SDK_DOM_STORAGE_TEST__";
                try {
                    return localStorage.setItem(e, e), localStorage.removeItem(e), sessionStorage.setItem(e, e), sessionStorage.removeItem(e), !0;
                } catch (e) {
                    return !1;
                }
            }() || console.warn("localstorage or sessionstorage is not enabled, please enable to use the video sdk,"), this[oV].init("", "", {
                language: e,
                dependentAssets: o,
                constraints: {
                    ...AN.checkSystemRequirements(),
                    screen: "object" == typeof WebAssembly && "function" == typeof Worker
                },
                additionalFeatures: [
                    "chat",
                    "cmd",
                    "recording",
                    "breakoutRoom",
                    "liveTranscription",
                    "logger",
                    "liveStream",
                    "summary"
                ],
                webEndpoint: (null == t1 ? void 0 : t1.webEndpoint) || "zoom.us",
                skipJsMedia: null == t1 ? void 0 : t1.skipJsMedia,
                enforceMultipleVideos: null == t1 ? void 0 : t1.enforceMultipleVideos,
                stayAwake: null == t1 ? void 0 : t1.stayAwake,
                enforceVirtualBackground: null == t1 ? void 0 : t1.enforceVirtualBackground,
                quicklyLeaveMeeting: null == t1 ? void 0 : t1.leaveOnPageUnload,
                patchJsMedia: null == t1 ? void 0 : t1.patchJsMedia,
                alternativeNameForVideoPlayer: null == t1 ? void 0 : t1.alternativeNameForVideoPlayer
            });
        }
        join(e, t1, o, r, i) {
            return ON(e) && ON(t1) && ON(o) ? e.length > 200 ? Promise.reject({
                type: _N,
                reason: "The maximum length of topic is 200"
            }) : o.length > 200 ? Promise.reject({
                type: _N,
                reason: "The maximum length of username is 200"
            }) : r && ("string" != typeof r || r.length > 10) ? Promise.reject({
                type: _N,
                reason: "The maximum length of password is 10"
            }) : this[oV].joinInstant(e, t1, o, CN, r, i) : Promise.reject({
                type: _N,
                reason: "Topic, token and userName must be string and required"
            });
        }
        leave() {
            var e;
            return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? (null === (e = rV.get(this)) || void 0 === e || e.clear(), this[oV].end()) : this[oV].leave();
        }
        on(e, t1) {
            const o = XN.find((t1)=>t1.event === e);
            if (o) {
                const { originalEvent: r, payloadTransform: i } = o;
                if (i) {
                    const o = (e)=>{
                        const o = i(e);
                        t1(o);
                    };
                    this[oV].on(r, o);
                    const n = rV.get(this);
                    if (n) {
                        n.has(e) || n.set(e, []);
                        const r = n.get(e);
                        null == r || r.push({
                            originalCb: t1,
                            newCb: o
                        });
                    }
                } else this[oV].on(r, t1);
            } else this[oV].on(e, t1);
        }
        off(e, t1) {
            const o = XN.find((t1)=>t1.event === e);
            if (o) {
                const { originalEvent: r, payloadTransform: i } = o;
                if (i) {
                    const o = rV.get(this);
                    if (o) {
                        const i = o.get(e), n = null == i ? void 0 : i.find((e)=>e.originalCb === t1);
                        if (n && i) {
                            this[oV].off(r, n.newCb);
                            const s = null == i ? void 0 : i.filter((e)=>e.originalCb !== t1);
                            o.set(e, s);
                        }
                    }
                } else this[oV].off(r, t1);
            } else this[oV].off(e, t1);
        }
        getMediaStream() {
            return this.stream || (this.stream = new jN(this[oV].getMediaStream())), this.stream;
        }
        getChatClient() {
            return this.chat || (this.chat = new BN(this[oV].getFeatureModule("chat"))), this.chat;
        }
        getRecordingClient() {
            return this.recording || (this.recording = new HN(this[oV].getFeatureModule("recording"))), this.recording;
        }
        getCommandClient() {
            return this.command || (this.command = new WN(this[oV].getFeatureModule("cmd"))), this.command;
        }
        getSubsessionClient() {
            return this.subsession || (this.subsession = new KN(this[oV].getFeatureModule("breakoutRoom"))), this.subsession;
        }
        getLiveTranscriptionClient() {
            return this.liveTranscription || (this.liveTranscription = new qN(this[oV].getFeatureModule("liveTranscription"))), this.liveTranscription;
        }
        getLoggerClient(e) {
            return this.logger || (this.logger = new YN(this[oV].getFeatureModule("logger"), e)), this.logger;
        }
        getLiveStreamClient() {
            return this.liveStream || (this.liveStream = new QN(this[oV].getFeatureModule("liveStream"))), this.liveStream;
        }
        getAIClient() {
            return this.aiClient || (this.aiClient = new tV(this[oV].getFeatureModule("summary"))), this.aiClient;
        }
        getSessionInfo() {
            const e = this[oV].getMeetingInfo();
            return {
                isInMeeting: e.isInMeeting || !1,
                password: e.password || "",
                topic: e.topic,
                userName: e.userName,
                userId: e.userId,
                sessionId: e.meetingId
            };
        }
        getCurrentUserInfo() {
            return NN(this[oV].getCurrentUserInfo());
        }
        getUser(e) {
            return NN(this[oV].getParticipantsList().find((t1)=>t1.userId === e));
        }
        getAllUser() {
            return this[oV].getParticipantsList().map((e)=>NN(e));
        }
        changeName(e, t1) {
            return this[oV].changeName(e, t1);
        }
        makeHost(e) {
            return this[oV].makeHost(e);
        }
        removeUser(e) {
            return this[oV].removeUser(e);
        }
        makeManager(e) {
            return this[oV].makeCoHost(e);
        }
        revokeManager(e) {
            return this[oV].revokeCoHost(e);
        }
        reclaimHost() {
            return this[oV].reclaimHost();
        }
        isHost() {
            return this[oV].isHost();
        }
        isOriginalHost() {
            return this[oV].isOriginHost();
        }
        getSessionHost() {
            return NN(this[oV].getMeetingHost());
        }
        isManager() {
            return this[oV].isCoHost();
        }
    }
    class nV {
        static createClient() {
            return this.videoClient || (this.videoClient = new iV), this.videoClient;
        }
        static destroyClient() {
            this.videoClient && (this.videoClient.leave(), this.videoClient = null);
        }
        static checkSystemRequirements() {
            return AN.checkSystemRequirements();
        }
        static checkFeatureRequirements() {
            return AN.checkFeatureRequirements();
        }
        static getDevices(e) {
            return AN.getDevices(e);
        }
        static createLocalAudioTrack() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return AN.createLocalAudioTrack(e);
        }
        static createLocalVideoTrack() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return AN.createLocalVideoTrack(e);
        }
        static preloadDependentAssets() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Global";
            AN.preloadDependentAssets(DN(e));
        }
    }
    nV.videoClient = void 0, nV.VERSION = CN;
    let sV = function(e) {
        return e[e.All = 1] = "All", e[e.NoOne = 4] = "NoOne", e[e.EveryonePublicly = 5] = "EveryonePublicly", e;
    }({}), aV = function(e) {
        return e[e.All = 0] = "All", e;
    }({}), dV = function(e) {
        return e[e.Automatically = zp.Automatically] = "Automatically", e[e.Manually = zp.Manually] = "Manually", e;
    }({}), uV = function(e) {
        return e[e.Initial = Qp.Initial] = "Initial", e[e.Invited = Qp.Invited] = "Invited", e[e.Joining = Qp.Joining] = "Joining", e[e.InSubsession = Qp.InRoom] = "InSubsession", e[e.Leaving = Qp.Leaving] = "Leaving", e[e.MainSession = Qp.MainSession] = "MainSession", e;
    }({}), lV = function(e) {
        return e[e.NotStarted = qp.NotStarted] = "NotStarted", e[e.InProgress = qp.InProgress] = "InProgress", e[e.Closing = qp.Closing] = "Closing", e[e.Closed = qp.Closed] = "Closed", e;
    }({}), cV = function(e) {
        return e[e.Failover = Jn.Failover] = "Failover", e[e.JoinSubsession = Jn.JoinBreakoutRoom] = "JoinSubsession", e[e.MoveToSubsession = Jn.MoveToBreakoutRoom] = "MoveToSubsession", e[e.BackToMainSession = Jn.BackToMainSession] = "BackToMainSession", e;
    }({}), pV = function(e) {
        return e[e.Unlocked = fd.HostGrab] = "Unlocked", e[e.Locked = fd.OnlyHost] = "Locked", e[e.MultipleShare = fd.MultipleShare] = "MultipleShare", e;
    }({}), hV = function(e) {
        return e[e.Unknown = Kd.Unknown] = "Unknown", e[e.Uninstalled = Kd.Uninstalled] = "Uninstalled", e[e.Installed = Kd.Installed] = "Installed", e[e.Unlaunched = zd.Unlaunched] = "Unlaunched", e[e.Launched = zd.Launched] = "Launched", e;
    }({});
    e.ActiveMediaFailedCode = ou, e.ApprovedState = Ad, e.AskHostHelpResponse = Xp, e.AudioChangeAction = pd, e.CRCProtocol = eu, e.CRCReturnCode = tu, e.CameraControlCmd = Bd, e.ChatFileDownloadStatus = ea, e.ChatFileUploadStatus = Xs, e.ChatMsgType = aV, e.ChatPrivilege = sV, e.ConnectionState = Yn, e.DialoutState = hd, e.FarEndCameraControlDeclinedReason = Fd, e.LeaveAudioSource = cd, e.LiveStreamStatus = HL, e.LiveTranscriptionLanguage = RL, e.LiveTranscriptionLanguageCode = _L, e.LiveTranscriptionMessageSource = SL, e.MobileVideoFacingMode = wd, e.MutedSource = ud, e.PassiveStopShareReason = Cd, e.ReconnectReason = cV, e.RecordingStatus = za, e.RemoteControlAppStatus = hV, e.RemoteControlSessionStatus = qd, e.SharePrivilege = pV, e.ShareStatus = yd, e.SubsessionAllocationPattern = dV, e.SubsessionStatus = lV, e.SubsessionUserStatus = uV, e.VideoActiveState = bd, e.VideoCapturingState = Id, e.VideoQuality = Sd, e.default = nV, Object.defineProperty(e, "__esModule", {
        value: !0
    });
});
}}),
}]);

//# sourceMappingURL=node_modules_%40zoom_videosdk_dist_index_umd_5d6cf514.js.map